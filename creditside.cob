%^ CREDITSIDE.COB source file.
*							      *
***************************************************************
*                                                             *
* Copyright 2006 - 2009 by ACI Worldwide, Inc. All rights     *
* reserved.						      *
*                                                             *
* This Software is confidential and proprietary to IntraNet   *
* and it is protected by U.S. copyright law, other national   *
* copyright laws, and international treaties. The Software may*
* not be disclosed or reproduced in whole or in part in any   *
* manner to any third party without the express prior written *
* consent of IntraNet, Inc.                                   *
*                                                             *
* This Software and its related Documentation are made        *
* available under the terms of the IntraNet Software License  *
* and may not be used, reproduced or disclosed in any manner  *
* except as expressly authorized by the Software License. All *
* other uses are strictly prohibited.                         *
*                                                             *
* This Software and its related Documentation are proprietary *
* and confidential material of ACI Worldwide, Inc.            *
*                                                             *
***************************************************************

%^******************************************************************************
%^
%^ Contains the following subroutine modules: 
%^      CREDITSIDE_LOOKUP
%^      CREDITSIDE_SCREEN
%^	CREDITSIDE_REROUTE
%^	CREDITSIDE_PUSHSCR
%^                                                                           
%^******************************************************************************



%^******************************************************************************
%^
%^      CREDITSIDE_LOOKUP
%^
%^******************************************************************************
%^
%^ Desired new features:
%^
%^	TODO - 
%^
%^ 
%^******************************************************************************
%^
%^ Description:
%^
%^	Contains message mapper lookup routines and supporting code to fill in
%^  and validate all message credit parties.  Any needed SI's are applied 
%^  during this process.  Debitside SI's and debit party account selection
%^  are also done during this process.
%^
%^ CREDITSIDE_LOOKUP routine.
%^
%^   Calling format:
%^	Call "Creditside_lookup" Using
%^		By Reference Nocheck_ambig
%^		By Reference Do_multibank
%^		By Reference Credit_currency
%^		By Reference Message_amount
%^              By Reference Message_currency
%^		By Reference Second_credit_id
%^		By Reference Second_credit_id_length
%^		By Reference Credit_account
%^		By Reference Is_payment
%^		By Reference Notell_no_credit
%^		By Reference Xbank_account_ok
%^		By Reference Credit_account_type
%^		By Reference Resume_SIs
%^		By Reference Do_chips_qualif
%^		By Reference Is_repetitive_lookup
%^		By Reference Lock_cdt_party
%^		By Reference Special_fee_key
%^		By Reference Party_rerun_ind
%^              By Reference Init_debit_currency
%^		By Reference Debit_currency
%^		By Reference Debit_account
%^		By Reference Debit_account_type
%^		By Reference Nochange_bank
%^		By Reference Lock_dbt_party
%^		By Reference Debit_fee_key
%^		By Reference Debit_internal_state
%^		By Reference Debit_not_suspect
%^		By Reference Debit_status
%^		By Reference Msg_bank_changed
%^		By Reference Debit_ErrMemo_count
%^		By Reference Debit_currency_found
%^		By Reference Credit_currency_found
%^		By Reference Original_cdt_depth
%^		By Reference Advice_parties
%^		By Reference Chips_qualified
%^		By Reference Second_credit_matched
%^		By Reference Cdt_not_suspect
%^		By Reference No_beneficiary
%^		By Reference Credit_ErrMemo_count
%^		By Reference Last_error_memo_text
%^		By Reference Last_error_memo_size
%^	    Returning Return_status_ws.
%^	Possible return status values are:
%^		SUCCESS
%^		FAILURE
%^
%^	Called to fill out credit side of message, retrieving any address
%^    information for on-file parties and to identify a credit account.  Also
%^    executes any debitside SI's and triggers final debit party account
%^    selection.
%^	We begin by doing an address lookup on the credit party. The 
%^    Nocheck_ambig and Do_multibank flag arguments control this address 
%^    lookup and all of the other address lookups done by this routine.
%^    If Do_multibank is non-0, we will search all banks for the address.
%^    If it is not, we will search only the current bank.  If
%^    Nocheck_ambig is non-0, we will continue the address lookup
%^    within the bank for which we get our first hit to see if we get a
%^    second hit using the same key.                                    
%^	If we have a second credit id, it applies to this initial credit
%^    party so we check it right after the initial address lookup.  (There 
%^    can be multiple second credit ids packed into this argument.  If so, 
%^    they will be split apart and treated independently.) The second
%^    credit ID can also be a reference to the next creditside party down
%^    or a beneficiary definition, due to SWIFT syntax ambiguities.  The 
%^    CHIPS auxiliary database is used to help resolve the ambiguous cases.)
%^	We then process SIs on the credit party.  AIN SI's can change the
%^    advice method as well as the credit party, so both the credit party 
%^    and the advice method "evolve" together through SI processing.  A COR 
%^    SI will interrupt this AIN SI processing.
%^	Processing the credit party special instructions can cause "pushdown" 
%^    -- another address is substituted as the new credit party, and the old
%^    credit party moves into the next slot in the creditside party chain.
%^    The creditside parties are FILLED in the order:
%^		Credit Party
%^		Beneficiary Party  	(BNP)
%^		Beneficiary's Bank 	(BBK)
%^		Intermediary Bank  	(IBK)
%^		First Intermediary Bank (IB1)
%^
%^    The order of receipt of the message by the Creditside parties is:
%^		Credit Party
%^		First Intermediary Bank (IB1)
%^		Intermediary Bank  	(IBK)
%^		Beneficiary's Bank 	(BBK)
%^		Beneficiary Party  	(BNP)
%^    If CHIPS qualification is done, the first party present in order of
%^    receipt after the credit party must be CHIPS qualified.  (That is
%^    the "special processing for the party AFTER the credit party.")
%^    If no CHIPS qualification is being done, we merely do an address
%^    lookup for this party.  Whether CHIPS qualification is being done or
%^    not, address lookups are all that is necessary for any remaining
%^    creditside parties.
%^
%^	For AIN processing, if the credit party address is on-file and not 
%^    ambiguous, we call the GLOBAL_PREF_CORR routine in SIDE_SUBS.COB to 
%^    check for a global preferred correspondent.  If we do not find one of 
%^    those, we call SI_FIRST_CREDIT in SI_SUBS.COB to search for an SI which 
%^    might cause party insertion or substitution.  If neither of these returns
%^    a new credit party, we call INTRTL_SPEC_PREF_CORR to get a new credit
%^    party.  If we find a new party, we can either insert it and push down
%^    the previous credit party or we can substitute it for the previous 
%^    credit party.  An information memo is written to the message history 
%^    documenting the change in credit party and its cause.
%^	We then enter a cycle of looking up the new candidate credit
%^    party address in our REL file, and, if we find it unambiguously,
%^    using SI_FIRST_CREDIT to check the new Credit Party for AIN SI's, 
%^    and if there are none, calling INTRTL_SPEC_PREF_CORR, ...
%^	We match to an AIN SI using the current advice method (if it is
%^    non-blank, which means that it is an override specified by the mapper
%^    which called us and not a default), the amount, and the message currency.
%^    We will ignore AIN's with a match parameter of EQL RRT.  Once we find
%^    a matching AIN, its Si_method, if non-blank, overrides the cdt_adv_typ.
%^    Its Si_submethod, if it is "SUB", means that we do a substitution and
%^    overwrite the credit party.  If the Si_submethod is either blank or 
%^    "INS", we push the credit party down and insert the new party.
%^
%^	Once there are no more substitutions, if we still have an unambiguous
%^    on-file credit party address, we call the SET_CREDIT_ADDRESS routine in
%^    SIDE_SUBS.COB to set credit party elements from the address set.
%^	If the Credit_account argument is not SPACES, we will use it as the
%^    credit party's account REGARDLESS of the identity of the credit party.
%^    If the Credit_account is not in the currency of the Credit_currency
%^    argument, we will return an error.  If the Credit_account argument is
%^    SPACES, then we will use the credit address (if we were able to determine
%^    one) as the basis for finding a credit account as follows:
%^	  If the Xbank_account_ok argument is zero, we will restrict the
%^      credit account search to finding accounts in the same bank as the
%^      credit party address.
%^        If the address was selected via an account id (type "D" OR "G" OR
%^      "F" OR "V" OR "P") then find that account and, if we have a required
%^	currency, make sure that the account is in the required currency.
%^	If the account is not in the right currency, give an error.
%^	If the account is in the right currency and ambiguity checking is not
%^	suppressed, check for a possible ambiguous account with the same
%^ 	identifier and the same currency.
%^	  Else if the address was NOT selected via an account id, check for
%^      a default account.  If there is one, check its currency against the 
%^      message.  If they match, there can be no ambiguity since there is
%^      only one default account.  If they do not match, scan the account 
%^      sequence.
%^	  The account sequence scan goes through the account sequence skipping
%^      entries which do not have a matching currency.  If a match is found
%^      and ambiguity checking is not suppressed, the scan continues to see
%^      if there is another match.
%^
%^      If we are able to unambiguously determin ea credit account, we call the
%^    SET_CREDIT_ACCOUNT routine in SIDE_SUBS.COB to set credit set elements 
%^    from the account set.                                        
%^
%^      Regardless of whether or not we were able to unambiguously determine
%^    an on-file credit party account and an on-file credit party address,
%^    we now proceed to process the other creditside parties.  If CHIPS
%^    qualification has been requested, we will try to qualify the first
%^    of the IB1, IBK, BBK, or BNP parties which exist.  If none exist and
%^    we have a secondary credit id which did not match the credit party,
%^    we will temporarily substitute this as a BNP and try to CHIPS qualify
%^    it.  If we succeed, it will become the BNP.  If not, we will post an
%^    error memo indicating that we could not find any parties to CHIPS
%^    qualify.
%^	If there is a creditside party which is properly positioned and CHIPS
%^    qualification has been requested, if it is our original credit party
%^    the second credit id will be considered to be additional CHIPS
%^    qualification information and will be used as such.  If the party to
%^    be CHIPS qualified is not the original credit party and was supplied
%^    at call time instead of resulting from a credit party pushdown, the 
%^    second credit id information will be taken from the overflow field (such 
%^    as Ibk_id_overflow) for that party.   If the party to be CHIPS qualified
%^    resulted from a credit party pushdown, there is no second credit id
%^    information for it.  (NOTE: if the second credit id did not
%^    match the original credit party address AND the original credit party
%^    address was pushed down BUT was not properly positioned for CHIPS
%^    qualification, this does not cause an error.  An error will only be
%^    generated if the second credit id did not match the original credit
%^    party address and no pushdown occurred and there was already at least
%^    a beneficiary creditside party.)
%^      If CHIPS qualification was attempted, REL address lookups will be done
%^    for any remaining credit parties REGARDLESS of the outcome of the CHIPS
%^    qualification.
%^      If no CHIPS qualification was attempted, REL address lookups will be
%^    done for all creditside parties below the Credit Party.
%^	If any significant database anomalies were found in processing the
%^    credit party, the status is returned as FAILURE.  Otherwise it will be
%^    returned as SUCCESS.
%^      If none of the creditside parties were ambiguous and the credit party
%^    lookup succeeded if the credit party was specified, the Nothing_suspicious
%^    argument will be returned non-0 to indicate that this message may continue
%^    through automated payment processing.
%^	The Resume_SIs argument causes this routine to skip over the credit
%^    party lookup, assuming that that has already occurred, and to hook up
%^    the Ent_c_adr_set if it matches the credit party address and to resume
%^    SI processing.
%^
%^ INPUT ARGUMENTS:
%^ explicit:
%^  Nocheck_ambig             Long    Non-0 if the (default) ambiguous key
%^	detection is to be suppressed.  The first item which matches an address
%^	identifier will be considered a match without checking for additional
%^	matches.
%^  Do_multibank 	      Long    Non-0 if the lookup is to be done
%^	across all banks beginning with the default bank.
%^  Credit_currency	      STR(3)  contains the credit currency.
%^	This is a mandatory field.  It may contain SPACES.
%^  Message_amount	      DEC(14.2)  contains the credit amount.
%^	This is a mandatory field.
%^  Message_currency    STR(3)  contains the currency of the message.
%^	This currency is used to match currency AIN's.  It may be SPACES
%^	if no message currency has been set.
%^  Second_credit_id	      STR(132) contains the second credit id if one
%^	exists; if not it should be SPACES.  Syntax uses type codes
%^	AC, CH, FW, CP, BC; if there is more than one id, a "/" separates
%^	them.  (For example, AC0123456789/CH123456.)
%^  Second_credit_id_length    Word   contains the number of characters in the
%^	second credit id if one exists; if not it should be zero.
%^  Credit_account	      ACC_ID_REC.DDF contains account ID if caller
%^  	has pre-determined it; else spaces.
%^  Is_payment		      Long    If NON-0, message is a payment and 
%^	both an unambiguous credit address and credit account are required.
%^  Notell_no_credit	      Long    Non-0 Suppresses error memo/notification
%^	if credit party itself is blank; this will presumably be detected and
%^	handled later by the caller.  (No credit party does not necessarily
%^	require notification and handling.  An ambiguous credit party always
%^	does.)
%^  Xbank_account_ok	      Long    Non-0 if we are permitted to find a
%^	credit account in a different bank from the credit party.
%^  Credit_account_type	      STR(1)  Select an account of this type from
%^ 	the accounts associated with the credit party address.
%^  Resume_SIs		      Long    Non-0 if we are resuming SI processing
%^      after interrupting ourselves to handle an immediate action SI such
%^	as a COR.
%^  Do_chips_qualif	      Long    Non-0 if we should attempt to CHIPS
%^      qualify the first existing creditside position downstream from the
%^	credit party (in order, the IB1, IBK, BBK, or BNP).
%^  Is_repetitive_lookup      Long   Non-0 if this is a repetitive lookup,
%^	in which case we will not map special instructions nor copy the
%^	debit account's cnf_seq to the message.
%^  Lock_cdt_party            Long   Non-0 if the credit party is locked
%^      (such as by instantiation of a locked repetitive) and should not be
%^ 	changed by AINs, INTRTL tables, or anything else.
%^  Special_fee_key	      Str(1) Passed to Set_credit_account.  
%^				     SPACE for nothing special.
%^				     For now, "W" if the fees are to be waived.
%^  Party_rerun_ind  	      Str(6)
%^				To be used to initiate a redo for the specified party
%^				triggerd by a PD or Autotreive change
%^ Explicit input arguments passed to DEBIT_LOOK_ACCOUNT:
%^  Debit_currency	      STR(3)  contains the debit currency.
%^	This is a mandatory field.
%^  Debit_account	      ACC_ID_REC.DDF contains account ID if caller
%^  	has pre-determined it; else spaces.
%^  Debit_account_type	      STR(1) Select an account of this type from
%^ 	the accounts associated with the debit party address.
%^  Nochange_bank	      Long   Non-0 if a debit party bank which 
%^	disagrees with the Menu_bnk_union bank should not cause a bank
%^	context switch.  (The Msg_bank_changed flag will still be hoisted
%^	when appropriate even though no context switch will be done.)
%^  Lock_dbt_party            Long   Non-0 if the debit party is locked
%^      (such as by instantiation of a locked repetitive) and should not be
%^ 	changed by AINs, INTRTL tables, or anything else.
%^  Debit_fee_key	      Str(1) Passed to Set_debit_account.  
%^				     SPACE for nothing special.
%^				     For now, "W" if the fees are to be waived.
%^  Debit_internal_state      Long   Indicator of what state of completion the
%^	pre-creditside part of debitside-lookup achieved.  It should always
%^	complete.
%^	
%^  
%^ implicit CREDITSIDE_LOOKUP:
%^   Credit party:
%^	Ent_credit_set.Cdt_typ
%^	Ent_credit_set.Cdt_name1		
%^	Ent_credit_set.Cdt_name2		
%^	Ent_credit_set.Cdt_name3		
%^	Ent_credit_set.Cdt_name4		
%^   IB1:
%^	Ent_credit_set.Ib1
%^	Ent_credit_set.Ib1_name1
%^	Ent_credit_set.Ib1_name2
%^	Ent_credit_set.Ib1_name3
%^	Ent_credit_set.Ib1_name4
%^   IBK:
%^	Ent_credit_set.Ibk
%^	Ent_credit_set.Ibk_name1
%^	Ent_credit_set.Ibk_name2
%^	Ent_credit_set.Ibk_name3
%^	Ent_credit_set.Ibk_name4
%^   BBK:
%^	Ent_credit_set.Bbk
%^	Ent_credit_set.Bbk_name1
%^	Ent_credit_set.Bbk_name2
%^	Ent_credit_set.Bbk_name3
%^	Ent_credit_set.Bbk_name4
%^   BNP:
%^	Ent_credit_set.Bnp
%^	Ent_credit_set.Bnp_name1
%^	Ent_credit_set.Bnp_name2
%^	Ent_credit_set.Bnp_name3
%^	Ent_credit_set.Bnp_name4
%^   Menu_bnk_union.Id for current bank id.
%^
%^ OUTPUT ARGUMENTS:
%^ Explicit arguments returned from DEBIT_LOOK_ACCOUNT:
%^  Debit_not_suspect	      long   is returned 0 if any mapping errors
%^	were detected during debitside setup, otherwise 1.  For payments,
%^	mapping errors are caused by any ambiguous debitside parties, a
%^	NOF debit party, or a non-existent or ambiguous debit
%^	account.  For non-payments, mapping errors are caused by any
%^	ambiguous debitside party or a NOF (but not non-existent) debit
%^	party.  If this flag is returned 0, the message should be routed to
%^	repair instead of being passed through for automated payment
%^	processing.
%^  Debit_status	      long   is returned SUCCESS if no obviously bad 
%^	or inconsistent rel or aux file data was read during debitside setup, 
%^	otherwise FAILURE.
%^  Msg_bank_changed	      long   is returned non-0 if the debit party was
%^      found in a different bank, requiring the message (context) bank to
%^      change.
%^  Debit_ErrMemo_count       Long   is the number of error or warning
%^	memos added to the message history during debitside lookup. 
%^	Informational memos indicating normal SI parsing and execution are
%^	NOT error or warning memos.
%^  Debit_currency_found      Str(3) is the debit currency found -- the
%^	explicit currency of the debit account, if any.  It will only be SPACES
%^	if no debit account was found.
%^
%^ Explicit arguments returned from CREDITSIDE_LOOKUP:
%^  Credit_currency_found      Str(3) is the credit currency found -- the
%^	explicit currency of the credit account, if any.  It will only be SPACES
%^	if no credit account was found.
%^  Original_cdt_depth 	      Long    Depth to which original credit party has
%^	been pushed down.  0 = still CDT, 1 = IB1, 2 = IBK, 3 = BBK, 4 = BNP
%^  Advice_parties	      Long    Number of creditside parties to receive
%^	advices.  1, 2, or 3.
%^  Chips_qualified	      Long    Non-0 if we successfully CHIPS QUALIFIED
%^      the first creditside party downstream from the credit party.
%^  Second_credit_matched     Long   Returned as SUCCESS if second credit id
%^      was supplied and matched original credit party.
%^  Cdt_not_suspect	      long    is returned 0 if any mapping errors
%^	were detected during creditside setup, otherwise 1.    For payments,
%^	mapping errors are caused by any ambiguous creditside parties, a
%^	NOF credit party for an advice type which requires a credit party, or a 
%^	non-existent or ambiguous credit account.  For non-payments, mapping 
%^      errors are caused by any ambiguous creditside party or a NOF credit 
%^	party id/idtype.                                            
%^  No_beneficiary	      Long    is returned 1 if there is NO beneficiary
%^ 	for a payment message  (This does not cause Cdt_not_suspect to be
%^	returned 0).
%^  Error_Memo_count          Long    is the number of error or warning
%^	memos added to the message history during creditside lookup. 
%^	Informational memos indicating normal SI parsing and execution are
%^	NOT error or warning memos.
%^  Last_error_memo_text      Str(80) is the returned text of the last error
%^	or warning memo added to the message history during creditside lookup.
%^  Last_error_memo_size      Word    is the number of characters of returned
%^	text of the last error or warning memo added to the message history
%^	during creditside lookup.
%^  Return_status_ws is SUCCESS if there were no obviously fatal errors during
%^	creditside setup, otherwise FAILURE.
%^
%^Implicit:
%^   Message history
%^   Credit party:
%^	Ent_credit_set.Cdt_adr_set_ptr
%^	Ent_credit_set.Cdt_rel_id
%^	Ent_credit_set.Cdt_adr_bnk_id
%^	Ent_credit_set.Cdt_typ
%^	Ent_credit_set.Cdt_name1		
%^	Ent_credit_set.Cdt_name2		
%^	Ent_credit_set.Cdt_name3		
%^	Ent_credit_set.Cdt_name4		
%^	Ent_credit_set.Cdt_account
%^	Ent_credit_set.Cdt_acc_class         
%^	Ent_credit_set.Cdt_acc_parent_code
%^	Ent_credit_set.Cdt_acc_prod_codes         
%^	Ent_credit_set.Cdt_adr_class         
%^	Ent_credit_set.Cdt_adv_typ         
%^	Ent_credit_set.Cdt_concen_acc
%^	Ent_credit_set.Cdt_currency         
%^	Ent_credit_set.Cdt_department         
%^	Ent_credit_set.Cdt_recon_ref        
%^	Ent_credit_set.Cdt_shnam         
%^	Ent_credit_set.Cdt_spc_inst1         
%^	Ent_credit_set.Cdt_spc_inst2         
%^	Ent_credit_set.Cdt_spc_inst3
%^	Ent_credit_set.Cdt_sys_of_rec         
%^	Ent_credit_set.Cdt_wir_key         
%^	Ent_credit_set.Flgs.Cdt_hold_flg         
%^	Ent_credit_set.Pymnt.Adv_type         
%^	Ent_credit_set.Pymnt.Location
%^	Ent_credit_set.Pymnt.Phn_time         
%^	Ent_credit_set.Pymnt.Que 
%^   IB1:
%^	Ent_credit_set.Ib1_adr_set_ptr
%^	Ent_credit_set.Ib1_adr_bnk_id
%^	Ent_credit_set.Ib1_rel_id
%^	Ent_credit_set.Ib1
%^	Ent_credit_set.Ib1_id_overflow
%^	Ent_credit_set.Ib1_name1
%^	Ent_credit_set.Ib1_name2
%^	Ent_credit_set.Ib1_name3
%^	Ent_credit_set.Ib1_name4
%^   IBK:
%^	Ent_credit_set.Ibk_adr_set_ptr
%^	Ent_credit_set.Ibk_adr_bnk_id
%^	Ent_credit_set.Ibk_rel_id
%^	Ent_credit_set.Ibk
%^	Ent_credit_set.Ibk_id_overflow
%^	Ent_credit_set.Ibk_name1
%^	Ent_credit_set.Ibk_name2
%^	Ent_credit_set.Ibk_name3
%^	Ent_credit_set.Ibk_name4
%^   BBK:
%^	Ent_credit_set.Bbk_adr_set_ptr
%^	Ent_credit_set.Bbk_adr_bnk_id
%^	Ent_credit_set.Bbk_rel_id
%^	Ent_credit_set.Bbk
%^	Ent_credit_set.Bbk_id_overflow
%^	Ent_credit_set.Bbk_name1
%^	Ent_credit_set.Bbk_name2
%^	Ent_credit_set.Bbk_name3
%^	Ent_credit_set.Bbk_name4
%^   BNP:
%^	Ent_credit_set.Bnp
%^	Ent_credit_set.Bnp_id_overflow
%^	Ent_credit_set.Bnp_name1
%^	Ent_credit_set.Bnp_name2
%^	Ent_credit_set.Bnp_name3
%^	Ent_credit_set.Bnp_name4
%^   FTR:
%^	Ent_ftr_set.cdt_adv_flg
%^      Ent_ftr_set.chrg.cdt_chrg 
%^	Ent_ftr_set.chrg.dbt_chrg 
%^	Ent_ftr_set.currency_code 
%^	Ent_ftr_set.flgs.adv_ovr_flg 
%^	Ent_ftr_set.flgs.cdt_adv_flg 
%^	Ent_ftr_set.instr_adv_type 
%^	Ent_ftr_set.loc_info.bank 
%^	Ent_ftr_set.si_flgs.check_found 
%^	Ent_ftr_set.si_flgs.cor_done 
%^	Ent_ftr_set.si_flgs.fx_found 
%^	Ent_ftr_set.si_flgs.pre_found 
%^	Ent_ftr_set.si_flgs.rte_done 
%^	Ent_ftr_set.type_code
%^
%^ Modification history:
%^
%^	Fred P. Isaacs	12-Apr-1995
%^		Initial version.
%^      Fred P. Isaacs  20-JUL-1995
%^		Now forces Dbt_adr_bnk_id to be Menu_bnk_union ID for NOF or
%^		ambiguous debit party and Cdt_adr_bnk_id to be same as
%^		Dbt_adr_bnk_id (or Menu_bnk_union ID for ENTRY if debit party
%^		bank is still blank).
%^      Fred P. Isaacs  25-JUL-1995
%^              Now calls SI_FIRST_CREDIT with length of list of SI types
%^		to make subsequent parse cleaner.
%^		Now requires blank cdt_idtype for CHK advice type.
%^      Fred P. Isaacs  31-JUL-1995
%^		Added Nochange_bank argument.
%^      Fred P. Isaacs  28-AUG-1995
%^              Tightened definition of full_parse for admins.  
%^      Fred P. Isaacs  6-SEP-1995
%^              Added secondary wire check.
%^      Fred P. Isaacs  11-SEP-1995
%^              Fixed Csid_try_chips flag init; make sure Csid_acc_seq set;
%^		correct chips qualification.
%^      Fred P. Isaacs  21-SEP-1995
%^		Added overwrite option to AIN insertion using SI_submethod.
%^      Fred P. Isaacs  22-SEP-1995
%^		Made sure that CREDITSIDE_LOOKUP leaves Ent_adv_seq connected.
%^      Fred P. Isaacs  11-OCT-1995
%^		Fixed AIN processing logic.
%^      Fred P. Isaacs  25-OCT-1995
%^              Changed GET_SECWIRE_DEST to GET_CDTWIRE_DEST.  Added code to
%^		set Cdt_wir_key in Ent_credit_set.
%^      Fred P. Isaacs  29-OCT-1995
%^		Cleaned up party substitution memos.
%^      Fred P. Isaacs  1-NOV-1995
%^		Suppress no debit account complaint for NOF credit party.
%^              Make Global preferred correspondent do pushdown.
%^      Fred P. Isaacs  3-NOV-1995
%^              Fix bug in which for NOF credit party for non-payment we tried
%^		to look up the account.
%^      Fred P. Isaacs  8-NOV-1995
%^              Added Lock_cdt_party argument.
%^	Fred P. Isaacs  17-NOV-1995
%^		Restructured advice type setup and usage.
%^      Fred P. Isaacs  27-NOV-1995
%^		Corrected nasty typo in account search.  Corrected nasty typo
%^		in BNP chips qualification.
%^      Fred P. Isaacs  28-NOV-1995
%^              Make sure that Csid_acctyp_seq is released after use.
%^      Fred P. Isaacs  6-DEC-1995
%^		Removed reset of adv type chain on reset of advice type.
%^      Fred P. Isaacs  11-DEC-1995
%^		Tweaked advice sequence setup.  Fixed credit party bank id.
%^	Fred P. Isaacs  12-JAN-1996
%^	     Posted V 4.0 fixes to V4.1:
%^              1) Changed lookup criteria for ABA and CHIPS messages. 
%^		2) Now properly sets title mode to let ACCOUNT_LOOKUP know 
%^		   target.
%^		3) Deleted references to UNCROSS_LOOKUP and fixed lookup 
%^		   eccentricities which had sometimes required it.
%^              4) Now handles XREFs of NOF SWF to NOF ABA correctly
%^ 	Fred P. Isaacs  12-JAN-1996
%^    		Now clears fed short name if there isn't one; 
%^	Fred P. Isaacs   1-FEB-1996
%^    		Now handles second id better. 
%^              Really fix second id!  Also make it ignore compound lower
%^		party id's which begin with space idtypes for non-chips.
%^ 	Fred P. Isaacs  6-FEB-1996
%^              Changed format of second id to be swift-like identifiers
%^		AC, CH, CP, FW, and BC.  Added overflow check to kill lookup
%^		on lower creditside parties.
%^ 	Fred P. Isaacs  9-FEB-1996
%^		Added DEBIT_LOOK_ACCOUNT arguments for pass-through call.
%^		Correct logic for Resume_SI mode.  Sorted and corrected
%^		paragraph numbering.
%^	K. Callihan	15-MAR-1996
%^		SPR=15181 Trapped during CHEQUE processing.  Also, cleaned
%^		up debit SI processing logic of CHK and PRE.  Added some 
%^		additional PREVICE edits.
%^ 	Fred P. Isaacs  15-MAR-1996
%^		Suppressed post-chips-qualification SWIFT lookups until later
%^		version in which we may fix ACCT_LOOKUP to support this.
%^ 	Fred P. Isaacs  27-MAR-1996
%^		Moved in V 4.0 changes:
%^		  a) Fixed chips qualification of subsidiary credit parties.
%^		  b) Also changed second id and overflow formats again.		
%^                c) Fixed trap on string overflow for second id account match.
%^		  d) Made sure that Csid_acctyp_seq gets BREAK"d.
%^                e) Tweaked CHIPS_QUALIFICATION_OVERRIDE criteria.
%^	K. Callihan	9-APR-1996
%^		PER 13182 - enhancement triggered by Rtn_dflt_acct intrtl
%^		When the flag is set and we look up credit party via an account
%^		that is designated not-on-file (*), then return default account
%^		(X) else error out.
%^	K. Callihan	9-APR-1996
%^		TIR 15917 - TKT advice type getting wiped out.
%^ 	Fred P. Isaacs  12-APR-1996
%^		Moved in V 4.0 changes:
%^		  a) Activated new ACCT_LOOKUP "$" mode to search swift AUX
%^		     ONLY for lower creditside parties.
%^		  b) Fixed CHIPS common UID table usage for both override
%^		    of lower credit party qualification and second credit id.
%^		  c) Now sets flags properly on magic bnp chips qual override.
%^		  d) Now does "C" lookup after common UID table match.
%^      Fred P. Isaacs   19-APR-1996
%^              Make returned memo count get fudged to 2 from 1 if there are
%^		info memos since error memo may not be last.
%^              Make sure Csid_try_chips gets cleared when next party fails.
%^		Make sure NOF ABA and not aux either is not full parsed and
%^		gets error memo.
%^		Insulate id in calls to ACCT_LOOKUP and make sure any changes
%^		made to fill out the id are kept.
%^	Fred P. Isaacs	 9-MAY-1996
%^              Flips ordering of lower creditside party id's if we have an
%^		account number or chips uid as a second id.  This makes the
%^		output mappers happier.
%^              Added validation of input ids, including correction of DDAs.
%^		Moved ordering flip of lower creditside party ids.
%^      	Removed code to reset Cdt_wir_key since this is now done in
%^		the CREDIT_ADVICE_LOOKUP routine.
%^              Made account number always have precedence over chips uid
%^		when shuffling ids.
%^              Fixed numbering error in idtypes in validation routine.
%^              Now concatenates second credit id to NOF credit party.
%^	        Tweaked error message capitalization.
%^	        Fixed rolldown so it checks 2nd credit in CHPS context
%^		   and always adds it if it will be okay.
%^	        If account number in lower creditside party, look for another
%^		   id by which to retrieve name and address.
%^	Fred P. Isaacs	15-MAY-1996
%^		Make sure that naked //FW and //CH cause fed or CHPS
%^		    advice only.
%^		Allow 2-party CHIPS if we have a ref num or BBI.
%^		Make sure error exits leave things ready for RPR/EXC.
%^		Fixed typo in validation routine which was confusing type
%^		    codes.
%^              Shortened error memos; made error /info memo write more robust.
%^	Fred P. Isaacs	22-MAY-1996
%^              Setup for PREadvise and SPLit now corrected.
%^		Changed args for SI_FIRST_CREDIT and SI_FIRST_DEBIT.
%^		Changed CREDITSIDE_LOOKUP args to have separate debitside
%^		    and creditside amounts and currencies passed by caller.
%^              Now sorts NOF credit party concatenated ID string.
%^	Fred P. Isaacs	28-MAY-1996
%^              Changed wording of PRE SI memos.
%^	Fred P. Isaacs	31-MAY-1996
%^		Make sure that Relget_msgcode is cleared before each lookup
%^	      step so we don't confuse an AUX lookup hit with a complete miss
%^              Combine error and info memo counts and return sum to caller.
%^	Fred P. Isaacs	4-JUN-1996
%^		Make sure bank is set correctly for NOF credit parties.
%^		Fix FX and CHEQUE logic and move to correct place.
%^		Maintain Instr_adv_type
%^	Fred P. Isaacs	13-JUN-1996
%^              Check for BKT Si_method on normal SI's and object to it.
%^		Change to clearer error message for really NOF ABA's.
%^	Fred P. Isaacs	17-JUN-1996
%^              Cleaned up COR SI logic.
%^	Fred P. Isaacs	28-JUN-1996
%^		Fixed trap on SUB AIN's
%^	Fred P. Isaacs	 3-JUL-1996
%^              Restructured lower creditside party lookups.  Lower creditside
%^		name and address now ONLY get overwritten if ALL party ids
%^		resolved to linked AUX entries or to the same REL entry.
%^	Fred P. Isaacs	 12-JUL-1996
%^		Tweaked restructured lookups so that a blank name and address
%^		  will get filled in if we can find ANY ID, so long as multiple
%^		  IDs are not inconsistent.
%^              Fixed case where ID found in AUX DB could get trashed by
%^		  overwriting it with a Relget_return_key which is all SPACES.
%^		Fixed misplaced length adjustment when unpacking condensed
%^		  lower credit party id.
%^		Fixed logic to prevent fall-through on chips qualification
%^		  override case to incorrect repeat lookup on id.
%^              Fixed return usage to recognize and not use a soft failure
%^		  (I.e, nothing found) for lower creditside lookup.
%^		Modularized and corrected lower credit party unpack/update
%^		  of long ID with overflow.
%^	Fred P. Isaacs	 17-JUL-1996
%^              Now eats trailing spaces on single lower creditside ID.
%^	John R. Phelan   19-JUL-1996
%^		Parsing Dictionary - Don't let Chkdgt_edit changed the DDA id
%^		if parsing dictionary is enabled. #18218
%^		Split Value Dating - Use the new Accounting Method parameter
%^		in Si_p1 of Ent_cnf_set to set the Dbt_ps_elig_flg.  Flag
%^		preadvise limit missing as "L" and preadvise limit expired as
%^              "X" in Dbt_ps_elig_flg. #18222
%^      John R. Phelan   26-JUL-1996
%^              Allow credit parties prefixed with a bbb: bank id.
%^      John R. Phelan   31-JUL-1996
%^              Parse off any bank ID which may be present on the
%^              base account id when we set up the account seq search.
%^              Discard trailing address id if present. Document new V4.2
%^		fields.
%^	Fred P. Isaacs   01-AUG-1996
%^	        Now no longer searches for COR SI if message source is COR.
%^              Now reports not fully parsed if we had a pushdown error.
%^              Now behaves better for AIN trying to insert NOF party.
%^		Fixed typo in RESTORE paragraph; COR VFY reject should work
%^		better. (Thanks to John Phelan.)
%^              Fixed typo in pushdown detection for lower creditside parties.
%^              Relaxed credit party edit to only object to missing credit
%^		account if we have a credit party address and require an
%^		account (i.e, when we are inconsistent).
%^		FTRSCR_EDITS will take care of NOF credit party checks when
%^		we lack both an account and an address.
%^      John R. Phelan  05-AUG-1996
%^              Increased size of Csid_lc_account, a temporary lower creditside
%^              account field.  Swift can send a 34 character account number.
%^      John R. Phelan  08-AUG-1996
%^              Change Creditside_lookup not to return errors on
%^              administrative messages. #19007
%^      John R. Phelan  21-AUG-1996
%^		Pd_enabled_map has changed back to Pd_enabled.
%^      John R. Phelan  21-AUG-1996
%^              Allow AIN to override Mapper advice type.  #19415
%^      John R. Phelan  29-AUG-1996
%^              Clear Cdt_recon_ref field.  #19552
%^      John R. Phelan  02-SEP-1996
%^              Set the NOF Cdt_account correctly.  #19175, #19199, #19313.
%^      T. Carroll       4-SEP-1996
%^              SPR 18573 - Added a new routine that will attempt to 
%^		disambiguate the credit party by matching the short name
%^		on the address with the derived (using AUTONAM) shortname
%^		from name line 1 of the message.  Routine is triggered 
%^		based on INTRTL switch SEARCH_SHORTNAME = T, the credit
%^		party is ambiguous and the source is FED or SWF.
%^      John R. Phelan   20-SEP-1996
%^              Maintain pointer to Ent_c_adr_set.
%^              Reconnect Ent_c_adr_set when a pushdown error occurs.  #20148
%^      John R. Phelan   26-SEP-1996
%^              Break Ent_c_acc_set and clear out other account level fields
%^              when Cdt_account is cleared.  #20393
%^      John R. Phelan   27-SEP-1996
%^              Write an error memo for ambiguous credit parties.  #19851
%^      John R. Phelan   27-SEP-1996
%^              Add call to Intrtl_spec_pref_corr to determine
%^              site specific preferred correspondents.  #19967
%^      John R. Phelan    3-OCT-1996
%^              If there was an AUX Db hit on a S/ credit id, copy the address 
%^              before checking for HO insertion. #20720.
%^      Fred P. Isaacs    3-OCT-1996
%^              Corrected error message for second id not found. #20636.
%^      Fred P. Isaacs    9-OCT-1996
%^              Added security arguments to GET_CDTWIRE_DEST.  Added
%^              Csid_lc_secwir flag to force lower creditside lookups into
%^              REL instead of AUX when we are sending a secwir to that lower
%^              party.  #20498, #20523.  Migrated to 4.2 by JRP.
%^      Fred P. Isaacs    9-OCT-1996
%^              Legitimized Answerback ("X"), telex dial digit ("T") types
%^              in lower creditside parties if used alone.  Legitimized any
%^              REL identifier for lower creditside parties which receive
%^              sec wires.  #19579, #19629.  Migrated to 4.2 by JRP.
%^      John R. Phelan   16-OCT-1996
%^              Break Relget_adr_set and Ent_c_adr_set for NOF parties.  Allow
%^              Intrtl_spec_pref_corr to be called for all idtypes.  #21072
%^      John R. Phelan   23-OCT-1996
%^              If another routine has already found a preferred correspartyondent
%^              for a not on file account, just exit out of B420_GET_NEWPARTY.
%^              C680_CDT_SWF_PARENT also finds correspondents for NOF accounts.
%^              #21359
%^      John R. Phelan   24-OCT-1996
%^              Make sure Set_nof_cdt_account is called prior to calling 
%^		Set_credit_unit_cnf to make sure that the Cdt_account field is
%^		set correctly.  Set_credit_unit_cnf passes Cdt_account to the
%^ 		Nof_domicil_unit Intrtl routine.  #21591
%^      John R. Phelan   24-OCT-1996
%^              Fix Chp_common_uids edit.  #21536
%^      John R. Phelan   28-OCT-1996
%^              Added Preferred advice and preferred submethod return arguments
%^              from Intrtl_spec_pref_corr routine.  #20726
%^      John R. Phelan   28-OCT-1996
%^              Fix bogus ambiguous lower creditside ABA party.  #20726
%^	John R. Phelan	 29-OCT-1996
%^		If the CONFIRM codeword is detected, call Si_delivery_confirm
%^		to create a default sender confirmation.  #20893
%^      John R. Phelan   31-OCT-1996
%^              Apply Swf_dda_qual_edt flag to any Faslink_gmx_srcs source,
%^              as well as SWF and WIR.  #20599
%^      John R. Phelan   04-NOV-1996
%^              Consolidate the logic that determines Type_code into
%^              Ftrscr_edits.  #21838
%^      John R. Phelan   19-NOV-1996
%^      	Enhance lookup portion of /confirm/ codeword support to use 
%^		the user_id of the sending bank as the routing id, and to look 
%^		up the application code in the Eft_key_info_table.  #22599
%^      John R. Phelan   21-NOV-1996
%^              Fix bug that prevented Spec_pref_corr preferred correspondent's
%^              advice type from overriding FED advice type from mapper. #22195
%^      Fred P. Isaacs   22-NOV-1996
%^              Distinguishes between case of ambiguous debit party because
%^              we found more than one (Relget_msgcode = VMSG$_AMBIG_LOOKUP)
%^              and ambiguous because we only have a partial match
%^              (Relget_msgcode = VMSG$_PARTIAL_LOOKUP).  Migrated to 4.2 by
%^		John R. Phelan.
%^      Fred P. Isaacs   22-NOV-1996
%^              1. Change logic to append second id onto NOF credit party
%^                 UNLESS credit party is an ABA and we are going FED.
%^              2. Change CHIPS qualification to
%^                a. Always roll down unmatched second credit id.
%^                b. Check for common UID if we have a uid and SWIFT only
%^                   but do this after initial qualification (so credit party
%^                   P is on common UID).
%^              Migrated to 4.2 by John R. Phelan.
%^      Fred P. Isaacs  22-NOV-1996
%^              Fix lower creditside party qualification to not register
%^              a conflict when it just cannot find an ID (as opposed to
%^              finding a conflicting one).  #21957  Migrated to 4.2 by
%^		John R. Phelan.
%^      Fred P. Isaacs  22-NOV-1996
%^              Fixed typo in B400_SET_ADVICE when setting Cdt_id.  22492
%^              Made CHIPS qualification failure still try for address
%^              sometimes.  22591  Migrated to 4.2 by John R. Phelan.
%^      John R. Phelan  27-DEC-1996
%^              Fixed bug in setting the Csid_multi_party flag.           
%^              Flag was sometimes getting set to 1 when the id field was
%^		empty.  #23053
%^      John R. Phelan   30-DEC-1996
%^              Don't issue message "Credit party ABA ... not found in REL or
%^              AUX", if the problem is that the ABA is ambiguous.  #22046
%^      John R. Phelan   30-DEC-1996
%^              Clear out credit party name and address when the address
%^              changes from on-file to not-on-file.  #21817
%^      John R. Phelan    9-JAN-1997
%^              If a message is received and the bene is for a common uid but
%^              is identified with a tid and account number, route the message
%^              straight thru.  #23563
%^      John R. Phelan    16-JAN-1997
%^              If the Def_secwir_if_pre_spl flag is "Y", and a BBK party
%^              might need to be preadvised, look up the REL for the BBK party
%^              so Valdate_edit has a country code to work with.  #21876
%^      John R. Phelan    23-JAN-1997
%^              If there's no room to insert a preferred correspondent,
%^		don't overwrite the credit party.  Also, make sure
%^		address sets are always connected NOMOD.  #22302
%^	Fred P. Isaacs	  11-FEB-1997
%^		Retain bank when changing to P account for CHP advice  #25403.
%^	Fred P. Isaacs	  12-FEB-1997
%^		Retain bank when changing to ABA for FED advice  #25449.
%^      John R. Phelan    12-MAR-1997
%^              Change the search currency if an account is inserted by an
%^              AIN.  #23745
%^      John R. Phelan    12-MAR-1997
%^              Clear out the Cdt_hold flag from the previous account whenever
%^              the Cdt_account field is cleared.  #24455
%^      John R. Phelan    12-MAR-1997
%^              Allow for "/" after dda account number.  #25199
%^      John R. Phelan    12-MAR-1997
%^              Cross-currency changes.  #23745
%^      John R. Phelan    12-MAR-1997
%^              Strip the preferred fed advising bank into the credit ABA id
%^              we gets the ABA ID from the AUX XREF (SWF to ABA) index
%^              and set the CDT_ADR_BNK_ID to that bank.  #25253
%^      John R. Phelan   12-MAR-1997
%^              Pass a the Fx insertion account to Acct_lookup using a 24
%^              character field instead of a 12 character field.
%^      John R. Phelan   12-MAR-1997
%^              If we have to strip in a 2nd ID for a not-on-file credit party,
%^              send the item to repair.  #25523
%^      John R. Phelan   12-MAR-1997
%^              Make suggested changes to cross-currency messages.  #25675
%^      John R. Phelan   12-MAR-1997
%^              Hose out the Cdt_rel_id if account changes to NOF.  #25324
%^      John R. Phelan   12-MAR-1997
%^              Further protections against bad repetitives.  #25740
%^      John R. Phelan   12-MAR-1997
%^              Correct two parse statements to parse from Cdt_id, not
%^              Cdt_idtype.  #25673
%^      John R. Phelan   12-MAR-1997
%^              Retain the credit bank context during the preferred
%^              correspondent loop.  #25666
%^
%^      Tom Carroll     19-MAR-1997
%^              Skip signalling an error when a standing instruction's
%^		pre-advise limit has expired and INTRTL switch PRE_EXPLIMIT_RSK
%^		or PRE_NOLIMIT_RPR are in use.  FTRSCR_EDITS will decide to send
%^              the transaction to repair or risk.
%^      John R. Phelan  27-MAR-1997
%^              Clear out the Cdt_account field if Cdt_typ is an ABA.  #26510
%^	Fred P. Isaacs	12-FEB-1997    27134
%^		Created C810_ROLL_DOWN paragraph to do second credit ID
%^		rolldowns for CHIPS qualification.  Checks for type collisions
%^		before doing the rolldown.
%^  
%^  	M. Kuske    23-Mar-1997     SPR26497
%^  		Initial bug was that the routing flag was not being cleared when
%^  		the credit account number was changed.  Investigation indicated
%^  		much redundant code and that debitside should also be changed.
%^     		The changes included changes creditside.cob, debitside.cob, and
%^  		qual_output.cob.
%^  
%^  	J. Phelan    7-Apr-1997     SPR27204
%^  		Fix problem that caused //CH not to be recognized.
%^
%^      J. Phelan    9-Apr-1997
%^              Don't re-lookup a locked credit party unless it absolutely
%^              has to be looked up again.  #26260
%^
%^      J. Phelan    5-May-1997
%^              Fix "Credit party address information has changed..." message
%^		logic  #28579
%^
%^      J. Phelan    6-May-1997
%^              Call the Intrtl_Nia_Pref_Corr routine from the screen routine
%^              as well as from the mapper routine.  #26964
%^
%^      John R. Phelan  19-MAY-1997
%^              Turn on code to disambiguate address based on currency in
%^              baseline mode.  #29039
%^
%^      Fred Kelley      2 Jun-1997   28375
%^              Added Csid_use_bank argument for GET_ACCOUNT_CURRENCY to 
%^              determine when to use bank defaults and when not to.
%^              4.1 to 4.2 
%^
%^	M. Kuske	12-Jun-1997	SPR29440	BOA
%^		Added the setting of CDT_NOT_SUSPECT_LS to zero to force 
%^		routing of message to repair and eliminated the resetting
%^		of the field when is_payment_ls is 1 and no previce si
%^		has been found.
%^
%^      Michael Kuske   19-Jun-1997     SPR29636
%^              Check digit routines can change the account number sent for
%^              verification.  This causes errors when processing secondary
%^              accounts.  When the account number received back from the
%^              check digit routine is different than that passed to the
%^              check digit routine, set the initial secondary account
%^              account number source to the new account number value.
%^
%^	Fred P. Isaacs	1-July-1997	PER 28784
%^		Implement Si_send_secwir_flg for credit party AIN.
%^
%^	A. Smith 28-Jun-1997		SPR #27131
%^		Use P_ID parameters in the debit or credit party bank-union to 
%^		replace hard-coded references to "CHIPS" and "CHP" as the 
%^		clearing-house name and source-code/cdt-advice-type associated 
%^		with the "P" idtype.
%^		Remove assumption that "E" idtype has 2-character local 
%^		clearing code id followed by "/" followed by local clearing 
%^		code: the "/" is no longer present.
%^		Add new arguments to the INTRTL_SPEC_PREF_COR routine which may
%^		now return both the party to insert as the credit party, and 
%^		the modified party identifier to push down to the next party.
%^		See "TODO(P_ID)" for places that would need refinement if a 
%^		different meaning of the "P" idtype is supported in different
%^		banks. Currently the assumption is that all banks have the same
%^		P_ID record set up. There might also be a need for different
%^		clearing houses sharing the "P" idtype, for example one per 
%^		currency.
%^
%^      John Phelan     23-Jul-1997   #31449
%^              If the first SI search fails, AND the address has no accounts,
%^              AND the credit_amount_currency_ls is NOT spaces, then use the
%^              credit_amount_currency_ls as the search currency for the
%^              second SI search.
%^
%^	Fred P. Isaacs	23-JUL-1997.  Check that account etc. are not spaces
%^		before clearing them.
%^
%^	A. Smith	29-Jul-1997
%^		Change X940 routine to remove hardcoded link between "P" idtype
%^		and "CP" SWIFT-account type.
%^
%^      John R. Phelan  04-Aug-1997    29206
%^              Break the Csid_accdef_seq so it doesn't cause problems for the
%^              next message.
%^
%^	A. Smith	13-Aug-1997
%^		Change order of items in parse statements, and corresponding
%^		oneof-values, so that the no-second-id case matches last. Also
%^		fix logic in various places to support the "E" idtype-subtypes
%^		instead of the usual suspects "BC", "FW", "CH", "CP", etc.
%^
%^		Parse can consume the entire string including the secondary
%^		ID as part of the primary ID if "(/)" case is first.
%^
%^		When comparing against secondary ID's in the REL file,
%^		ignore trailing characters in the in the address file version
%^		of the secondary ID only for short-name types of id's, unless
%^		the secondary ID is 0-length (i.e. there was a 2-character type,
%^		such as "FW", with no identifier). Previously, the strings were
%^		being compared only up to the length of the secondary ID from
%^		the message, ignoring character positions in the address after
%^		that length.
%^
%^		Init length of CSID_PREFERRED_CORR and remove redundant 
%^		initialization.
%^		Add CSID_CORR_DERIVATION, which indicates on return from 
%^		_NEW_PARTY how a preferred correspondent was derived. The 
%^		error flagged when a party is its own preferred correspondent 
%^		is now flagged only if the AIN-SI came from the REL; for 
%^		non-REL insertion and substitution, it is sometimes correct 
%^		for the credit and next party to both end up pointing to the 
%^		same address, using different identifiers from that address.
%^
%^      John R. Phelan  20-Aug-1997    19962
%^              Allow inserted party to be NOF, as long as it's on the AUX file.
%^
%^	Fred P. Isaacs 28-Aug-1997	33173
%^		Make sure that Csid_acc_seq gets broken after probing for 
%^		currency during AIN execution.
%^
%^	A. Smith	30-Aug-1997
%^		Takeout-garbage was losing blanking a BNP account with idtype G.
%^
%^	Fred P. Isaacs	2-SEP-1997
%^		Changed argument lists -- first step towards new currency
%^		conversion.
%^
%^      Mike Vallee     05-Nov-1997. 35555
%^              Removed the instruction in paragraph B500_debit_sis that
%^		assigne Dbt_ps_elig_flg of Ent_debit_set to "S".  This was
%^		causing messages that had a PRE SI with an expired PAL to be
%^		processed as a SPLit and routed straight through.  This change
%^		should process the message as a PRE and route the message to
%^		risk.
%^
%^	Fred Isaacs	8-DEC-1997
%^		Restructured X940_TAKEOUT_GARBAGE to give up when it encounters
%^		an E/ID or something it doesn't understand.  Now builds 
%^		idstring containing possibly changed account numbers as it goes.
%^		Paragraph is now much simpler and incorporates previous
%^		changes.
%^		X940_TAKEOUT_GARBAGE paragraph was not allowing address id's
%^		to be appended to our account types (D, V, G, P, and F). 
%^              35856.  Make lock flag not allow account id substitution.
%^              Also added 2nd id check to 2nd id returned from 
%^		INTRTL_SPEC_PREF_CORR.
%^
%^      John R. Phelan  24-Dec-1997    19962
%^              Allow inserted party to be NOF, as long as it's on the AUX file.
%^		Insert space in "Pref correspondent" message.
%^
%^      John R. Phelan  24-Dec-1997    29206
%^              Break the Csid_accdef_seq so it doesn't cause problems for the
%^              next message.
%^
%^	Fred P. Isaacs 8-Jan-1998
%^	37782   Make call to clear account things and strip in confirmation for
%^	        NOF credit party unconditional.
%^      37793   Make sure that if second id is present, our internal version
%^		begins with a "/".
%^      37994	Reworked credit bank setup.
%^
%^	Fred P. Isaacs  12-JAN-1998
%^	37993	Fixed multiple-id detection in lower credit parties.
%^
%^      John R. Phelan  13-JAN-1998.  In X940_TAKEOUT_GARBAGE, If the Idtype
%^              is not blank, D, S, C, A, or P, just return it as is.
%^              Also, define "U" as a valid lower creditside idtype.
%^              This is a requirement, since the FASIN mapper uses the "U"
%^              idtype in the SBK party, and the SAF_ISO mapper copies this
%^              party to the BNP party.
%^              #32218
%^
%^	H. Podany	19-Jan-1998	International Version
%^		Support "CHQ" advice type.
%^
%^      Fred Kelley     26-JAN-1998
%^      30746   Aux extended ids -make sure id is passed for E type
%^              C820_lower_credit.  Migrated to V4.3 by Jphelan.
%^
%^      John R. Phelan  03-FEB-1998
%^      35648   Added three new parameters to the Intrtl_spec_pref_corr
%^              routine to pass the 3 characters suffixes of P/ accounts,
%^		and the bank wire service register.  Changed to call the new 
%^		Validate_pid_adv_type subroutine to determine the valid "P" 
%^		advice type, since this can now vary depending on bank.  
%^		Changed to call the new Lookup_pid_rec subroutine to lookup
%^		up "P" ID information, since this can vary depending on bank,
%^		account suffix, currency, etc...  These changes are 
%^		necessary for the Amex German Clearing Interface.  Also fixed
%^		Men2_bnk_union subject not connected trap.
%^
%^	Fred P. Isaacs  6-FEB-1998
%^	38536	Make CDT party bank explicit when message owning bank changes.
%^      39084  Pass additional argument to INTRTL_SPEC_PREF_CORR from 
%^		CREDITSIDE_LOOKUP: the 2nd credit party identifier. In 
%^		CREDITSIDE_SCREEN and ~_REROUTE, pass a zero-length string,
%^		since there is no contextual 2nd identifier.
%^
%^      John R. Phelan  10-Feb-1998
%^      39285   Implement Aux AIN Standing Instructions for the Amex German
%^              clearing interface.  They need to be able to add a single
%^              AIN to Aux records.  Acct_lookup will return the AIN in
%^              Relget si set.  B420_GET_NEWPARTY will check for an
%^              AIN in Relget si set as the last step.
%^
%^      Fred P. Isaacs  18-Feb-1998
%^	36856	X940_TAKEOUT_GARBAGE no longer fooled by extraneous spaces
%^	36920   Make sure explicit fed bank is inserted.
%^	35131	Already applied -- X940_TAKEOUT_GARBAGE restructuring for E/.
%^	
%^      B. Lanza        24-Feb-1998     #39561
%^      Traps with Acct_Lookup_Index not connected.  On a partial match do not
%^      perform c690_snam_chck to resolve ambiguity using short name.
%^
%^	Fred P. Isaacs	3-MAR-1998	#40082
%^	Made sure that it knows relget_adr_set is not valid for NOF pushdown.
%^
%^      B. Lanza        6-Mar-1998      #39561  migrated from 4.2
%^      Traps with Acct_Lookup_Index not connected.  On a partial match
%^      (relget_msgcode = vmsg$_part_lookup) do not perform
%^      C690_SNAM_CHCK to resolve ambiguity using short name.
%^
%^      Tom C. Carroll 25-MAR-1998     40407
%^      Placed a memo in the message history when set_credit_address sets
%^      the message priority.
%^
%^ 	Fred P. Isaacs	8-APR-1998
%^	41633.  Modify fix 36920 above to not do it if tran-type is "BPF".
%^
%^      M. Vallee       17-APR-1998     41545
%^      Clear out any residual error messages from CSID_ERR_MEMO area.
%^
%^	Fred Isaacs	6-MAY-1998      42503
%^	Now recognizes that AIN inserting NOF address from AUX may not be an 
%^	error.
%^
%^	Fred Isaacs	12-May-1998	42642
%^	Now properly eats trailing slash after account id (null address id).
%^
%^      John Phelan     27-May-1998     43299
%^      When the FTR bank changes after Debit_look_account, correctly
%^      format the implicit/explicit credit bank.
%^
%^      John Phelan     15-Jun-1998     43650
%^      Detect Id and Idtype changes coming back from Acct_lookup in the
%^	A100_push routine.
%^
%^      John Phelan     12-Jun-1998     43736
%^      If AIN insertion found on AUX and Csid_id_bank_ws is blank, default
%^      it to Ent_ftr_set.loc_info.bank
%^
%^      Fred Kelley     21-Jul-1998    #43062  migr 3-Nov-98 to 4.4
%^      Call new rtn "GET_EQUIV_CURRENCY" if address found but account for 
%^      currency not found. This rtn will return an equivalent currency if
%^      any. Another attempt to find an account with this currency will be 
%^      made if an equivalent currency is returned (such as EUR).
%^      If an account is found, it will be used, and the new currency
%^      will be returned to the caller, who will convert the amt to the new
%^      currency. In parag B340_FIND_ACCOUNT
%^
%^	Don Ryan	24-Aug-1998	#45981
%^	Extended ID's with a sub-type of "ID" and alpha characters after the 
%^	code word were writing an ambiguous message for the beneficiary on 
%^	incoming telex messages.  Paragraph C820_lower_credit is being modified.
%^
%^	Fred Isaacs	10-SEP-1998	#45875
%^ 	Now changes ID in message to match credit account.
%^
%^ 	Fred P. Isaacs	11-SEP-1998	#45796
%^	Lengthened VSTR's for temp lower creditside party representations to
%^	prevent traps on bad ID's.
%^
%^      Fred Kelley  11-Sep-1998    #25062
%^      Under INTRTL control, new Chips qualification rule.
%^      a. -c780 If not qualified, and both acct and Swift tid are provided,
%^          allowed straight thru as not qualified 
%^      b. -In b200 b220 b240 b260, if chips_qual ok, chips_qual_idstr not,
%^          call new para c700. 
%^          In c700 if swift id present, try chips_qual again with Swf id
%^          If ok, send to repair, as it is on different uids
%^          Not ok, reestablished relget_adr and allow it to go through
%^
%^      T. Carroll      20-OCT-1998     #47026
%^      Create a SYSMEMO in the message history when the INTRTL_SPEC_PREF_CORR
%^      successfully returns a new correspondent.
%^
%^      J. Phelan       10-NOV-1998     #48905
%^      "If the primary credit id is an address id and the second credit id is
%^      an account id and if the second id account is found attached to the
%^      address found using the primary credit id, the primary credit id
%^      should be changed to the account specified in the second credit id.
%^      That will force use of the actual account as the credit account
%^      instead of simply selecting the default account as is done today." -
%^      from Fred Isaacs' problem writeup.  Fix 4 nested if statements.
%^
%^	Fred P. Isaacs 31-Mar-1999	52862 (PORT)
%^	Csid_si_error is now Boolean to match what the SI_FIRST_CREDIT and
%^	SI_FIRST_DEBIT routines think it is.
%^
%^	Fred P. Isaacs 22-Apr-1999	53240 (PORT)
%^	Fixed problem with aux credit party address.
%^
%^ 	Fred P. Isaacs	5-MAY-1999	54146(PORT)
%^	Corrected call to GET_SUFFIX_FROM_PID
%^
%^ 	Fred P. Isaacs	21-JUL-1999	54115(PORT)
%^	Cleaned up error message when AIN cannot get secwire sent to
%^	pushed-down credit party.
%^
%^      J. Phelan       28-JAN-1999     #50786
%^      When the "Incorrectformat in credit party" error is flagged, set
%^      the Cdt_adr_bnk_id field before exiting the routine.  Mpa and
%^      message routing need this field.
%^
%^      T. Carroll	17-FEB-1999     #50463
%^      Move the routine to disambiguate based on short name (using the  
%^      me_first index) up before disambiguation by currency code.
%^
%^ 	Fred P. Isaacs	7-APR-1999	#52348
%^	When setting account to match clearinghouse advising method,
%^	need to match on suffix (if in use) as well as "P" idtype.
%^
%^      J. Walsh 	08-APR-1999	MPER 48548  Migrate 37490
%^      Add INTRTL CHIPS_DOUBLE_ID_FLAG for additional qualification
%^      procedures after Chips_qualification_idstr fails.
%^
%^      B. Lanza        13-Apr-1999     #52168
%^      Repetitive processed through ISI with Chips id type "P", is
%^      getting "Incorrect format in the credit party" returned from
%^      creditside_lookup because the length is not 4 and the id is not
%^      numeric because of the slash after the Chips id (P/0008/) .
%^      Changed X940_TAKEOUT_GARBAGE to remove ending slash from id.
%^
%^      B. Lanza        15-Apr-1999     #53295
%^      Error "Incorrect format in BNF C003877/(BCBEXADZALBIC/AC11004405)"
%^      is generated when processing a repetitive.  Changed B200_BNP to
%^      clear everything after the "/" in the bnp_id for type "C".
%^      It will get re-mapped.
%^
%^	D. Ryan		10-May-1999	#15526 & 54097
%^	Add new argument to Acct_lookup (Acct_look_pend_del).
%^
%^	K. Hanlon	14-Jun-1999	PER 50434
%^	Call SI_COPY_ADV to copy the advice set into the message (adv_Seq)
%^	(MT103 processing needs this information)
%^
%^	J. Phelan	21-Jun-1999	#55382
%^	BREAK: the Relget_adr_set to avoid trapping on Cms_map repetitives.
%^
%^
%^	Kristen Hanlon	22-Jul-1999	#56260
%^	If we are pushing down a "D" idtype to a lower-level party due to the
%^	FX codeword, clear out the idtype to stop account edits.
%^
%^	Kristen Hanlon	28-Jul-1999	#56343
%^	Change clearing logic for 56260 above to be SUBJECT vs COBOL statements
%^	since COBOL statements are not committing it to the database.
%^
%^	Tom Carroll	30-Jul-1999	#55572
%^	Find the TTL account to be used via the 1st element of the
%^	TTL_ABA_ACCTS INTRTL table rather than a hard coded constant.
%^
%^	Fred P. Isaacs	29-Sep-1999	57899
%^	Fix null set and sequence definitions for PORT.
%^
%^	Fred P. Isaacs	29-Sep-1999
%^	Tweaked status checks for executing Chips double id non-qualification
%^	override.
%^
%^	Fred P. Isaacs	30-Sep-1999	57634 for PORT
%^	Fixed trap on Ent_c_adr_set not connected after AIN.
%^
%^	Fred P. Isaacs	5-Oct-1999	58119 for port
%^	PID suffix will be checked on suffixed PID against advice method;
%^	suffix for advice method will be appended onto unsuffixed PID.
%^
%^	Fred P. Isaacs	7-Oct-1999	Migrate 57534 
%^	Move Initialization of Csid_push_error to top of routine.
%^
%^	Fred P. Isaacs	15-Oct-1999	58231 for port
%^	Cleaned up Csid_acc_id_ws usage.
%^
%^	Fred P. Isaacs	19-Oct-1999	58233 migrate to port
%^	Remove erroneous NOT in IF test for C690_SNAME paragraph.
%^
%^	Fred Isaacs	23-DEC-1999     #59991
%^	Corrected implementation of 52168 and removed some other problems.
%^	Null or actual address id after chips account is now ignored while
%^	account	is checked and appended back after account id in
%^	X940_TAKEOUT_GARBAGE paragraph.  P/0009/ comes out still being P/0009/
%^	so we don't get spurious errors on repetitive credit parties but
%^	account check is only done on P/0009
%^
%^	K. Hanlon	10-Nov-1999	#58951
%^	In B200_bnp, if we fail chips qualification we should still
%^	do the lookup of the bnp and map in the address info from aux.
%^
%^	K. Hanlon	15-Dec-1999	#59129
%^	When we now do the lookup due to 58951 above, we must do it
%^	on AUX first not REL and only do it on REL if not found in AUX.
%^
%^	Fred Isaacs	11-JAN-2000     #60256
%^	Removed logic which disabled check digit account number change if
%^	Pd_enabled was "T".
%^
%^	Fred Isaacs	18-JAN-2000     #60094
%^	Made sure we break Csid_bnk_union before we hook it up.
%^
%^	Fred Isaacs	18-MAY-2000     #60874
%^	If explicit account identifier has been given for credit party, make
%^	sure that we use that account, even if there is a currency mismatch.
%^
%^	Fred Isaacs	19-MAY-2000     #63716
%^	Modified changes for 60874 above to fix problem when finding default
%^	from a NOF reference and to enforce stickiness of account id when
%^	not appropriate for advice method (actually simplifies lookup logic).
%^
%^	Fred Isaacs	20-JUL-2000     #65678
%^	Found another place to BREAK: Csid_accdef_seq.
%^
%^	Fred Isaacs	24-JUL-2000	#52354 #54255
%^	If we are about to check a preadvise_limit or its expiration date and
%^	we have a concentration account, then we must look for the preadvise
%^	limit and expiration date in the concentration account, not the debit
%^	account.  54255 is same for group.
%^
%^	Anna Caci	15-SEPT-2000
%^	Code cleanup to resolve java translator issues.
%^	Also, fixed sbj not connected for csid_accdef_seq and
%^	reversed the sides of the following equate
%^ 	Csid_accdef_seq EQUATE: Csid_acc_seq.
%^
%^	Fred Isaacs	10-OCT-2000	67472
%^	Made sure that we use local aux db set connected NOMOD to Csid_aux_set
%^	in place of references to Aux_db_set, which may be connected strangely.
%^	Make sure that if we have a partial success in C820_LOWER_CREDIT that
%^	we emerge with a relget from which we can copy the address.
%^
%^	H. Podany	19-Oct-2000
%^	Add new arguments returned from GET_PID_ADV_DATA.
%^
%^	Fred Isaacs	26-OCT-2000	68396
%^	Add currency and amount arguments to call to CUST_SPEC_PREF_CORR routine
%^	so that those passed as arguments to CREDITSIDE routines can be passed
%^	through to CUST routines.  They are not set in the message yet.
%^
%^	Fred Isaacs	1-NOV-2000	67416, 67675
%^	Make sure that record structure of preferred correspondent ids is
%^	reflected in code and that record lengths are passed as an argument when
%^	records are passed.
%^
%^	Fred Isaacs	2-NOV-2000	67675
%^	Correct usage of CUST_XTEND_ID_EDIT routine.  Change arguments for
%^	routine.
%^
%^	Fred Isaacs	10-NOV-2000	68611
%^ 	Now set Bnp_bnk_flag to indicate beneficiary is a bank in
%^	C600_UPDATE_BNP paragraph.
%^
%^	Fred Isaacs	12-DEC-2000
%^	68909 Make FED advice override for NOF ABA credit party not happen for
%^		source FED.
%^	70256 Make sure local account sequence not connected when we go to use
%^		it.
%^	70356 Make sure to do change to set overall record length after using
%^		record arg to cust sub.
%^
%^	Fred Isaacs	10-JAN-2001	70875
%^	Fixed typo in parse statement when parsing off bank name looking for
%^	account.
%^
%^	Fred P. Isaacs	7-FEB-2001	70982
%^	Move SET_NOF_CDT_ACCOUNT calls to right place.
%^	Make clearing recon field explicit.
%^
%^ 	Fred P. Isaacs  8-Feb-2001	70258
%^	Don't do lower creditside lookup on party that was just pushed down.
%^
%^	Fred P. Isaacs  13-MAR-2001	70804
%^	Added logic to X940_TAKEOUT_GARBAGE paragraph to squidge out
%^	a duplicate function indicator with a null id at the beginning of the
%^	ID.  (For example,  /AC7107896 becomes  /7107896, S/BCFREDUS33 becomes
%^	S/FREDUS33)
%^
%^	Fred P. Isaacs	15-MAY-2001	73480
%^	Corrected B400_SET_ADVICE paragraph P account matcher.
%^
%^	E. Osterberg	16-May-2001	73057
%^	Correct status check for ent_code_seq to prevent Subject trap which was
%^	doing a FIRST following a Failure_is check, a Success_is check seems
%^	to be the intended check.
%^
%^	Fred P. Isaacs	6-JUN-2001	75024
%^	For clearinghouse advice method and credit party with corresponding
%^	clearinghouse E/ id, check extended id config table and do not change
%^	the E/ id to a P/ id if it is marked as deferred in the table.
%^
%^      J. Walsh        17-Jul-2001     73997 
%^      Add paragraph C655_2ND_CREDIT_ID to disambiguate non-blank second
%^      credit IDs.
%^
%^	Fred P. Isaacs  6-AUG-2001    74825, 76147
%^		Made "Y" accounts non-candidates for selection by currency
%^		match.
%^
%^	J. Walsh	21-Aug-2001	76171
%^	Correct trap when there is no xref entry found in D860_SWIFT_TO_ABA.
%^
%^	Ken Bjelke	8-Nov-2001 	78841
%^	Add parameter to call to CREDIT_ADVICE_LOOKUP to determine whether
%^	to mod the ent_adv_set of not. Creditside can so call with 1, Trade_lookups
%^	cannot, so it uses 0.
%^
%^      S. Smith        6-Nov-2001      78825
%^      initialize Csid_id_bank_ws. If a batch of message is being processed
%^      and the first one has a bank preface and the following have an ain
%^      of a AUX aba then the cdt_adr_bnk_ws is incorrect for all of them.
%^
%^      D. Boyajian    24-Dec-2001	Spr 75405
%^	TRN expansion project:
%^	 . Expand "Csid_trn" from 12 (6 & 6) to 16 (8 & 8).
%^
%^	Fred P. Isaacs	21-Dec-2001	73608
%^	Need to blank out lower party id's with spaces when resetting them
%^	because a previous id may have been longer and some users may ignore
%^	counts.
%^
%^	Ken Bjelke	02-Jan-2002 75468
%^	Move setting of ent_credit_set.bnp_bnk_flg up to prior to B400_SET_ADVICE
%^	calll to allow for proper evaluation of ADV_SEQ rules.
%^
%^	Ken Bjelke	08-Jan-2002	80548
%^	Add the preferred_chp_bnk logic (ported). May need to be revisitted later.
%^		Vax comments:
%^		In a cross-bank scenario where different backs belong to non-"CHP" clearing
%^		houses in different countries, this logic should not be invoked, or at least refined.
%^	X940_takeout_garbage modified to call CUST_P_CHECK_DIGIT for CHIPS accounts.
%^
%^	T. Carroll	07-Feb-2002	81459
%^	Do not copy the bank id from the credit party to the AIN when 
%^	the AIN is an ABA.
%^
%^ 	Ken Bjelke	11-Feb-2002	81298
%^	Always call INTRTL_NIA_PREF_CORR as part GET_NEWPARTY. AIN
%^	should always be performed. This make CREDITSIDE_LOOKUP consistent
%^	with CREDITSIDE_SCREEN.
%^
%^	D. Pacelle	4-Apr-2002	76638
%^	Account number expansion.  Removed obsolete overflow id logic.
%^
%^	Ken Bjelke	29-Apr-2002	83550
%^	Allow Cdt to be own pref corr when SUB is the AIN action.
%^	Add check to GET_NEWPARTY ensure that we don't loop count when
%^	SUB AIN and current party have the same address. The 1st substitution
%^	takes place OK, an we will detect and exit after that.
%^
%^	Ken Bjelke  8-Aug-2002
%^	Add returned account from Channel_determination. Ensure that it does
%^	NOT override the Cdt ID.
%^
%^
%^	Ken Bjelke 	23-Aug-2002
%^	remove reference to relget si set, replaced with new fields in 
%^	Reget_fsect
%^
%^
%^	Ken Bjelke	9-Sep-2002	Spr 88382
%^	If Fx_ena is low value, and the cdt_acc rel account currency is blank,
%^	See if the message matches the Base currency. If so, allow item to be paid.
%^
%^	Add GET_CHANNEL call to allow us to obtain the clearinghouse status of channel.
%^	This  will eventually completly replace the call to GET_PID_ADV_DATA.
%^
%^
%^	Ken Bjelke 	17-Sep-2002spr 89318	
%^	Correct the calling orders for the PRULE_UPDATE_PARTY and the PRULE_CHANGE_CREDIT
%^	calls.
%^
%^
%^ Ken Bjelke	01-Oct-2002
%^		Add parameter Party_rerun_ind. Will be used to allow CREDITSIDE LOOKUP
%^		to operate like Creditside_screen for parties changed by PD or Autotreive.
%^
%^
%^
%^ Ken Bjelke	28-Oct-2002
%^		Add Csid_extnd_country to Cust_xtend_id_edit
%^
%^
%^ Ken Bjelke	30-Oct-2002
%^		Creditside_lookup :
%^			Change takeout_garbage to check gcht_ac and ghct_nomatch 
%^			for IBANS
%^
%^		Creditside_screen:
%^			reset chandet_called flag after insertions to allow for new
%^			Channel_determination call
%^
%^			Allow cdt_acocunt to be set correctly for clearing systems
%^				
%^			Leave manually entered BNP_BNK_FLG intact
%^
%^ Ken Bjelke	6-Nov-2002	91650
%^		Connect the correct BNK profile
%^
%^ Fred P. Isaacs  11-NOV-2002  90950
%^		Changed Prule_party_fsect to make AUX prules work.
%^
%^
%^ Ken Bjelke	14-Nov-2002
%^		Correct Creditside_lookup handling of IBANS.
%^
%^ Ken Bjelke	18-Nov-2002 	Spr 90296
%^		Correct CDTAIN processing in Creitside_Lookup
%^
%^
%^ Ken Bjelke 	20-Nov-2002	92258
%^		REmove some references to GET_PID routines. No
%^		longer required, and causing problems.
%^
%^
%^ Ken Bjelke	 21-Nov-202	90089
%^		DFT entry issues. CDTAIN was being inhibitted by Originally
%^		NOF credit party. With PRULES, this must be allowed.
%^
%^ Ken Bjelke	22-Nov-2002 	91803
%^		Complete the DFT processing. Tweaks to allow the account 
%^		INS'ed by the AIN the be handled correctly.
%^
%^
%^ Ken Bjelke 	26-Nov-2002	Spr 91446
%^		Correct Execution parameter names the Method on an AIN.
%^		Param was METHOD now use PAYMENT_CHANNEL.
%^
%^ Ken Bjelke	27-Nov-2002	Spr 82640
%^		Correct setting of musthave_account flag. was inhibitting RPT
%^		entry in some cases.
%^
%^ Ken Bjelke 	4-Dec-2002	Spr 92511
%^		Correct connection of AUX item for PRULE setting.
%^
%^ Ken Bjelke 	12-dec-2002	spr 93333
%^		Allow for blank cdt_id and cdt_idtype, should result in CHK
%^		relax edit for AIN is own pref corr, downgrade to a skip the push,
%^		instead of flagging as an error.
%^
%^ Ken Bjelke	12-Dev-2002	spr 93151
%^		Add the creation of the PRM CDT_NATIVEACCOUNT when a Valie IBAN
%^		is received. This will reside at the message level.
%^
%^ Jan Walsh	16-Dec-2002	93532
%^	Add mode and credit currency to arguements for SECWIRE_EVAL call.
%^
%^
%^ Ken Bjelke 18-Dec-2002	
%^	Relax edit for Own_pref_corr for CREDITSIDE_LOOKUP
%^	Could be triggered by Bank level CLR. Just exit the push loop
%^
%^ Ken Bjelke	20-Dec-2002	93849
%^	Leave relget-Adr connected for AUX items. 1 case was dis-connecting.
%^
%^ Cam Hansen   30-Dec-2002     59856
%^      moved  Go to B200_BNP_END  after set failure_is in creditside_screen_ls
%^
%^ Ken Bjelke	02-Jan-2003	94041
%^	Modify CREDITSIDE_LOOKUP to ensure populatiion of the cdt clearing account
%^	gl returned by Channel_Determination regardless of CD return status.
%^
%^ Ken Bjelke 	08-Jan-2003	93745
%^	Set cdt_not_suspect and creditside_look_ls to Failure when we haven't
%^	had a successful Channel_determination call. Should indicate failure to 
%^	caller.
%^
%^ Ken Bjelke 	08-Jan-2003  91245
%^	Correct pick list for IBAN derived BBK's. Just populate.
%^
%^ Ken Bjelke 09-Jan-2003    94449
%^	If an ON US but NOF BBAN is detected, do not flag as error, allowing
%^	Autotreive call to take place.
%^
%^
%^ Ken Bjelke 10-Jan-2003   94492
%^	In TAKEOUT_GARBAGE, call IBAN validation for all D type calls when
%^	STRUCTURED_ACCT_IN_USE is set. This should allow proper processing
%^	of BBAN's and IBAN's.
%^
%^ Ken Bjelke	14-Jan-2003	94672
%^	Correct overwriting of IBAN in BNP with inserted BBK information 
%^
%^ Ken Bjelke 	14-Jan-2003	93787
%^	Ensure that the BNP country of residence when an IBAN is present.
%^
%^ Fred P. Isaacs  16-JAN-2003 94807
%^	"Soften" connection via credit and debit set address pointers since
%^	AUX entry can get erased while message is still being processed.
%^
%^ B. Lanza	21-Jan-2003	Spr 89085
%^	Remove check of menu_next_function. This belongs in creditside_screen.
%^
%^ Ken Bjelke	28-Jan-2003	Spr 94619
%^	Correct erroneous error message when BNP has no IDTYPE nor ID.
%^	This was being checked in TAKEOUT_GARBAGE instead of just bypassing.
%^
%^ Ken Bjelke 05-Feb-2003	Spr 95527 
%^	Inhibit INSERT AIN's at levels above address. SUBS allowed at any level 
%^	this is for Internal ID's only D,G,F, V.
%^
%^ Ken Bjelke	06-Feb-2003	Spr 95614
%^	Correct trap when called with a Repetitive that is an One Us dda.
%^	If the lock_cdt_party flag is set, do not act upon BBAN sub.
%^
%^
%^ Ken Bjelke 	12-Feb-2003	95858
%^	Restore Idtype on Repetitives.
%^
%^ Ken Bjelke 	21-Feb-2003
%^	96094 - Modify logic for check AIN party against existing party. Need to 
%^	check id type to see whether to strip the / or not. Length checks were
%^	inhibiting some AINs from taking place.
%^	96190 - Don't call Channel_DETERMINATION for non-payments. It will just return
%^	an error resulting in bad message history memo entry
%^
%^ E McCurdy	28-Feb-2003	96208
%^	Change the csid_lcp_index_type_ws for Chips 'P' from 'A' to 'R' to avoid
%^	SJB$_INVOBJTYPE trap when connecting from chips_index to csid_lcp_adr_set.
%^	Paragraph D870_LOCKED_CREDIT_PARTY.
%^
%^ Ken Bjelke	04-Mar-2003	94675
%^	Leave Accounts on ABA. Was being blanked.
%^
%^ Ken Bjelke	05-Mar-2003	96350
%^	When Second id is assumed to be D, check for csid_adr_set connection
%^	first to defend against sbj-not-con. Was happening when 2 accounts 
%^	present in incoming SWF, not illegal, but not recomended(no nak but
%^	not allowed).
%^
%^ C Czerwinski	06-Mar_2003	96090
%^	Added BBAN and removed in cdt to wording in B280_credit_adr
%^	 "IBAN/BBAN Detected "
%^
%^ Ken Bjelke	20-Mar-2003	97376
%^	Correct the lookup order for Accounts. F first, then D.
%^	Parameter cdt_acc_type_ls was set incorrecly as str(3), corrected to str(1).
%^
%^ Ken Bjelke	24-Mar-2003	92770,93828
%^	Correct processing for REP_BBK_DFORMAT and add REP_BBK_AFORMAT for IBAN
%^	processing. If REP_BBK_AFORMAT is set, and the BBK on an incoming is a
%^	BIC with "BE" as it's country code, replace if BNP IBAN derived BIC.
%^
%^ Ken Bjelke 	02-Apr-2003	98145
%^	Correct the inhibit logic for Skipping CDTAINs on levels above address.
%^
%^ J. Curley	03-Apr-2003	98264
%^	Correct Not Str Thru: Found duplicate credit account when only one account
%^	for address.
%^
%^ K. Bjelke	04-Apr-2003	98167
%^	Clear out idtype when pushing down IBAN, D was left over in 
%^	bnp_id by mistake.
%^
%^
%^ Ken Bjelke	30-Apr-2003	Several SPR's
%^
%^	99197 - Correct level usage in Prule_msg_rule_macth call. Was using wrong
%^		definition, causing CDTAIN match to be missed.
%^
%^	98480 - Lookup account order changed
%^
%^ Ken Bjelke 	6-May-2003	97169,98803,98108
%^	98108 - Avoid mismatch on 2 ids with a currency on the account
%^	98169
%^	98803 - Skip adding the "D" on Failed IBAN validation. Was
%^		causing bad values to be sent to Autotreive
%^
%^ Ken Bjelke 	23-May-2003	spr 100059
%^	Correct parameter checking for REP_BBK format calls. Was only finding
%^	when in Credit party, shoudl look throughout prules list.
%^
%^ Bob Lanza	27-May-2003	100358
%^	Port spr 65033. When Do_chips_qualif_ls = 2 do not return fail 
%^	(cdt_not_suspect_ls = 0 ) if chips qualification fails. 
%^
%^ Ken Bjelke 	02-Jun-2003	100627
%^	Correct processing for bank without structured_account flag set.
%^	If flag is NOT st, skip all IBAN processing
%^
%^ Ken Bjelke 	09-Jun-2003	100554
%^	Correct Cdt_account lookup Order.
%^
%^ John Phelan 	10-Jun-2003	100734
%^ 	Reset flags upon return from D780_BNP_IBAN.
%^	B200_BNP performs D780_BNP_IBAN because the iban was found, 
%^	which performs B220_BBK.  B220_BBK sets the csid_found_it flag to success.  
%^	When control is returned to B200_BNP, the csid_found_it flag from the BBK 
%^	is still set to success, so it thinks the BNP party is onfile as well.  
%^	So SET_BNP_PARTY is called, which clears out bnp_name1.
%^
%^ Ken Bjelke 	11-Jun-2003	100258
%^	Don't insert BBK from IBAN when CDT party contains a BIC
%^	either on Address or in ID
%^
%^ Ken Bjelke 	16-Jun-2003
%^
%^	100502  - Inhibit AIN from taking place when Account in Currency is available
%^		  in credit party.
%^
%^ Ken Bjelke 	23-Jun-2003	101450
%^	Correct trap when chanking for AIN account. Was happening when the
%^	encountering an AIN on AUX after an IBAN insert
%^
%^ D. Ryan	02-Jul-2003	#101499 & #100209
%^	Modify logic for displaying the error message, "Credit party address information
%^	has changed", if the not credit party is not on file. 
%^
%^ Ken Bjelke	07-July-2003	101907
%^	Long Cdt id with Secondary id was being truncated to 24.
%^	Allow max 64.
%^
%^ Ken Bjelke	17-July-2003	102124
%^	Correct invocation of CDTAIN when non-account id provided and
%^	account is available. AIN should still be invoked if it is not
%^	above the address level.
%^
%^ J. Phelan	17-Jul-2003	100487
%^	Don't overlay xxx_res_country if already filled in.
%^
%^	Ken Bjelke 	28-July-2003	101377
%^	Strip extra ID's when RPT is sent in with UID. Extra Id's causing
%^	problems, and will be lookup up later.
%^
%^ Ken Bjelke 	30-July-2003	101878,102078
%^	101878 - Move setting of credit_set rel_id items to before
%^		 Channel determination call. Setting is tentative.
%^	102078 - If IBAN in BNP, and no BBK use it to replace Credit
%^		 party right at the start, if it validates. Dependant upon
%^		REP_BBK_AFORMAT and REP_BBK_DFORMAT parameters.
%^
%^
%^ Ken Bjelke 	4-Aug-2003	103299
%^	Clear the Pref_corr_rec when encountering a SUB of same. 
%^	This should exit loop and allow processing to continue.
%^
%^ Tom Carroll	8-Aug-2003	103427
%^	When mapping the credit party from the BNP (SPR 102078 above),
%^      also map the name1 thru name4 fields so they are retained when 
%^	the party is pushed down.
%^
%^ Ken Bjelke 12-Aug-2003 	103473
%^	Correct default account detection logic. Bug was causing a 
%^	curency mismatch as wrong account was being compared.
%^
%^ Ken Bjelke 	14-Aug-2003 	103474
%^	Clear csid_iban_country each pass.
%^
%^ Ken Bjelke 	15-Aug-2003 103589
%^	Add calls to PRULE_CHANGE_CREDIT to allow correct
%^	Channel determination
%^
%^ B. Lanza	25-Aug-2003	101894 (vax 61874)
%^	When acct and bic and swf_str_thru_qual_edt = T, allow to process
%^	straight thru.
%^
%^ A. Sowers 	02-Sep-2003 104217
%^  Check if beneficiary country of residence is filled before overlaying
%^  with country found from iban/bban validation.
%^
%^ Ken Bjelke	03-Sep-2003	104260
%^  When using the SWIFT_HO_INSERTION logic, restore the RELGET_ADR_SET to it's
%^  original (branch) value after setting up the HO  in the csid_pref_corr_rec.
%^  Not doing so was resulting in the HO being pushed to the BNP along with being
%^ inserted.
%^
%^ Ken Bjelke 	09-Sep-2003 104445, 104446
%^	ensure CDT_RES_COUNTRY is cleared on a pushdown, and
%^	reset csid_musthave_acct priot to each CHANNEL_DETERMINATION call
%^
%^ Ken Bjelke 	30-Sep-2003 105372,105483	
%^	Clear csid_iban_cntry_ws and attempt to fill coutries for BNP
%^	prior to takeout_garbage call. Handle country changes better.
%^
%^ Ken Bjelke 	02-Oct-2003	105294
%^	When calling Channel determination for a second time, clear the 
%^	Channel account if one was found in the 1st pass.
%^
%^ Ken Bjelke 	02-Oct-2003	104447
%^	Ensure we have a currency set during the CDTAIN check for Level and
%^	presence of the account.
%^
%^ Ken Bjelke 	14-Oct-2003	100672,105601,105715,105795
%^
%^	100672 - Inhibit the choosing of "L" accounts, as is done with
%^		 P and Y.
%^
%^	105601 - Correct ASI finding proper Credit Party Information.
%^		 Ruels on AUX items not found correctly.
%^
%^	105715 - CDT party CNF's were removed when BNP changed. Corrected.
%^
%^	195795 - AUX clr not found, Leave relget_adr_set connected thru PRULE
%^		 CHANGE_CREDIT call. Was setting as Message rule seq as opposed
%^		 to AUX.
%^
%^
%^ Ken Bjelke 	20-Oct-2003	106349
%^	Correct handling of a NOF On-Us IBAN split. There was a problem
%^	causing a trap when substituting the NOF ON US BBAN from the Iban.
%^
%^ Cam Hansen   27-Oct-2003     59856
%^      changed paragraph name B340_FIND_ACCOUNT_DEFAULT to
%^      B340_FIND_ACCOUNT_EXIT for java translation
%^
%^ Ken Bjelke 	27-Oct-2003	106571
%^	Move copy address call up to prior to B400_set_advice. 
%^	Avoids getting the relget_adr_set trounced before the copy.
%^
%^ Ken Bjelke 	30-Oct-2003 	105603
%^	Leave bnp_charge intact when Moving IBAN to CDT. It will be 
%^	pushed back down.
%^
%^ D. Ryan	05-Nov-2003	106399
%^	The error message regarding the credit party address changing since the
%^	repetitive was create now only checks if the credit rel_id has changed
%^	in the creditside_lookup module.  Also if the validate_iban fails and the
%^	source is STO, then do not change the csid_ambig_parties value in B200_Bnp.
%^	This allows the STO to be created even though the BNP is not a valid Iban.
%^
%^ Ken Bjelke 	12-Nov-2003	106338
%^	Move "DETERM_RES_COUNTRY" call for Credit party to C720_COPY_ADDRESS.
%^
%^ C. Crain	18-Dec-2003 PER	97347
%^	Modified B200_BNP to clear address pointer before lookup.
%^
%^ D. Ryan	24-Dec-2003	108093 & 107870
%^	108093
%^ 	Use the credit party's country of residency or the menu_bnk_union.country_code
%^	when the call to validate bban is made via the call to validate_iban.  In paragraph
%^	B280_credit_addr the credit party's country code was not being used 
%^	(Csid_iban_cntry_ws).
%^
%^ 	107870
%^	In #106399 the incorrect format for BNF also should be applied for the
%^	incorrect format for the credit party in B280_credit_adr.
%^
%^ Ken Bjelke 	24-Dec-2003	108387
%^	Correct edits for pref_corr SUB pointing to self.
%^
%^ Brian McLean 30-Dec-2003     97344
%^      Added call to Precalc_cdt_value_date to support effective dates for
%^      Channel Determination.
%^
%^ Ken Bjelke 	09-Jan-2004 	108574
%^	When checking for BNP_IBAN, skip performing the REP_BBK_AFORMAT when the
%^	Cdt_iban flag is already set, and the dreived bic is already in position.
%^	This was causing the BNP to receive a bad value(account lost, bad bic replaced).
%^	Happens when called from autrv_retry.
%^
%^ Ken Bjelke 08-Dec-2003	107303
%^	Check if FED is an allowable ADV type, If so, process look for ABA's
%^	as A idtype  on the ABA index.
%^	If NOT look for E/FW info in the Extended ID index.
%^
%^ Ken Bjelke 	15-Jan-2004 109138
%^	Make the processing from 108093 only for STO's. Was being 
%^	invoked for SWF items, using the D to remain in the Cdt_idtype when
%^	it should have been cleared.
%^
%^ Ken Bjelke 	21-Jan-2004	109250
%^	Clear out csid_prm_method_ws and csid_prm_secwir and csid_acctg_method_ws
%^	each pass thru GET_EXEC_PARAMS. Leftover values causing trouble.
%^
%^ Ken Bjelke 	30-Jan-2004	98430
%^	Add support for COLLECTIONS_TRAN_TYP config. When tran type matches,
%^	Copy BBK down to BNP if bnp is blank. Skip SECWIRE_EVAL call, and
%^	set the BBK_SECWIR flag.
%^
%^ Ken Bjelke	05-Feb-2004	109229
%^	When pushing UP the IBAN in from  BNP to CDT, push the  
%^	residency when supplied. ALSO, change CDTCOR to COR.
%^
%^ Ken Bjelke 	16-Feb-2004	106393
%^	Changes added to support/generate hybrid NOF cdt_id attached to 
%^	Onfile Address. Remove search for account on REL in Currency inhibitting
%^	Bank Level AIN's. Need to be optionalized for general usage.
%^
%^ C. Crain	20-Feb-2004	PER 97347
%^	For Lower credit parties, replace "E" Idtype BCC with BIC based on
%^	LKUP_BIC_BY_BCC flag.
%^
%^ C. Crain	24-Feb-2004	SPR 109989
%^	Set no ambiguous check in C820_LOWER_CREDIT when "E" Idtype BCC and
%^	BCC Code Use configured (LKUP_BIC_BY_BCC).
%^
%^ C. Hansen    2-Mar-2004      SPR 59856
%^      comment out paragraphs which are not performed and change returning in
%^      calls to cfg_match_ityem in x1000_check_for_fed and x1100_check_for_fed
%^      to use Csid_ret_stat instead of Csid_fed_index_flg
%^
%^ Ken Bjelke 	05-Mar-2004	110575
%^	Rearrange the calling of ACCTSUB_CDT_NOF. This routing was clearing 
%^	cdt_adr_ptr_ok when it needs to be set (on aux pref corr).
%^
%^ Ken Bjelke 	09-Mar-2004	110575
%^	Avoid calling SET_CREDIT_ADDRESS when using an AUX address. Was generating TRap.
%^
%^ D. ALbertsen	11-Mar-2004	110730
%^	Need to perform B510_debit_check_si at the end of B500_debit_sis.
%^	It was omitted when B510 was split off to it's own section.
%^
%^ D. Ryan	17-Mar-2004	110884
%^	Modify x970_check_for_iban to not move "D" to the csid_party_idtype.
%^
%^ Ken Bjelke - 25-Mar-2004 	Re-sync to v1.2 
%^
%^ Ken Bjelke  17-Mar-2004 	Bring in changes from Z_FOR branch
%^
%^	 Ken Bjelke 	16-Feb-2004	106393
%^		Changes added to support/generate hybrid NOF cdt_id attached to 
%^		Onfile Address. Remove search for account on REL in Currency inhibitting
%^		Bank Level AIN's.
%^
%^ 	Ken Bjelke	3-Mar-2004	109636
%^		Add message for no Pay To country when IBAN validations fails and
%^		bnp_mailing_country is blank.
%^
%^ 	J. Curley	04-Mar-2004	110567
%^		Reset Csid_party_idtype to SPACES for BNP after performing TAKEOUT_GARBAGE 
%^		which sets the idtype to "D" when calling VALIDATE_IBAN and failure returned.
%^
%^ 	Ken Bjelke 	05-Mar-2004	110575
%^		Rearrange the calling of ACCTSUB_CDT_NOF. This routing was clearing 
%^		cdt_adr_ptr_ok when it needs to be set (on aux pref corr).
%^  
%^ 	Ken Bjelke 	09-Mar-2004	110575
%^		Avoid calling SET_CREDIT_ADDRESS when using an AUX address. Was generating TRap.
%^
%^	 Ken Bjelke 	12-Mar-2004 	109951 111045
%^		109951 - Correct handling of MT200 id's REP_BBK parties needd to be more aware
%^			 of Multiple Id's being present on Push Up.
%^
%^		111045 - Never set xxx_res_country from csid_iban_country.
%^
%^ 	Ken Bjelke	12-Mar-2004	107268
%^		Fill in CHG_BBK and CHG_BBK and CHG_CDT
%^
%^ 	J. Curley	12-Mar-2005	109688
%^		Don't set Risk_country and Country_code passed to DETERM_RES_COUNTRY
%^		in para C600_UPDATE_BNP, DETERM_RES_COUNTRY will connect to BNP's adr
%^		set via BNP_ADR_SET_PTR if available.
%^
%^	 Ken Bjelke 	17-Mar-2004	110563
%^		Correct Country for VALIDATE_IBAN call. Was not being set in x1000, resulting
%^		in invalid Iban return.
%^
%^ Ken Bjelke 	18-Mar-2004	107510
%^	Add seperate messages for Invalid IBAN detected and Invalid BBAN detected.
%^
%^ Ken Bjelke 	23-Mar-2004	106393
%^	Correct STO processing for REP_BBK_A format. Do not perform this for items,
%^	where the Locked_cdt_party_ls flag is set.
%^	Correct issue where the cdt_adr_ptr for AUX items wasnot set correctly.
%^
%^ Ken Bjelke 	23-Mar-2004	110828
%^	When detecting a bad IBAN refrain from inserting a D in the
%^	Id type unless the Csid_valid_iban_flg_ws is "N", indicating a bad BBAN
%^
%^ Ken Bjelke 	24-Mar-2004	111666
%^	Do not perform REP_BBK_xFORMAT processing if no bank code was returned
%^	from a successfull VALIDATE_IBAN call. Was dropping usefull data.
%^
%^ J. Curley	02-Apr-2004	109688 112021
%^	Don't set BNP_RES_COUNTRY based on IBAN Country code.  Also, fix trap
%^	when Cdt_typ is on AUX but not on REL causing trap in SET_CREDIT_ADDRESS.
%^
%^ Ken Bjelke 	29-Apr-2004	112708
%^	Correct "PRE"  rule detection. 
%^
%^ Ken Bjelke 	3-May-2004	Bring up to date with v1.2 changes
%^
%^	 Ken Bjelke 	29-Mar-2004	111239
%^		Modify Edit criteria for D items in x940_takeout_garbage.
%^		Retry server items were getting rejected needlessly.
%^
%^	 Ken Bjelke 30-Mar-2004	110698
%^		Delay the call to GET_IDTYPE_FROM_CHAN until all AIN's have been
%^		evaluated. This will allow the original received ID's to be pushed down.
%^
%^	 D.Beer	31-Mar-2004	111644
%^		1. Limit SPR 106399 setting of Cdt_adv_flg in CREDITSIDE_LOOKUP to 
%^		   repetitives because thats what 106399 was about. This fixes a problem
%^		   with Cdt_adv_flg being inappropriately set in cases where CREDITSIDE_LOOKUP
%^		   gets called twice due to HOST_GET, PARTY_DETERMINATION or AUTOTRIEVE retry.
%^		   TODO: decide if setting Cdt_adv_flg should be in sto_demon, rpvtin, or removed.
%^		2. Convert some PRULE_MSG_RULE_MATCH calls to PRULE_MSG_RULE_MATCH_FROM for
%^		   improved performance.
%^
%^	 Ken Bjelke 	01-Apr-2004	111801
%^		Correct find acc by cur logic. On first pass, did not always have 
%^		a bnk_union connected, hence did not find account.
%^
%^	Ken Bjelke 	9-Apr-2004	105592
%^		In X940_takeout_garbage if a bank ID is detected, but not valid, exit
%^		right away.  This defends against bad ":" in the incoming data that was
%^		causeing a trap later on.
%^
%^ 	Ken Bjelke	13-Apr-2004	111971
%^		Correct DDA account checking  when STRCTRD_ACCT_IN_USE  not set.
%^		VALIDATE_IBAN was bein called in error.
%^
%^	 Ken Bjelke 	14-Apr-2004	112362
%^		Correct CHKSI debit SI processing.
%^
%^	 Ken Bjelke 	29-Apr-2004	112708
%^		Correct "PRE"  rule detection. 
%^
%^ Ken Bjelke 	05-May-2004	112958
%^	Reset the party IDtype to D if VALIDATE_IBAN succeeds, and no Bank code
%^	is provided, and not an IBAN check.
%^
%^ Ken Bjelke  10-May-2004 	113363
%^	In X1000_CHECK_IBAN_BNP skip REP_BBK_AFORMAT if the bic is to be replaced
%^	with same. (previously was checking cdt_iban flag, removed this qualification).
%^
%^ Ken Bjelke 	12-May-2004	95185,97006
%^	Add call to "CUST_BILAT_ACCT" to populate Bilateral account fields
%^	when required.
%^
%^ Cam Hansen   03-Jun-2004     59856
%^     change a110_main_exit to a110_got_credit_exit for java translation
%^
%^
%^ Ken Bjelke 	03-Jun-2004	114091
%^	Parse cdtnativeaccount PRM to only send the IBAN, dropping the extra
%^	ID's when present. Was sending the BIC along with ID.
%^
%^ Ken Bjelke 	04-Jun-2004	114038,114039
%^	When completing the processing of AUX cdt party, connect the ent_c_adr_set
%^	to allow Channel Determination to fill in the WIR key correctly.
%^
%^ Ken Bjelke 08-Jun-2004	113435
%^	Set cdt_iban flag Only when full IBAN, was being set on valid bbans.
%^
%^ Ken Bjelke 09-Jun-2004	114264
%^	Restore the original ID after performing the Secondary id check, 
%^	whether the secondary was found or not. Was dropping original.
%^
%^ Ken Bjelke 	15-Jun-2004	114427
%^	Correct possible trap when re-entring from a Retry Process (eg autrv_retry).
%^	If a hybrid NOF dda with AUX/REL BIC we need to reconnect the Relget_adr_set.
%^	This was not happening as no secondary ID is passed in for the second pass.
%^
%^ Ken Bjelke 	23-Jun-2004	114518
%^	Don't attempt to get acount if Channel_Determination has failed
%^	AND the proposed  Channel is RTGS or CLEARING house. This
%^ 	will allow the correct error message to be displayed, instead
%^	of no such account.
%^
%^ Ken Bjelke 	24-Jun-2004	114599
%^	Use the returned bank from the Channel_record account for
%^	Checks as the cdt_adr_bnk_id.
%^
%^ Ken Bjelke 	29-Jun-2004	114861
%^	Correct handling of Second ID type of P. Look for it in the
%^	Chips-Id field of the adr_set, no longer an account.
%^
%^ J. Curley	30-Jul-2004	113891 (migrate)
%^	Modified a check to clear out fields from prior ON file 
%^	information in credit party when mapper switches party to NOF.
%^
%^
%^ Ken Bjelke 3-Aug-2004	112704
%^	Add the csid_irr_acc_type field to enforce Channel_Determination set
%^	account id's.  When Channel_Determination sets an account type it will
%^	be enforced.
%^
%^ Bring forward 1.2 changes from Z_FOR
%^
%^	 Chuck Boddy	21-Jul-2004 	114840
%^ 		Reset cdt_not_suspect_ls and Csid_had_garbage after calling CUST_SPEC_PREF_CORR
%^		and receiving back a positive status. This to prevent items from going to repair
%^		after getting a pushdown (unless some other condition tags the lookup further along in processing.
%^
%^ 	Ken Bjelke 	30-Aug-2004	
%^		Split the IVAL$_IBAN_REQ message into Warning and Blocking versions,
%^		IVAL$_IBAN_REQ_W and IVAL$_IBAN_REQ_B.
%^
%^	 Ken Bjelke  31-Aug-2004	116580
%^		Add check of BIC against the IBAN country. Calls table IBAN_BIC_CC_EXC
%^ 		for any allowable mismatched pairs.
%^
%^ 	Ken Bjelke 	01-Sep-2004	116580
%^		Cleanup more IBAN/BBAN issues
%^
%^ 	Ken Bjelke 	7-Sep-2004 116564, 116719	
%^		Add *Info messages for the Failure_ignore_is return from Validate_iban.
%^		Ensure that the Invalid Iban message is first displayed in RPR instead
%^		of Incorrect Format in .....
%^
%^ 	Ken Bjelke 	14-Sep-2004	116874, 116848
%^		Correct IBAN reporting messages (was saying BBAN instead of IBAN).
%^		When a Succes is returned for a BBAN, but no bank code present, do NOT
%^		prefix with a "D".
%^
%^ 	Ken Bjelke	30-Jul-2004	115521
%^		Use the Preferred CHIPS Bank for lookups of UID's entered in the Credit Party.
%^
%^	D.Beer		4-Oct-2004	97596
%^		Set Csid_lc_flg_aba and Csid_lc_flg_uid to "Y" on successful AUX lookups,
%^		thereby causing SET_IB1/IBK/BBK/BNP_PARTY to be called. Fixes a problem
%^		where no name and address info would be mapped for on-AUX lower credit parties.
%^
%^ 	J. Walsh	05-Oct-2004
%^		Remove obsolete references to standing instruction data structures.
%^
%^ D. Ryan	7-Oct-2004	116931
%^  	If the function is "MRE", the errors should not be written to the message
%^	history, but are now being displayed on the screen.  MRE calls
%^	creditside_lookup, instead of creditside_screen, because the Operator has 
%^	very little control with respect to data being entered.
%^
%^ D. Ryan	08-Nov-2004	118341
%^	STO items should not be routed to the exception queue if the repetitive's
%^	credit party is on AUX.  This is related to ABA's that are on the main
%^	bank's AUX file and also on another bank's REL file.  
%^
%^ D. Ryan	18-Nov-2004	108742 & 118341
%^	Include DFM also.
%^
%^ K. Morrow	01-Dev-2004	118047
%^	Change FASLINK_GMX_SRCS to SWIFTLIKE_SRCS.
%^
%^ J. Curley	14-Dec-2004	117492 (migrate fixes z_wtx_creditside from 04-Oct and 06-Oct)
%^	When 2nd Id not in credit party error, clear out Csid_know_acc_id and
%^	break the Ent_c_acc_set.  CREDIT_EDIT was setting the CDT_ACCOUNT 
%^	from the Ent_c_acc_set because it was connected.
%^	Failed retest at BOA where test case was a bit different.  At BOA 
%^	Channel Determination returned failure and the Channel Account.
%^	Channged to goto B400_Set_Advice_End when Channel_Determination returns
%^	failure before setting Csid_know_acc_id to Channel Account.
%^
%^ J.Curley	14-Dec-2004	117739 (migrate)
%^	Change Creditside_lookup to only set BNP_MAILING_COUNTRY when value is 
%^	spaces.  This is to prevent a supplied PAY TO from being changed.
%^
%^
%^ Ken Bjelke 	15-Dec-2004	118780
%^	Allow CDTAIN PUSH of same REL_ID if id's are different.
%^
%^ D. Ryan	07-Jan-2005	119765
%^	Prevent a STO_demon trap which should not be calling set_credit_address.
%^	Additional checks are now being done before B320_set_address is performed. 
%^
%^ B. McLean    12-Jan-2005     119786
%^      Removed the code that was setting the PS_ELIG flag to "N" when NOT A CORE
%^      PAYMENT command was issued in the COR function. Setting this to N was 
%^      causing the Date Calculation to come up with different dates, in this
%^      case turing a PRE to a SPL. 
%^
%^ Ken Bjelke 	26-Jan-2005	120260
%^	Perform SET_CREDIT_ACCOUNT  in all cases in B360_SET_ACCOUNT. Was not
%^	being called when ent_c_acc_set was already connected.
%^
%^ Ken Bjelke 14-Mar-2005	Migrate from 1.3
%^ 	Ken Bjelke 	06-Oct-2004	117400
%^		Clear the csid_bnk_code_rec_ws each pass, and skip the call to 
%^		VALDIATE_IBAN in X1000 if no BNP id it present. Carry over was resulting.
%^
%^ T. Welch	30-Mar-2005	121060
%^	SBJNOTCON trap when EQUATE done on men2_bnk_union.
%^	Added logic to check if men2_bnk_union is connected.  If not,
%^	connect it before doing EQUATE.
%^
%^ D. Ryan	04-Apr-2005	121711
%^	Before calling the Set_credit_address module, see if the Ent_c_adr_set is
%^	connected.
%^
%^
%^ Ken Bjelke  8-Apr-2005	122078
%^	Skip the account finding logic when CHANNEL_DETERMINATION has  failed and
%^	no channel is selected. This leaves original ID in CDT party.
%^
%^ Ken Bjelke 	15-Apr-2005	122328
%^	When performing a pushdown of a multiple ID, ensure both
%^	id's are passed down.
%^
%^ Ken Bjelke	27-Apr-2005	Updates from lower versions
%^ 		117312
%^		Correct triggers for the REP_BBK_xFORMAT prms on the BBK.
%^
%^		117413,117736
%^		When 2 id's are provided, a BBAN/IBAN and a BIC, treat the BBAN as
%^		an accounting IDtype and attempt a lookup with the BIC if the BBAN is invalid.
%^
%^
%^ Ken Bjelke 	28-Apr-2005	More updates
%^	 	118361
%^		Do not set the Cdt_adv_typ and cdt_adv_flg u on an AIN containing
%^		a Method until we have checked to id's and are sure of performing
%^		the AIN.
%^
%^		117244,119151
%^		Check "D" id type for CheckDigit prior to attempting VALIDATE_IBAN logic. 
%^
%^		121147
%^		Skip the REP_BBKA_FORMAT if Bic was already in address. In case of
%^		Autrv_retry, a second try at insertion was made, resulting in the bnp_bnk_flg
%^		incorrectly being set to Y.
%^
%^ J. Walsh	17-May-2005	123046
%^	Do not blank out cdt_adv_typ in B420_GET_NEWPARTY.
%^
%^ Tom Carroll 	20-May-2005	121884
%^	When channel_determination returns a failure status, do not attempt to 
%^	continue with AIN processing when the prule MTS$DISABLE_AIN is present.
%^
%^ Tom Carroll 	07-Jun-2005	121884
%^	When we are inserting an IBAN and the operator IMPOSED a channel, then
%^	don't attempt to perform advice type processing until the new credit party
%^	is inserted.
%^
%^ Ken Bjelke	09-Jun-2005	123722
%^	After performing REBUILD_2ID, clear the Second_cdt_id_ls field. 
%^
%^ C. Crain	14-Jul-2005	124573
%^	Correct X1000_CHECK_IBAN_BNP so the csid_set_chg_flg_ws is set to 
%^	failure when the BIC is on AUX and thus avoid setting the CDT, BBK and
%^	BIC change fields.
%^
%^ J. Curley	15-Jul-2005	122662 (migrate)
%^	Correct problem when retry server calls creditside lookup with a BNP 
%^	C/003179/(BCNWBKGB2L/AC0011945540).  Change para B200_BNP to drop from
%^	"/(" onward when BNP ID Type is C - this was being done for all repetitives
%^	now being done for any BNP IDtype of C.
%^
%^ J. Curley	15-Jul-2005	120610 (migrate)
%^	When CDT id is on AUX but not on REL and ACCT_LOOKUP returns a different
%^	id in RELGET_RETURN_KEY but same idtype in RELGET_RETURN_IDTYPE, replace
%^	the CDT_TYP.CDT_ID with the value returned in RELGET_RETURN_KEY.  This is 
%^	this is what is done in CREDITSIDE_SCREEN.
%^ 
%^ J. Curley	15-Jul-2005	122662 and 122702 (migrate)
%^	Add checks for BBK, IBK, IB1 to correct problem when retry server calls
%^	creditside lookup with a id like C/003179/(BCNWBKGB2L/AC0011945540).
%^	Change checks for ids with /( to all IDtypes not just idtype C.
%^
%^ D. Ryan	22-Jul-2005	124516
%^	Moving the "If" statement for moving the Csid_err_memo to Last_memo_ls
%^	closer to the end of A110_got_credit, since there more errors after its
%^	present position.
%^
%^ C. Crain	05-Aug-2005	122222 
%^	Do not try to disambiguate an AUX by currency. Can generate TRAP 
%^	when calling NEXT_ACCT_LOOKUP.
%^
%^ Ken Bjelke	10-Aug-2005	125259
%^	Restore the "D" on a failed BBAN lookup when a failure return and
%^	a "S" for suppressed in the csid_valid_iban_flg.
%^
%^ J. Walsh	21-Dec-2005	118625
%^	Migrate from v12 z_for_creditside logic to suppress secondary wire.
%^
%^ C. Crain	01-Mar-2006	126253
%^	Modified C600_UPDATE_BNP to set bnp_bnk_flg for E/ids (to cover those 
%^      not on REL/AUX).  Migrated from 2.0.
%^
%^ Ken Bjelke 	23-Feb-2006	124477
%^	Add call to CUST_CHP_UNQ_PASS to allow Unqualified item to go STP.
%^
%^ D. Ryan	04-Apr-2006	129923
%^	Revise the edits for routing STO items with a Warning - BBAN failed validation
%^	message.
%^
%^ Ken Bjelke 		6-Apr-2006	129848,117871
%^	Correct push down for CHG flag settings. Maintain CHG_CDT setting if
%^	set already by caller.
%^
%^ Ken Bjelke	18-May-2006	130629
%^	When RTGS of CLEARING_HOUSE channel is detected, and P is the 
%^	IDtype, load it right at channel detection. This allows the
%^	Spec_pref_corr routine to use this for evaluation. Restores original
%^	PRE prule idtpe setting.
%^
%^ Ken Bjelke 26-May-2006
%^	
%^	131051 - Correct cross bank AIN processing, detect when a cross bank	
%^		 AIN has been performed and avoid self insertion loop.
%^
%^	131003 - Clear csid_save_cntry_ws each pass to correct any carry over
%^		 in IBAN processing.
%^
%^ Ken Bjelke		5-Apr-2006	129558
%^	If a trailing /RT or /FW is present, with NO id,  re-append and allow this
%^	to be processing(should only be present in lower parties).
%^
%^ Ken Bjelke 		09-Jun-2006	131418
%^	Correct circular AIN detection logic.
%^
%^ Ken Bjelke 		08-Aug-2006	132147
%^	Add support for MTS$BBAN_UNSTRUCT which allows Unstructed Home accounts in the
%^	credit party to be looked up.
%^
%^ D. Ryan		80-Aug-2006	icr_000689
%^	For the Sys_memo, "Chips payment; unqualified BNF", use the correct credit
%^	party.
%^
%^ Ken Bjelke 	Reconcile all updates 
%^		
%^	122755,112928
%^	Leave the GL recon intact if it appears to be the product of a VLD call.
%^	Check that VLD is active, and skip the clear if it is.
%^
%^	124663
%^	Correct issues with CUST_IS_ID_ON_US processing. Csid_ovr must be set to
%^	avoid substitution being skipped by GET_NEWPARTY. Also, do not attempt
%^	to prefix bank ID when blank.
%^
%^ 	126212
%^	Ensure that a prodived IBAN that translates to an On-Us account,
%^	when presented with a BIC.
%^
%^	127576
%^	Set the ent_ftr_set.Currency to the message_currency_ls if blank,
%^	just for the duration of the CDTAIN Prule processing calls. 
%^
%^ 	132833
%^	Clear csid_multi_party in B280_credit_addr. Was inhibiting IBAN lookup
%^	on a 2 party, IBAN cdt processing after a Multi-party prior message.
%^
%^ 	134099
%^	Inhibit Iban-BNP checking when the cdt_iban flag is already set. Indicates
%^	that item has already been thru lookups, probably here from Retry server. 
%^
%^	133725
%^	Clear the adr_pointers more aggressively. If the item rel_id NOT = 0 and failed lookup
%^	OR the flag is already set(and failed lookup).
%^
%^	134138
%^	Do not perform the PREVICE checking for items with is_payment_ls set to 0.(non payments).
%^ D. Beer		17-Nov-2006
%^	1. Add CREDITSIDE_SCREEN_RESET for an external (java) caller to use
%^	   when Cdt_screen_state needs to be reset to Init_is.
%^	2. Add CREDITSIDE_SCREEN_EQUATE for an external (java) caller to use
%^	   when it wants to save a Relget_index selection that might get clobbered
%^	   by a debitside call that occurs before coming back into creditside.
%^	3. At the start of CREDITSIDE_SCREEN, call CREDITSIDE_SCREEN_RESTORE to
%^	   reset a Relget_index connection that might have been saved by an
%^	   external call to CREDITSIDE_SCREEN_EQUATE.
%^
%^ Fred P. Isaacs  28-NOV-2006    134758
%^	Cleaned up post-CDTAIN filtering code to not reject an AIN inserting a
%^	BIC-11 to supersede a BIC-8.
%^
%^
%^ Ken Bjelke 	4-Jan-2007	icr_1137
%^	On DDR's use the party's account, not the clearing.
%^
%^
%^ Ken Bjelke 	12-Jan-2007	135466
%^	Load the bnp_mailing_country from the BIC in the BNP is that is the ID present.
%^
%^ D. Boyajian	09-Feb-2007	SPR 136107
%^	In 3.0: .Declare ONEOF variable Csid_val_iban_ret by a (revised)
%^		 Return_status_oneof.ddf rather than inline.
%^		.Change the OLD statement "Initialize csid_val_iban_ret"
%^		 (which *at one time* for the inline ONEOF was equivalent to
%^		 setting it to Success (zero)) so that it now explicitly
%^		 sets Csid_val_iban_ret to SUCCESS.
%^
%^ D. Beer		17-Nov-2006
%^	In CREDITSIDE_SCREEN, Help out java mode by setting Relget_title_flag before
%^	calling	REL_ACC_FROM_ADDR, which can yield the need for a select screen.
%^
%^ Fred P. Isaacs	21-Feb-2007  132507
%^  	Implement SPR 131507.  This loosens second id SWIFT matches to the 
%^	first 6 characters of the BIC if the SWF_DUALID_MATCH6 config flag is 
%^	set to Y.  The non-SWIFT ID must be the primary key and the BIC must
%^	be tested against it.
%^
%^ Ken Bjelke	21-Mar-2007	132507
%^	Add support for the SWF_DUALID_MATCH6 table. If set to Y in the
%^	owning bank. allow match for dual ID's on the 1st 6 characters
%^	of the BIC.
%^
%^ Fred P. Isaacs  29-Mar-2007	135695
%^	SEND_SECWIRE=N execution parameter on a CDTAIN now turns off ALL
%^	secondary wires.  SEND_SECWIRE=Y turns on secondary wire for 
%^	party being pushed down regardless of SECWIRE_EVAL routine 
%^	results.  If there are multiple CDTAINs with the SEND_SECWIRE
%^	execution parameter set to different results the last one wins.
%^
%^ J.Curley	  03-Apr-2007	icr_1732
%^	Correct calling argument to CUST_MATCH_SECOND_ID.  Was causing Java
%^	translation problem because returning integer but cust_match_second_id
%^	expecting boolean.
%^
%^
%^ Ken Bjelke	6-Apr-2007	137244
%^	Populate bei_flg field. 
%^
%^ Fred P. Isaacs  17-Apr-2007    137413
%^	Due to certain complex prule environments, detect 
%^	MTS$SUBPARTICIPANT_CDTAIN parameter in message and override 
%^	Lock_cdt_party_ls argument for CDTAIN
%^	execution since we are in a Target subparticipant and need to find our
%^	participant regardless of any overrides.
%^	Also pass through MTS$TARGET_ACCOUNT_BIC parameter if it's found on
%^	a CDTAIN
%^
%^
%^ Ken Bjelke 	26-Apr-2007	137904
%^	Correct the duplicate AIN detection logic, Was declaring more 
%^	as duplicates then it should.
%^
%^
%^ Ken Bjelke 	4-May-2007	137630
%^	Refine duplicate AIN detection when cross bank is involved. Was
%^	causing EXC with pref_corr_loop when preventable.
%^
%^ Cynthia Crain   08-May-2007    133448
%^	Qualifed REP_BBK_DFORMAT so replacement occurs when name1 is present
%^      and id is not present and REP_BBK_AFORMAT so replacement does not
%^	occur if the S idtype's id contains two ids.
%^
%^ Cynthia Crain   15-May-2007    135866
%^	Add logic to save the BNP country for mismatch comparision in BNP_200.
%^
%^
%^ Ken Bjelke	23-May-2007	136705
%^	In LOWER_CREDIT set csid_ovr to ? instead of * on Soft Failures. Trap
%^	was resulting on unusual cases of Mismatched BIC/UID both on AUX.
%^
%^ J. Walsh	02-Oct-2007	140448
%^	Test for second id being equal to credit party before appending it
%^	to the credit party in C805_REBUILD_2ID.
%^
%^ Ken Bjelke 	26-Oct-2007	icr_003282
%^	Add flag FED_XBANK_NOPREF, this will Disable the Fed_Preffered bank lookup and
%^	instead, look cross bank for the ABA. Also, if found, will take the ABA Off-File
%^	if the bank does not match the Clearing account's bank.
%^
%^ Fred P. Isaacs  1-Nov-2007  
%^	135695 Corrected logic to handle MTS$SEND_SECWIRE parameter value of 
%^		N on a CDTAIN.
%^	134700 CREDITSIDE_LOOKUP should not use preferred CHIPS bank for UID 
%^		lookup.  Thus UID lookup will be done in all banks.  However, 
%^		CREDITSIDE_SCREEN will continue to use the preferred CHIPS bank
%^		for UID lookup because otherwise the UID lookup would only be 
%^		done in the owning bank.
%^	141702 	Restore calls to CUST_SECWIRE_SAVE after secwire flags are 
%^		updated.
%^
%^ D. Ryan	05-Nov-2007	141343		icr_003504
%^	Made code similar to that in Creditside_screen for displaying the error
%^	message, "Country code of IBAN does not match country code of BIC".
%^
%^ Ken Bjelke	27-Nov-2007	Icr_003642
%^	Correct csid_retry_cdtain flag setting. was not initialized. Ains were 
%^	not being searched for.
%^
%^ Fred P. Isaacs   20-December-2007	141620  CR 385
%^	Added call to CUST_PAYTO_NETWORK() routine to handle TGT2 insertions.
%^
%^ Ken Bjelke	4-Jan-2008	CR371
%^	Correct lower party lookup for AC Bic combination.
%^
%^ J. Walsh	25-Jan-2008		CR866
%^	The men2_bnk_union should never be set to mod.
%^	This is causing object lock waits in ASI/RPI processes.
%^
%^ Ken Bjelke	27-Feb-2008	CR1577
%^	Use csid_second_id instead of cdt_second_id_ls when rebuild second
%^	dual ID for pushdown. This will ensure the imbedded / regardless of
%^	what was sent by caller.
%^
%^ Ken Bjelke - Migrate CR5125
%^ 	Tom Carroll 	22-Sep-2008	CR2559
%^		Do not set the BBK_RES_COUNTRY when ID and IDTYPE are missing.
%^
%^ Ken Bjelke 	CR4184
%^	Migration for Iban as Second ID processing
%^
%^ Fred P. Isaacs  22-JAN-2009    CR6039
%^ 	Added calls to CUST_EXTENDED_ID_QUAL to CHIPS qualification code for 
%^	each lower credit party.
%^
%^ Joseph Carey		10-Feb-2009	
%^			Migrate from 2.0 ---> Joseph Carey  03-Dec-2008	CR5935
%^	Update code that populates the Bnp_bei_flag.
%^	This code was not cognizant of all the Swf subtypes that
%^	indicate a BEI.  The SWIFT handbook for 2008 lists
%^	six Swift subtypes that indicate that a BIC is really a BEI:
%^	    BEID, CORP, MCCO, SMDP, TESP, TRCO
%^
%^ J. Pfaff	CR7795	12-FEB-2009
%^	Add global fsect dsid_cust_fsect; add setting cst_party_usage.
%^
%^
%^ Ken Bjelke	Migration   CR6963
%^		22-Dec-2008	CR5752
%^	Correct dual ID  processing when ID is found on AUX and the 
%^	LKUP_NO_KEY_MATCH_REQ flag is set. Item will process using the AUX
%^	address, instead of flagging an error. 
%^
%^ J. Carey	26-Jun-2009	CR 11829
%^	Fix problem in the following change:
%^	    Ken Bjelke 	CR4184
%^	    "Migration for Iban as Second ID processing"
%^	CR4184 was a migration of CR2563 -- a change that allowed the second
%^	credit ID to be an IBAN.  However, as implemented in 4184, there was
%^	one minor problem -- the code that validates the second credit ID
%^	would not allow the ID to be longer than 19 characters.  Of course this
%^	length is not big enough to accommodate most IBANs.
%^	So in order to permit the second credit ID to be a IBAN,
%^	we allow for a second ID size of 34 instead of 19.
%^	Changes in paragraphs B440_SETUP_2ND_ID and B460_SET_2ND_AGAIN.
%^
%^ B. Lanza		06-Aug-2009	CR10438/CR12639
%^	In ENT, entered cdt id and bnf and used "Move cdt to bnf" command
%^	without pressing <enter>, party moves down, then enter cdt id and
%^	press <enter>. It was not setting the Secondary wire flag.
%^	SECWIRE_EVAL was not being called. 
%^	Change in B220_BBK_INIT_LKUP to set bbk_init_secwir as next state
%^	when exiting early, rather than bnp_init_lkup. 
%^	Similar problem for CR12639 for AIN.
%^
%^ Fred P. Isaacs  27-Jul-2009	CR12399
%^	Clear our field containing COR/CDTAIN selector between uses, preventing
%^	check against "CORAIN".
%^
%^ Ken Bjelke	28-Jul-2009	CR12472 / 12720
%^	Check for Bank presence when parsing BIC for IBAN/BIC consistency check.
%^	Could result in mismatch and incorrect error.
%^
%^ Ken Bjelke	21-Sep-2009	tc 9542
%^	When lookging for an account requested by IDtype/Currency,  detect if
%^	oneof the accounts is a default and honor it. Previously, a DUPE acc
%^	would be flagged if multiples in currency found, regardless of default flag. 
%^
%^
%^ Ken Bjelke	21-Oct-2009	tc10007
%^	Remove the hard setting of FED channel for On Aux ABA ids. Obselete,
%^	allow CHANNEL_DETERMITION to perform the settings later in the flow.
%^
%^ Diana Pacelle	12-Nov-2009	tc206 (CR8424)
%^	Made code similar to that in Creditside_screen for setting the
%^	csid_id_bank_ws when an AIN transition from AUX was made
%^	in Creditside_lookup.
%^
%^ End Revision History
%^******************************************************************************

%^******************************************************************************
%module CREDITSIDE_LOOKUP;

%^*****************************************************************************
%^                                                                            *
%^ Paragraphs in this procedure are labeled as follows:                       *
%^                                                                            *
%^	A100_MAIN	     Subroutine entry point, dispatch, and return
%^      B200_BNP	     Looks up Beneficiary Party.
%^      B220_BBK	     Looks up Beneficiary Party's Bank.
%^      B240_IBK	     Looks up Intermediary BanK.
%^      B260_IB1	     Looks up First Intermediary BanK.
%^      B280_CREDIT_ADDR     Looks up Credit Party and sets up message.
%^	B300_SECOND_CREDIT   Checks credit party against second id.
%^	B320_SET_ADDRESS     Sets up message credit party from address info.
%^	B330_PERFORM_FIND_ACC  Performs b340 maybe more than once if equiv curr
%^	B340_FIND_ACCOUNT    Selects proper account from party address.
%^	B360_SET_ACCOUNT     Sets up message credit party from account info.
%^	B380_MAGIC_BNP	     Sets up special BNP from Second_cdt_id.
%^	B400_SET_ADVICE	     Sets advice method for this credit party.
%^	B420_GET_NEWPARTY    Tries to get a pushdown/substitute party.
%^	B440_SETUP_2ND_ID    Sets up second id for credit party check.
%^	B460_SET_2ND_AGAIN   Sets up second id for rolldown into lower parties.
%^	B480_FX_ACCOUNT	     Inserts the FX account as the credit party
%^	B500_DEBIT_SIS	     Preadvising processing
%^	B520_RECONNECT	     Reconnects credit party if possible for SI resume.
%^	C600_UPDATE_BNP      Updates BNP from Csid_party_id
%^	C610_UPDATE_BBK      Updates BBK from Csid_party_id
%^	C620_UPDATE_IBK      Updates IBK from Csid_party_id
%^	C630_UPDATE_IB1      Updates IB1 from Csid_party_id
%^      C650_LOOKUP_BBK_ADDRESS Looks up BBK REL address
%^	C655_2ND_CREDIT_ID   Disambiguate address based on second credit id.
%^	C660_FIND_ADR_CUR    Disambiguate address based on currency match.
%^      C670_CHECK_COMMON_UID Check for case of a COMMON UID and SWIFT TID.
%^	C680_CDT_SWF_PARENT  Resolve NOF SWF branch by using parent.
%^	C690_SNAM_CHK        Attempt a Short Name Search
%^	C720_COPY_ADDRESS    Copies address info into credit party.
%^	C730_GET_PID_SUFFIXES  Get P ID Suffixes for the Spec_pref_corr Rtn
%^      C740_CHECK_DUPE	     Checks Side_acc_seq for ambiguating account.
%^	C760_FIND_ACC_CUR    Scans Side_acc_seq for account with currency
%^	C780_CHIPS_OVERRIDE  Gets CHIPS-qualified party id.
%^	C800_PUSH_CREDIT     Pushes current credit party down.
%^	C810_ROLL_DOWN	     Tries to roll 2nd credit id down for CHIPS qual.
%^	C820_LOWER_CREDIT    Looks up a lower creditside party
%^	C830_SWAP_CREDIT_IDS Swaps argument in Csid_Second_id_ls and credit set
%^	D100_BCC_LKUP_BIC    Replaces BCC with BIC based on config	
%^	D840_MATCH_IDS_TO_REL  Matches lower credit party id's to REL address
%^	D860_SWIFT_TO_ABA    Uses lower credit party SWIFT ID as index to XREF
%^      D870_LOCKED_CREDIT_PARTY  Checks to see if locked cdt party should be
%^				  looked up
%^	X880_CHECK_CURRENCY  Checks Side_acc_seq currency against message
%^      X900_ERROR_MEMO	     Writes an error or warning memo.
%^	X920_INFO_MEMO	     Writes an informational memo.
%^	X940_TAKEOUT_GARBAGE Checks a multiple id for garbage.
%^	X950_CHECK_ACCOUNT   Calls CHKDGT_EDIT to check an account ID.
%^	X960_SHUFFLE_IDS     Puts chips uid or account number first.
%^      
%^*****************************************************************************
%^ Macro definitions.
%^ %MAR
%^ .default	displacement,long
%^ $LNMDEF
%^ %end
%^*****************************************************************************
%^ Subject definitions.
%def  		<AUX_FS>	%`SBJ_DD_PATH:AUX_FS_FSECT.DDL`		%end
%def  		<ENTFTR>	%`SBJ_DD_PATH:ENTFTR_FSECT.DDL`		%end
%def  		<ENT>		%`SBJ_DD_PATH:ENT_FSECT.DDL`		%end
%def  		<ENTREPT>	%`SBJ_DD_PATH:ENTREPT_FSECT.DDL`	%end
%def  		<ACE>		%`SBJ_DD_PATH:ACE_FSECT.DDL`		%end
%def  		<RELGET>	%`SBJ_DD_PATH:RELGET_FSECT.DDL`		%end
%def  		<PRULE_PARTY>	%`SBJ_DD_PATH:PRULE_PARTY_FSECT.DDL`	%end
%def 		<REL_CHANNEL>	%`SBJ_DD_PATH:REL_CHANNEL_FSECT.DDL`	%end
%def		<REL_PROFILE>	%`SBJ_DD_PATH:REL_PROFILE_FSECT.DDL`	%end
%def 		<RELGET_SUBS>	%`SBJ_DD_PATH:RELGET_SUBS_FSECT.DDL`	%end
%def 		<CSID_CUST>	%`SBJ_DD_PATH:CSID_CUST_FSECT.DDL`	%end
%def		<DSID_CUST>	%`SBJ_DD_PATH:DSID_CUST_FSECT.DDL`	%end

%^
%^ Local storage subject definitions.
%def		<CSID_WS>	%^ local fsect

%^ Lookup status indicator
Csid_ovr:	      	str(1) ;
Csid_2nd_ovr:		str(1) ;
Csid_credit_pend_del:	Boolean ;
Csid_lkup_pend_del:	Str(1) ;

%^ Lookup returned status
Csid_ret_stat: 		Boolean;
Csid_ret2_stat: 	Boolean;
Csid_conn_stat: 	Boolean;
Csid_conn2_stat: 	Boolean;
Csid_chips_stat:	Boolean;
Csid_Nia_Stat:          Boolean;
Csid_Spec_Stat:         Boolean;

%^ Scratch id.
Csid_New_Idtype_Ws:     str(1);
Csid_New_Id_Ws:         vstr(34);
Csid_idtype_ws:		str(1) ;
Csid_id_ws:		vstr(64);
Csid_return_key:        vstr(64) ;
Csid_20charid_ws:	vstr(20) ;
Csid_find_adr_idtype_ws:	str(1);
Csid_find_adr_id_ws:    vstr(64);
Csid_id_bank_ws:	vstr(3) ;
Csid_acc_id_arg:	vstr(64) ;
Csid_tmp_id_ws:		vstr(64);
Csid_tmp_id2_ws:	vstr(64);
Csid_fx_ws:		vstr(40);
Csid_fx_acct_idt_ws:	Str(1);
Csid_fx_acct_id_ws:	vstr(12);
Csid_new_acct_ws:	vstr(12);
Csid_match_acct_ws:	vstr(12);
Csid_match_bank_ws:	Str(3);
Csid_corr_ws:		vstr(40);
Csid_party_extype:	str(2);
Csid_party_extype2:	str(2);
Csid_party_intro:	vstr(3);
Csid_party_intro2:  	vstr(3);

%^ ID part of address specified by account.
Csid_acc_id_ws:		vstr(64);

%^ Character arguments for matching old lookup routine conventions.
Csid_ambig_ws:		str(1) = " " ;
Csid_multibank_ws:	str(1) = " " ;
csid_temp_multibank_ws: str(1) = " " ; %^ temp switch when preferred_fed_bank is specified
%^ Used to determine new currency
Csid_currency_ws:       str(3) ;
Csid_currency_arg:       str(3) ;
Csid_savcdt_currency:   str(3) ;

%^ Used to determine equivalent currency
Csid_Equiv_curr:        str(3) ;
Csid_equiv_status:      Boolean ;
Csid_save_curr_ws:      str(3) ;

%^ Address account seq for searches.
Csid_acc_seq:		seq( %`SBJ_DD_PATH:REL_NAME_SEQ.DDF` );

%^ Fields to help determine if we need to re-lookup a locked credit party
Csid_lcp_index_type_ws: str(1);
Csid_lcp_bypass_lookup: Boolean;
Csid_lcp_lookup_reason: long;
Csid_lcp_conn_stat:     long;
Csid_lcp_bnk_ws:        str(3);
Csid_lcp_acc_ws:        str(36);
Csid_lcp_adr_ws:        str(5);
Csid_lcp_key_ws:        rec(%`SBJ_DD_PATH:ADR_ID_REC.DDF`);
Csid_lcp_index:         que(%`SBJ_DD_PATH:REL_NAME_INDEX.DDF`);
Csid_lcp_adr_set:       set(%`SBJ_DD_PATH:ADR_SET.DDF`);
Csid_lcp_union:         set(%`SBJ_DD_PATH:REL_UNION.DDF`);
Csid_lcp_nul_seq:       seq(%`SBJ_DD_PATH:DAT_NULL_SEQ.DDF`);
Csid_lcp_nul_set:       set(%`SBJ_DD_PATH:DAT_NULL_SET.DDF`);
Csid_lcp_orig_rel_id:   long ;
Csid_lcp_orig_cdt_typ:  rec(
 Cdt_ovr:               str(1);
 Cdt_idtype:            str(1);
 Cdt_id:                vstr(64); );
Csid_lcp_orig_cdt_acct: rec(   %`SBJ_DD_PATH:ACC_ID_REC.DDF`); %^TRmod

%^ For finding default account for an address
Csid_accdef_seq:	seq(	%`SBJ_DD_PATH:REL_NAME_SEQ.DDF`) 
					Scan_Key = Disp_default ;

%^ For finding account by type for an address
Csid_acctyp_seq:	seq(	%`SBJ_DD_PATH:REL_NAME_SEQ.DDF`) 
				Scan_Key = Rel_name_key.Idtype ;

%^ Error memo text.
Csid_err_memo:		vstr(256) ;	%^ Increase to match FORMAT_MSG_TO_TEXT conversion
csid_save_err_memo:	vstr(256);

%^ Info memo text.
Csid_info_memo:		vstr(256) ;	%^ Increase to match FORMAT_MSG_TO_TEXT conversion

%^ Compose subject.
Csid_compose:		COMPOSE(^NOTRAP) ;
Csid_parse:		PARSE(^NOTRAP) ;
Csid_clip_compose:	COMPOSE(^NOTRAILING_BLANKS);

%^ Returned rel id
Csid_rel_id:		long ;

%^ Known debit account id
Csid_know_acc_id:        rec(	%`SBJ_DD_PATH:ACC_ID_REC.DDF`);
%^ Holds duplicate account id.
Csid_dupe_acc_ws:	rec(	%`SBJ_DD_PATH:ACC_ID_REC.DDF`);

%^ Scratch address id -- label of account sequence.
Csid_scr_adr_id:        rec(	%`SBJ_DD_PATH:ADR_ID_REC.DDF`);

%^ Scratch address set
Csid_adr_set:		set(    %`SBJ_DD_PATH:ADR_SET.DDF`);
Csid_tmp_adr_set:	set(    %`SBJ_DD_PATH:ADR_SET.DDF`);

%^ Temp bank union for currency checks.
Csid_bnk_union:	set(	%`SBJ_DD_PATH:BNK_UNION.DDF`);

%^ Last qualified rel id.
Csid_qualified_rel:	long ;
                                              
%^ For scanning.
Csid_next_status:	Boolean ;
Csid_found_it:		Boolean ;
Csid_chips_candidate:	Boolean ;
Csid_failed_lookup:	Boolean ;
Csid_found_account:	Boolean ;

%^ For holding name and address lines.
Csid_name1_ws:		vstr(35);
Csid_name2_ws:		vstr(35);
Csid_name3_ws:		vstr(35);
Csid_name4_ws:		vstr(35);
Csid_sname_ws:          vstr(35);

%^ For account checks
Csid_curr_ok_ws:	Boolean ;
Csid_acc_bank_ws:	str(3) = "   ";
Csid_bank_curr_ws:	str(3) = "   ";
Csid_acc_curr_ws:	str(3) ;
Csid_msg_curr_ws:	str(3) ;
Vmsg_dat_notonfile_wc:		str  = "VMSG$_DAT_NOTONFILE";
Vmsg_missingdat_wc:		str  = "VMSG$_MISSINGDAT";
Vmsg_ambig_lookup_wc:           str  = "VMSG$_AMBIG_LOOKUP" ;
Vmsg_part_lookup_wc:            str  = "VMSG$_PART_LOOKUP";
Vmsg_lookup_fail_wc:		str  = "VMSG$_LOOKUP_FAIL";

Csid_set_address:	Boolean ;
Csid_set_account:	Boolean ;

%^ Credit party depth of first non-pushed-down party.
Csid_orig_depth:	oneof(SIDES_NONE, SIDES_BNP, SIDES_BBK, SIDES_IBK, 
				SIDES_IB1 ) ;
Csid_try_chips:		Boolean ;

%^ Used in CHIPS qualification.
Csid_oneof_ord:		word;
Unq_chips_overide:	Boolean;

%^ Preferred bank for credit party.
Csid_preferred_bank:	str(3) ;

%^ Temp vstring
Csid_temp1_vstr:	vstr(132) ;
Csid_temp2_vstr:	vstr(132) ;
Csid_temp3_vstr:	vstr(132) ;
Csid_temp4_vstr:        vstr(132) ;
Csid_temp5_vstr:        vstr(132) ;
Csid_temp6_vstr:        vstr(132) ;
%^
%^ Not only do we need temporary vstrings, but sometimes we
%^ need areas to save the vstring information.  In this case
%^ it's for secondary account numbers returned from the check
%^ digit routine(s).
Csid_save2_vstr:        vstr(132);                      %^SPR29636
Csid_2nd_id_bank:       str(3);                         %^SPR29636
Csid_2nd_id_acct:       vstr(124);                      %^SPR29636
Csid_2nd_id_rmnd:       vstr(124);                      %^SPR29636
Csid_oneof_ord1:        long;                           %^SPR29636
Csid_oneof_ord2:        long;                           %^SPR29636
Csid_oneof_ord3:        long;                           %^SPR29636
%^ Preferred correspondent.
%^ Id returned by subroutine to replace credit ID as overlay or insert
%^ Moved to csid_cust_fsect  Csid_pref_corr_rec:	rec( %`SBJ_DD_PATH:PARTY_REC.DDF`);	
%^ Id returned by subroutine as next party after inserted party: this in
%^ effect overlays the previous credit ID when it is pushed down
Csid_pref_next_id_rec: rec( %`SBJ_DD_PATH:PARTY_REC.DDF`);
%^ Id returned by subroutine as second ID for replacement credit ID.
Csid_pref_corr_2id_rec:	rec( %`SBJ_DD_PATH:PARTY_REC.DDF`);	
							
Csid_preferred_advice:  str(3);
Csid_pref_submethod: str(3);

%^ Where preferred_corr was found: "REL", "SPC", "GBL", "NIA"
Csid_corr_derivation:	Str(3);	

%^ Success in setting last preferred correspondent.
Csid_push_error:	Boolean ;

%^ Number of SI types to match and return.
Csid_number_SIs:	long = <0> ;

%^ Account suffixes passed to Intrtl_spec_pref_corr
Csid_suffixes:		vstr(80);
Csid_suffix_count:	long ;
Csid_curr_suffix:	Str(3);
Csid_more_suffixes:	Vstr(80);
Csid_wire_svc_bits:	bits(%`SBJ_DD_PATH:BNK_WIRE_SERVICE_BITS.DDF` );


%^ Null sequence
Csid_null_seq:		seq(%`SBJ_DD_PATH:DAT_NULL_SEQ.DDF`) ;

%^ Depth to which we have pushed credit party on this cycle
Csid_pushed_credit:	long;

%^ Loop counters for punctuation stripper.
Csid_punct_loop:	word ;
Csid_punct_2loop:	word ;

%^ Second id comparison status for creditside
Csid_bad_2nd_cdt:	Boolean ;
Csid_2nd_cdt_matched:	Boolean ;

%^ Count of ambiguous parties.
Csid_ambig_parties:	word ;

%^ Count of parties with lookup problems.
Csid_bogus_parties:	word ;

%^ Search mode for account lookup routine.
Csid_account_mode:	long ;

%^ Temporary parking place for Ent_acc_set.
Csid_acc_set:	set( %`SBJ_DD_PATH:ACC_SET.DDF`);

%^ Connection status for Ent_acc_set.
Csid_ent_acc_conn:	long ;

%^ For parsing out swift addresses from entry.
Csid_acchfwid:		vstr (124);
Csid_oneof_acchfw:	word ;
Csid_twoof_acchfw:	word ;

%^ For parsing out multiple id's from the BBK party
Csid_oneof_bbk:         word ;

%^ The ABA route-transit number of the IRS TT&L tax deposit account:
Csid_Ttl_account: 	str(9);

%^ For doing ABA lookups.
Csid_aux_set:		set( %`SBJ_DD_PATH:AUX_DB_SET.DDF`);
Csid_aux_index:		que( %`SBJ_DD_PATH:REL_NAME_INDEX.DDF`);

%^ Temporary length instrument.
Csid_length:		long;
Csid_other_length:	long;

%^ VSTR to hold SI types for credit party AIN search
Csid_SI_types:		vstr(90) ;
Csid_AINSI_types:	vstr(90) ;
Csid_num_AINSIs:	long ;
Csid_pre_codeword:	Boolean ;
Csid_chk_codeword:	Boolean ;

%^ Longwords to hold Standing Instruction Search Statuses
Csid_si_defer_ws:      	long;
Csid_si_dummy_ws:      	long;
Csid_si_error_ws:       Boolean;

%^ Null bank id string
Csid_null_bank_ws:	vstr(3) = "   ";

%^ For special entry mode
Csid_IRS_tran:		Boolean ;

%^ For returned VMSG codes
Csid_vmsg_ws:		str(%`%ACE$_MSG_STR_SIZE`) ;

%^ Target advice type.
Csid_target_adv:	Str(3);

%^ New advice type.
Csid_new_adv:		Str(3) ;

%^ Flag to indicate pushdown or overwrite for credit party.
Csid_do_pushdown:	oneof(SUBSTITUTE, PUSHDOWN) ;

%^ Loop limiting counter to prevent an infinite overwrite loop
Csid_push_count:	word ;

%^ Flag that party substitution was actually do to an SI
Csid_didansi_ws:	Boolean ;

%^ Saved advice information.
Csid_opr_advice:	Str(3) ;
Csid_ain_advice:	Str(3) ;

%^ Account required flag.
Csid_musthave_acct:	Boolean;

%^ Vstr which holds second credit id for parsing
Csid_2id_ws:		vstr(132) ;

%^ Temps to hold id being checked for second credit
Csid_checkid_ws:	vstr(34) ;
Csid_checkidt_ws:	str(1) ;

%^ Remembers check status for 2-part second id.
Csid_wascheck_ws:	Long ;

%^ Temps for chips qualification
Csid_2id_oneof:		word ;
%^ Rationalized first part of 2-part second credit id for credit level.
Csid_2aid_idt:		str(1) ;
Csid_2aid_id:		vstr(132) ;

%^ Rationalized second part of 2-part second credit id for credit level.
Csid_2bid_idt:		str(1) ;
Csid_2bid_id:		vstr(34) ;

%^ Parking place for actual credit id when we are trying to CHIPS qualify
%^   the second credit id argument as a magic BNP and we're not adv type CHP.
Csid_savcdt_idt:	str(1) ;
Csid_savcdt_id:		vstr(64) ;

%^ For holding error memos and error message id's.
Csid_error_memo:	vstr(%`%ACE$_MSG_STR_SIZE`) ;
Csid_error_code:	vstr(%`%ACE$_MSG_STR_SIZE`) ;

%^ Resultant debit party changed argument.  We tell DEB
%^   that it's changed if the credit party or advice type changes.
Csid_change_debit:	long ;

%^ Flag that indicates a debit screen account lookup should occur
%^ because something has changed on the creditside that might cause
%^ an AIN to be executed on the debit side.
Csid_debit_ain: 	Boolean ;


%^ For passing previce argument to SI_FIRST_DEBIT.
Csid_previce_vstr:      vstr(8) ;
Csid_previce_si_ind:	oneof(FOUND_PREVICE_SI, NO_PREVICE_SI);	

%^ Switch to stop rerouter AIN substitution after an RRT match param found.
Csid_got_rrt_ain:	Boolean ;

%^ For customizing advice sequence for BKT advice selection.
Csid_adv_text_seq:	seq( %`SBJ_DD_PATH:DAT_TEXT_SEQ.DDF`);
Csid_copy_count:	long ;
Csid_hold_adv_seq:	seq(%`SBJ_DD_PATH:DAT_NULL_SEQ.DDF`) ;
Csid_adv_seq_conn:	long ;

%^ Working id for creditside party.
%^ Moved to csid_cust_fsect Csid_party_id:		vstr(132) ;
%^ Moved to csid_cust_fsect Csid_party_idtype:	str(1) ;
Csid_acc_idtype_ws:	str(1) ;
Csid_hold_priority_ws:  str(1) ;

%^ Indicates that mapper passed on something it found indigestable.
Csid_had_garbage:	Boolean ;

%^ Indicates that this is a multi-id party.
Csid_multi_party:	Boolean ;

%^ Qualification worked for this party.
Csid_chips_party:	Boolean ;

%^ We did an override for this party
Csid_chips_override:	Boolean ;

%^ Temporary to allow AUX-only type indicator override for lower credit parties
Csid_temp_idtype:	Str(1) ;

%^ Temporaries for common UID chips qualification.
Csid_party_swfid:	Vstr(11) ;
Csid_party_uid:		Vstr(6) ;

%^ Working flag to indicate if advice type is "CHP"-equivalent
Csid_itsa_clearhouse:	Boolean;
Csid_clrhs_adv:		Str(3);
Csid_clrhs_swf_acc:	Str(2);
Csid_clrhs_currency:	Str(3);
Csid_clrhs_formatter:	Str(3);
Csid_clrhs_min_length:	Long;
Csid_clrhs_max_length:	Long;
Csid_clrhs_mod_check:	Vstr(3);
Csid_clrhs_ch_name:	Vstr(9);
Csid_clrhs_suffix:	Vstr(3);
Csid_clrhs_clr_sys:	Vstr(3);
Csid_clrhs_destype:	Vstr(3);
Csid_clrhs_dfincpy:	Vstr(3);
Csid_clrhs_lqm_fnc:	Vstr(3);
Csid_clrhs_clr_type:	Vstr(2);
Csid_clrhs_clr_bic:	Vstr(11);
Csid_clrhs_clr_gl:	Vstr(30);
Csid_clrhs_clr_nstro:	Vstr(30);
Csid_suffix_index:	long ;
Csid_clrhs_pid_id:	Vstr(40);

%^ Count for information messages
Csid_info_count:	long ;

%^ Temporaries for shuffling pieces of ids.
Csid_shuffle_alt:	vstr(64) ;
Csid_shuffle_part1:	vstr(64) ;
Csid_shuffle_part2:	vstr(64) ;
Csid_shuffle_acct:	vstr(34) ;
Csid_shuffle_type:	str(2) ;
Csid_shuffle_oneof:	word ;
Csid_shuffle_parens:	vstr(64) ;
Csid_shuffle_idt:	Str(1) ;

%^ For sanity check and garbage check
Csid_gcheck_oneof:	word ;        %^ Current idtype
Csid_gcheck_twoof:	word ;        %^ Next idtype
Csid_gcheck_adrof:	word ;	      %^ Appended address id	
Csid_gcheck_states:	oneof (GCHT_NONE, GCHT_DDA, GCHT_SAV, GCHT_GL,
				GCHT_NOSTRO, GCHT_AC, GCHT_SWF, GCHT_CHUSER, 
				GCHT_FED, GCHT_CHIPS, GCHT_CLEAR, 
				GCHT_GARBAGE, GCHT_EXTEND, GCHT_NOMATCH ) ;
Csid_gcheck_bank_id:    vstr(3) ;     %^ Bank id
Csid_party_bank_id:	vstr(3) ;     %^ Bank id parsed out of party
Csid_gcheck_id:		vstr(124) ;   %^ Next id
Csid_gcheck_dda_id:	vstr(124) ;   %^ Next id (used only for DDA)
Csid_gcheck_remain:	vstr(124) ;   %^ Remaining id string
Csid_gcheck_remain2:	vstr(124) ;   %^ Other remaining id string
Csid_gcheck_first:	long ;        %^ Flag first cycle using idt.
Csid_gcheck_processed:  vstr(124) ;   %^ Reconstituted string with changes.
Csid_gcheck_actodd:	Boolean ;     %^ SUCCESS map /AC to "D", else to " ".
Csid_gcheck_adr_id:	vstr(6) ;     %^ Holds slash and address id.
%^ Temp for ACCT_LOOKUP ids
Csid_lookup_temp:	vstr(64) ;

%^ Accounting method from Si_p1 of Ent_cnf_set.
csid_acctg_method_ws:   str(1);

%^ Temp for memo posting.
Csid_temp_memo:		vstr(80);

%^ Flag to take care of Debit SI credit insertion
Csid_credit_changed:	long ;

%^ Internal flag to indicate that we found a COR SI
Csid_cor_found:		Boolean ;

%^ Lower creditside lookup temp IDs
Csid_lc_aba:		vstr(64) ;
Csid_lc_account:	vstr(64) ;
Csid_lc_partic:		vstr(64) ;
Csid_lc_swift:		vstr(64) ;
Csid_lc_uid:		vstr(64) ;
Csid_lc_extid:		vstr(64) ;
Csid_lc_bogus:		vstr(64) ;
Csid_lc_ansbak:         vstr(64) ;
Csid_lc_dialdig:        vstr(64) ;
Csid_lc_user:           vstr(64) ;
Csid_lc_onrel:          vstr(64) ;
Csid_lc_adridt:		vstr(1);
Csid_lc_adrid:		vstr(64);
Csid_lc_nowadr:		boolean;

%^ Lower creditside lookup state flags.
%^     Values are "F" for found in id, "Y" for matched, "N" for conflict,
%^	"P" for cannot confirm, and SPACE for irrelevant.
Csid_lc_flg_aba:	str(1) ;
Csid_lc_flg_account:	str(1) ;
Csid_lc_flg_partic:	str(1) ;
Csid_lc_flg_swift:	str(1) ;
Csid_lc_flg_uid:	str(1) ;
Csid_lc_flg_extid:	str(1) ;
Csid_lc_flg_ansbak:     str(1) ;
Csid_lc_flg_dialdig:    str(1) ;
Csid_lc_flg_user:       str(1) ;
Csid_lc_flg_onrel:      str(1) ;
Csid_lc_flg_secwir:     str(1) ;
Csid_lc_flg_bogus:	str(1) ;

%^ Lower creditside first lookup type.
Csid_lc_first_idt:	str(1) ;

%^ Lower creditside party error message.
Csid_lc_error:		vstr(80) ;

%^ Lower creditside party no address flag
Csid_lc_noaddress:	Boolean ;

Csid_first_time_ws:     long;  %^ TEMP?
%^ Want secure routing from GET_CDTWIRE_DEST
Csid_want_secure:       long ;

%^ Got secure routing from GET_CDTWIRE_DEST
Csid_got_secure:        long ;

%^ Abstracted version of secwire flag for lower creditside lookup.
Csid_lc_secwir:         str(1) ;

%^ Retained version of original credit party for second id error message
Csid_orig_credit:       rec(
  Csid_oc_idtype:           str(1) ;
  Csid_oc_id:               vstr(64) ; ) ;

%^ Indicates that this is one of the source for which the Swf_dda_qual_edt and
%^ Swf_swfid_qual_edt flags apply.
Csid_qual_edt_source:   Boolean;

%^ Indicates that if garbage was found in a second id, it was in a DDA.
Csid_bad_dda:           Boolean ;

%^ For ENTRY deletion loop detector.
Csid_trn: 		rec(
 Ctrn_date:		str(8) = "      " ;
 Ctrn_num:		str(8) = "      " ; );

Csid_entries:		long ;
Csid_this_deletes:	long ;
Csid_this_psflags:	long ;
Csid_this_more:		long ;
Csid_total_psflags:	long ;
Csid_total_deletes:	long ;
Csid_stop_msg: 		vstr(132) ;
Csid_loop_limit:	long = <200> ;
Csid_process_name:	Vstr(12) ;
Csid_image_full:	vstr(256) ;
Csid_port_name:		vstr(256) ;
Csid_image_name:	vstr(128) ;
Pay_badparam_wc:	str  = "PAY$_BADPARAM"; %^ "String only" message.
Csid_lnm_string:	str  = "LNM$_STRING" ;
Csid_temp_long:		long ;

%^ If Success_is, we try to do second id rolldown
Csid_do_rolldown:	Boolean ;

%^ Receives second id for parsing.
Csid_second_id:		vstr(132) ;

%^ Dummy special fee key argument.
Csid_spec_key_dummy:	Str(1) = " " ;

Csid_from_aux:		Boolean ;
Csid_adr_conn:		long ;
Csid_rrt_lookidt:	str(1) ;
Csid_rrt_lookid:	vstr(64) ;
Csid_rrt_lookbnk:	str(3) ;

Csid_check_stat:	Boolean;
Csid_save_adv_type:	Str(3);

%^ Subject variables for call to configuration routines.
Csid_union_key_ws:   	rec (%`SBJ_DD_PATH:CFG_ID_REC.DDF`);
Csid_item_key_ws:	vstr(25);
Csid_item_type_ws:	vstr(16);
Csid_item_data_ws:   	vstr(256);
Csid_seq_ordinal_ws:	word;
Csid_error_msg_ws:	vstr(%`%ACE$_MSG_STR_SIZE`);
Csid_match_key_ws:	vstr(80);

Csid_instring:		Str(80);
Csid_intype_oneof:	word;
Csid_changed_it:	Boolean;
Csid_got_advice:	Boolean;
Csid_tmp_acc_set:	set( %`SBJ_DD_PATH:ACC_SET.DDF`);
Csid_tmp_grp_set:	set( %`SBJ_DD_PATH:GRP_SET.DDF`);
Csid_grp_acc_seq:	seq(%`SBJ_DD_PATH:DAT_NULL_SEQ.DDF`);
Csid_tmp_rel_union:     set( %`SBJ_DD_PATH:REL_UNION.DDF`);
Csid_temp_conn:		long ;
Csid_got_group:		Boolean ;
Csid_pref_curr:		Str(3);
Csid_pref_amount:	amount;
Csid_tmp_rel_reg:	reg(%`SBJ_DD_PATH:REL_REG.DDF`);

Csid_temp_stat:		Boolean ;
Csid_not_garbage:	Boolean;
Csid_delay_change:	Boolean;

%^ For parsing external id table entry
Csid_ext_min_length:	word;
Csid_ext_max_length:	word ;
Csid_ext_dtype:		vstr(1);
Csid_ext_got_id:	vstr(2);
Csid_ext_mod:		vstr(3);
Csid_ext_advice:	vstr(3);
Csid_ext_id:		vstr(80) ;
Csid_ext_special:	vstr(3) ;
Csid_ext_when:		vstr(1) ;
Csid_ext_errmsg:	vstr(%`%ACE$_MSG_STR_SIZE`);

Csid_extnd_country:	str(2);

%^ to detect MENU command issued from ambiguous screens (REL_GET)
Csid_next_function:	rec(%`SBJ_DD_PATH:MENU_FUNCTION_ID_REC.DDF`);

%^ Items to allow for IBAN/BBAN processing
csid_iban_bcode_found:		Boolean;
csid_iban_found:		Boolean;
csid_lookup_bban:		Boolean;
csid_iban_cntry_ws:	str(2);
csid_iban_bnk_ws:	vstr(10);
csid_iban_brnch_ws:	vstr(10);
csid_iban_curr_ws:	Str(3);
csid_bnk_code_rec_ws:	rec(%`SBJ_DD_PATH:ADR_ID_REC.DDF`);
%^ Indicate whether we are Pushing down or Inserting UP
csid_iban_party_ws:	oneof( none_is,		%^ error case
			       bnp_is,		%^ Bene contains party
			       Cdt_is);		%^ Credit Party

csid_val_iban_ret:	ONEOF(%`SBJ_DD_PATH:RETURN_STATUS_ONEOF.DDF`);	%^ Spr 136107
csid_bcode_key:		str(12);
csid_iban_expanded:	Boolean;	%^ Iban has already been expanded
csid_save_cntry_ws:	Str(3);	
csid_Cfg_bic_ctry_ws:	str(2);
csid_Cfg_iban_ctry_ws:	str(2);
Csid_Bic_cc_exc_wf:	boolean;
Cfg_status_wf:		Boolean;


%^ Parameter/Rule processing stuff
csid_prm_name:			vstr(40);
csid_pr_level:		oneof(%` SBJ_DD_PATH:PRULE_MSGLEVEL_ONEOF.DDF`);
csid_prm_level:		oneof(%` SBJ_DD_PATH:PRULE_LEVEL_ONEOF.DDF`);
csid_pr_source:		oneof(%` SBJ_DD_PATH:PRULE_SOURCE_ONEOF.DDF`);
csid_prm_edit_type:		oneof(%` SBJ_DD_PATH:PR_PARAM_EDIT_ONEOF.DDF`);
csid_prm_values_remain:		long;
csid_prm_value:			Str(80);
csid_pr_ret_stat:		Boolean;
csid_upd_level:		oneof(%` SBJ_DD_PATH:PRULE_LEVEL_ONEOF.DDF`);
Csid_pr_debit_side:	Oneof(%`SBJ_DD_PATH:PRULE_SIDE_ONEOF.DDF`) = Adebit_side;
Csid_pr_credit_side:	Oneof(%`SBJ_DD_PATH:PRULE_SIDE_ONEOF.DDF`) = Acredit_side;
Csid_pr_msg_side:	Oneof(%`SBJ_DD_PATH:PRULE_SIDE_ONEOF.DDF`) = Msg_side;
Csid_pr_search_level:	Oneof(%`SBJ_DD_PATH:PRULE_MSGLEVEL_ONEOF.DDF`);
Csid_pr_search_source:	Oneof(%`SBJ_DD_PATH:PRULE_SOURCE_ONEOF.DDF`);

dbt_search_side_wc:	Oneof(%`SBJ_DD_PATH:PRULE_SIDE_ONEOF.DDF`) = debit_side;

csid_pr_type_ws:	vstr(80);
csid_pr_ordinal_ws:	long;
csid_pr_subtype_ws:	vstr(80);
csid_pr_memo:	vstr(%`%ACE$_MSG_STR_SIZE`);
csid_pr_stat_ws:	boolean;

tmp_value_date_ws:		Date;
tmp_bcode_id:			Str(10);
tmp_strt:	Long;
%^ Parameter processing 

csid_prm_name_ws:		vstr(40);
csid_prm_value_ws:		str(80);
csid_prm_memo_ws:		vstr(80);
csid_prm_level_wo:		oneof(%`SBJ_DD_PATH:PRULE_LEVEL_ONEOF.DDF`);
csid_prm_source_wo:		oneof(%`SBJ_DD_PATH:PRULE_SOURCE_ONEOF.DDF`);
csid_prm_edit_wo:		oneof(%`SBJ_DD_PATH:PR_PARAM_EDIT_ONEOF.DDF`);
csid_prm_remaining_ws: 		long;
csid_prm_status_wf:			boolean;
csid_prm_mode_wf:		boolean;
csid_prm_present_wf:		boolean;
csid_prm_time_on_ws:		Time;
csid_prm_time_off_ws:		Time;


%^ Proccessing Rule Constants
AIN_pr_wc:	Str = "CDTAIN";
COR_pr_wc:	Str = "COR";
IRT_pr_wc:	Str = "IRT";

%^ parameter names
Party_prm_wc:	Str = "MTS$PARTY";
Method_prm_wc:	Str = "MTS$METHOD";
Snd_secwir_wc:	Str = "MTS$SEND_SECWIR";

csid_prm_method_ws: 	str(3);
csid_prm_secwir_ws:	str(1);


lcl_scan_stat_ws:	boolean;
lcl_param_name_ws:	vstr(80);
lcl_param_value_ws:	vstr(80);
Lcl_Param_type_ws:	Oneof(%`SBJ_DD_PATH:PR_PARAM_EDIT_ONEOF.DDF`);
lcl_prms_remaining_ws:	Long;

%^ 'hard' booleans for passing parameters
csid_false_ws:		Boolean = Failure_is;
csid_true_ws:		Boolean = Success_is;
tmp_party_seq: 		seq( %`SBJ_DD_PATH:PRULE_SEQ.DDF`);
%^ oneof needed for 

Csid_Chdet_called:	boolean;
Csid_chan_acc_ws:	rec(	%`SBJ_DD_PATH:ACC_ID_REC.DDF`);	%^ GL returned from Certain Channels
Csid_chdet_stat_ws:	boolean;

csid_bnk_code_bnk_ws:	str(3);
csid_on_us_bnk_code:	Boolean;

%^ GET_profile items
%^
Csid_prchan_mode:	Oneof(%`SBJ_DD_PATH:CHANNEL_IDTYPE_ONEOF.DDF`);
Csid_prof_ident_ws:	rec(%`SBJ_DD_PATH:ADR_ID_REC.DDF`);
Csid_chan_ident_ws:	rec(%`SBJ_DD_PATH:ADR_ID_REC.DDF`); 
Csid_Got_channel_ws:	Boolean;
csid_got_prof_ws:	Boolean;
csid_chan_imposed_acct:	Boolean;
%^ Moved to csid_cust_fsect  csid_temp_party_id:	Vstr(132);	%^ holder for IBAN calls
csid_valid_iban_flg_ws:	Str(1);
csid_orig_iban_ws:	vstr(132);
csid_tmp_flg_ws:	Str(1);	%^ for GCV calls
csid_struct_acct_ws:	str(1);
csid_bban_cntry_req_ws:	Boolean; 
csid_precalc_cvd_ws:    str(1); 


Lkup_cfg_values_ws:	oneof(Not_loaded_is, Loaded_is);
Csid_fed_index_flg:	oneof(Extended_is, Aba_is);
Csid_col_tran_type_ws:	Str(3);

%^ for future reroute updates.
Previous_chnl_ws:      Str(3);
Chnl_to_skip_ws:	Str(3);
Targ_chnl_ws:          Str(3);
Sts_ws:                Boolean;
tmp_scr_stat_ws: 	vstr(80);

Csid_risk_country_ws:		str(2);
Csid_country_code_ws:		str(2);
Csid_res_country_ws:		str(2);
Csid_blank_country_ws:		Str(2);
tmp_party_len_ws:		long;
Csid_tmp_start_pos_ws:		long;
Csid_tmp_fin_pos_ws:		Long;
csid_tmp_corr_len_ws:		Long;
Csid_tmp_strt_pos_2_ws:		Long;

%^ Moved to csid_cust_fsect Csid_disable_AIN_ws:		Boolean;
Csid_save_cdtid_ws:  rec(Cdt_ovr:               str(1);
			 Cdt_idtype:            str(1);
			 Cdt_id:                vstr(64); );
save_iban_stat_ws:		Boolean;

Csid_msg_mnemonic_ws:	Vstr(80);
Csid_2ND_ID_NOCHECK_ws:	Boolean;


%^ Lookup BIC by BCC 
Lkup_bic_by_bcc_ws:		str(1);
Bcc_lkup_status:		boolean;
Bcc_lkup_party:			str(3);
Bcc_now_bic:			boolean;
Csid_ambig_save_ws:		str(1);

Csid_second_cdt_pass_ws: Boolean;
Csid_irr_acc_type_ws:	Str(1);


csid_already_warned_ws:	Boolean;
csid_msg_hist:		Seq( %`SBJ_DD_PATH:MSG_HISTORY_SEQ.DDF` ) ;
csid_set_chg_flg_ws:	Boolean;
csid_force_push_exit:	Boolean;
Csid_errs_before_cred:	Long;
Csid_stat_before_cred:	Long;
Csid_errors_saved:	Boolean;
Csid_errs_forgiven:	Long;

Moved_msg_cur_to_ftr:	Boolean;
tmp_msg_cur_ws:		Str(3);


%^ New Creditside_screen state declarations

Cdt_screen_state:	Oneof(	Init_is,		%^ 0

			      	Cdt_Lkup,
			      	Cdt_index_conn1,
			     	Cdt_map
				Cdt_pty,
				Cdt_pty_map,
				Cdt_index_conn2,
				Ain_processing,
				Ain_index_conn1,
				Ain_processing2,
				Ain_index_conn2,	%^ 10
				Ain_proc_Compl,
			      	Bnp_init_Lkup,
			      	Bnp_aux_lkup,
			      	Bnp_aux_conn,
				Bnp_aux_compl,
				Bnp_lookup,
				Bnp_index_conn,
			     	Bnp_map,
			      	Bbk_init_Lkup,
			      	Bbk_name_lkup,		%^20
			      	Bbk_name_conn,
				Bbk_name_compl,
				Bbk_lookup,
				Bbk_index_conn,
			     	Bbk_map,
			      	Ibk_init_Lkup,
			      	Ibk_name_lkup,
			      	Ibk_name_conn,
				Ibk_name_compl,
				Ibk_lookup,		%^ 30
				Ibk_index_conn,
			     	Ibk_map,
			      	Ib1_init_Lkup,
			      	Ib1_name_lkup,
			      	Ib1_name_conn,
				Ib1_name_compl,
				Ib1_lookup,
				Ib1_index_conn,
			     	Ib1_map,
				Bbk_init_secwir,	%^ 40
				Bbk_secwir_conn,
				Secwir_proc,
				Got_credit,
				Got_credit_1,
				Got_credit_2,
				Got_credit_conn,
				Got_credit_compl,
				Do_account,
				Do_account_compl,
				Account_index_conn,	%^ 50
				Completion_proc,
				Complete_is,
				Menu_is,
				Error_is);

Resolve_Ambiguous:		Boolean;
Initial_Ain:			Boolean;

Csid_iban_bbk_proc:		Boolean;
Csid_bban_unstruct:		Boolean;

%^ For saving/restoring a Relget_index in CREDITSIDE_SCREEN_EQUATE/CREDITSIDE_SCREEN_RESTORE
Csid_relget_return_idt:		Str(1);
Csid_relget_return_bank:	Str(3);
Csid_relget_index_conn:		Boolean;
Csid_relget_index:		que( %`SBJ_DD_PATH:REL_NAME_INDEX.DDF`) read_only;
TGT2_subpartic:			Boolean;
Temp_adv_hold_ws:		Str(3);
Dbt_int_save_ws:		word;
Csid_swf_dualid_match6:		Boolean;
Csid_swf_part1_idtype:		Str(1);
Csid_swf_part1_id:		Vstr(128);
Csid_swf_part1_subtype:		Str(2);
Csid_swf_part1_full_id:		Vstr(128);
Csid_swf_part2_idtype:		Str(1);
Csid_swf_part2_id:		Vstr(128);
Csid_swf_part2_subtype:		Str(2);
Csid_swf_part2_full_id:		Vstr(128);


csid_non_ucc_src:	Boolean;
csid_ucc_save_src:	Str(3);
Csid_locked_cdt_party:	Boolean;
Csid_tgt_account_bic:	Vstr(15);

Fed_xbank_nopref_flg:	Boolean;
Csid_retry_cdtain:	Boolean;
Csid_dummy_status:	Boolean;
Csid_net_memo:		Vstr(%`%ACE$_MSG_STR_SIZE`);
Csid_net_stat:		Boolean;
Csid_onscreen:		Long;
csid_bic_in_adr:	Boolean;
Dual_rpr_id:		Boolean;
csid_tmp_bnk_ws:	Str(3);		%^ temp bank  CR12949

%End


%linkage
01  Nocheck_ambig_ls  	  	%Long;
01  Do_multibank_ls 	  	%Long;
01  Credit_currency_ls	  	%Str(3);
01  Message_amount_ls	  	%Amount;
01  Message_currency_ls   	%Str(3);
01  Second_cdt_id_ls	  	%Str(132);
01  Second_cdt_id_leng_ls 	%Length;
01  Credit_account_ls	  	%Str(34);
01  Is_payment_ls	  	%Long;
01  Notell_no_credit_ls   	%Long;
01  Xbank_account_ok_ls	  	%Long;
01  Cdt_acc_type_ls  	  	%Str(1);
01  Resume_SIs_ls   	  	%Long;
01  Do_chips_qualif_ls	  	%Long;
01  Is_rptv_lookup_ls	  	%Long;
01  Lock_cdt_party_ls	  	%Long;
01  Special_fee_key_ls	  	%Str(1);
01  Party_rerun_ind_ls		%Str(6);
01  Init_debit_currency_ls 	%Str(3);
01  Debit_currency_ls	  	%Str(3);
01  Debit_account_ls	  	%Str(34);
01  Dbt_acc_type_ls  	  	%Str(1);
01  Nochange_bank_ls	  	%Long;
01  Lock_dbt_party_ls	  	%Long;
01  Debit_fee_key_ls	  	%Str(1);
01  Dbt_internal_ls	  	%Long;
01  Dbt_not_suspect_ls	  	%Long;
01  Debit_status_ls	  	%Boolean;
01  Msg_bank_changed_ls	  	%Long;
01  Dbt_err_memo_count_ls 	%Long;
01  Dbt_currency_found_ls 	%Str(3);
01  Cdt_currency_found_ls 	%Str(3);
01  Credit_depth_ls 	  	%Long;
01  Advice_parties_ls	  	%Long;
01  Chips_qualified_ls	  	%Long;
01  Second_cdt_matched_ls 	%Long;
01  Cdt_not_suspect_ls	  	%Long;
01  No_beneficiary_ls	  	%Long;
01  Cdt_err_memo_count_ls 	%Long;
01  Last_memo_ls 	  	%Str(80);
01  Last_memo_leng_ls 	  	%Length;
01  Creditside_look_ls		%Boolean;


%Procedure using Nocheck_ambig_ls, Do_multibank_ls, Credit_currency_ls,
                Message_amount_ls, Message_currency_ls,
                Second_cdt_id_ls, Second_cdt_id_leng_ls,
		Credit_account_ls, Is_payment_ls, Notell_no_credit_ls, 
		Xbank_account_ok_ls, Cdt_acc_type_ls, Resume_SIs_ls, 
		Do_chips_qualif_ls, Is_rptv_lookup_ls, Lock_cdt_party_ls,
		Special_fee_key_ls, party_rerun_ind_ls,
		Init_debit_currency_ls, Debit_currency_ls,
		Debit_account_ls, Dbt_acc_type_ls, Nochange_bank_ls, 
		Lock_dbt_party_ls, Debit_fee_key_ls, Dbt_internal_ls, 
		Dbt_not_suspect_ls, Debit_status_ls, Msg_bank_changed_ls, 
		Dbt_err_memo_count_ls,	Dbt_currency_found_ls, 
		Cdt_currency_found_ls, Credit_depth_ls,
 		Advice_parties_ls, Chips_qualified_ls, Second_cdt_matched_ls, 
		Cdt_not_suspect_ls, No_beneficiary_ls, Cdt_err_memo_count_ls, 
		Last_memo_ls, Last_memo_leng_ls
	RETURNING Creditside_look_ls.

%^*****************************************************************************

%^*****************************************************************************
A100_MAIN.
*  Initialize returned variables.
	Set Success_is in Creditside_look_ls to true.
	Move ZERO to Csid_suffix_count.
	%Beg  Csid_suffixes = NULL;  %End.
	Set FOUND_PREVICE_SI in Csid_previce_si_ind to TRUE.
	Move ZERO to Chips_qualified_ls.
	Move ZERO to Second_cdt_matched_ls.
	Move 1 to Cdt_not_suspect_ls.
	Move ZERO to Credit_depth_ls.
	Move ZERO to Advice_parties_ls
	Move ZERO to Cdt_err_memo_count_ls.
	Move ZERO to Csid_info_count.
	Move ZERO to Last_memo_leng_ls
	Move SPACES to Last_memo_ls.
        Move Credit_currency_ls to Csid_currency_ws.
        Move SPACES to Csid_dupe_acc_ws.
	Move ZERO to Csid_ambig_parties.
	Set Failure_is in Csid_iban_found to True.
	Set Success_is in Csid_chdet_stat_ws to True.
        Move SPACES to Csid_orig_iban_ws, csid_iban_cntry_ws, Csid_irr_acc_type_ws
		       csid_prm_method_ws, csid_prm_secwir_ws, csid_acctg_method_ws,
		       csid_ucc_save_src.
	Initialize csid_bnk_code_rec_ws, csid_save_cntry_ws.
	Set Failure_is in csid_on_us_bnk_code to True.
	Set Success_is in csid_set_chg_flg_ws to True.
 	Set Failure_is in Csid_errors_saved to TRUE.
	Set Failure_is in TGT2_subpartic to True.
	Set Failure_is in csid_non_ucc_src to True.
	Set Failure_is in Dual_rpr_id to True.
        Set Credit_is in cst_party_usage to True.

	If (Not_loaded_is in Lkup_cfg_values_ws)
	Then
		Set Loaded_is in lkup_cfg_values_ws to True
		Call "GCV_STRCTRD_ACCT_IN_USE" using
			by reference csid_struct_acct_ws
		If (csid_struct_acct_ws = "Y") Then
			Call "GCV_BBAN_CNTRY_REQ" using
			      by reference csid_tmp_flg_ws
			If csid_tmp_flg_ws = "Y" or "T" Then
				Set Success_is in csid_bban_cntry_req_ws to True
			else
				Set Failure_is in csid_bban_cntry_req_ws to True
			end-if
		end-if
		Call "GCV_PRECALC_CVD" using
			by reference csid_precalc_cvd_ws
		Call "GCV_COLLECTIONS_TRAN_TYP" using
			by Reference Csid_col_tran_type_ws
		Perform X1100_check_for_fed thru
			X1100_check_for_fed_end
%^ 		Get config flag for replacing lower debit party BCC Id with BIC
		%^ Disable BCC processing.
%^		Set Nothing_is in BCC_Mode of BCC_CODE to True
%^		Set Failure_is    in Lkup_bic_by_bcc_ws to True

		Call "GCV_LKUP_NO_KEY_MATCH_REQ" using
			by reference csid_tmp_flg_ws
		If csid_tmp_flg_ws = "Y" or "T" Then
			Set Success_is in csid_2nd_id_nocheck_ws  to True
		else
			Set Failure_is in csid_2nd_id_nocheck_ws to True
		end-if

		%beg csid_compose ^out(csid_prm_name) "MTS$BBAN_UNSTRUCTURED",/;
		     csid_prm_values_remain = <0>;
		%end
		Call "PRULE_MSG_GET_PARAM" Using
			by Reference	csid_prm_name
			by Reference 	csid_prm_name_length
			by Reference 	csid_prm_level
			by Reference 	csid_pr_source
			by reference 	csid_prm_edit_type
			by reference 	csid_prm_values_remain
			by reference 	csid_prm_value
			by reference 	csid_prm_value_length
		returning csid_pr_ret_stat
		If Success_is in Csid_pr_ret_stat  And
		   Csid_prm_value = "T" or "Y"
		Then
			Set Success_is in Csid_bban_unstruct to True
		Else
			Set Failure_is in Csid_bban_unstruct to True
		End-if
%^ Get config flag for 6 character BIC match on dual ids
%^		Call "GCV_SWF_DUALID_MATCH6" using
%^			by reference csid_tmp_flg_ws
		Perform X1400_CHK_DUAL_MATCH6 Thru
			X1400_CHK_DUAL_MATCH6_END
		If csid_tmp_flg_ws = "Y" or "T" Then
			Set Success_is in Csid_swf_dualid_match6 to True
		else
			Set Failure_is in Csid_swf_dualid_match6 to True
		end-if

		Call "GCV_FED_XBANK_NOPREF" using
		      by reference csid_tmp_flg_ws
		If csid_tmp_flg_ws = "Y" or "T"
		Then
			Set Success_is in Fed_xbank_nopref_flg to True
		Else
			Set Failure_is in Fed_xbank_nopref_flg to True
		End-if
	end-if.

	%Beg
	Csid_pref_corr_rec = NULL;
	Csid_pref_next_id_rec = NULL;
	csid_bnk_code_rec_ws = NULL;
	Csid_tgt_account_bic = NULL;
	%End.
        Move SPACES to Csid_err_memo.
        Move ZERO To Csid_err_memo_length.
	Set Failure_is in Csid_push_error to TRUE.
	%Beg  Csid_know_acc_id = NULL;  %End.
	If (Credit_account_ls NOT = SPACES )
            Move Credit_account_ls to Csid_instring
	    %Beg
	    Csid_clip_compose ^OUT(Csid_temp1_vstr)
		Csid_instring, / ;
	    Csid_parse ^IN(Csid_temp1_vstr)
		^OPTION( Csid_know_acc_id.idbank(^STR<3>)),
		Csid_intype_oneof( ^ONEOF(" ",
					"D",
					"G",
					"V",
					"F",
					"P" )),
		Csid_know_acc_id.idkey(^STR<-1>), / ;
	   Csid_compose ^OUT(Csid_know_acc_id.idtype)
		Csid_intype_oneof(^ONEOF(" ",
					"D",
					"G",
					"V",
					"F",
					"P" )), / ;
	   %End
	END-IF.
	Move SPACES To Csid_corr_derivation.
	Move SPACE to Csid_2aid_idt.
        Move SPACES to Csid_orig_credit.
        %Beg  Csid_orig_credit = NULL ;  %End.
	Set Failure_is in Csid_pre_codeword to true.
	Set Failure_is in Csid_chk_codeword to true.
	Move SPACE to Csid_id_bank_ws.

%^ #106399 If the credit advice is not spaces, then set the cdt_adv_flg of 
%^	   Ent_ftr_set to "Y"
%^ #111644 This change is not good when CREDITSIDE_LOOKUP is called twice due
%^	   HOST_GET, PARTY_DETERMINATION or AUTOTRIEVE retry. Limit setting of
%^	   Cdt_adv_flg to repetitives because thats what 106399 was about.
%^	   TODO: decide if setting Cdt_adv_flg should be in sto_demon, rpvin, or removed.

	If Cdt_adv_typ of Ent_credit_set NOT = SPACES and
	   (Is_rptv_lookup_ls NOT = 0)
	Then
	    %Beg
		Ent_ftr_set.flgs.cdt_adv_flg = "Y";
	    %End
	End-if.

	If ( Cdt_adv_flg of Ent_ftr_set = "Y")
	   AND (Cdt_adv_typ of Ent_credit_set NOT = SPACES )
	THEN
	    Move Cdt_adv_typ of Ent_credit_set to Csid_opr_advice
	ELSE
	    Move SPACES to Csid_opr_advice
	END-IF.
	IF (Csid_opr_advice NOT = Instr_adv_type of Ent_ftr_set )
	    %Beg  Ent_ftr_set.Instr_adv_type = Csid_opr_advice ;  %End
	END-IF.
	Move SPACES to Csid_ain_advice.
	Set Failure_is in Csid_gcheck_actodd to true
	Set Failure_is in Csid_cor_found to true.
	Move SPACES to Csid_acc_curr_ws.

*  Set up local flags.
	If (Nocheck_ambig_ls NOT = 0 )
	    Move "T" to Csid_ambig_ws 
	ELSE
	    Move SPACE to Csid_ambig_ws 
	END-IF.
	If (Do_multibank_ls NOT = 0 )
	    Move "Y" to Csid_multibank_ws 
	ELSE
	    Move SPACE to Csid_multibank_ws 
	END-IF.
 	Set Failure_is in Csid_bad_2nd_cdt to TRUE.
	Set Failure_is in Csid_set_address to TRUE.
	Set Failure_is in Csid_set_account to TRUE.
	Set Success_is in Csid_musthave_acct to true.
	Set Failure_is in Csid_do_rolldown to TRUE.
	%Beg  Csid_acc_bank_ws = NULL ; 
	      Csid_chan_acc_ws = Null;	%end.
	Set Failure_is in Csid_credit_pend_del to TRUE.
	Move ZERO to Csid_pushed_credit.

* Record initial shallowest party.
	If (Bnp_id of Ent_credit_set NOT = SPACES )
	   OR ( (Bnp_name1_length of Ent_credit_set_lengths NOT = 0 )
		 AND (Bnp_name1 of Ent_credit_set NOT = SPACES ) )
	THEN
	    If (Bbk_id of Ent_credit_set NOT = SPACES )
	       OR ( (Bbk_name1_length of Ent_credit_set_lengths NOT = 0 )
		     AND (Bbk_name1 of Ent_credit_set NOT = SPACES ) )
	    THEN
	        If (Ibk_id of Ent_credit_set NOT = SPACES )
		   OR ( (Ibk_name1_length of Ent_credit_set_lengths NOT = 0 )
			 AND (Ibk_name1 of Ent_credit_set NOT = SPACES ) )
	            If (Ib1_id of Ent_credit_set NOT = SPACES )
		       OR ( (Ib1_name1_length of Ent_credit_set_lengths 
				NOT = 0 )
		 	     AND (Ib1_name1 of Ent_credit_set NOT = SPACES ) )
		    THEN
			%Beg  Csid_orig_depth SIDES_IB1 ;  %End
		    ELSE
			%Beg  Csid_orig_depth SIDES_IBK ;  %End
		    END-IF
		ELSE
		    %Beg  Csid_orig_depth SIDES_BBK ;  %End
		END-IF
	    ELSE
		%Beg  Csid_orig_depth SIDES_BNP ;  %End
	    END-IF
	ELSE
	    %Beg  Csid_orig_depth SIDES_NONE ;  %End
	END-IF.

%^ Check for lower party UCC handling
	If NOT(SIDES_NONE in csid_orig_depth)	AND
	   NOT(csid_ucc_save_src = src_code of Ent_ftr_set)
	Then
		Perform X1300_CHK_UCC_SRC thru
			X1300_CHK_UCC_SRC_END
	End-if.

%^ See if this is a locked credit party, and if so, is it still valid?
        Perform D870_LOCKED_CREDIT_PARTY thru D870_LOCKED_CREDIT_PARTY_end.

	If (Cor_done in Si_flgs of Ent_ftr_set = SPACE)
	   AND (Src_code of Ent_ftr_set NOT = "COR" )
	THEN
	    Move 2 to Csid_num_AINSIs
	    %Beg  Csid_AINSI_Types = "COR,CDTAIN" ;  %End
	ELSE
	    If (Cor_done in Si_flgs of Ent_ftr_set = "P" )
		Set Success_is in Csid_cor_found to true
	    END-IF
* Don't interrupt AIN search for CORs.  Been there, done that.
	    Move 1 to Csid_num_AINSIs
	    %Beg  Csid_AINSI_Types = "CDTAIN" ;  %End
	END-IF.

	If (Resume_SIs_ls NOT = 0 )
* If we are cleaning up after COR rejection, skip to SI processing.
	    PERFORM B520_RECONNECT through B520_RECONNECT_END
	    GO TO A100_MAIN_CLEANUP
	END-IF.
 	%Beg  Relget_msgcode = NULL ;  %End

	%^
	If csid_struct_acct_ws = "Y" Then
		%^ Check PUSH UP IBAN A and D format replacement logic
		%^ THis can result in a new Credit party right off the bat
		Perform X1000_CHECK_IBAN_BNP Thru
			X1000_CHECK_IBAN_BNP_END
	End-if.		

* Now let's figure out who the credit party is.
	If (Cdt_idtype of Cdt_typ of Ent_credit_set = SPACE )
	   AND (Cdt_id of Cdt_typ of Ent_credit_set = SPACES )
	THEN
	    %Beg  Ent_credit_set.cdt_typ.Cdt_ovr = "*" ;
		  csid_ovr = "*";
	    %End

	    If (Cdt_adr_bnk_id of Ent_credit_set NOT = 
					      Bank of Loc_info of Ent_ftr_set )	
	        %Beg
	        Ent_credit_set.Cdt_adr_bnk_id = Ent_ftr_set.loc_info.bank ;
	        %End
	    END-IF
	    %^ Flush things here, that used to flush in b280 credit_addr
	    %beg break: relget_adr_set; 	%^ safety first
		 relget_msgcode = NULL;
	    %end
	Else
		%^ Only call B280_CREDIT_ADDR if there is ANY info,
		%^ Else, get to B400_set_advice without setting error codes
		%^ For FOR spr 93333
 		Move Cdt_not_suspect_ls to Csid_stat_before_cred
 		Move Cdt_err_memo_count_ls to Csid_errs_before_cred
 		Set Success_is in Csid_errors_saved to TRUE
		Perform B280_CREDIT_ADDR through B280_CREDIT_ADDR_END
	END-IF.
* Let's get the second credit id argument set up if there is one
	%Beg  Csid_second_id = NULL ;  %End
	If (Second_cdt_id_leng_ls NOT = 0 )
	    If (Second_cdt_id_ls(1:1) NOT = "/" )
		Move "/" to Csid_second_id
		Move Second_cdt_id_ls(1:Second_cdt_id_leng_ls) to
		   Csid_second_id(2:Second_cdt_id_leng_ls)
		Add 1 to Second_cdt_id_leng_ls giving Csid_second_id_length
	    ELSE
		Move Second_cdt_id_leng_ls to Csid_second_id_length
		Move Second_cdt_id_ls(1:Csid_second_id_length) to 
								Csid_second_id
	    END-IF
	END-IF.
	Perform B440_SETUP_2ND_ID through B440_SETUP_2ND_ID_END.

	If (Csid_ovr = SPACE )
           OR ( ( Csid_ovr = "*" )
	      AND (Relget_msgcode = Vmsg_dat_notonfile_wc ) )
        THEN
* We actually did get a REL or AUX db hit, so let's copy the address.
	    Perform C720_COPY_ADDRESS through C720_COPY_ADDRESS_END
	ELSE
		%^ NO Hit
		%^ We need to check for a secondary ID and use it to attempt
		%^ to get a Credit Address record, BUT maintain the ID if it is
		%^ an Accounting ID type D,F,G or V
		%^ Try a swap on the Credit Set IDtype and send it thru the B280_CREDIT_ADDR
		%^ section, then replace the original ID after the address context has been
		%^ set.
		If (Cdt_idtype of Cdt_typ of Ent_credit_set = "D" or "F" or "V" or "G" or " ") and
		   (Csid_2aid_idt = "S") %^ Secondary ID is a BIC %^ " " added in 117736,117413
		Then
		    %beg  csid_save_cdtid_ws(.cdt_ovr = ent_credit_set.cdt_typ.cdt_ovr,
		 			     .cdt_idtype  = ent_credit_set.cdt_typ.cdt_idtype,
					     .cdt_id   = ent_credit_set.cdt_typ.cdt_id);
				
			  Ent_credit_set.cdt_typ
					(.Cdt_ovr = Null,
					 .cdt_idtype = Csid_2aid_idt,
					 .Cdt_id     = Csid_2aid_id);
		    %end
		    If Success_is in Csid_iban_found Then
			Set Success_is in save_iban_stat_ws to True
			Set Failure_is in csid_iban_found to True
		    End-if
		    If (Failure_is in Csid_errors_saved)
 			Move Cdt_not_suspect_ls to Csid_stat_before_cred
 			Move Cdt_err_memo_count_ls to Csid_errs_before_cred
 			Set Success_is in Csid_errors_saved to TRUE
 		    END-IF
		    Perform B280_CREDIT_ADDR Thru
			    B280_CREDIT_ADDR_END
			If (Csid_ovr = SPACE )
           		OR ( ( Csid_ovr = "*" ) AND
	      		     (Relget_msgcode = Vmsg_dat_notonfile_wc ) )
			Then
				%^ A BIC hit on the secondary, the Connections
				%^ have been made, restore the ID for AUTOTREIVE
				%^ implications
			   	Perform C720_COPY_ADDRESS through
					C720_COPY_ADDRESS_END
				%^ Move the orignal to the secondary
				%^ If 2 ids, set the AC based upon type.
				%beg Csid_2aid_idt = csid_save_cdtid_ws.cdt_idtype;
				     Csid_2aid_id  = csid_save_cdtid_ws.cdt_id;
				%end
			end-if
		 	If Success_is in save_iban_stat_ws Then
				Set Failure_is in save_iban_stat_ws to True
				Set Success_is in csid_iban_found to True
			end-if

			If Not(cdt_idtype of csid_save_cdtid_ws = " ") Or
			      (Success_is in csid_on_us_bnk_code) %^ restore the IBAN and left this lookup
			     Or Success_is in Csid_iban_found	  %^ get the IBAN back for push.
			Then
				%^ Restore the Original ID regardless
				%beg 
					Ent_credit_set.cdt_typ
						(.Cdt_ovr = csid_save_cdtid_ws.cdt_ovr,
					         .cdt_idtype =  csid_save_cdtid_ws.cdt_idtype,
					         .Cdt_id     =  csid_save_cdtid_ws.cdt_id);
				%end
			        If (Success_is in csid_iban_found or   %^ 
				    Success_is in csid_on_us_bnk_code) %^ 126212
				Then %^ required to make the insertion happen
					Move "*" to csid_ovr
				end-if
			end-if

		End-if
	End-if.
 
	If Success_is in csid_2nd_id_nocheck_ws
	Then
		If  (((Failure_blocking_is in Csid_val_iban_ret) Or	%^ Restack ANY error,
      		      (Failure_warning_is in Csid_val_iban_ret)  Or	%^ Can't pay at this point
		      (Failure_ignore_is  in Csid_val_iban_ret)  Or
		       %^ Add success case for Good BBAN's with bad/no bank codes
		       %^ Since no expansion can occur, bust them 
		      (Success_is in csid_val_iban_ret And  csid_bnk_code_rec_ws = Spaces And
		       Csid_valid_iban_flg_ws  = "N"))
 		      AND
	 	       second_cdt_id_ls NOT = spaces And Cdt_idtype of Ent_credit_set = "S")
		   OR ( %^ Need a case for non-iban banks, using this switch.
			csid_struct_acct_ws = "N"
		        And (csid_ovr = "*" and NOT (Relget_msgcode = Vmsg_dat_notonfile_wc )
			And csid_second_id NOT = Spaces))
		Then	%^ Error tagged, stack the ID's now
			%^ We had a Bad IBAN and a good BIC, stack the id's for RPR
			Set Success_is in Dual_rpr_id to True
			Perform C805_REBUILD_2ID  Thru
				C805_REBUILD_2ID_END
		End-if
	Else
		Perform B390_DO_SECOND_ID thru
			B390_DO_SECOND_ID_END
	End-if.
 
 	If Success_is in Csid_val_iban_ret and
	   Success_is in Csid_iban_found and
	   Success_is in Csid_iban_expanded
		%beg 
		csid_compose ^out(csid_prm_name) "MTS$DISABLE_AIN",/;
		csid_prm_values_remain = <0>;
		csid_prm_value = NULL;
		%end
		Set Msg_ml in Csid_pr_level to true
		Call "PRULE_MSG_GET_PARAM_FROM" Using
			by Reference	csid_prm_name
			by Reference 	csid_prm_name_length
			by Reference	csid_pr_msg_side
			by Reference 	csid_pr_level
			by Reference	csid_prm_level
			by Reference 	csid_pr_source
			by reference 	csid_prm_edit_type
			by reference 	csid_prm_values_remain
			by reference 	csid_prm_value
			by reference 	csid_prm_value_length
			returning csid_pr_ret_stat
		If (Success_is in Csid_pr_ret_stat) and (csid_prm_value(1:1) = "Y")
		Then
			Go to A100_MAIN_CLEANUP
		End-if
	End-if.

	Perform B400_SET_ADVICE through B400_SET_ADVICE_END.

	Perform B420_GET_NEWPARTY through B420_GET_NEWPARTY_END
	If (Failure_is in Creditside_look_ls   )
	    OR (Success_is in Csid_cor_found   )
	THEN
	    PERFORM A110_GOT_CREDIT through A110_GOT_CREDIT_END
	    GO TO A100_MAIN_END
%^	    GO TO A100_GOT_CREDIT
	END-IF.

A100_MAIN_CLEANUP.
	Move 5 to Csid_push_count.
	%Beg  Relget_msgcode = NULL ;  %End.

	Move Csid_multibank_ws to Csid_temp_multibank_ws.	%^ can be changed in loop	
	Set Failure_is in Csid_force_push_exit to True.

	Perform UNTIL (Idtype of Csid_pref_corr_rec = SPACE )
		       OR (Success_is in Csid_push_error)

            %^ Retain the bank context from the previous party
            %^ unless it has been explicitly changed
            If Cdt_id of Ent_credit_set (4:1) = ":" 
              AND Idkey of Csid_pref_corr_rec (4:1) not = ":"
	      AND Idtype of Csid_pref_corr_rec not  = "A"
            THEN
                %Beg
                Csid_parse ^IN(Ent_credit_set.cdt_typ.cdt_id)
                                Csid_id_bank_ws, ":", ^STRING, / ;
                %End
                If Success_is in Csid_parse_status   and
                   Csid_id_bank_ws not = spaces
                THEN
                    %Beg
                    Csid_parse ^IN(Csid_pref_corr_rec.idkey),
                        ^OPTION(^STRING<3>,":"), Csid_temp1_vstr, ^SPACE, /;
                    Csid_Compose ^OUT(Csid_pref_corr_rec.idkey),
                        Csid_id_bank_ws, ":", Csid_temp1_vstr, /;
                    %End
                END-IF
            END-IF

	    If (Csid_stat_before_cred NOT = Cdt_not_suspect_ls)
		Move Csid_stat_before_cred to Cdt_not_suspect_ls
		Subtract Csid_errs_before_cred from Cdt_err_memo_count_ls
			giving Csid_errs_forgiven
		If (Csid_errs_forgiven NOT = 0 )
		    %Beg
		    Csid_compose ^OUT(Csid_info_memo)
			Csid_errs_forgiven, 
			" errors now warnings after credit party ";
		    %End
	   	ELSE
		    %Beg
		    Csid_compose ^OUT(Csid_info_memo)
			"Credit error status reset by credit party ";
		    %End
	   	END-IF
	    End-if

	    If (Csid_push_count > 0 )
	        Subtract 1 from Csid_push_count
	    ELSE
	    	%Beg
		Csid_compose ^OUT(Csid_err_memo)
		       "Preferred correspondent loop?? for "
			Csid_pref_corr_rec, / ;
	 	%End
		Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
		Set Failure_is in Creditside_look_ls to true
		Set Success_is in Csid_push_error to TRUE
	    END-IF

	    %^ 82786 
	    If Idtype of Csid_pref_corr_rec = "A" and
	       Idkey  of Csid_pref_corr_rec(4:1) not = ":" Then
		Move "N" to Csid_temp_multibank_ws
	    Else
		%^ reset/preserve to original
		Move Csid_multibank_ws to Csid_temp_multibank_ws
	    end-if

	    Set CDT in Relget_title_flag to TRUE
	    Move SPACES to Csid_lookup_temp
	    %ACE_IS Ent_c_adr_set connected giving Csid_conn_stat;
	    %Beg  
	    Csid_lookup_temp = Csid_pref_corr_rec.idkey ;  
	    %End
	    Move "F" to Csid_lkup_pend_del
	    Call "ACCT_LOOKUP" using   
	        by reference Idtype of Csid_pref_corr_rec
	        by reference Csid_lookup_temp
	        by reference Csid_ovr
	        by reference Csid_ambig_ws 
	        by reference Csid_temp_multibank_ws
	        by reference Credit_currency_ls
		by reference Csid_lkup_pend_del
	      RETURNING Csid_ret_stat

           If Csid_lkup_pend_del = "T"
		Set Success_is in Csid_credit_pend_del to TRUE
           End-if 
           If (Relget_return_key Not = Spaces )
                If (Csid_ovr = Space )
                Or ( (Csid_ovr = "*")
		     AND (Relget_msgcode = Vmsg_dat_notonfile_wc))
                    %Beg
                    Csid_pref_corr_rec.idtype = Relget_return_idtype ;
                    Csid_clip_compose  ^OUT(Csid_pref_corr_rec.idkey),
                        Relget_return_key, / ;
                    %End
               End-if
            End-if
	    If (Csid_ovr = SPACE)
	        AND (Cdt_ovr of Cdt_typ of Ent_credit_set = SPACE )
		AND (Csid_corr_derivation = "REL")
	        And (Cdt_idtype of Ent_credit_set = Idtype of csid_pref_corr_rec)
		And (Cdt_id of Ent_credit_set = Idkey of Csid_pref_corr_rec)
		And NOT (SUBSTITUTE in Csid_do_pushdown) %^ 83550 - allow account sub
	        %^ ALLOW AIN to INSERT itself when the ID to Insert s a different ID than
  	        %^ the current ID
	    THEN
 		Set Success_is in Csid_push_error to TRUE
		Set Success_is in csid_force_push_exit to True
	    Else
		%^ We are going to perform the AIN, so set the Channel Now 118361
		If (Csid_prm_method_ws  NOT = SPACES )
		    %Beg
		        Ent_credit_set.cdt_adv_typ = csid_prm_method_ws ;
                        Ent_ftr_set.flgs.cdt_adv_flg = "Y" ;
		        Csid_ain_advice = Csid_prm_method_ws ;
		    %End
		End-if
	    END-IF
	    If (Idkey_length of Csid_pref_corr_2id_rec_lengths NOT = 0 )
		AND (Idkey of Csid_pref_corr_2id_rec NOT = SPACES )
	    THEN
		Set Failure_is in Csid_do_rolldown to TRUE
		If (Csid_ovr = SPACE )
		    %Beg
		    Csid_clip_compose ^OUT(Csid_second_id)
			Csid_pref_corr_2id_rec.idtype,
			Csid_pref_corr_2id_rec.idkey, / ;
		    BREAK: Csid_adr_set ;
		    Relget_adr_set EQUATE: Csid_adr_set(NOMOD) ;
		    %End
		    Perform B440_SETUP_2ND_ID through B440_SETUP_2ND_ID_END
	    	    If (Csid_2aid_id_length NOT = 0 )
			%Beg  
			Csid_checkid_ws = Csid_2aid_id ;  
			Csid_checkidt_ws = Csid_2aid_idt ;
			%End
			Perform B300_SECOND_CREDIT 
						through B300_SECOND_CREDIT_END

			If (Csid_2bid_id_length NOT = 0 )
* We must also check the second second id.
			    Move Second_cdt_matched_ls to Csid_wascheck_ws
                	    Move ZERO to Second_cdt_matched_ls
			    %Beg
			    Csid_checkid_ws = Csid_2bid_id ;
			    Csid_checkidt_ws = Csid_2bid_idt ;
			    %End
			    Perform B300_SECOND_CREDIT 
						through B300_SECOND_CREDIT_END
	                    If (Second_cdt_matched_ls NOT = Csid_wascheck_ws )
%^ Inconsistent results are a real no-no.
		   	        %Beg
			        Csid_compose ^OUT(Csid_err_memo)
				    "Inconsistent second credit IDs ", 
				    Csid_2aid_idt, "/", Csid_2aid_id, " and ", 
				    Csid_2bid_idt, "/", Csid_2bid_id, / ;
		        	%End
	   			Perform X900_ERROR_MEMO 
						   through X900_ERROR_MEMO_END
		    		Set Success_is in Csid_push_error to TRUE
			    END-IF
			END-IF
	                If (Second_cdt_matched_ls = 0 )
		   	    %Beg
			    Csid_compose ^OUT(Csid_err_memo)
				"Second credit ID ", Csid_pref_corr_2id_rec, 
				" not in inserted credit party ", 
				Csid_pref_corr_rec, / ;
		            %End
	   		    Perform X900_ERROR_MEMO 
						   through X900_ERROR_MEMO_END
		    	    Set Success_is in Csid_push_error to TRUE
			END-IF
		    END-IF
		END-IF
	    END-IF                    
	    If (Failure_is in Csid_push_error )
	        IF (PUSHDOWN in Csid_do_pushdown  )
		    %ACE_IS Ent_c_adr_set connected giving Csid_conn_stat;
		    %ACE_IS Relget_adr_set connected giving Csid_conn2_stat;
		    If (Success_is in Csid_conn2_stat)
			%Beg
			BREAK: Csid_adr_set ;
        		Relget_adr_set EQUATE: Csid_adr_set(NOMOD) ;
			BREAK: Relget_adr_set ;
			%End
		    END-IF
		    If (Success_is in Csid_conn_stat)
			%Beg
			Ent_c_adr_set EQUATE: Relget_adr_set(NOMOD) ;
			BREAK: Ent_c_adr_set;
	                %End
		    ELSE
		        Move 0 to Rel_id of Relget_adr_set
		    END-IF
	            Perform C800_PUSH_CREDIT through C800_PUSH_CREDIT_END
		    If Success_is in Csid_push_error then
		        Perform A110_GOT_CREDIT through A110_GOT_CREDIT_END
		        Go to A100_MAIN_END
		    END-IF
		    If (Success_is in Csid_didansi_ws)
		        IF (csid_prm_secwir_ws = "Y")
		            If ((Bbk_secwir of BBK of Ent_credit_set NOT = "Y" )
			     AND (Ibk_secwir of IBK of Ent_credit_set NOT = "Y")
			     AND (Ib1_secwir of IB1 of Ent_credit_set 
								     NOT = "Y"))
		            THEN
%^ Si on pushed party requests a secondary wire.
			        Evaluate Csid_pushed_credit
			          WHEN 1
				    %Beg
			            Ent_credit_set.Ib1.Ib1_secwir = "Y" ;
	    		            Csid_compose ^OUT(Csid_info_memo)
				       "Secondary wire to IB1 set by AIN", / ;
			            %End
	    		            Perform X920_INFO_MEMO through 
							   X920_INFO_MEMO_END
				    Call "CUST_SECWIRE_SAVE"

			          WHEN 2
			            %Beg
			            Ent_credit_set.Ibk.Ibk_secwir = "Y" ;
	    		            Csid_compose ^OUT(Csid_info_memo)
				       "Secondary wire to IBK set by AIN", / ;
			            %End
	    		            Perform X920_INFO_MEMO through 
							     X920_INFO_MEMO_END
				    Call "CUST_SECWIRE_SAVE"

			          WHEN 3
			            %Beg
			            Ent_credit_set.Bbk.Bbk_secwir = "Y" ;
	    		            Csid_compose ^OUT(Csid_info_memo)
				   	"Secondary wire to BBK set by AIN", / ;
			            %End
	    		            Perform X920_INFO_MEMO through 
							     X920_INFO_MEMO_END
				    Call "CUST_SECWIRE_SAVE"

			          WHEN Other
                                    %Beg
	    		            Csid_compose ^OUT(Csid_err_memo)
 	       				"AIN cannot send secondary wire ",
					"to pushed-down credit party", / ;
			            %End
			            Perform X900_ERROR_MEMO through 
							    X900_ERROR_MEMO_END
	    		            Move ZERO to Cdt_not_suspect_ls
                                    Set Failure_is in Creditside_look_ls to true
		                END-EVALUATE
			    END-IF
			    Move SPACE to Csid_prm_secwir_ws
			ELSE
			    If (Csid_prm_secwir_ws = "N")
%^ Si on pushed party requests a secondary wire.
			        Evaluate Csid_pushed_credit
			          WHEN 1
				    %Beg
			            Ent_credit_set.Ib1.Ib1_secwir = "N" ;
	    		            Csid_compose ^OUT(Csid_info_memo)
				  "Secondary wire to IB1 suppressed by AIN", / ;
			            %End
	    		            Perform X920_INFO_MEMO through 
							   X920_INFO_MEMO_END
				    Call "CUST_SECWIRE_SAVE"

			          WHEN 2
			            %Beg
			            Ent_credit_set.Ibk.Ibk_secwir = "N" ;
	    		            Csid_compose ^OUT(Csid_info_memo)
				  "Secondary wire to IBK suppressed by AIN", / ;
			            %End
	    		            Perform X920_INFO_MEMO through 
							     X920_INFO_MEMO_END
				    Call "CUST_SECWIRE_SAVE"

			          WHEN 3
			            %Beg
			            Ent_credit_set.Bbk.Bbk_secwir = "N" ;
	    		            Csid_compose ^OUT(Csid_info_memo)
				  "Secondary wire to BBK suppressed by AIN", / ;
			            %End
	    		            Perform X920_INFO_MEMO through 
							     X920_INFO_MEMO_END
				    Call "CUST_SECWIRE_SAVE"

			          WHEN Other
                                    %Beg
	    		            Csid_compose ^OUT(Csid_err_memo)
 	       				"AIN cannot suppress secondary wire ",
					"to pushed-down credit party", / ;
			            %End
			            Perform X900_ERROR_MEMO through 
							    X900_ERROR_MEMO_END
	    		            Move ZERO to Cdt_not_suspect_ls
                                    Set Failure_is in Creditside_look_ls to true
		                END-EVALUATE
				Move SPACE to Csid_prm_secwir_ws
			    END-IF
			END-IF
		    END-IF
		    %Beg  BREAK: Relget_adr_set ;  %End
                    If (Success_is in Csid_conn2_stat )
		        %Beg
			Csid_adr_set EQUATE: Relget_adr_set(NOMOD) ;
			BREAK: Csid_adr_set ;
		        %End
		    ELSE
%^ We must repeat the lookup.
		    	Move SPACES to Csid_lookup_temp
	    	        %Beg  
	    		Csid_lookup_temp = Csid_pref_corr_rec.idkey ;  
	    	        %End
	    		Move "F" to Csid_lkup_pend_del
	    	        Call "ACCT_LOOKUP" using
		            by reference Idtype of Csid_pref_corr_rec
		            by reference Csid_lookup_temp
	                    by reference Csid_ovr
		            by reference Csid_ambig_ws 
		            by reference Csid_temp_multibank_ws
	        	    by reference Credit_currency_ls
			    by reference Csid_lkup_pend_del
		          RETURNING Csid_ret_stat
		    END-IF
		ELSE
* We are doing an overwrite, so just break the credit set.
		    %Beg  BREAK: Ent_c_adr_set ;  %End
		END-IF
	    END-IF
	    If (Failure_is in Csid_push_error)
		%^ Moved address copy down, perform after the ID's are loaded
		%^ Id's are required for the DETERM_RES_COUNTRY call
%^
		If (Success_is in Csid_ret_stat   )
		    OR (Relget_msgcode = Vmsg_dat_notonfile_wc )
	            THEN 
			%^  We actually did get a REL or AUX db hit set the bank
		        %Beg  Csid_id_bank_ws = Relget_adr_set.bnk_id ;  %End
		end-if
		If (Relget_return_key NOT = SPACES )
		        %Beg
		        Csid_parse ^IN(Relget_return_key), Csid_return_key, 
				^SPACE, / ;
		        %End
		ELSE
		        %Beg  Csid_return_key = Csid_acc_id_ws ;  %End
		END-IF	
		If (Csid_id_bank_ws = SPACES )
		        %Beg
			Csid_id_bank_ws = Ent_ftr_set.Loc_info.Bank ;
			%End
		END-IF
%^
		If (Csid_ovr NOT = " " )
		     AND (Relget_msgcode NOT = Vmsg_dat_notonfile_wc)
		     And (Failure_is in csid_on_us_bnk_code) %^ can be NOF with no error
							     %^ Continue if success
		THEN
		    If (Csid_ovr = "*" ) Then
		        %Beg
	                Csid_compose ^OUT(Csid_err_memo)
		    	        "NOF credit party preferred corr ",
			        Csid_pref_corr_rec, / ; 
		        Csid_parse ^IN(Csid_pref_corr_rec.Idkey)
			        Csid_id_bank_ws, ":", ^STRING, / ;
	                %End
		    ELSE
			If (Success_is in Csid_credit_pend_del)
		            %Beg
                	    Csid_compose ^OUT(Csid_err_memo)
			      "Preferred corr marked for deletion ", 
				Csid_pref_corr_rec,  / ;
			    %End
                	else
	                    %Beg
	                    Csid_compose ^OUT(Csid_err_memo)
		    		"Ambiguous credit party preferred corr ",
				Csid_pref_corr_rec, / ; 
	                    %End
			end-if
		    END-IF
	            Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
	            Set Failure_is in Creditside_look_ls to true
 		    Set Success_is in Csid_push_error to TRUE
		    If Csid_id_bank_ws = SPACES 
        	        %Beg
		        Csid_id_bank_ws = Ent_ftr_set.Loc_info.Bank ;
	                %End
		    END-IF
		    If (Failure_is in csid_on_us_bnk_code) Then
			%^ If this is an IBAN split, and the On US is nof,
			%^ leave the info
	                %Beg
	                Ent_credit_set (.Cdt_name1 = NULL,
			       	        .Cdt_name2 = NULL,
				        .Cdt_name3 = NULL,
				        .Cdt_name4 = NULL ) ;
		        %end
		    end-if
		    %beg
	            Ent_credit_set (.Cdt_typ 
				     (.Cdt_ovr    = Csid_ovr,
				      .Cdt_idtype = Csid_pref_corr_rec.Idtype,
				      .Cdt_id     = Csid_pref_corr_rec.Idkey ),
				    .Cdt_adr_bnk_id = Csid_id_bank_ws,
				    .Cdt_rel_id = <0>,
				    .Cdt_adr_set_ptr delete,
				    .flgs3.cdt_adr_ptr_ok = NULL) ;
                    BREAK: Relget_adr_set;
                    BREAK: Ent_c_adr_set;
		    Csid_pref_corr_rec = NULL ;
	            %End
* clear all the other stuff left over from previous on-file address
	            Call "ACCTSUB_CDT_NOF"
	        ELSE
%^ It's a hit.
		    If (Csid_ovr = SPACE )	%^ ON REL  pref corr 
		        If (Relget_return_key NOT = SPACES )
		            %Beg
		            Csid_parse ^IN(Relget_return_key)
				 Csid_pref_corr_rec.idkey, ^SPACE, / ;
		            %End
		        END-IF
			%Beg
		        Ent_credit_set.Cdt_adr_bnk_id = Relget_adr_set.bnk_id ;
	                Relget_adr_set EQUATE: Ent_c_adr_set(NOMOD) ;
                        Ent_credit_set( .Cdt_rel_id = Ent_c_adr_set.Rel_id,
                                        .Cdt_adr_set_ptr POINT: Ent_c_adr_set,
					.flgs3.cdt_adr_ptr_ok = "T");
		        %End
		    ELSE
			%^
                      	If Csid_id_bank_ws = SPACES
			Then
				%Beg
		                       	Csid_id_bank_ws = Ent_ftr_set.Loc_info.Bank ;
               		        %End
                        END-IF
			%^
			%^ clear all the other stuff left over from previous on-file address
			%^
	                Call "ACCTSUB_CDT_NOF"
			%^ Need to ensure that this is on AUX, what we have here is
			%^ a NOF on-us DDA being substituted in
			If (Success_is in csid_on_us_bnk_code) Then %^ can be NOF with no error
							       	    %^ Continue if success
			    %beg
		                Ent_credit_set(.Cdt_adr_bnk_id = Csid_id_bank_ws,
					       .Cdt_rel_id = <0>,
					       .Cdt_adr_set_ptr delete,	
					       .flgs3.cdt_adr_ptr_ok = NULL) ;
       		                BREAK: Relget_adr_set;
       	        	        BREAK: Ent_c_adr_set;
	                    %End
			Else
				%^ Add setting of Bank AUX should always be set to owning bank
				%^
				%^ ON AUX pref corr
				%Beg
					Csid_id_bank_ws = Ent_ftr_set.Loc_info.Bank;
					%^
					Ent_credit_set(.Cdt_adr_bnk_id = Csid_id_bank_ws,
				       		       .Cdt_rel_id = <0>,
                                       		       .Cdt_adr_set_ptr POINT: Relget_adr_set,
				       		       .flgs3.cdt_adr_ptr_ok = "T");
                           		%^ NEEDEDto change party BREAK: Relget_adr_set;
                           		%^ still required.BREAK: Ent_c_adr_set;
			   		BREAK: Ent_c_acc_set;
					BREAK: Ent_c_acc_rel_reg;
	                	%End
			end-if
			%^ acctsub_cdt_nof call was here
		    END-IF
		    IF (Success_is in Csid_didansi_ws)
		        %Beg
		        Csid_compose ^OUT(Csid_info_memo)
				"Credit party ",
				Ent_credit_set.cdt_typ,
				Csid_do_pushdown (^oneof(" substituted ", 
						      " inserted ")),
				Csid_pref_corr_rec.Idtype,"/",
				Csid_pref_corr_rec.Idkey, / ;
		        %End
		        Perform X920_INFO_MEMO through X920_INFO_MEMO_END
		    END-IF

		    Set Failure_is in Csid_didansi_ws to TRUE
 	            %Beg
 	            Ent_credit_set(.Cdt_typ 
				    (.Cdt_ovr    = Csid_ovr,
 				     .Cdt_idtype = Csid_pref_corr_rec.Idtype,
				     .Cdt_id     = Csid_pref_corr_rec.Idkey));
		   %End
		END-IF
	        If (Csid_ovr = SPACE )
	           OR ( ( Csid_ovr = "*" )
		      AND (Relget_msgcode = Vmsg_dat_notonfile_wc ) )
	        THEN
		    %^ We actually did get a REL or AUX db hit, so let's copy the address.
	            Perform C720_COPY_ADDRESS through C720_COPY_ADDRESS_END
	        END-IF
		%Beg  Csid_pref_corr_rec = NULL ;  %End
		Perform X980_CHANGE_CREDIT thru X980_CHANGE_CREDIT_END
		Perform B400_SET_ADVICE through B400_SET_ADVICE_END
	        Perform B420_GET_NEWPARTY through B420_GET_NEWPARTY_END
		If (Failure_is in Creditside_look_ls   )
		    OR (Success_is in Csid_cor_found   )
	    	THEN
		    Perform A110_GOT_CREDIT through A110_GOT_CREDIT_END
		    Go to A100_MAIN_END
		END-IF
	    END-IF		    
	END-PERFORM.

	If Success_is in csid_force_push_exit
	Then
		Set Failure_is in csid_push_error to True
		Set Failure_is in Csid_force_push_exit to True
	end-if.

                                           
	PERFORM A110_GOT_CREDIT through A110_GOT_CREDIT_END.
A100_MAIN_END.
	
	%^ regardless of lookup status, set cdt_not_suspect to failure
	%^ if we haven't had a successfull CHANNEL_DETERMINATION call
	If (Failure_is in Csid_chdet_stat_ws) Then
		Set Failure_is in creditside_look_ls to True
		Move 0 to Cdt_not_Suspect_ls
	end-if.

        %EXIT PROGRAM.


A110_GOT_CREDIT.
%^
%^ Finalize IDtype
%^
	If  ((Failure_blocking_is in Csid_val_iban_ret) Or
      	     (Failure_warning_is in Csid_val_iban_ret) ) And
	     second_cdt_id_ls NOT = spaces And Cdt_idtype of Ent_credit_set = "S"
	Then	%^ Error tagged, stack the ID's now
		%^ We had a Bad BBAN and a good BIC, and no rules changing the party,
		%^ Present the Bad BBAN in RPR		129512
		If Cdt_idtype of Ent_credit_set = "S" And
		Csid_2aid_id Not = Spaces and Csid_2aid_idt = "D" or "G" or "F" or "V" or " "
		Then
			%beg
				Ent_credit_set.cdt_typ( .Cdt_idtype = Csid_2aid_idt,
							.cdt_id = csid_2aid_id);
			%end
		End-if
	Else
		If Success_is in Dual_rpr_id 
		Then
		     	%^ 2 Id's in the Credit part is a failure state, Flag it
			If csid_struct_acct_ws = "Y"
			Then
			     	If Success_is in Csid_val_iban_ret 
			     	Then
				     %beg	
					Csid_compose ^OUT(Csid_err_memo)
				       	     "Valid BBAN format, no Bank Code entry Found, cannot determine routing",/;	
			             %End
				     Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
				     Move 0 to Cdt_not_suspect_ls
			     	end-if
				If Failure_ignore_is in Csid_val_iban_ret
				Then	%^ Need to make this a failure case.
					Move 0 to Cdt_not_suspect_ls
				end-if
			End-if
		Else
			Perform B405_SET_IDTYPE_FROM_CHAN Thru
				B405_SET_IDTYPE_FROM_CHAN_END
		End-if
	End-if.

* Now let's see if we have any codewords we care about
	%ACE_IS Ent_codeword_seq connected giving Csid_conn_stat;
	If (Failure_is in Csid_conn_stat)
* Try hooking up just in case.
	    %Beg  
	    Ent_msg_union (NOTRAP,
			   .codeword_seq CONN: Ent_codeword_seq (NOMOD) ) ;
	    Ent_msg_union(ETRAP) ;
	    %End
	    %ACE_IS Ent_codeword_seq connected giving Csid_conn_stat;
	END-IF.
	If (Success_is in Csid_conn_stat)
	   AND (Failure_is in Csid_cor_found   )
	THEN
	   %Beg  FIRST: Ent_codeword_seq ;  %End
	   Perform until (SEQ_END_IS in Ent_codeword_seq_cursor)

	       Evaluate True

		   When Ent_codeword_seq = "FX" 
		        If (Fx_found of Si_flgs of Ent_ftr_set NOT = "Y" )
		     	    PERFORM B480_FX_ACCOUNT THRU B480_FX_ACCOUNT_END
                        END-IF
		 %^ OBSELETE
		 %^  When Ent_codeword_seq = "CONFIRM" 


		   When Ent_codeword_seq = "CHEQUE"
		     Set Success_is in Csid_chk_codeword to true

		   When Ent_codeword_seq = "PREVICE"
		     Set Success_is in Csid_pre_codeword to true

	       End-evaluate

	       %Beg NEXT: Ent_Codeword_seq; %End
	   End-perform
	End-if.

	If tran_type of Ent_ftr_set = "DDR"
	Then
		%^ flip the SOURCE and ADV_TYP for the duration of the call
		%beg
			Temp_adv_hold_ws = Ent_credit_set.cdt_adv_typ;
			Ent_credit_set.cdt_adv_typ = Ent_ftr_set.src_code;
			Ent_ftr_set.src_code = temp_adv_hold_ws;
		%end
		Move dbt_internal_ls to dbt_int_save_ws
		Move 1 to dbt_internal_ls %^ Initial call
	End-if

* We have either pushed down through all preferred correspondents or had
* an error doing so.
* Now finish any debit SI lookups.
	Call "DEBIT_LOOK_ACCOUNT" USING
            By Reference Init_debit_currency_ls
	    By Reference Debit_currency_ls
	    By Reference Message_amount_ls
            By Reference Message_currency_ls,
	    By Reference Debit_account_ls
	    By Reference Is_payment_ls
	    By Reference Xbank_account_ok_ls
	    By Reference Dbt_acc_type_ls
	    By Reference Resume_SIs_ls
	    By Reference Is_rptv_lookup_ls
	    By Reference Nochange_bank_ls
	    By Reference Lock_dbt_party_ls
	    By Reference Debit_fee_key_ls
	    By Reference Dbt_internal_ls
	    By Reference Dbt_currency_found_ls
	    By Reference Dbt_not_suspect_ls
	    By Reference Msg_bank_changed_ls
	    By Reference Dbt_err_memo_count_ls
	    By Reference Csid_error_memo
	    By Reference Csid_error_memo_length
	  RETURNING Debit_status_ls.

	If tran_type of Ent_ftr_set = "DDR"
	Then
		%^ flip the SOURCE and ADV_TYP Back
		%beg
			Ent_ftr_set.src_code = Ent_credit_set.cdt_adv_typ;
			Ent_credit_set.cdt_adv_typ = Temp_adv_hold_ws;
		%end
		Move dbt_int_save_ws to dbt_internal_ls
	End-if

	If (Msg_bank_changed_ls NOT = 0 )
	    %ACE_IS Ent_c_adr_set connected giving Csid_conn_stat;
	    %Beg
	    Csid_id_bank_ws = NULL ;
            Csid_parse ^IN(Ent_credit_set.cdt_typ.cdt_id)
		Csid_id_bank_ws, ":", Csid_party_id, ^SPACE, / ;
            %End
            If (Failure_is in Csid_parse_status   )
            THEN
	        If (Success_is in Csid_conn_stat)
                and (Bnk_id of Ent_c_adr_set NOT =
					      Bank of Loc_info of Ent_ftr_set )
		THEN
%^ It's on file in the previous implicit credit bank.  Make it explicit.
		    %Beg    
		    Csid_clip_compose ^OUT(Csid_party_id)
			Ent_credit_set.cdt_typ.cdt_id, / ;
		    Csid_compose ^OUT(Ent_credit_set.cdt_typ.cdt_id)
                        Ent_c_adr_set.Bnk_id, ":", Csid_party_id, / ;
		    %End
		END-IF
	    ELSE
		If (Csid_id_bank_ws = Bank of Loc_info of Ent_ftr_set )
%^ Explicit bank is same as owning bank.  Make it implicit.
		    %Beg  Ent_credit_set.cdt_typ.cdt_id = Csid_party_id ;  %End
		END-IF
	    END-IF
	END-IF.

	If Failure_is in Csid_cor_found  
	    If Dbt_rel_id of Ent_debit_set not = 0 
		Perform B500_DEBIT_SIS thru B500_DEBIT_SIS_END
		%^ Reconnect Relget_adr_set to the Ent_c_adr_set if there 
		%^ is one.  Later lookups will need it.
	        %Beg 
		Break: Relget_adr_set;
		%End
		%ACE_IS Ent_c_adr_set connected giving Csid_conn_stat;
		If (Success_is in Csid_conn_stat) then
	            %Beg Ent_c_adr_set EQUATE: Relget_adr_set(NOMOD); %End
		end-if
	    ELSE
	         If Success_is in Csid_pre_codeword    And
	   	    Not(Is_payment_ls = 0) %^ no point if not payment 134138
		then
	            %Beg	      
	            Csid_compose ^OUT(Csid_err_memo)
		        "PREVICE codeword but no pre SI for "
	    	        Ent_debit_set.Dbt_typ.Dbt_idtype,"/",
	    	        Ent_debit_set.Dbt_typ.Dbt_id, / ; 
	             %End
	             Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END     
		     Set NO_PREVICE_SI in Csid_previce_si_ind to TRUE %^SPR29440
		     Move ZERO to cdt_not_suspect_ls		%^SPR29440
	             Set Failure_is in Creditside_look_ls to true
	         END-IF
            END-IF
	END-IF.

	Move SPACES to Cdt_currency_found_ls.
	If (Cdt_ovr of Cdt_typ of Ent_credit_set NOT = SPACE ) And
 	   (cdt_adr_ptr_ok of flgs3 of Ent_credit_set NOT = "T") %^ semi onfile address 
	Then
* NOF or ambiguous credit party.
	    If (Cdt_rel_id of Ent_credit_set NOT = 0 )
		%Beg
		Ent_credit_set( .Cdt_shnam         = NULL ,
				.Cdt_name1         = NULL ,
				.Cdt_name2         = NULL ,
				.Cdt_name3         = NULL ,
				.Cdt_name4         = NULL 
			      ) ;
                BREAK: Relget_adr_set;
                BREAK: Ent_c_adr_set;
		%End
* clear all the other stuff left over from previous on-file address
	        Call "ACCTSUB_CDT_NOF"
	        MOVE "N" to Cdt_comm_charge_ws                             
	        MOVE "N" to Cdt_cbl_charge_ws
	    END-IF
	ELSE
	    If (Cdt_rel_id of Ent_credit_set Not = 0) And		%^ Don't set_address of AUX item
	       (cdt_adr_ptr_ok of flgs3 of Ent_credit_set = "T")

%^ #119765 Add additional checks before deciding to call B320_set_address
%^		AND (Cdt_account of Ent_credit_set = SPACES )
%^              AND ( (Cdt_adv_typ of Ent_credit_set NOT = "FED" )
%^		AND (ABA_id of Ent_c_adr_set NOT = SPACES ) )
%^		AND (Cdt_adv_typ of Ent_credit_set NOT = "CHK" AND "CHQ")
%^ #121711 If Ent_c_adr_set is connected, then do the Perform.

	    Then
            	%Ace_is Ent_c_adr_set connected giving Csid_conn_stat;
              	If Success_Is in Csid_conn_stat
		Then
		    Perform B320_SET_ADDRESS through B320_SET_ADDRESS_END
		End-if
	    End-if
	END-IF.

%^ Set up credit bank.
	If (Csid_acc_bank_ws = SPACES )
	    %Beg  BREAK: Csid_bnk_union;  %End
	    If (Cdt_adr_bnk_id of Ent_credit_set = Bnk_id of Menu_bnk_union )
	        %Beg  
	        Menu_bnk_union EQUATE: Csid_bnk_union(NOMOD) ;
		Csid_acc_bank_ws = Csid_bnk_union.bnk_id ;
		%End
	    ELSE
	        If (Cdt_adr_bnk_id of Ent_credit_set =
						    Bnk_id of Men2_bnk_union )
		   AND ( Bnk_id of Men2_bnk_union not = spaces)
		    %ace_is Men2_bnk_union connected;
		    if failure_is in ace_status_wf	%^ not connected yet
		        %beg
			Bnk_index( Key = 
			    Ent_credit_set.Cdt_adr_bnk_id,
			    ^search CONN: Men2_bnk_union(NOMOD) );
			%end
		    end-if
	            %Beg  
		    Men2_bnk_union EQUATE: Csid_bnk_union(NOMOD) ;  
		    Csid_acc_bank_ws = Csid_bnk_union.bnk_id ;
		    %End
	        ELSE
		    %Beg
		    SEARCH: Bnk_index (Key = Ent_credit_set.Cdt_adr_bnk_id ) ;
		    %End
		    If Success_is in Bnk_index_status  
		        %Beg  
			Bnk_index CONN: Csid_bnk_union(NOMOD) ;  
		        Csid_acc_bank_ws = Csid_bnk_union.bnk_id ;
			%End
		    END-IF
	        END-IF
	    END-IF
	END-IF.		


        Move spaces to Csid_dupe_acc_ws.
	IF (Cdt_idtype of Cdt_typ of Ent_credit_set = "A" )
	     AND (Cdt_adv_typ of Ent_credit_set = "FED" )
	THEN
* Don't need accounting info
            Set Failure_is in Csid_musthave_acct to true
	    Move "USD" to Cdt_currency_found_ls
	END-IF.

	If (Cdt_adv_typ of Ent_credit_set = "CHK" OR "CHQ")
           Set Failure_is in Csid_musthave_acct to true
    	   If (csid_chan_acc_ws Not = Spaces)	Then
		%^ Channel Determination provided an account number use, it
		%beg
		   Ent_credit_set.cdt_adr_bnk_id = Csid_chan_acc_ws.idbank;
		   Ent_credit_set.cdt_account(.idbank = Csid_chan_acc_ws.idbank,
					      .idtype = Csid_chan_acc_ws.idtype,
					      .idkey  = Csid_chan_acc_ws.idkey ) ;
		%end
		%^ Need to get a better currency, in Europe,
		%^ multiple currency checks can be
		%^ cut from 1 bank derived GL from channel determination should be used.
		%^
   	 	%ace_conn_root_q Rel_acc_index ;
    		%Beg
	    		BREAK: Ent_acc_set ;
	    		BREAK: Ent_acc_rel_reg ;
    			Rel_acc_index ^SEARCH (FORWARD, EQL,
			     .Rel_name_key(.Idbank = ent_credit_set.cdt_account.Idbank, 
			 	    .Idtype = ent_credit_set.cdt_account.Idtype,
			 	    .Idkey (.Idacc = ent_credit_set.cdt_account.Idkey,
				 	    .Idadr = NULL,
				 	    .Idpad = NULL ) ),
			 CONN: Ent_acc_set(NOMOD)) ;
		%end
		If (Success_is in Ent_acc_set_status) THen
		    Move Currency_id of Ent_acc_set to Cdt_currency_found_ls
   	            If (Cdt_currency_found_ls = SPACES ) Then
			 If Cdt_adr_bnk_id of Ent_credit_set =
					Bnk_id of Menu_bnk_union
			       Move Base_currency_id of Menu_bnk_union to 
						  Cdt_currency_found_ls
		         else
			    %Beg
	        		 BREAK: Csid_bnk_union ;
	   			 SEARCH: Bnk_index 
		 	  		(Key = Ent_credit_set.Cdt_adr_bnk_id ) ;
			    %end
	        	    If Failure_is in Bnk_index_status  
	            		Move SPACES to Cdt_currency_found_ls
	        	    ELSE
	            		%Beg  Bnk_index CONN: Csid_bnk_union (NOMOD) ; %End
	            		Move Base_currency_id of Csid_bnk_union to 
						    Cdt_currency_found_ls
	        	    END-IF
            	    	 end-if
		    end-if
		    %beg Break: ent_acc_set; %end
		end-if
	    else
		    Move Base_currency_id of Csid_bnk_union to
			 Cdt_currency_found_ls
	    end-if
	END-IF.

	%Beg  BREAK: Ent_c_acc_set ;
	      BREAK: Ent_c_acc_rel_reg;
	%End
%^
	    
	If (Csid_know_acc_id = SPACES )
* We have not been passed a credit account, so we should try to find one.
	    If (Is_payment_ls = 0 )
		OR (Failure_is in Csid_musthave_acct   )
	    THEN
		GO TO A110_GOT_CREDIT_CLEANUP

	    END-IF

	    IF ((Cdt_ovr of Cdt_typ of Ent_credit_set NOT = SPACE )
		OR (Cdt_rel_id of Ent_credit_set = 0 ))
	    THEN
		If( (Cdt_recon_ref of Ent_credit_set NOT = SPACES )
		  OR (Cdt_recon_ref_length of Ent_credit_set_lengths NOT = 0))
		AND (HostGet_calls_vld of Menu_cfg Not = "T") %^ probable VLD return Value leave it
		THEN
		    %Beg  Ent_credit_set.Cdt_recon_ref = NULL;  %End
		END-IF
                Call "SET_NOF_CDT_ACCOUNT"
		GO TO A110_GOT_CREDIT_CLEANUP
	    END-IF

	    If (Failure_is in csid_chdet_stat_ws) and
	      ((RTGS_IS in Endpoint_type of Rchan_channel_set) or
	       (clrhouse_is in Endpoint_type of Rchan_channel_set) OR %^ 122078  Not account if no channel...
	       (Cdt_adv_typ of Ent_credit_set = Spaces) Or 	
		   (Cdt_adv_flg of Ent_ftr_set = "Y") )
	    Then
		%^ We cannot get a valid Account at this point,
		%^ Take an Exit
	        Set Failure_is in Csid_musthave_acct to true
		Go To  A110_GOT_CREDIT_CLEANUP
	    End-if

%^ We have a credit address, so let's go look up an account.
            If (Credit_currency_ls NOT = SPACES )
%^ Search currency was set by caller
		Perform B330_PERFORM_FIND_ACC  through B330_PERFORM_FIND_ACC_END
	    ELSE
		If Message_currency_ls = SPACES 
	            Perform B330_PERFORM_FIND_ACC     through
                            B330_PERFORM_FIND_ACC_END
		ELSE
%^ Message currency is set but debit currency was not.
		    If (Cdt_idtype of Cdt_typ of Ent_credit_set =
					      "D" OR "V" OR "G" OR "P" OR "F" )
	                Perform B330_PERFORM_FIND_ACC     through
                                B330_PERFORM_FIND_ACC_END
		    ELSE
%^ Not an account identifier
			If (Fx_ena of Menu_cfg = LOW-VALUES )
%^ Baseline currency environment
			    If (Dbt_idtype of Dbt_typ of Ent_debit_set =
						     "D" OR "V" OR "G" OR "P" )
				Move Message_currency_ls to Csid_currency_ws
                            ELSE
				If (Dbt_idtype of Dbt_typ of Ent_debit_set =
									  "F" )
				  Move Base_currency_id of Csid_bnk_union to
								Csid_currency_ws
				  Move SPACES to Csid_acc_curr_ws
				END-IF
			    END-IF
	                    Perform B330_PERFORM_FIND_ACC     through
                                    B330_PERFORM_FIND_ACC_END
                        ELSE
%^ Cross-currency environment.  Try the message currency.
			    Move Message_currency_ls to Csid_currency_ws
	                    Perform B330_PERFORM_FIND_ACC     through
                                    B330_PERFORM_FIND_ACC_END
                            If (Csid_know_acc_id = SPACES)
                            then  
%^ That didn't work.  Try no preference and defaulting.
                                 Move SPACES to Csid_currency_ws
	                         Perform B330_PERFORM_FIND_ACC     through
                                             B330_PERFORM_FIND_ACC_END
                             END-IF
			END-IF
		    END-IF			    	
		END-IF
	    END-IF
        ELSE
%^ We were passed a credit account
	    If (Credit_currency_ls NOT = SPACES )
		%ace_conn_root_q Rel_acc_index ;
		%Beg
		SEARCH: Rel_acc_index (FORWARD, GEQ, .Rel_name_key 
				(.Idbank        = Csid_know_acc_id.Idbank,
				 .Idtype        = Csid_know_acc_id.Idtype,
				 .Idkey (.Idacc = Csid_know_acc_id.Idkey,
				         .Idadr = NULL,
			       		 .Idpad = NULL ) ) ) ;
                %End
	        If (Success_is in Rel_acc_index_status   )
	           AND (Idbank of Rel_name_key of Rel_acc_index =
						Idbank of Csid_know_acc_id )
	           AND (Idtype of Rel_name_key of Rel_acc_index =
						Idtype of Csid_know_acc_id )
	           AND (Idacc of Idkey of Rel_name_key of Rel_acc_index =
						Idkey of Csid_know_acc_id )
	        THEN
		    %Beg  Rel_acc_index CONN: Ent_c_acc_set(
				REG:  Ent_c_acc_rel_reg (NOMOD));  %End
 		 	 If (Fx_ena of Menu_cfg = LOW-VALUES) Then
			    If (Currency_id of Ent_c_acc_set = Spaces) Then
			       If Not(Credit_currency_ls = Base_currency_id of Csid_bnk_union)
			       Then
					%^ Mismatch.
				        %Beg
				        Csid_compose ^OUT(Csid_err_memo)
					    "Requested credit account ", Csid_know_acc_id, 
					    " not set; not in currency ", Csid_currency_ws, / ;
			        	%End
			        	Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
					Move SPACES to Csid_know_acc_id
					%Beg  BREAK: Ent_c_acc_set ;
					      BREAK: Ent_c_acc_rel_reg;
					%End
				end-if
			     end-if
			 Else
			    If (Currency_id of Ent_c_acc_set NOT = Credit_currency_ls )
				%^ Mismatch.
			        %Beg
			        Csid_compose ^OUT(Csid_err_memo)
				    "Requested credit account ", Csid_know_acc_id, 
				    " not set; not in currency ", Csid_currency_ws, / ;
		        	%End
		        	Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
				Move SPACES to Csid_know_acc_id
				%Beg  BREAK: Ent_c_acc_set ; 
				      BREAK: Ent_c_acc_rel_reg;
				%End
			    END-IF
			 end-if
		END-IF
            END-IF
	END-IF.
	If Csid_dupe_acc_ws NOT = SPACES 
	   AND Csid_ambig_ws = "T"
	THEN
%^  We just take the first one we found.
	    %Beg  Csid_dupe_acc_ws = NULL ;  %End
	END-IF.

	If (Csid_know_acc_id = SPACES )
* Still couldn't resolve credit account.
	    If (Is_payment_ls = 0 )
	       OR (Failure_is in Csid_musthave_acct   ) 
	    THEN
		CONTINUE
	    ELSE
		If (Cdt_account of Ent_credit_set NOT = SPACES )
		   %Beg
                   Ent_credit_set (
                            .cdt_account            = NULL,
                            .cdt_acc_prod_codes     = NULL,
                            .cdt_acc_class          = NULL,
                            .flgs.cdt_hold_flg 	    = NULL );
		    %End
		END-IF
		If (Cdt_ovr of Cdt_typ of Ent_credit_set NOT = "?" )
		    %Beg  Ent_credit_set.cdt_typ.cdt_ovr = "?" ;  %End
		END-IF
		%Beg  
		BREAK: Ent_c_acc_set;
		BREAK: Ent_c_acc_rel_reg;
                Csid_compose ^OUT(Csid_err_memo)
			    "Not Str Thru: Could not find credit account for ",
				   Ent_credit_set.cdt_typ, / ;
		%End
	        Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
		Move ZERO to Cdt_not_suspect_ls
	    END-IF
	    GO TO A110_GOT_CREDIT_CLEANUP
	END-IF.

	If (Csid_dupe_acc_ws NOT = SPACES )
*  Ambiguous.
	    If (Is_payment_ls NOT = 0 )
		If (Cdt_account of Ent_credit_set NOT = SPACES )
		    %Beg
                    Ent_credit_set (
                                .cdt_account            = NULL,
                                .cdt_acc_prod_codes     = NULL,
                                .cdt_acc_class          = NULL,
                                .flgs.cdt_hold_flg 	= NULL );
		    %End
		END-IF
		If (Cdt_ovr of Cdt_typ of Ent_credit_set NOT = "?" )
		    %Beg  Ent_credit_set.cdt_typ.cdt_ovr = "?" ;  %End
		END-IF
		%Beg
		BREAK: Ent_c_acc_set;
		BREAK: Ent_c_acc_rel_reg;
                Csid_compose ^OUT(Csid_err_memo)
			       "Not Str Thru: Found duplicate credit account ", 
				Csid_know_acc_id, / ;
		%End
		Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
		Move ZERO to Cdt_not_suspect_ls
	    END-IF
	GO TO A110_GOT_CREDIT_CLEANUP
	END-IF.	

	Perform B360_SET_ACCOUNT through B360_SET_ACCOUNT_END.

%^
%^ At this point, we have a Channel and a good Account, check for the Bilat
%^
	Call "CUST_BILAT_ACCT".


A110_GOT_CREDIT_CLEANUP.

	%^  Ensure that we fill in res_country if possible

	If cdt_res_country of ent_credit_set = spaces
	    Initialize Csid_risk_country_ws, Csid_country_code_ws
	    If rel_id of relget_adr_set not = 0
		  %Ace_is relget_adr_set connected;
		  If success_is in ace_status_wf
	            Move risk_country of relget_adr_set to Csid_risk_country_ws
	            Move country_code of relget_adr_set to Csid_country_code_ws
		  end-if
	    end-if
	    Call "DETERM_RES_COUNTRY" using
	       by content "CDT"
	       by reference cdt_idtype of Ent_credit_set
	       by reference cdt_id of Ent_credit_set
	       by reference cdt_id_length of Ent_credit_set_lengths
	       by reference Csid_risk_country_ws
	       by reference Csid_country_code_ws
	       by reference cdt_res_country of Ent_credit_set
	       by reference Csid_res_country_ws
	    If Csid_res_country_ws not = spaces
	        %Beg Ent_credit_set.cdt_res_country = Csid_res_country_ws; %end
	    end-if
	end-if.
			
*  Now that any pushdowns have occurred, we go through the lower creditside 
*    parties.
	Call "SET_CREDIT_ADVICE" USING
	    By reference Credit_account_ls
	    By reference Is_rptv_lookup_ls
	  RETURNING Csid_ret_stat.

	%^ If this is a not on file account, check to see if any unit
	%^ confirmations need to be generated.
	If Cdt_rel_id of Ent_credit_set = 0 then
		Call "SET_CREDIT_UNIT_CNF"
	end-if.

	If (Success_is in Csid_do_rolldown)
%^Set up second credit party information for rolldown
	    PERFORM B460_SET_2ND_AGAIN through B460_SET_2ND_AGAIN_END
	END-IF.

%^ If CHIPS qualification is requested, which is a U.S.-specific phenomenon, 
%^   check for specific "CHP" credit advice method
	If (Do_chips_qualif_ls NOT = 0 )
	   AND (Cdt_ovr of Cdt_typ of Ent_credit_set = SPACE )
	   AND (Cdt_adv_typ of Ent_credit_set = "CHP")
	THEN
	    Set Success_is in Csid_try_chips to TRUE
	ELSE
	    Set Failure_is in Csid_try_chips to TRUE
	END-IF.

%^
%^ 	Call now to clear/set the override 
%^
	Call "CUST_CHP_UNQ_PASS"  using
		By Reference 	Unq_chips_overide.

  
	If (Ib1_id of Ib1 of Ent_credit_set NOT = SPACES )
	  OR ( (Ib1_name1_length of Ent_credit_set_lengths NOT = 0 ) 
	     AND (Ib1_name1 of Ent_credit_set NOT = SPACES ) )
	  AND ( (Success_is in Csid_try_chips)
	     OR (Csid_pushed_credit NOT = 1 ) )
	THEN
	    PERFORM B260_IB1 through B260_IB1_END
	END-IF.


	If (Ibk_id of Ibk of Ent_credit_set NOT = SPACES )
	  OR ( (Ibk_name1_length of Ent_credit_set_lengths NOT = 0 ) 
	     AND (Ibk_name1 of Ent_credit_set NOT = SPACES ) )
	  AND ( (Success_is in Csid_try_chips)
	     OR (Csid_pushed_credit NOT = 2 ) )
	THEN
	    PERFORM B240_IBK through B240_IBK_END
	END-IF.

	If (Bbk_id of Bbk of Ent_credit_set NOT = SPACES )
	  OR ( (Bbk_name1_length of Ent_credit_set_lengths NOT = 0 ) 
	        AND (Bbk_name1 of Ent_credit_set NOT = SPACES ) )
	  AND ( (Success_is in Csid_try_chips)
	     OR (Csid_pushed_credit NOT = 3 ) )
	THEN
	    PERFORM B220_BBK through B220_BBK_END
            %^ If the secondary wire flag has a chance of being defaulted
            %^   to "Y", then look up the BBK address.
	    If date_time of Cdt_value_date of Ent_credit_set NOT = 0 Then
		%beg tmp_value_date_ws =
		   	Ent_credit_set.cdt_value_date.date_time;
		%end
	    else
		%beg tmp_value_date_ws = Null; %end
	    end-if
	    %^
            If (Def_secwir_if_pre_spl of Menu_cfg = "Y")
               AND (Bbk_rel_id of Ent_credit_set = 0)
               AND (Dbt_ps_elig_flg of Ent_debit_set = "P" or "S")
               AND (Bbk_idtype of Ent_credit_set not = "S")
               AND (tmp_value_date_ws > Menu_date_ws)
            %^  AND (Value_date of Ent_ftr_set > Menu_date_ws)
               AND ( (Bbk_id of ent_credit_set not = spaces) 
		     OR (Bbk_name1 of ent_credit_set not = spaces))
               AND (Bbk_secwir of ent_credit_set = SPACE)
               AND (Ib1_secwir of ent_credit_set not = "Y")
               AND (Ibk_secwir of ent_credit_set not = "Y")
	    THEN
                Perform C650_LOOKUP_BBK_ADDRESS thru 
			C650_LOOKUP_BBK_ADDRESS_end
            END-IF
	END-IF.
%^
%^
%^ Call SECWIRE_EVAL and react accordingly
%^
	If (bbk_id of Ent_credit_set Not = Spaces and	%^ Y will be forced
	    Tran_type of Ent_ftr_set = csid_col_tran_type_ws And
	    csid_col_tran_type_ws NOT = spaces)
	    %^ This is a Collection, skip SECWIRE_EVAL, Force Y to BBK
	    %beg
		 Ent_credit_set.bbk.bbk_secwir = "Y";
		 Ent_credit_set.bnp_bnk_flg = "Y";
	    %end
            Perform C650_LOOKUP_BBK_ADDRESS thru
                    C650_LOOKUP_BBK_ADDRESS_end

	    If  (Bnp_id of Bnp of Ent_credit_set = SPACES ) AND
	        ( (Bnp_name1_length of Ent_credit_set_lengths = 0 ) And
	         (Bnp_name1 of Ent_credit_set = SPACES ) )
	    Then
		%^ If the BNP is blank at this point, copy in the current BBK
		Perform C750_BBK_TO_BNP thru
			C750_BBK_TO_BNP_END
	    End-if
	Else
	    %^ ALL other items need to be evaulated
	    Call "SECWIRE_EVAL" using
	    	by content "MAP"
	    	by reference Cdt_currency_found_ls
	End-if.


%^ Now see if we need to do some more work

        If (Ib1_secwir of Ent_credit_set = "Y" )
	   AND (Routexcp_edit of Menu_cfg = "T" )
	THEN
* Must check for place to send secondary wire.
	    Move SPACES to Csid_id_ws	
            %Beg  Csid_temp2_vstr = NULL ;  %End
            If (Ib1_rel_id of Ent_credit_set = 0 )
                AND (Ib1_idtype of Ib1 of Ent_credit_set NOT = "S" )
            THEN
* Removed overflow from compose - obsolete
                %Beg
                Csid_compose ^OUT(Csid_temp1_vstr)
                                Ent_credit_set.Ib1.Ib1_id, / ;
                Csid_parse ^IN(Csid_temp1_vstr)
                                ^STRING, "/BC", Csid_temp2_vstr,
                                ^ONEOF ( ("/", ^STRING, / ),
                                         (/) ) ;
                %End
                If (Failure_is in Csid_parse_status   )
                    %Beg
                    Csid_parse ^IN(Csid_temp1_vstr),
                                ^STRING, "/(BC", Csid_temp2_vstr,
                                ^ONEOF ( ("/", ^STRING, / ),
                                         (")", ^STRING, / ),
                                         (/) ) ;
                    %End
                    If (Failure_is in Csid_parse_status   )
                        %Beg  Csid_temp2_vstr = NULL ;  %End
                    END-IF
                END-IF
            END-IF
            If (Csid_temp2_vstr_length NOT = 0 )
                %Beg
                Csid_id_ws = Csid_temp2_vstr ;
                Csid_idtype_ws = "S" ;
                %End
            ELSE
                %Beg
                Csid_parse ^IN(Ent_credit_set.Ib1.Ib1_id)
                        Csid_id_ws, ^ONEOF ( ("/", ^STRING, / ),
                                             (/) ) ;
                Csid_idtype_ws = Ent_credit_set.Ib1.Ib1_idtype ;
                %End
            END-IF
            %Beg  BREAK: Relget_adr_set ;  %End
	    Initialize Relget_adr_set
            If (Ib1_rel_id of Ent_credit_set NOT = 0 ) Or
		Ib1_adr_ptr_ok of flgs3 of Ent_credit_set = "T" Then
                %Beg
		Relget_adr_set(NOTRAP);
		Ent_credit_set(NOTRAP);
                Ent_credit_set.ib1_adr_set_ptr CONN: Relget_adr_set(NOMOD);
		Relget_adr_set(ETRAP);
		Ent_credit_set(ETRAP);
                %End
            END-IF
            Move 1 to Csid_want_secure
            Call "GET_CDTWIRE_DEST" Using
                By content "WIR"
                By reference Csid_idtype_ws
                By reference Csid_id_ws
                By reference Csid_id_ws_length
                By content "    "
                By reference Csid_want_secure
                By reference Csid_got_secure
                By reference Csid_info_memo
                By reference Csid_info_memo_length
                By reference Csid_vmsg_ws
              RETURNING Csid_ret_stat
            If (Failure_is in Csid_ret_stat   )
                OR (Csid_got_secure = 0  )
            THEN
		%Beg
		Csid_compose ^OUT(Csid_err_memo) "IB1: ", Csid_info_memo, / ;
		%End
	        Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
		Move 1 to Csid_ambig_parties
	    END-IF
	END-IF.

        If (Ibk_secwir of Ent_credit_set = "Y" )
	   AND (Routexcp_edit of Menu_cfg = "T" )
	THEN
* Must check for place to send secondary wire.
	    Move SPACES to Csid_id_ws	
            %Beg  Csid_temp2_vstr = NULL ;  %End
            If (Ibk_rel_id of Ent_credit_set = 0 )
                AND (Ibk_idtype of Ibk of Ent_credit_set NOT = "S" )
            THEN
* Removed overflow from compose - obsolete
                %Beg
                Csid_compose ^OUT(Csid_temp1_vstr)
                                Ent_credit_set.Ibk.Ibk_id, / ;
                Csid_parse ^IN(Csid_temp1_vstr)
                                ^STRING, "/BC", Csid_temp2_vstr,
                                ^ONEOF ( ("/", ^STRING, / ),
                                         (/) ) ;
                %End
                If (Failure_is in Csid_parse_status   )
                    %Beg
                    Csid_parse ^IN(Csid_temp1_vstr),
                                ^STRING, "/(BC", Csid_temp2_vstr,
                                ^ONEOF ( ("/", ^STRING, / ),
                                         (")", ^STRING, / ),
                                         (/) ) ;
                    %End
                    If (Failure_is in Csid_parse_status   )
                        %Beg  Csid_temp2_vstr = NULL ;  %End
                    END-IF
                END-IF
            END-IF
            If (Csid_temp2_vstr_length NOT = 0 )
                %Beg
                Csid_id_ws = Csid_temp2_vstr ;
                Csid_idtype_ws = "S" ;
                %End
            ELSE
                %Beg
                Csid_parse ^IN(Ent_credit_set.Ibk.Ibk_id)
                        Csid_id_ws, ^ONEOF ( ("/", ^STRING, / ),
                                             (/) ) ;
                Csid_idtype_ws = Ent_credit_set.Ibk.Ibk_idtype ;
                %End
            END-IF
            %Beg  BREAK: Relget_adr_set ;  %End
	    Initialize Relget_adr_set
            If (Ibk_rel_id of Ent_credit_set NOT = 0 ) Or
	       (Ibk_adr_ptr_ok of flgs3 of Ent_credit_set = "T") Then
		%Beg
		Relget_adr_set(NOTRAP);
		Ent_credit_set(NOTRAP);
                Ent_credit_set.ibk_adr_set_ptr CONN: Relget_adr_set(NOMOD) ;
		Relget_adr_set(ETRAP);
		Ent_credit_set(ETRAP);
                %End
            END-IF
            Move 1 to Csid_want_secure
            Call "GET_CDTWIRE_DEST" Using
                By content "WIR"
                By reference Csid_idtype_ws
                By reference Csid_id_ws
                By reference Csid_id_ws_length
                By content  "    "
                By reference Csid_want_secure
                By reference Csid_got_secure
                By reference Csid_info_memo
                By reference Csid_info_memo_length
                By reference Csid_vmsg_ws
              RETURNING Csid_ret_stat
            If (Failure_is in Csid_ret_stat   )
                OR (Csid_got_secure = 0  )
            THEN
		%Beg
		Csid_compose ^OUT(Csid_err_memo) "IBK: ", Csid_info_memo, / ;
		%End
	        Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
		Move 1 to Csid_ambig_parties
	    END-IF
	END-IF.


        If (Bbk_secwir of Ent_credit_set = "Y" )
	   AND (Routexcp_edit of Menu_cfg = "T" )
	THEN
* Must check for place to send secondary wire.
	    Move SPACES to Csid_id_ws	
            Move 1 to Csid_want_secure
            %Beg  Csid_temp2_vstr = NULL ;  %End
            If (Bbk_rel_id of Ent_credit_set = 0 )
                AND (Bbk_idtype of Bbk of Ent_credit_set NOT = "S" )
            THEN
* Removed overflow from compose - obsolete
                %Beg
                Csid_compose ^OUT(Csid_temp1_vstr)
                                Ent_credit_set.Bbk.Bbk_id, / ;
                Csid_parse ^IN(Csid_temp1_vstr)
                                ^STRING, "/BC", Csid_temp2_vstr,
                                ^ONEOF ( ("/", ^STRING, / ),
                                         (/) ) ;
                %End
                If (Failure_is in Csid_parse_status   )
                    %Beg
                    Csid_parse ^IN(Csid_temp1_vstr),
                                ^STRING, "/(BC", Csid_temp2_vstr,
                                ^ONEOF ( ("/", ^STRING, / ),
                                         (")", ^STRING, / ),
                                         (/) ) ;
                    %End
                    If (Failure_is in Csid_parse_status   )
                        %Beg  Csid_temp2_vstr = NULL ;  %End
                    END-IF
                END-IF
            END-IF
            If (Csid_temp2_vstr_length NOT = 0 )
                %Beg
                Csid_id_ws = Csid_temp2_vstr ;
                Csid_idtype_ws = "S" ;
                %End
            ELSE
                %Beg
                Csid_parse ^IN(Ent_credit_set.Bbk.Bbk_id)
                        Csid_id_ws, ^ONEOF ( ("/", ^STRING, / ),
                                             (/) ) ;
                Csid_idtype_ws = Ent_credit_set.Bbk.Bbk_idtype ;
                %End
            END-IF
            %Beg  BREAK: Relget_adr_set ;  %End
	    Initialize Relget_adr_set
            If (Bbk_rel_id of Ent_credit_set NOT = 0 ) Or
	       (bbk_adr_ptr_ok of flgs3 of Ent_credit_set = "T") Then
                %Beg
		Relget_adr_set(NOTRAP);
		Ent_credit_set(NOTRAP);
                Ent_credit_set.bbk_adr_set_ptr CONN: Relget_adr_set(NOMOD) ;
		Relget_adr_set(ETRAP);
		Ent_credit_set(ETRAP);
                %End
            END-IF
            Call "GET_CDTWIRE_DEST" Using
		By content "WIR"
                By reference Csid_idtype_ws
		By reference Csid_id_ws 
		By reference Csid_id_ws_length
		By content "    "
                By reference Csid_want_secure
                By reference Csid_got_secure
                By reference Csid_info_memo
                By reference Csid_info_memo_length
                By reference Csid_vmsg_ws
              RETURNING Csid_ret_stat 
	    If (Failure_is in Csid_ret_stat   )
                OR  (Csid_got_secure = 0  )
            THEN
		%Beg
		Csid_compose ^OUT(Csid_err_memo) "BBK: ", Csid_info_memo, / ;
		%End
	        Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
		Move 1 to Csid_ambig_parties
	    END-IF
	END-IF.

%^
%^ Copied from above, secwire flags may have changed.
%^
        If (Def_secwir_if_pre_spl of Menu_cfg = "Y")
               AND (Bbk_rel_id of Ent_credit_set = 0)
               AND (Dbt_ps_elig_flg of Ent_debit_set = "P" or "S")
               AND (Bbk_idtype of Ent_credit_set not = "S")
               AND (tmp_value_date_ws > Menu_date_ws)
            %^  AND (Value_date of Ent_ftr_set > Menu_date_ws)
               AND ( (Bbk_id of ent_credit_set not = spaces) 
		     OR (Bbk_name1 of ent_credit_set not = spaces))
               AND (Bbk_secwir of ent_credit_set = SPACE)
               AND (Ib1_secwir of ent_credit_set not = "Y")
               AND (Ibk_secwir of ent_credit_set not = "Y")
	THEN
                Perform C650_LOOKUP_BBK_ADDRESS thru 
			C650_LOOKUP_BBK_ADDRESS_end
        END-IF.



	If (Bnp_id of Bnp of Ent_credit_set NOT = SPACES )
	  OR ( (Bnp_name1_length of Ent_credit_set_lengths NOT = 0 ) 
	     AND (Bnp_name1 of Ent_credit_set NOT = SPACES ) )
	  AND ( (Success_is in Csid_try_chips)
	     OR (Csid_pushed_credit NOT = 4 ) )
	THEN
	    PERFORM B200_BNP through B200_BNP_END
	ELSE
* BNP id is blank, the BNP name is blank also, there are no intermediate
* parties, and the second credit id check exists and failed against the
*  original credit party.
	    If (SIDES_NONE in Csid_orig_depth )
		AND (Csid_2aid_id_length NOT = 0 )
		AND (Success_is in Csid_do_rolldown)
	    THEN
                Perform B380_MAGIC_BNP through B380_MAGIC_BNP_END
	    END-IF
	END-IF.

	If (Success_is in Csid_try_chips)
* Made it through creditside without CHIPS qualification.
	    If ( (Dbt_bnk_inf1_length of Ent_debit_set_lengths NOT = 0)
		 AND (Dbt_bnk_inf1 of Ent_debit_set NOT = SPACES ) )
	      OR (Orp_ref_num_length of Ent_debit_set_lengths NOT = 0 )
	    THEN
		Move 1 to Chips_qualified_ls
 	    ELSE
		%Beg
		Csid_compose ^OUT(Csid_err_memo)
			"CHIPS payment not qualified: no next party", /;
		%End
		Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
	    END-IF
	END-IF.

	If (Success_is in Csid_do_rolldown)
* Second credit id did not match and wasn't a second CHIPS ID.
	    %Beg
            Csid_compose ^OUT(Csid_err_memo)
		"Second credit ID ", Csid_second_id, " not in credit party ", 
		Csid_orig_credit, / ;
	    %End
	    Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
	    Move SPACES to Csid_know_acc_id     %^ JC 117492
	    %Beg  BREAK: Ent_c_acc_set ; 	%^ JC 117492
		  BREAK: Ent_c_acc_rel_reg;
	    %End	
	    Move ZERO to Cdt_not_suspect_ls
	END-IF.
	
	If (Is_payment_ls = 0 )
* Admins have fewer requirements.
	    If (Csid_ambig_parties NOT = 0 )
		OR (Success_is in Csid_push_error )
	    THEN
* Admin credit party was not completely processed.
	        Move ZERO to Cdt_not_suspect_ls
	    END-IF
	ELSE
	    If (Success_is in Csid_musthave_acct   )
		AND (Failure_is in Csid_set_account)
	    THEN
 		%^ With the HYBRID NOF DDA/Onfile REL/AUX this is no longer true
 		%^ Check for NOF dda and Skip 
 		If (Success_is in Csid_set_address) AND
 		   NOT((cdt_ovr of Cdt_typ of Ent_credit_set = "*") and
 		       (Cdt_idtype of Cdt_typ of Ent_credit_set = "D" or "G" or "F" or "V"))
 		Then
		    IF(Cdt_ovr of Cdt_typ of Ent_credit_set NOT = "?" )
		        %Beg  Ent_credit_set.cdt_typ.cdt_ovr = "?" ;  %End
		    END-IF
	            %Beg
                    Csid_compose ^OUT(Csid_err_memo)
			"No valid account for this credit party.", / ;
		    %End
	            Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
	            Move ZERO to Cdt_not_suspect_ls
		END-IF
	    END-IF
          
	    Set Failure_is in Unq_chips_overide to True

	    Call "CUST_CHP_UNQ_PASS"  using
			By Reference 	Unq_chips_overide

	    If ( (Do_chips_qualif_ls NOT = 0 )
		 AND (Do_chips_qualif_ls NOT = 2)	%^ allow thru
		 AND (Chips_qualified_ls = 0 )
		 AND (Cdt_idtype of Cdt_typ of Ent_credit_set = "P" )
		 AND (Cdt_adv_typ of Ent_credit_set = "CHP")
		 AND (Cdt_ovr of Cdt_typ of Ent_credit_set = SPACE ) )
	       OR (Success_is in Csid_do_rolldown)
%^ #106399 If this is a STO and it has failed the validate_iban, then the
%^	   Csid_ambig_parties value is zero.
	       OR (Csid_ambig_parties NOT = 0 )
	       OR (Success_is in Csid_push_error)
	    THEN
		If Failure_is  in Unq_chips_overide
* Credit party was not completely processed: CHIPS qualification was requested, and payment is CHIPS, but is unqualified
	        Move ZERO to Cdt_not_suspect_ls
		End-if
	    END-IF
	END-IF.

	If (Bnp_id of Bnp of Ent_credit_set = SPACES )
	   AND ( (Bnp_name1_length of Ent_credit_set_lengths = 0 )
		OR (Bnp_name1 of Ent_credit_set = SPACES ) )
	THEN
	    Move 1 to No_beneficiary_ls
	ELSE
	    Move 0 to No_beneficiary_ls
	END-IF.

	If (Advice_parties_ls > 3 )
* Maximum of three advice parties.
	   Move 3 to Advice_parties_ls
	END-IF.

	%Beg
	BREAK: Csid_acc_seq ;
	%End.
	Add Csid_info_count to Cdt_err_memo_count_ls.

%^ CREDITSIDE_LOOKUP routine should always set Cdt_not_suspect_ls argument to 1
%^ and return a status of SUCCESS if Is_payment_ls argument is = 0.  (This means
%^ that, while error memos will still be posted to the message history, the
%^ message itself will not be sent to RPR for creditside party eccentricities.)
%^
%^ SPR29440 - 	But should the eccentricity be that no previce has been found, 
%^		we should route to repair regardless of the contents of the
%^		field Is_payment_ls.
%^
	If FOUND_PREVICE_SI in Csid_previce_si_ind 	%^SPR29440
	        If Is_payment_ls = 0
                	Move 1 to Cdt_not_suspect_ls
                	Set Success_is in Creditside_look_ls to true
		end-if
        end-if.							%^SPR29440

%^ ABA's shouldn't have accounts anymore...Should Already be filled, don't clear
        If Cdt_idtype of Ent_credit_set = "A" then
           %^ If Cdt_account of Ent_credit_set not = spaces then
           %^     %Beg
           %^     Ent_credit_set (
           %^         .cdt_account        = NULL,
           %^         .cdt_acc_prod_codes = NULL,
           %^         .cdt_acc_class      = NULL,
           %^         .flgs.cdt_hold_flg  = NULL );
           %^     BREAK: Ent_c_acc_set ;
           %^     %End
           %^ end-if
	    Move SPACES to Csid_preferred_bank
	    If (Bank of Loc_info of Ent_ftr_set = Bnk_id of Menu_bnk_union )
		Move Preferred_fed_bnk_id of Menu_bnk_union to
							    Csid_preferred_bank
	    ELSE
		%Beg
		BREAK: Csid_bnk_union ;
		SEARCH: Bnk_index 
			(Key = Ent_ftr_set.Loc_info.Bank ) ;
		%End
		If Success_is in Bnk_index_status  
		    %Beg  Bnk_index CONN: Csid_bnk_union (NOMOD) ;  %End
		    Move Preferred_fed_bnk_id of Csid_bnk_union to 
							Csid_preferred_bank
		END-IF
            END-IF
	    If (Csid_preferred_bank NOT = SPACES AND 
					Cdt_adr_bnk_id of Ent_credit_set)
	       AND (Tran_type of Ent_ftr_set NOT = "BPF" )
	    THEN	
		If (Cdt_id of Cdt_typ of Ent_credit_set(4:1) = ":" )
		    %Beg
		    Csid_parse ^IN(Ent_credit_set.Cdt_typ.Cdt_id)
			^STRING<3>, ":", Csid_temp1_vstr, ^SPACE, / ;
		    %End
		ELSE
		    %Beg
		    Csid_temp1_vstr = Ent_credit_set.cdt_typ.cdt_id ;
		    %End
		END-IF
		%Beg
		Csid_compose ^OUT(Ent_credit_set.Cdt_typ.Cdt_id)
		Csid_preferred_bank, ":", Csid_temp1_vstr, / ;
		Ent_credit_set.Cdt_adr_bnk_id = Csid_preferred_bank ;
		%End
	    END-IF
        END-IF.

        If (Lock_cdt_party_ls NOT = 0 )  and
	   (Is_rptv_lookup_ls NOT = 0 )
	then
            %Beg
            BREAK: Csid_lcp_index;
            BREAK: Csid_lcp_adr_set;
            %End

%^ #106399 Only check if the Cdt_rel_id has changed.

            If Csid_lcp_orig_rel_id not = Cdt_rel_id of Ent_credit_set 

%^                Csid_lcp_orig_cdt_typ not = Cdt_typ of Ent_credit_set or
%^ #101499 & #100209 If the credit party is not on file, then the original cdt_account
%^	   is blank. By-pass this check since Cdt_account of Ent_credit_set has been
%^	   found by channel determination, but the original cdt_account is null.
%^               Csid_lcp_orig_cdt_acct not = Cdt_account of Ent_credit_set
%^               (Csid_lcp_orig_cdt_acct not = Cdt_account of Ent_credit_set and
%^		Csid_lcp_orig_cdt_acct not = spaces)
              then
                %Beg
                Csid_compose ^OUT(Csid_err_memo)
                   "Credit party address information has changed since the repetitive was created", /;
                %End
                Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
                Move ZERO to Cdt_not_suspect_ls
            end-if
        end-if.
        %Beg  BREAK: Csid_bnk_union;  %End.

	%^ Lets add any IBAN as NATIVEACCOUNT PRM that we may have encountered
	%^ along the way.
	
	If csid_orig_iban_ws_length > 0 and
	   csid_orig_iban_ws (1:csid_orig_iban_ws_length) not = spaces Then
		  %Beg 
	 	  Compose ^OUT(csid_prm_name_ws) "MTS$CDTNATIVE_ACCOUNT", /; 
		  Compose ^OUT(csid_prm_value_ws) csid_orig_iban_ws, /;
		  csid_Prm_level_wo msg_is;
		  csid_Prm_source_wo msg_is;
		  csid_Prm_edit_wo Text_is;
		  %End
		  Initialize csid_prm_time_on_ws, csid_prm_time_off_ws
		  Initialize csid_prm_remaining_ws
		  Set Success_is in csid_prm_mode_wf to True
		  Call "PRULE_MSG_UPDATE_PARAM" using
			   by reference csid_prm_name_ws,	  %^ vstr(40)
			   by reference csid_prm_name_ws_length,  %^ length
			   by reference csid_prm_level_wo, 	  %^ PRULE_LEVEL_ONEOF.DDF
			   by reference csid_prm_source_wo, 	  %^ PRULE_SOURCE_ONEOF.DDF
			   by reference csid_prm_time_on_ws,	  %^ time
			   by reference csid_prm_time_off_ws,	  %^ time
			   by reference csid_prm_edit_wo, 	  %^ PR_PARAM_EDIT_ONEOF.DDF
			   by reference csid_prm_mode_wf,	  %^ boolean
			   by reference csid_prm_remaining_ws	  %^ long
			   by reference csid_prm_value_ws,	  %^ vstr(80)
			   by reference csid_prm_value_ws_length, %^ length
			   by reference csid_prm_present_wf, 	  %^ boolean
			   by reference csid_prm_memo_ws,	  %^ vstr(ACE$_MSG_STR_SIZE)
			   by reference csid_prm_memo_ws_length	  %^ length
			   returning csid_prm_status_wf		  %^ boolean
	end-if.


%^ NEED to check for FED_XBANK_NOPREF
%^ %^ Begin the clear out of an Address that id not in the same bank as the Clearing 
%^ Account being paid. 
%^
	If Success_is in Fed_xbank_nopref_flg
	Then
		If (Idbank of Cdt_account of Ent_credit_set is not = Cdt_adr_bnk_id of Ent_credit_set And
		    Idbank of Cdt_account of Ent_credit_set is not = spaces )
		And ((RTGS_IS in Endpoint_type of Rchan_channel_set) or
		     (clrhouse_is in Endpoint_type of Rchan_channel_set))
		And
		    ((Cdt_rel_id of Ent_credit_set NOT = 0 ) or
		     (Cdt_adr_ptr_ok of Flgs3 of Ent_credit_set = "T"))
		Then
			%^ Take the Credit off file and set the cdtr_adr_bnk_id to match the
			%^ Clearing account. THis is the bank where the payment should take place
		    %Beg
			    Ent_credit_set(
				 .cdt_adr_bnk_id = ent_credit_set.cdt_account.idbank,
			         .cdt_rel_id = <0>, 
				 .Cdt_spc_inst1 = null,
				 .Cdt_spc_inst2 = null,
				 .Cdt_spc_inst3 = null,
				 .Cdt_department = null,
				 .Cdt_adr_class = null,
				 .Cdt_adr_type = null,
				 .cdt_wir_key = null,
 			 	 .cdt_adr_set_ptr   delete ,
				 .flgs3.cdt_adr_ptr_ok = Null,
				 .cdt_typ.cdt_ovr = "*") ;
			    Break: Relget_adr_set;
       		     %End
		     %^ Update the Prule info 
		     Perform X980_CHANGE_CREDIT thru
			     X980_CHANGE_CREDIT_END
		End-if
	END-IF.


	%beg csid_upd_level cdt_party_is; %end
	Call "PRULE_UPDATE_PARTY" Using
		By Reference csid_upd_level
		By Reference csid_pr_memo
		by reference csid_pr_memo_length
	returning csid_ret_stat.
  
%^ #124516 moving this logic further down it the paragraph.

	If (Csid_err_memo_length NOT = 0 )
            Move Csid_err_memo_length to Last_memo_leng_ls
            Move Csid_err_memo(1:Csid_err_memo_length) to Last_memo_ls
        END-IF.

A110_GOT_CREDIT_END.

	EXIT.
B200_BNP.
*  Paragraph to do account lookup on the BNP.  If Success_is in Csid_try_chips
*    when we get here, we will try to chips qualify it.
*    If that fails, we will look at the Credit_depth_ls value.  If it is 4,
*    then we know that the BNP element was set up by a pushdown from the
*    Credit Party and no further lookup is necessary.  If it is not set,
*    then we do a REL lookup.  If the lookup succeeds, we copy in the name
*    and address info.  If it was found in the rel file we copy in the 
*    Bnp_adv_inst.

	%Beg  Relget_msgcode = NULL;  %End.
	Set Failure_is in Csid_found_it to true.
	Set Failure_is in Csid_failed_lookup to true.
	Set Failure_is in Csid_chips_candidate to true.
	Set Failure_is in Csid_multi_party to true.
	Set Failure_is in Csid_chips_party to true.
	Set Failure_is in Csid_chips_override to true.
	Move SPACES to Csid_party_id.
	Move spaces to Csid_iban_cntry_ws.

	%^ Hose the rel pointers, if we're here, we'll relookup
	%beg
	   Ent_credit_set(.bnp_rel_id = <0>,
	    		  .bnp_adr_set_ptr DELETE,
			  .flgs3.bnp_adr_ptr_ok = Null);
    	%End

	%^ If ID format is xxxxxxxxxx/(xxxxxxxxxxxx) remove everything
	%^ from the / onward it will be re-mapped.  
        %Beg
        Csid_parse ^IN(Ent_credit_set.Bnp.Bnp_id)
                Csid_temp1_vstr, "/(", ^STRING, ^SPACE, / ;
        %End
        If Success_is in Csid_parse_status
                %Beg
                Csid_compose ^OUT(Ent_credit_set.Bnp.Bnp_id)
                                Csid_temp1_vstr, / ;
                %End
        End-if.
* Removed overflow test - obsolete

	    %Beg  
	    Csid_parse ^IN(Ent_credit_set.Bnp.Bnp_id)
	    		Csid_party_id, ^SPACE, / ;
	    %End
	    If Success_is in Csid_parse_status  
	        %Beg
		Csid_parse ^IN(Csid_party_id),
		    ^ONEOF(
			(Csid_temp1_vstr, "/", 
				Csid_party_extype (^STRING<2>(<CHAR$M_ALPHA>)), 
				^STRING, ^SPACE, /),
			(Csid_temp1_vstr, "/??", ^STRING, ^SPACE, /));
	        %End
	        If (Success_is in Csid_parse_status   )
		    AND (Csid_temp1_vstr_length NOT = 0 )
		THEN
		    Set Success_is in Csid_multi_party to true
	        END-IF
	    END-IF.

%^
%^ 135466
%^ Assume that a BIC in the  BNP id indicates a Bank and therefore, PAY TO country
%^
 	If (Bnp_idtype of Bnp  of Ent_credit_set = "S")
	Then
	    If  Bnp_id of Bnp of Ent_credit_set(4:1) = ":"
	    Then
		    Move Bnp_id of Bnp of Ent_credit_set(9:2) to Csid_res_country_ws
	    Else
		    Move Bnp_id of Bnp of Ent_credit_set(5:2) to Csid_res_country_ws
	    End-if
	    %beg ent_credit_set.bnp_mailing_country = Csid_res_country_ws; %end
	    Move Spaces to Csid_res_country_ws
	End-if.


	%^ Before we go to TAKEOUT GARBAGE, we need a country for Validate IBAN
	If bnp_res_country of ent_credit_set = spaces
	    Initialize Csid_risk_country_ws, Csid_country_code_ws
	    Call "DETERM_RES_COUNTRY" using
	       by content "BNP"
	       by reference bnp_idtype of Ent_credit_set
	       by reference bnp_id of Ent_credit_set
	       by reference bnp_id_length of Ent_credit_set_lengths
	       by reference Csid_risk_country_ws
	       by reference Csid_country_code_ws
	       by reference bnp_res_country of Ent_credit_set
	       by reference Csid_res_country_ws
	    If Csid_res_country_ws not = spaces
	        %Beg Ent_credit_set.bnp_res_country = Csid_res_country_ws; %end
	    end-if
	end-if.
%^ 109999
%^ pass the BNP_MAILING Country into VALIDATE_IBAN, if blank, use BBK_RES_COUNTRY
%^ unless no BBK then use CDT_RES_COUNTRY
	If (Bbk of Ent_credit_set not = SPACES or 
	    Bbk_name1 of Ent_credit_set not = SPACES) then
			Initialize Csid_res_country_ws
			If Bbk_idtype of bbk of Ent_credit_set = "S" Then
			    If  Bbk_id of Bbk of Ent_credit_set(4:1) = ":"
			    Then
				    Move Bbk_id of Bbk of Ent_credit_set(9:2) to Csid_res_country_ws
			    Else
				    Move Bbk_id of Bbk of Ent_credit_set(5:2) to Csid_res_country_ws
			    End-if
			Else
			    If (bbk_adr_ptr_ok of flgs3 of ent_credit_set = "T")
			    Then
				%beg break: csid_tmp_adr_set;
	     			     Ent_credit_set.bbk_adr_set_ptr CONN: csid_tmp_adr_set;
	     			     break: csid_tmp_adr_set;
				%end
	   			If (Swift_id of csid_tmp_adr_set Not = Spaces)
				Then
				    Move Swift_id of  csid_tmp_adr_set(5:2) to Csid_res_country_ws
				end-if
			    Else
				If Bbk_idtype of bbk of Ent_credit_set = "E"
				Then
					%^ get country for Extended IDs table
					%beg
						Csid_parse ^in(ent_credit_set.bbk.bbk_id)
							Csid_party_extype (^STRING<2>),
							csid_gcheck_id,/;
					%end
					CALL "CUST_XTEND_ID_EDIT" using
						BY REFERENCE Csid_party_extype
		   				BY REFERENCE Csid_gcheck_id
		   	     			BY REFERENCE Csid_gcheck_id_length
		    				BY REFERENCE Csid_temp1_vstr
		    				By REFERENCE Csid_temp1_vstr_length
		    				By REFERENCE Csid_delay_change
		    				BY REFERENCE Csid_got_advice
		    				By Reference Csid_extnd_country
		    				BY REFERENCE Csid_error_memo
		    				BY REFERENCE Csid_error_memo_length
		    				By REFERENCE Csid_error_code
		    				By REFERENCE Csid_error_code_length
		    				BY REFERENCE Csid_check_stat
		    				BY REFERENCE Csid_not_garbage
		  			RETURNING Csid_ret2_stat
					If Success_is in Csid_ret2_stat And
					   Csid_extnd_country NOT = Spaces
					Then
						%beg csid_res_country_ws = csid_extnd_country; %end
					end-if
					%^ get country for Extended IDs table
				end-if
			    end-if
			end-if
			If csid_res_country_ws = spaces  AND
			   bbk_res_country of ent_credit_set NOT = Spaces
			Then
	 		  	%beg csid_res_country_ws = ent_credit_set.bbk_res_country; %end
			Else
				If Csid_res_country_ws not = spaces
		       		    %Beg Csid_iban_cntry_ws = Csid_res_country_ws; %End
				    %^ JC 117739
				    If Bnp_mailing_country of Ent_credit_set = SPACES then
				        %Beg Ent_credit_set.bnp_mailing_country = Csid_res_country_ws; %End
				    End-if
 				end-if	
			end-if
		Else
			Initialize Csid_res_country_ws
			%^ Check the Credit Party
			If Cdt_idtype of Cdt_typ of Ent_credit_set = "S" Then
			    If  Cdt_id of Cdt_typ of Ent_credit_set(4:1) = ":"
			    Then    %^ Skip over the bank
				Move Cdt_id of Cdt_typ of Ent_credit_set(9:2) to Csid_res_country_ws 
			    Else
			    	Move Cdt_id of Cdt_typ of Ent_credit_set(5:2) to Csid_res_country_ws 
			    End-if
			Else
			    If (Cdt_adr_ptr_ok of flgs3 of ent_credit_set = "T")
			    Then
				%beg break: csid_tmp_adr_set;
	     			     Ent_credit_set.Cdt_adr_set_ptr CONN: csid_tmp_adr_set;
	     			     break: csid_tmp_adr_set;
				%end
	   				If (Swift_id of csid_tmp_adr_set Not = Spaces)
				Then
				    Move Swift_id of  csid_tmp_adr_set(5:2) to Csid_res_country_ws
				end-if
			    Else
				If Cdt_idtype of cdt_typ of Ent_credit_set = "E"
				Then
					%beg
						Csid_parse ^in(ent_credit_set.cdt_typ.cdt_id)
							Csid_party_extype (^STRING<2>),
							csid_gcheck_id,/;
					%end
					CALL "CUST_XTEND_ID_EDIT" using
						BY REFERENCE Csid_party_extype
		   				BY REFERENCE Csid_gcheck_id
		   	     			BY REFERENCE Csid_gcheck_id_length
		    				BY REFERENCE Csid_temp1_vstr
		    				By REFERENCE Csid_temp1_vstr_length
		    				By REFERENCE Csid_delay_change
		    				BY REFERENCE Csid_got_advice
		    				By Reference Csid_extnd_country
		    				BY REFERENCE Csid_error_memo
		    				BY REFERENCE Csid_error_memo_length
		    				By REFERENCE Csid_error_code
		    				By REFERENCE Csid_error_code_length
		    				BY REFERENCE Csid_check_stat
		    				BY REFERENCE Csid_not_garbage
		  			RETURNING Csid_ret2_stat
					If Success_is in Csid_ret2_stat And
					   Csid_extnd_country NOT = Spaces
					Then
						%beg csid_res_country_ws = csid_extnd_country; %end
					end-if
					%^ get country for Extended IDs table
				end-if
			    end-if
			end-if
			If csid_res_country_ws = spaces  AND
			   cdt_res_country of ent_credit_set NOT = Spaces
			Then
	 		  	%beg csid_res_country_ws = ent_credit_set.cdt_res_country; %end
			Else
	   			If Csid_res_country_ws not = spaces
		       		    %Beg Csid_iban_cntry_ws = Csid_res_country_ws; %End
				    If Address_type of Cdt_adr_type of Ent_credit_set = "B" and
				       Bnp_mailing_country of Ent_credit_set = SPACES then	%^ JC 117739
				      %Beg Ent_credit_set.bnp_mailing_country = Csid_res_country_ws; %End
				    End-if
				End-if
   			end-if
		End-if
	%^End-if

%^ #141343 Make this code similar to that which is in creditside_screen.
%^	   Adding an "Else" and moving the Csid_save_cntry_ws.

	If csid_res_country_ws = Spaces
	Then
		%^ No decision from above, try bnp_mailing and BNK
		If NOT(bnp_MAILING_country of ent_credit_set = Spaces) Then
			%beg csid_iban_cntry_ws = ent_credit_set.bnp_MAILING_country; %end
		Else
			%beg csid_iban_cntry_ws = menu_bnk_union.country_code; %end
		end-if
	Else
		%beg Csid_save_cntry_ws = csid_iban_cntry_ws; %end
	End-if

	%Beg
		Csid_party_idtype = Ent_credit_set.Bnp.Bnp_idtype ;
%^                csid_save_cntry_ws = csid_iban_cntry_ws;	%^ Setup for mismatch comparision

	%End.

	Perform X940_TAKEOUT_GARBAGE through X940_TAKEOUT_GARBAGE_END.
	If (Failure_is in Csid_had_garbage   ) %^
	    PERFORM X960_SHUFFLE_IDS through X960_SHUFFLE_IDS_END
        END-IF.
	

%^ 110567 - reset Csid_party_idtype to SPACES if it comes back as "D", validate IBAN
%^ IDtype D not valid for a BNP.

	If Csid_party_idtype = "D" then
	   Initialize Csid_party_idtype
	End-if.

	%^
	%^ If IBAN, we now need to INSERT a BBK if required.
	%^
	If (Success_is in csid_iban_found) Then
		If csid_save_cntry_ws NOT = csid_iban_cntry_ws And spaces	%^ #141343 Changed "or" to "and"
		Then	%^  Need to check table to see if this is OK
			%^  IBAN country does not match the nesxt higher country
			If (Success_is in csid_val_iban_ret) AND
			   (csid_save_cntry_ws NOT = csid_iban_cntry_ws) AND
			   (csid_valid_iban_flg_ws = "I")
			Then
				%^ BBK/CDT country differs from IBAN country in
				%^ Check table for allowable difference, else,
				%^ flag as a Blocking type error
				Perform X1150_CHECK_IBAN_CNTRY Thru
					X1150_CHECK_IBAN_CNTRY_END
				If Not(Success_is in Csid_Bic_cc_exc_wf)
				Then
					%^ No match, flag as error and exit
					%beg csid_msg_mnemonic_ws = "LKUP$_IBAN_BIC_CC"; %End

					Call "FORMAT_MSG_TO_TEXT" Using	
						By Reference csid_msg_mnemonic_ws
						By Reference csid_msg_mnemonic_ws_length
						by Value %siz(Csid_err_memo)
						by Reference Csid_err_memo
						By Reference Csid_err_memo_length
					%^
		        		Perform X900_error_memo THRU 
	           				X900_error_memo_end
					Set Success_is in Csid_had_garbage to True
					Move 1 to csid_ambig_parties
					Go to B200_BNP_END				
				End-if
			End-if
		end-if
		%^ we may need to insert a BBK
		Perform X990_IBAN_BBK_INSERT thru X990_IBAN_BBK_INSERT_END
		%^ Reset flags that might have been set by B220_BBK, which
		%^ is performed by X990_IBAN_BBK_INSERT
		Set Failure_is in Csid_found_it to true
		Set Failure_is in Csid_failed_lookup to true
		Set Failure_is in Csid_chips_candidate to true
		Set Failure_is in Csid_chips_party to true
		Set Failure_is in Csid_chips_override to true
	end-if.
	%^
	%^
	Perform C600_UPDATE_BNP through C600_UPDATE_BNP_END.
	If (Success_is in Csid_had_garbage   )
	   If csid_struct_acct_ws = "Y" And
	      csid_party_idtype = " "
	   Then
		 %^ Add "*" to alow the IBAN/BBAN error message to take precidence
		 If csid_err_memo_length NOT = 0 Then
			%beg csid_save_err_memo = csid_err_memo; %end
		 end-if
	   	 %Beg

	    		Csid_compose ^OUT(Csid_err_memo)
	    			"*Incorrect format in BNF ", Csid_party_idtype, 
			Csid_party_id, / ;         
	    	%End
		Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
		%^ reset to IBAN check message will be present on join and be 1st
		%^ thing shown to operator
		if csid_save_err_memo_length NOT = 0 Then
			%beg csid_err_memo = csid_save_err_memo;
			     csid_save_err_memo = NULL;
			%end
		end-if
	    Else
	   	 %Beg
	    		Csid_compose ^OUT(Csid_err_memo)
	    			"Incorrect format in BNF ", Csid_party_idtype, 
			Csid_party_id, / ;         
	    	%End
	        Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
	    end-if

	    %Beg
	    Csid_compose ^OUT(Csid_err_memo)
	    	"Incorrect format in BNF ", Csid_party_idtype, 
		Csid_party_id, / ;         
	    %End
	    Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END

%^ #106399 If this is a STO and the validate_iban failed (csid_val_iban_ret),
%^	   do not set the csid_ambig_parties to one.  The error is written
%^	   just as a warning, but the STO will not be sent to an exceptions queue.
%^ #129923  Revise the audits for routing the STO items.

	    If Src_code of Ent_ftr_set = "STO" and
	       Not(Failure_blocking_is in Csid_val_iban_ret)
	    Then
	    	Move 0 to Csid_ambig_parties
	    Else
	    	Move 1 to Csid_ambig_parties
	    End-if
	    Set Failure_is in Csid_try_chips to TRUE
	    GO TO B200_BNP_END
	END-IF.

	If (Success_is in Csid_try_chips)
%^ Try for CHIPS qualification lookup.
            If (Success_is in Csid_do_rolldown)
		Perform C810_ROLL_DOWN through C810_ROLL_DOWN_END 
		If (Failure_is in Csid_do_rolldown)
%^ Successful rolldown, so readjust the BNP.
		    Perform C600_UPDATE_BNP through C600_UPDATE_BNP_END
		END-IF
            END-IF
	    If (Csid_party_id_length NOT > 0  )
		OR (Csid_party_id = SPACES )
	    THEN
* No ID to qualify

	   	If 	Success_is in Unq_chips_overide
	  	Then
	        	%Beg
				Csid_compose ^OUT(Csid_info_memo)
					"CHIPS payment; BNF not qualified: no ID.", /;
		        %End
		        Perform X920_INFO_MEMO through X920_INFO_MEMO_END
	   	else
	        	%Beg
			Csid_compose ^OUT(Csid_err_memo)
				"CHIPS payment; BNF not qualified: no ID.", /;
		        %End
			Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
		End-if
		Set Failure_is in Csid_try_chips to TRUE
	        GO TO B200_BNP_END
	    END-IF
	    Call "CUST_EXTENDED_ID_QUAL"  USING
		by Reference Csid_party_idtype
		by Reference Csid_party_id
		by Reference Csid_party_id_length
		by Reference Csid_party_idtype
		by Reference Csid_party_id
		by Reference Csid_party_id_length
		by Reference Bnp_idtype of Ent_credit_set
		by Reference Bnp_id of Ent_credit_set
		by Reference Bnp_id_length of Ent_credit_set_lengths
	      returning Csid_temp_stat

	    Call "CHIPS_QUALIFICATION"  USING
		By reference Csid_party_idtype
		By reference Csid_party_id
	      RETURNING Csid_ret_stat
	    If (Success_is in Csid_ret_stat   )
		Set Success_is in Csid_found_it to true
		If Success_is in  Csid_chp_qual_cand	%^  (Chips_uid_id of Relget_adr_set NOT = SPACES )
		Then
		    Set Success_is in Csid_chips_candidate to true
		END-IF
            ELSE
                Set Success_is in Csid_failed_lookup to true
	    END-IF
	    If (Failure_is in Csid_chips_candidate   )
		Perform C780_CHIPS_OVERRIDE through C780_CHIPS_OVERRIDE_END
		If Success_is in Csid_ret_stat  
		    Set Success_is in Csid_chips_override to true
		    Move 1 to Chips_qualified_ls
		ELSE
		    Set Failure_is in Csid_found_it to true
                END-IF
            ELSE
* Try for further CHIPS qualification since UID is okay with participant
	        Call "CUST_EXTENDED_ID_QUAL"  USING
		    by Reference Bnp_idtype of Ent_credit_set
		    by Reference Bnp_id of Ent_credit_set
		    by Reference Bnp_id_length of Ent_credit_set_lengths
		    by Reference Bnp_idtype of Ent_credit_set
		    by Reference Bnp_id of Ent_credit_set
		    by Reference Bnp_id_length of Ent_credit_set_lengths
		    by Reference Csid_tmp_flg_ws
		    by Reference Csid_temp1_vstr
		    by Reference Csid_temp1_vstr_length
	          returning Csid_temp_stat

                Call "CHIPS_QUALIFICATION_IDSTR"  USING
                    By reference Bnp_idtype of Bnp of Ent_credit_set
                    By reference Bnp_id of Bnp of Ent_credit_set
                    By reference Bnp_id_length of Ent_credit_set_lengths
                    By reference Csid_id_ws
                    By reference Csid_id_ws_length
                  RETURNING Csid_chips_party
                If (Success_is in Csid_chips_party   )
		    %Beg
                    Csid_compose ^OUT(Csid_party_id )
                        Csid_id_ws, / ;
		    %End
                ELSE
* Could have case of a COMMON UID and SWIFT TID.
                    Perform C670_CHECK_COMMON_UID thru
                            C670_CHECK_COMMON_UID_end
%^ spr 25062  -additional qualification rules by INTRTL
                    If (Swf_str_thru_qual_edt of Menu_cfg = "T")
		      AND (Failure_is in Csid_chips_party)
		    then
                       Perform C700_CHECK_SWIFT_QUAL thru
                               C700_CHECK_SWIFT_QUAL_END  
		    END-IF
%^ mper 48548 / spr 37490 
		    If ( Chips_double_id_flag of Menu_cfg = "T")
		      AND (Failure_is in Csid_chips_party)
		      AND (Success_is in Csid_try_chips)
		    then 
                        Perform C705_CHIPS_DOUBLE_ID thru
                            C705_CHIPS_DOUBLE_ID_END
		    END-IF
		END-IF
	    END-IF
            Set Failure_is in Csid_try_chips to TRUE
	    If (Success_is in Csid_chips_party )
		Perform C600_UPDATE_BNP through C600_UPDATE_BNP_END
		Move 1 to Chips_qualified_ls
	    END-IF

            If (Success_is in Csid_chips_party   )
                OR (Success_is in Csid_chips_override   )
            THEN
                Add 1 to Advice_parties_ls
            ELSE
		    Call "CUST_CHP_UNQ_PASS"  using
			By Reference 	Unq_chips_overide
		If(Success_is in Unq_chips_overide)
		Then
			Add 1 to advice_parties_ls
			%beg
		        	Csid_compose ^OUT(Csid_info_memo)
     			      		"CHIPS payment; unqualified BNF ",
                  			 Ent_credit_set.Bnp.Bnp_idtype, "/",		%^ icr_000689
                			 Ent_credit_set.Bnp.Bnp_id, /;
		        %End
		        Perform X920_INFO_MEMO through X920_INFO_MEMO_END
			%^ Make this an Info message Not Error			
		Else
	                %Beg
       			         Csid_compose ^OUT(Csid_err_memo)
              			      	"CHIPS payment; unqualified BNF ",
                    		       	Ent_credit_set.Bnp.Bnp_idtype, "/",
                   		 	Ent_credit_set.Bnp.Bnp_id, /;
                	%End
               		 Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
		End-if
	    END-IF

	    If Success_is in Csid_found_it
	        GO TO B200_BNP_CLEANUP
	    END-IF

	END-IF.

	If (Credit_depth_ls = 4 ) And
	   (bnp_name1 of Ent_credit_set NOT = Spaces) %^ Possibly not yet looked up
* Must be a pushdown.
	    Add 1 to Advice_parties_ls
 	    GO TO B200_BNP_END
	END-IF.	    

	If ( (Bnp_name1_length of Ent_credit_set_lengths NOT = 0 ) 
             AND (Bnp_name1 of Ent_credit_set NOT = SPACES ) )
	   OR ( (Bnp_name2_length of Ent_credit_set_lengths NOT = 0 ) 
             AND (Bnp_name2 of Ent_credit_set NOT = SPACES ) )
	   OR ( (Bnp_name3_length of Ent_credit_set_lengths NOT = 0 ) 
             AND (Bnp_name3 of Ent_credit_set NOT = SPACES ) )
	   OR ( (Bnp_name4_length of Ent_credit_set_lengths NOT = 0 ) 
             AND (Bnp_name4 of Ent_credit_set NOT = SPACES ) )
	THEN
	    Set Failure_is in Csid_lc_noaddress to true
	ELSE
	    Set Success_is in Csid_lc_noaddress to true
	END-IF.

	If (Bnp_idtype of Bnp of Ent_credit_set = SPACE)
	   AND (Failure_is in Csid_lc_noaddress   )
	THEN
%^ If one of the id's is a foreign account number, we cannot
%^  confirm the id so we cannot use any address information that we have.
%^  Skip the lookup.
	    Add 1 to Advice_parties_ls
	    GO TO B200_BNP_END
	END-IF.	    

%^ We still need to try the lookup
        Move SPACE to Csid_lc_secwir.
	Set BNP in Relget_title_flag to TRUE
        PERFORM C820_LOWER_CREDIT through C820_LOWER_CREDIT_END.
	If (Csid_ovr = "?" )
* An ambiguous case -- kick it back to the operator.
	    %Beg
	    Csid_compose ^OUT(Csid_err_memo)
		"Not Str Thru: Ambiguous BNF party ", Csid_ovr, 
			Ent_credit_set.BNP, / ;
	    %End
	    Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
	    Add 1 to Csid_ambig_parties
	    GO TO B200_BNP_END
	END-IF.

	If ( ( (Csid_ovr = SPACE ) OR (Csid_ovr = "*" ) )
	      AND (Success_is in Csid_ret_stat )
	      AND ( Success_is in Csid_lc_noaddress or 
		    Success_is in csid_non_ucc_src))
	THEN
	    Set Success_is in Csid_found_it to true

 	END-IF.
	Perform C600_UPDATE_BNP through C600_UPDATE_BNP_END.
	If ((Csid_ovr = SPACE ) OR (Csid_ovr = "*" )) AND
	    (Success_is in Csid_ret_stat ) And
	    (Failure_is in Csid_found_it )	%^ need to keep Name.address instact, remark as onREL/AUX
	Then
		%beg 	    Ent_credit_set(.bnp_rel_id = Relget_adr_set.rel_id,
	    		   		   .bnp_adr_set_ptr POINT: Relget_adr_set,
			   		   .flgs3.bnp_adr_ptr_ok = "T");
		%end
	End-if.

	If (Failure_is in Csid_found_it   )
	    GO TO B200_BNP_END
	END-IF.

B200_BNP_CLEANUP.
* Removed overflow from compose - obsolete
	%Beg
	Csid_compose ^OUT(Csid_id_ws) 
		Ent_credit_set.bnp.bnp_id, / ;
	Csid_idtype_ws = Ent_credit_set.bnp.bnp_idtype ;
	%End.  
	Call "SET_BNP_PARTY" USING
	    By reference Csid_idtype_ws
	    By reference Csid_id_ws
	    By reference Csid_id_ws_length
	    By reference Bank of Loc_info of Ent_ftr_set
	  RETURNING Csid_ret_stat.
	Add 1 to Advice_parties_ls.

B200_BNP_END.

   EXIT.
B220_BBK.
*  Paragraph to do account lookup on the BBK.  If Success_is in Csid_try_chips
*    when we get here, we will try to chips qualify it.
*    If that fails, we will look at the Bbk_rel_id element.  If it is set,
*    then we know that the BBK element was set up by a pushdown from the
*    Credit Party and no further lookup is necessary.  If it is not set,
*    then we do a REL lookup.  If the lookup succeeds, we copy in the name
*    and address info.  If it was found in the rel file, we set the Bbk_rel_id
*    and the Bbk_adr_set_ptr and copy in the Bbk_adv_inst.

	%Beg  Relget_msgcode = NULL;  %End.
	Set Failure_is in Csid_found_it to true.
	Set Failure_is in Csid_failed_lookup to true.
	Set Failure_is in Csid_chips_candidate to true.
	Set Failure_is in Csid_multi_party to true.
	Set Failure_is in Csid_chips_party to true.
	Set Failure_is in Csid_chips_override to true.



	%^ If ID format is xxxxxxxxxx/(xxxxxxxxxxxx) remove everything
	%^ from the / onward it will be re-mapped.  
        %Beg
        Csid_parse ^IN(Ent_credit_set.Bbk.Bbk_id)
                Csid_temp1_vstr, "/(", ^STRING, ^SPACE, / ;
        %End

        If Success_is in Csid_parse_status
                %Beg
                Csid_compose ^OUT(Ent_credit_set.Bbk.Bbk_id)
                        Csid_temp1_vstr, / ;
                %End
        End-if.


	Move SPACES to Csid_party_id.
* Removed overflow test - obsolete
	%Beg  
	    Csid_parse ^IN(Ent_credit_set.Bbk.Bbk_id)
	    		Csid_party_id, ^SPACE, / ;
	%End
	If Success_is in Csid_parse_status  

	    %Beg
		Csid_parse ^IN(Csid_party_id),
		   ^ONEOF(
			(Csid_temp1_vstr, "/", 
				Csid_party_extype (^STRING<2>(<CHAR$M_ALPHA>)), 
				^STRING, ^SPACE, /),
			(Csid_temp1_vstr, "/??", ^STRING, ^SPACE, /));
	    %End
	    If (Success_is in Csid_parse_status   )
		    AND (Csid_temp1_vstr_length NOT = 0 )
	    Then
		Set Success_is in Csid_multi_party to true
	    END-IF
	END-IF.

	%Beg  Csid_party_idtype = Ent_credit_set.Bbk.Bbk_idtype ;  %End
	Perform X940_TAKEOUT_GARBAGE through X940_TAKEOUT_GARBAGE_END.
	If (Failure_is in Csid_had_garbage   )
	    PERFORM X960_SHUFFLE_IDS through X960_SHUFFLE_IDS_END
        END-IF.
	Perform C610_UPDATE_BBK through C610_UPDATE_BBK_END.
	If (Success_is in Csid_had_garbage   )
	    %Beg
	    Csid_compose ^OUT(Csid_err_memo)
	    	"Incorrect format in BBK ",  Csid_party_idtype, 
		Csid_party_id, / ;
	    %End
	    Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
	    Move 1 to Csid_ambig_parties
	    Set Failure_is in Csid_try_chips to TRUE
	    GO TO B220_BBK_END
	END-IF.

	If (Success_is in Csid_try_chips)
%^ Try for CHIPS qualification lookup.
            If (Success_is in Csid_do_rolldown)
		Perform C810_ROLL_DOWN through C810_ROLL_DOWN_END 
		If (Failure_is in Csid_do_rolldown)
%^ Successful rolldown, so readjust the BBK.
		    Perform C610_UPDATE_BBK through C610_UPDATE_BBK_END
		END-IF
	    END-IF
            If (Csid_party_id_length NOT > 0  )
                OR (Csid_party_id = SPACES )
	    THEN
* No ID to qualify
		If Failure_is in Unq_chips_overide
		Then
	                %Beg
       			         Csid_compose ^OUT(Csid_err_memo)
               			         "CHIPS payment; BBK not qualified: no ID.", /;
                	%End
                	Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
		Else
	                %Beg
       			         Csid_compose ^OUT(Csid_info_memo)
					"CHIPS payment; BBK not qualified: no ID.", /;  
                	%End		     
		        Perform X920_INFO_MEMO through X920_INFO_MEMO_END
		End-if
               	Set Failure_is in Csid_try_chips to TRUE
               	GO TO B220_BBK_END
            END-IF
	    Call "CUST_EXTENDED_ID_QUAL"  USING
		by Reference Csid_party_idtype
		by Reference Csid_party_id
		by Reference Csid_party_id_length
		by Reference Csid_party_idtype
		by Reference Csid_party_id
		by Reference Csid_party_id_length
		by Reference Bbk_idtype of Ent_credit_set
		by Reference Bbk_id of Ent_credit_set
		by Reference Bbk_id_length of Ent_credit_set_lengths
	      returning Csid_temp_stat

            Call "CHIPS_QUALIFICATION"  USING
                By reference Csid_party_idtype
                By reference Csid_party_id
              RETURNING Csid_ret_stat
            If (Success_is in Csid_ret_stat   )
                Set Success_is in Csid_found_it to true
		If Success_is in  Csid_chp_qual_cand	%^  (Chips_uid_id of Relget_adr_set NOT = SPACES )
		Then
                    Set Success_is in Csid_chips_candidate to true
                END-IF
            ELSE
                Set Success_is in Csid_failed_lookup to true
            END-IF
            If (Failure_is in Csid_chips_candidate   )
                Perform C780_CHIPS_OVERRIDE through C780_CHIPS_OVERRIDE_END
                If Success_is in Csid_ret_stat  
                    Set Success_is in Csid_chips_override to true
                    Move 1 to Chips_qualified_ls
                ELSE
                    Set Failure_is in Csid_found_it to true
                END-IF
            ELSE
* Try for further CHIPS qualification since UID is okay with participant
	        Call "CUST_EXTENDED_ID_QUAL"  USING
		    by Reference Bbk_idtype of Ent_credit_set
		    by Reference Bbk_id of Ent_credit_set
		    by Reference Bbk_id_length of Ent_credit_set_lengths
		    by Reference Bbk_idtype of Ent_credit_set
		    by Reference Bbk_id of Ent_credit_set
		    by Reference Bbk_id_length of Ent_credit_set_lengths
		    by Reference Csid_tmp_flg_ws
		    by Reference Csid_temp1_vstr
		    by Reference Csid_temp1_vstr_length
	          returning Csid_temp_stat

                 Call "CHIPS_QUALIFICATION_IDSTR"  USING
                    By reference Bbk_idtype of Bbk of Ent_credit_set
                    By reference Bbk_id of Bbk of Ent_credit_set
                    By reference Bbk_id_length of Ent_credit_set_lengths
                    By reference Csid_id_ws
                    By reference Csid_id_ws_length
                  RETURNING Csid_chips_party
                If (Success_is in Csid_chips_party   )
                    %Beg
                    Csid_compose ^OUT(Csid_party_id )
                        Csid_id_ws, / ;
		    %End
                ELSE
* Could have case of a COMMON UID and SWIFT TID.
                    Perform C670_CHECK_COMMON_UID thru
                            C670_CHECK_COMMON_UID_end
%^ spr 25062  -additional qualification rules by INTRTL
                    If (Swf_str_thru_qual_edt of Menu_cfg = "T")
		      AND (Failure_is in Csid_chips_party)
		    then
                       Perform C700_CHECK_SWIFT_QUAL thru
                               C700_CHECK_SWIFT_QUAL_END  
		    END-IF
%^ mper 48548 / spr 37490 
		    If ( Chips_double_id_flag of Menu_cfg = "T")
		      AND (Failure_is in Csid_chips_party)
		      AND (Success_is in Csid_try_chips)
		      AND (Success_is in Csid_try_chips)
		    then 
                        Perform C705_CHIPS_DOUBLE_ID thru
                            C705_CHIPS_DOUBLE_ID_END
		    END-IF
		END-IF
	    END-IF
            Set Failure_is in Csid_try_chips to TRUE
	    If (Success_is in Csid_chips_party   )
		Perform C610_UPDATE_BBK through C610_UPDATE_BBK_END
		Move 1 to Chips_qualified_ls
	    END-IF
            If (Success_is in Csid_chips_party   )
                OR (Success_is in Csid_chips_override   )
            THEN
                Add 1 to Advice_parties_ls
            ELSE
		    Call "CUST_CHP_UNQ_PASS"  using
			By Reference 	Unq_chips_overide
		If Success_is in Unq_chips_overide
		Then
			%beg
		        	Csid_compose ^OUT(Csid_info_memo)
      			      		"CHIPS payment; unqualified BNF ",
                    			 Ent_credit_set.Bbk.Bbk_idtype, "/",
                   			 Ent_credit_set.Bbk.Bbk_id, /;
		        %End
		        Perform X920_INFO_MEMO through X920_INFO_MEMO_END
			%^ Make this an Info message Not Error			
		Else
	                %Beg
       			         Csid_compose ^OUT(Csid_err_memo)
              			      	"CHIPS payment; unqualified BNF ",
                    		       	Ent_credit_set.Bbk.Bbk_idtype, "/",
                   		 	Ent_credit_set.Bbk.Bbk_id, /;
                	%End
               		 Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
		End-if
            END-IF
	    If Success_is in Csid_found_it  
	        GO TO B220_BBK_CLEANUP
	    ELSE
                If (Failure_is in Csid_failed_lookup   )
                    GO TO B220_BBK_END
                END-IF
	    END-IF
	END-IF.

	If (Bbk_rel_id of Ent_credit_set NOT = 0 )
* Must be a pushdown.
	    Add 1 to Advice_parties_ls
 	    GO TO B220_BBK_END
	END-IF.	    

	If ( (Bbk_name1_length of Ent_credit_set_lengths NOT = 0 ) 
             AND (Bbk_name1 of Ent_credit_set NOT = SPACES ) )
	   OR ( (Bbk_name2_length of Ent_credit_set_lengths NOT = 0 ) 
             AND (Bbk_name2 of Ent_credit_set NOT = SPACES ) )
	   OR ( (Bbk_name3_length of Ent_credit_set_lengths NOT = 0 ) 
             AND (Bbk_name3 of Ent_credit_set NOT = SPACES ) )
	   OR ( (Bbk_name4_length of Ent_credit_set_lengths NOT = 0 ) 
             AND (Bbk_name4 of Ent_credit_set NOT = SPACES ) )
	THEN
	    Set Failure_is in Csid_lc_noaddress to true
	ELSE
	    Set Success_is in Csid_lc_noaddress to true
	END-IF.

        Move Bbk_secwir of Bbk of Ent_credit_set to Csid_lc_secwir
	If (Bbk_idtype of Bbk of Ent_credit_set = SPACE)
	   AND (Failure_is in Csid_lc_noaddress   )
	THEN
%^ If one of the id's is a foreign account number, we cannot
%^  confirm the id so we cannot use any address information that we have.
%^  Skip the lookup.
	    Add 1 to Advice_parties_ls
	    GO TO B220_BBK_END
	END-IF.	    

%^ We still need to try the lookup
	Set BBK in Relget_title_flag to TRUE
        PERFORM C820_LOWER_CREDIT through C820_LOWER_CREDIT_END.
	If (Csid_ovr = "?" )
* An ambiguous case -- kick it back to the operator.
	    %Beg
	    Csid_compose ^OUT(Csid_err_memo)
		"Not Str Thru: Ambiguous BBK party ", Csid_ovr, 
			Ent_credit_set.BBK, / ;
	    %End
	    Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
	    Add 1 to Csid_ambig_parties
	    GO TO B220_BBK_END
	END-IF.

	If ( ( (Csid_ovr = SPACE ) OR (Csid_ovr = "*" ) )
	      AND (Success_is in Csid_ret_stat )
	      AND ( Success_is in Csid_lc_noaddress or 
		    Success_is in csid_non_ucc_src))
	THEN
	    Set Success_is in Csid_found_it to true
 	END-IF.

	Perform C610_UPDATE_BBK through C610_UPDATE_BBK_END.

	If ((Csid_ovr = SPACE ) OR (Csid_ovr = "*" )) AND
	    (Success_is in Csid_ret_stat ) And
	    (Failure_is in Csid_found_it )	%^ need to keep Name.address instact, remark as onREL/AUX
	Then
		%beg 	    Ent_credit_set(.bbk_rel_id = Relget_adr_set.rel_id,
	    		   		   .bbk_adr_set_ptr POINT: Relget_adr_set,
			   		   .flgs3.bbk_adr_ptr_ok = "T");
		%end
	End-if.

	If (Failure_is in Csid_found_it   )
	    GO TO B220_BBK_END
	END-IF.

B220_BBK_CLEANUP.
* Removed overflow from compose - obsolete
	%Beg
	Csid_compose ^OUT(Csid_id_ws) 
		Ent_credit_set.bbk.bbk_id, / ;
	Csid_idtype_ws = Ent_credit_set.bbk.bbk_idtype ;
	%End.  

	Call "SET_BBK_PARTY" USING
	    By reference Csid_idtype_ws
	    By reference Csid_id_ws
	    By reference Csid_id_ws_length
	    By reference Bank of Loc_info of Ent_ftr_set
	  RETURNING Csid_ret_stat.
	Add 1 to Advice_parties_ls.
B220_BBK_END.

   EXIT.
B240_IBK.
*  Paragraph to do account lookup on the IBK.  If Success_is in Csid_try_chips
*    when we get here, we will try to chips qualify it.
*    If that fails, we will look at the Ibk_rel_id element.  If it is set,
*    then we know that the IBK element was set up by a pushdown from the
*    Credit Party and no further lookup is necessary.  If it is not set,
*    then we do a REL lookup.  If the lookup succeeds, we copy in the name
*    and address info.  If it was found in the rel file, we set the Ibk_rel_id
*    and the Ibk_adr_set_ptr and copy in the Ibk_adv_inst.

	%Beg  Relget_msgcode = NULL;  %End.
	Set Failure_is in Csid_found_it to true.
	Set Failure_is in Csid_failed_lookup to true.
	Set Failure_is in Csid_chips_candidate to true.
	Set Failure_is in Csid_multi_party to true.
	Set Failure_is in Csid_chips_party to true.
	Set Failure_is in Csid_chips_override to true.
	Move SPACES to Csid_party_id.

	%^ If ID format is xxxxxxxxxx/(xxxxxxxxxxxx) remove everything
	%^ from the / onward it will be re-mapped.  
        %Beg
        Csid_parse ^IN(Ent_credit_set.Ibk.Ibk_id)
                Csid_temp1_vstr, "/(", ^STRING, ^SPACE, / ;
        %End

        If Success_is in Csid_parse_status
              %Beg
              Csid_compose ^OUT(Ent_credit_set.Ibk.Ibk_id)
                                Csid_temp1_vstr, / ;
              %End
        End-if.


* Removed overflow test - obsolete
	    %Beg  
	    Csid_parse ^IN(Ent_credit_set.Ibk.Ibk_id)
	    		Csid_party_id, ^SPACE, / ;
	    %End
	    If Success_is in Csid_parse_status  
	        %Beg
		Csid_parse ^IN(Csid_party_id),
		    ^ONEOF(
			(Csid_temp1_vstr, "/", 
				Csid_party_extype (^STRING<2>(<CHAR$M_ALPHA>)), 
				^STRING, ^SPACE, /),
			(Csid_temp1_vstr, "/??", ^STRING, ^SPACE, /));
	        %End
	        If (Success_is in Csid_parse_status   )
		    AND (Csid_temp1_vstr_length NOT = 0 )
		THEN
		    Set Success_is in Csid_multi_party to true
	        END-IF
	    END-IF.

	%Beg  Csid_party_idtype = Ent_credit_set.Ibk.Ibk_idtype ;  %End
	Perform X940_TAKEOUT_GARBAGE through X940_TAKEOUT_GARBAGE_END.
	If (Failure_is in Csid_had_garbage   )
	    PERFORM X960_SHUFFLE_IDS through X960_SHUFFLE_IDS_END
        END-IF.
	Perform C620_UPDATE_IBK through C620_UPDATE_IBK_END.
	If (Success_is in Csid_had_garbage   )
	    %Beg
	    Csid_compose ^OUT(Csid_err_memo)
		"Incorrect format in IBK ", Csid_party_idtype, 
		Csid_party_id, / ;         
	    %End
	    Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
	    Move 1 to Csid_ambig_parties
	    Set Failure_is in Csid_try_chips to TRUE
	    GO TO B240_IBK_END
	END-IF.

	If (Success_is in Csid_try_chips)
%^ Try for CHIPS qualification lookup.
            If (Success_is in Csid_do_rolldown)
		Perform C810_ROLL_DOWN through C810_ROLL_DOWN_END 
		If (Failure_is in Csid_do_rolldown)
%^ Successful rolldown, so readjust the IBK.
		    Perform C620_UPDATE_IBK through C620_UPDATE_IBK_END
		END-IF
            END-IF
	    If (Csid_party_id_length NOT > 0  )
		OR (Csid_party_id = SPACES )
	    THEN
* No ID to qualify
		If Failure_is in Unq_chips_overide
		Then
	                %Beg
       			         Csid_compose ^OUT(Csid_err_memo)
					"CHIPS payment; IBK not qualified: no ID.", /;  
                	%End
                	Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
		Else
	                %Beg
       			         Csid_compose ^OUT(Csid_info_memo)
					"CHIPS payment; IBK not qualified: no ID.", /;  
                	%End		     
		        Perform X920_INFO_MEMO through X920_INFO_MEMO_END
		End-if
               	Set Failure_is in Csid_try_chips to TRUE
	        GO TO B240_IBK_END
	    END-IF
	    Call "CUST_EXTENDED_ID_QUAL"  USING
		by Reference Csid_party_idtype
		by Reference Csid_party_id
		by Reference Csid_party_id_length
		by Reference Csid_party_idtype
		by Reference Csid_party_id
		by Reference Csid_party_id_length
		by Reference Ibk_idtype of Ent_credit_set
		by Reference Ibk_id of Ent_credit_set
		by Reference Ibk_id_length of Ent_credit_set_lengths
	      returning Csid_temp_stat

	    Call "CHIPS_QUALIFICATION"  USING
		By reference Csid_party_idtype
		By reference Csid_party_id
	      RETURNING Csid_ret_stat
	    If (Success_is in Csid_ret_stat   )
		Set Success_is in Csid_found_it to true
		If Success_is in  Csid_chp_qual_cand	%^  (Chips_uid_id of Relget_adr_set NOT = SPACES )
		Then
                    Set Success_is in Csid_chips_candidate to true
                END-IF
	    ELSE
                Set Success_is in Csid_failed_lookup to true
	    END-IF
	    If (Failure_is in Csid_chips_candidate   )
		Perform C780_CHIPS_OVERRIDE through C780_CHIPS_OVERRIDE_END
		If Success_is in Csid_ret_stat  
		    Set Success_is in Csid_chips_override to true
		    Move 1 to Chips_qualified_ls
		ELSE
		    Set Failure_is in Csid_found_it to true
                END-IF
            ELSE
* Try for further CHIPS qualification since UID is okay with participant
	        Call "CUST_EXTENDED_ID_QUAL"  USING
		    by Reference Ibk_idtype of Ent_credit_set
		    by Reference Ibk_id of Ent_credit_set
		    by Reference Ibk_id_length of Ent_credit_set_lengths
		    by Reference Ibk_idtype of Ent_credit_set
		    by Reference Ibk_id of Ent_credit_set
		    by Reference Ibk_id_length of Ent_credit_set_lengths
		    by Reference Csid_tmp_flg_ws
		    by Reference Csid_temp1_vstr
		    by Reference Csid_temp1_vstr_length
	          returning Csid_temp_stat

                Call "CHIPS_QUALIFICATION_IDSTR"  USING
                    By reference Ibk_idtype of Ibk of Ent_credit_set
                    By reference Ibk_id of Ibk of Ent_credit_set
                    By reference Ibk_id_length of Ent_credit_set_lengths
                    By reference Csid_id_ws
                    By reference Csid_id_ws_length
                  RETURNING Csid_chips_party
                If (Success_is in Csid_chips_party   )
		    %Beg
                    Csid_compose ^OUT(Csid_party_id )
                        Csid_id_ws, / ;
		    %End
                ELSE
* Could have case of a COMMON UID and SWIFT TID.
                    Perform C670_CHECK_COMMON_UID thru
                            C670_CHECK_COMMON_UID_end
%^ spr 25062  -additional qualification rules by INTRTL
                    If (Swf_str_thru_qual_edt of Menu_cfg = "T")
		      AND (Failure_is in Csid_chips_party)
		    then
                       Perform C700_CHECK_SWIFT_QUAL thru
                               C700_CHECK_SWIFT_QUAL_END  
		    END-IF
%^ mper 48548 / spr 37490 
		    If ( Chips_double_id_flag of Menu_cfg = "T")
		      AND (Failure_is in Csid_chips_party)
		      AND (Success_is in Csid_try_chips)
		    then 
                        Perform C705_CHIPS_DOUBLE_ID thru
                            C705_CHIPS_DOUBLE_ID_END
		    END-IF
		END-IF
	    END-IF
            Set Failure_is in Csid_try_chips to TRUE
	    If (Success_is in Csid_chips_party   )
		Perform C620_UPDATE_IBK through C620_UPDATE_IBK_END
		Move 1 to Chips_qualified_ls
	    END-IF
            If (Success_is in Csid_chips_party   )
                OR (Success_is in Csid_chips_override   )
            THEN
                Add 1 to Advice_parties_ls
            ELSE
		    Call "CUST_CHP_UNQ_PASS"  using
			By Reference 	Unq_chips_overide
		If Success_is in Unq_chips_overide
		Then
			%beg
		        	Csid_compose ^OUT(Csid_info_memo)
      			      		"CHIPS payment; unqualified BNF ",
                    			 Ent_credit_set.Ibk.Ibk_idtype, "/",		%^ icr_000689
                   			 Ent_credit_set.Ibk.Ibk_id, /;
		        %End
		        Perform X920_INFO_MEMO through X920_INFO_MEMO_END
			%^ Make this an Info message Not Error			
		Else
	                %Beg
       			         Csid_compose ^OUT(Csid_err_memo)
              			      	"CHIPS payment; unqualified BNF ",
                    		       	Ent_credit_set.Ibk.Ibk_idtype, "/",
                   		 	Ent_credit_set.Ibk.Ibk_id, /;
                	%End
               		 Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
		End-if
            END-IF
	    If Success_is in Csid_found_it  
	        GO TO B240_IBK_CLEANUP
	    ELSE
                If (Failure_is in Csid_failed_lookup   )
                    GO TO B240_IBK_END
                END-IF
	    END-IF
	END-IF.

	If (Ibk_rel_id of Ent_credit_set NOT = 0 )
* Must be a pushdown.
	    Add 1 to Advice_parties_ls
 	    GO TO B240_IBK_END
	END-IF.	    

	If ( (Ibk_name1_length of Ent_credit_set_lengths NOT = 0 ) 
             AND (Ibk_name1 of Ent_credit_set NOT = SPACES ) )
	   OR ( (Ibk_name2_length of Ent_credit_set_lengths NOT = 0 ) 
             AND (Ibk_name2 of Ent_credit_set NOT = SPACES ) )
	   OR ( (Ibk_name3_length of Ent_credit_set_lengths NOT = 0 ) 
             AND (Ibk_name3 of Ent_credit_set NOT = SPACES ) )
	   OR ( (Ibk_name4_length of Ent_credit_set_lengths NOT = 0 ) 
             AND (Ibk_name4 of Ent_credit_set NOT = SPACES ) )
	THEN
	    Set Failure_is in Csid_lc_noaddress to true
	ELSE
	    Set Success_is in Csid_lc_noaddress to true
	END-IF.

        Move Ibk_secwir of Ibk of Ent_credit_set to Csid_lc_secwir
	If (Ibk_idtype of Ibk of Ent_credit_set = SPACE)
	   AND (Failure_is in Csid_lc_noaddress   )
	THEN
%^ If one of the id's is a foreign account number, we cannot
%^  confirm the id so we cannot use any address information that we have.
%^  Skip the lookup.
	    Add 1 to Advice_parties_ls
 	    GO TO B240_IBK_END
	END-IF.	    

%^ We still need to try the lookup
	Set IBK in Relget_title_flag to TRUE
        PERFORM C820_LOWER_CREDIT through C820_LOWER_CREDIT_END.
	If (Csid_ovr = "?" )
* An ambiguous case -- kick it back to the operator.
	    %Beg
	    Csid_compose ^OUT(Csid_err_memo)
			"Not Str Thru: Ambiguous IBK party ", Csid_ovr, 
			Ent_credit_set.IBK, / ;
	    %End
	    Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
	    Add 1 to Csid_ambig_parties
	    GO TO B240_IBK_END
	END-IF.

	If ( ( (Csid_ovr = SPACE ) OR (Csid_ovr = "*" ) )
	      AND (Success_is in Csid_ret_stat )
	      AND ( Success_is in Csid_lc_noaddress or 
		    Success_is in csid_non_ucc_src))
	THEN
	    Set Success_is in Csid_found_it to true
	END-IF.

	Perform C620_UPDATE_IBK through C620_UPDATE_IBK_END.

	If ((Csid_ovr = SPACE ) OR (Csid_ovr = "*" )) AND
	    (Success_is in Csid_ret_stat ) And
	    (Failure_is in Csid_found_it )	%^ need to keep Name.address instact, remark as onREL/AUX
	Then
		%beg 	    Ent_credit_set(.ibk_rel_id = Relget_adr_set.rel_id,
	    		   		   .ibk_adr_set_ptr POINT: Relget_adr_set,
			   		   .flgs3.ibk_adr_ptr_ok = "T");
		%end
	End-if.

	If (Failure_is in Csid_found_it   )
	    GO TO B240_IBK_END
	END-IF.

B240_IBK_CLEANUP.
	Move SPACES to Csid_id_ws.
* Removed overflow from compose - obsolete
	%Beg
	Csid_compose ^OUT(Csid_id_ws) 
		Ent_credit_set.ibk.ibk_id, / ;
	Csid_idtype_ws = Ent_credit_set.ibk.ibk_idtype ;
	%End.  

	Call "SET_IBK_PARTY" USING
	    By reference Csid_idtype_ws
	    By reference Csid_id_ws
	    By reference Csid_id_ws_length
	    By reference Bank of Loc_info of Ent_ftr_set
	  RETURNING Csid_ret_stat.
	Add 1 to Advice_parties_ls.

B240_IBK_END.

   EXIT.
B260_IB1.
*  Paragraph to do account lookup on the IB1.  If Success_is in Csid_try_chips
*    when we get here, we will try to chips qualify it.
*    If that fails, we will look at the Ib1_rel_id element.  If it is set,
*    then we know that the IB1 element was set up by a pushdown from the
*    Credit Party and no further lookup is necessary.  If it is not set,
*    then we do a REL lookup.  If the lookup succeeds, we copy in the name
*    and address info.  If it was found in the rel file, we set the Ib1_rel_id
*    and the Ib1_adr_set_ptr and copy in the Ib1_adv_inst.

	%Beg  Relget_msgcode = NULL;  %End.
	Set Failure_is in Csid_found_it to true.
	Set Failure_is in Csid_failed_lookup to true.
	Set Failure_is in Csid_chips_candidate to true.
	Set Failure_is in Csid_multi_party to true.
	Set Failure_is in Csid_chips_party to true.
	Set Failure_is in Csid_chips_override to true.
	Move SPACES to Csid_party_id.

	%^ If ID format is xxxxxxxxxx/(xxxxxxxxxxxx) remove everything
	%^ from the / onward it will be re-mapped.  
        %Beg
        Csid_parse ^IN(Ent_credit_set.Ib1.Ib1_id)
                        Csid_temp1_vstr, "/(", ^STRING, ^SPACE, / ;
        %End
* Removed overflow setting - obsolete
        If Success_is in Csid_parse_status
               %Beg
               Csid_compose ^OUT(Ent_credit_set.Ib1.Ib1_id)
                                Csid_temp1_vstr, / ;
               %End
        End-if.

* Removed overflow test - obsolete
	%Beg  
	    Csid_parse ^IN(Ent_credit_set.Ib1.Ib1_id)
	    		Csid_party_id, ^SPACE, / ;
	%End
	If Success_is in Csid_parse_status  
		%Beg
		Csid_parse ^IN(Csid_party_id),
		   ^ONEOF(
			(Csid_temp1_vstr, "/", 
				Csid_party_extype (^STRING<2>(<CHAR$M_ALPHA>)), 
				^STRING, ^SPACE, /),
			(Csid_temp1_vstr, "/??", ^STRING, ^SPACE, /));
	        %End
	        If (Success_is in Csid_parse_status   )
		    AND (Csid_temp1_vstr_length NOT = 0 )
		THEN
		    Set Success_is in Csid_multi_party to true
	        END-IF
	END-IF.

	%Beg  Csid_party_idtype = Ent_credit_set.Ib1.Ib1_idtype ;  %End
	Perform X940_TAKEOUT_GARBAGE through X940_TAKEOUT_GARBAGE_END.
	If (Failure_is in Csid_had_garbage   )
	    PERFORM X960_SHUFFLE_IDS through X960_SHUFFLE_IDS_END
        END-IF.
	Perform C630_UPDATE_IB1 through C630_UPDATE_IB1_END.
	If (Success_is in Csid_had_garbage   )
	    %Beg
	    Csid_compose ^OUT(Csid_err_memo)
	    	"Incorrect format in IB1 ", Csid_party_idtype, 
		Csid_party_id, / ;         
	    %End
	    Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
	    Move 1 to Csid_ambig_parties
	    Set Failure_is in Csid_try_chips to TRUE
	    GO TO B260_IB1_END
	END-IF.

	If (Success_is in Csid_try_chips)
%^ Try for CHIPS qualification lookup.
            If (Success_is in Csid_do_rolldown)
		Perform C810_ROLL_DOWN through C810_ROLL_DOWN_END 
		If (Failure_is in Csid_do_rolldown )
%^ Successful rolldown, so readjust the Ib1.
		    Perform C630_UPDATE_IB1 through C630_UPDATE_IB1_END
		END-IF
	    END-IF
            If (Csid_party_id_length NOT > 0  )
                OR (Csid_party_id = SPACES )
	    THEN
* No ID to qualify
		If Failure_is in Unq_chips_overide
		Then
	                %Beg
       			         Csid_compose ^OUT(Csid_err_memo)
					"CHIPS payment; IB1 not qualified: no ID.", /;  
                	%End
                	Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
		Else
	                %Beg
       			         Csid_compose ^OUT(Csid_info_memo)
					"CHIPS payment; IB1 not qualified: no ID.", /;  
                	%End		     
		        Perform X920_INFO_MEMO through X920_INFO_MEMO_END
		End-if
               	Set Failure_is in Csid_try_chips to TRUE
	        GO TO B260_IB1_END
            END-IF
	    Call "CUST_EXTENDED_ID_QUAL"  USING
		by Reference Csid_party_idtype
		by Reference Csid_party_id
		by Reference Csid_party_id_length
		by Reference Csid_party_idtype
		by Reference Csid_party_id
		by Reference Csid_party_id_length
		by Reference Ib1_idtype of Ent_credit_set
		by Reference Ib1_id of Ent_credit_set
		by Reference Ib1_id_length of Ent_credit_set_lengths
	      returning Csid_temp_stat

            Call "CHIPS_QUALIFICATION"  USING
                By reference Csid_party_idtype
                By reference Csid_party_id
              RETURNING Csid_ret_stat
            If (Success_is in Csid_ret_stat   )
                Set Success_is in Csid_found_it to true
		If Success_is in  Csid_chp_qual_cand	%^  (Chips_uid_id of Relget_adr_set NOT = SPACES )
		Then
                    Set Success_is in Csid_chips_candidate to true
                END-IF
            ELSE
                Set Success_is in Csid_failed_lookup to true
            END-IF
            If (Failure_is in Csid_chips_candidate   )
                Perform C780_CHIPS_OVERRIDE through C780_CHIPS_OVERRIDE_END
                If Success_is in Csid_ret_stat  
                    Set Success_is in Csid_chips_override to true
                    Move 1 to Chips_qualified_ls
                ELSE
                    Set Failure_is in Csid_found_it to true
                END-IF
            ELSE
* Try for further CHIPS qualification since UID is okay with participant
	        Call "CUST_EXTENDED_ID_QUAL"  USING
		    by Reference Ib1_idtype of Ent_credit_set
		    by Reference Ib1_id of Ent_credit_set
		    by Reference Ib1_id_length of Ent_credit_set_lengths
		    by Reference Ib1_idtype of Ent_credit_set
		    by Reference Ib1_id of Ent_credit_set
		    by Reference Ib1_id_length of Ent_credit_set_lengths
		    by Reference Csid_tmp_flg_ws
		    by Reference Csid_temp1_vstr
		    by Reference Csid_temp1_vstr_length
	          returning Csid_temp_stat

                Call "CHIPS_QUALIFICATION_IDSTR"  USING
                    By reference Ib1_idtype of Ib1 of Ent_credit_set
                    By reference Ib1_id of Ib1 of Ent_credit_set
                    By reference Ib1_id_length of Ent_credit_set_lengths
                    By reference Csid_id_ws
                    By reference Csid_id_ws_length
                  RETURNING Csid_chips_party
                If (Success_is in Csid_chips_party   )
                    %Beg
                    Csid_compose ^OUT(Csid_party_id )
                        Csid_id_ws, / ;
                    %End
                ELSE
* Could have case of a COMMON UID and SWIFT TID.
                    Perform C670_CHECK_COMMON_UID thru
                            C670_CHECK_COMMON_UID_end
%^ spr 25062  -additional qualification rules by INTRTL
                    If (Swf_str_thru_qual_edt of Menu_cfg = "T")
		      AND (Failure_is in Csid_chips_party)
		    then
                       Perform C700_CHECK_SWIFT_QUAL thru
                               C700_CHECK_SWIFT_QUAL_END  
		    END-IF
%^ mper 48548 / spr 37490 
		    If ( Chips_double_id_flag of Menu_cfg = "T")
		      AND (Failure_is in Csid_chips_party)
		      AND (Success_is in Csid_try_chips)
		    then 
                        Perform C705_CHIPS_DOUBLE_ID thru
                            C705_CHIPS_DOUBLE_ID_END
		    END-IF
		END-IF
            END-IF
            Set Failure_is in Csid_try_chips to TRUE
            If (Success_is in Csid_chips_party   )
		Perform C630_UPDATE_IB1 through C630_UPDATE_IB1_END
		Move 1 to Chips_qualified_ls
	    END-IF
            If (Success_is in Csid_chips_party   )
                OR (Success_is in Csid_chips_override   )
            THEN
                Add 1 to Advice_parties_ls
            ELSE
		    Call "CUST_CHP_UNQ_PASS"  using
			By Reference 	Unq_chips_overide
		If Success_is in Unq_chips_overide
		Then
			%beg
		        	Csid_compose ^OUT(Csid_info_memo)
      			      		"CHIPS payment; unqualified BNF ",
                    			 Ent_credit_set.Ib1.Ib1_idtype, "/",		%^ icr_000689
                   			 Ent_credit_set.Ib1.Ib1_id, /;
		        %End
		        Perform X920_INFO_MEMO through X920_INFO_MEMO_END
			%^ Make this an Info message Not Error			
		Else
	                %Beg
       			         Csid_compose ^OUT(Csid_err_memo)
              			      	"CHIPS payment; unqualified BNF ",
                    		       	Ent_credit_set.Ib1.Ib1_idtype, "/",
                   		 	Ent_credit_set.Ib1.Ib1_id, /;
                	%End
               		 Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
		End-if
            END-IF
	    If Success_is in Csid_found_it  
	        GO TO B260_IB1_CLEANUP
	    ELSE
                If (Failure_is in Csid_failed_lookup   )
                    GO TO B260_IB1_END
                END-IF
	    END-IF
	END-IF.

	If (Ib1_rel_id of Ent_credit_set NOT = 0 )
* Must be a pushdown.
	    Add 1 to Advice_parties_ls
 	    GO TO B260_IB1_END
	END-IF.	    

	If ( (Ib1_name1_length of Ent_credit_set_lengths NOT = 0 ) 
             AND (Ib1_name1 of Ent_credit_set NOT = SPACES ) )
	   OR ( (Ib1_name2_length of Ent_credit_set_lengths NOT = 0 ) 
             AND (Ib1_name2 of Ent_credit_set NOT = SPACES ) )
	   OR ( (Ib1_name3_length of Ent_credit_set_lengths NOT = 0 ) 
             AND (Ib1_name3 of Ent_credit_set NOT = SPACES ) )
	   OR ( (Ib1_name4_length of Ent_credit_set_lengths NOT = 0 ) 
             AND (Ib1_name4 of Ent_credit_set NOT = SPACES ) )
	THEN
	    Set Failure_is in Csid_lc_noaddress to true
	ELSE
	    Set Success_is in Csid_lc_noaddress to true
	END-IF.

        Move Ib1_secwir of Ib1 of Ent_credit_set to Csid_lc_secwir
	If (Ib1_idtype of Ib1 of Ent_credit_set = SPACE)
	   AND (Failure_is in Csid_lc_noaddress   )
	THEN
%^ If one of the id's is a foreign account number, we cannot
%^  confirm the id so we cannot use any address information that we have.
%^  Skip the lookup.
	    Add 1 to Advice_parties_ls
 	    GO TO B260_IB1_END
	END-IF.	    

%^ We still need to try the lookup
	Set IBK in Relget_title_flag to TRUE                           
        PERFORM C820_LOWER_CREDIT through C820_LOWER_CREDIT_END.

	If (Csid_ovr = "?" )
* An ambiguous case -- kick it back to the operator.
	    %Beg
	    Csid_compose ^OUT(Csid_err_memo)
		"Not Str Thru: Ambiguous IB1 party ", Csid_ovr, 
				Ent_credit_set.IB1, / ;
	    %End
	    Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
	    Add 1 to Csid_ambig_parties
	    GO TO B260_IB1_END
	END-IF.

	If ( ( (Csid_ovr = SPACE ) OR (Csid_ovr = "*" ) )
	      AND (Success_is in Csid_ret_stat )
	      AND ( Success_is in Csid_lc_noaddress or 
		    Success_is in csid_non_ucc_src))
	THEN
	    Set Success_is in Csid_found_it to true
 	END-IF.
	Perform C630_UPDATE_IB1 through C630_UPDATE_IB1_END.

	If ((Csid_ovr = SPACE ) OR (Csid_ovr = "*" )) AND
	    (Success_is in Csid_ret_stat ) And
	    (Failure_is in Csid_found_it )	%^ need to keep Name.address instact, remark as onREL/AUX
	Then
		%beg 	    Ent_credit_set(.ib1_rel_id = Relget_adr_set.rel_id,
	    		   		   .ib1_adr_set_ptr POINT: Relget_adr_set,
			   		   .flgs3.ib1_adr_ptr_ok = "T");
		%end
	End-if.

	If (Failure_is in Csid_found_it   )
	    GO TO B260_IB1_END
	END-IF.

B260_IB1_CLEANUP.
	Move SPACES to Csid_id_ws.
* Removed overflow from compose - obsolete
	%Beg
	Csid_compose ^OUT(Csid_id_ws) 
		Ent_credit_set.ib1.ib1_id, / ;
	Csid_idtype_ws = Ent_credit_set.ib1.ib1_idtype ;
	%End.  

	Call "SET_IB1_PARTY" USING
	    By reference Csid_idtype_ws
	    By reference Csid_id_ws
	    By reference Csid_id_ws_length
	    By reference Bank of Loc_info of Ent_ftr_set
	  RETURNING Csid_ret_stat.
	Add 1 to Advice_parties_ls.

B260_IB1_END.

   EXIT.
B280_CREDIT_ADDR.
* Paragrph to do actual lookup of credit party.
%^
%^
	Set Failure_is in Csid_second_cdt_pass_ws to True.
	Set Failure_is in csid_multi_party to True.
	If ( (Cdt_idtype of Ent_credit_set = "S" )
	    AND (Success_is in Csid_swf_dualid_match6)
	    AND (Second_cdt_id_leng_ls NOT = 0 )
	    AND (Csid_second_id(2:2) NOT = "BC" ) )
	THEN
	    Perform C830_SWAP_CREDIT_IDS through C830_SWAP_CREDIT_IDS_END
	END-IF

	%Beg  Relget_msgcode = NULL;  %End.
* First set bank preference if there is one.
	MOVE SPACES to Csid_preferred_bank.

	Evaluate True
		When    (Cdt_idtype of Cdt_typ of Ent_credit_set = "A" ) AND
			(Preferred_fed_bnk_id of Menu_bnk_union not = SPACES )
			    MOVE Preferred_fed_bnk_id of Menu_bnk_union to Csid_preferred_bank
		When    (Cdt_idtype of Cdt_typ of Ent_credit_set = "P" ) AND 
			(Preferred_chp_bnk_id of Menu_bnk_union not = SPACES )
			    MOVE Preferred_chp_bnk_id of Menu_bnk_union to Csid_preferred_bank
	end-evaluate.

	If ( Cdt_idtype of Cdt_typ of Ent_credit_set = "A" ) And
	   ( Success_is in Fed_xbank_nopref_flg )
	Then
		Move Spaces to Csid_preferred_bank
		Move "Y" to csid_multibank_ws
	End-if.

	If (Csid_preferred_bank NOT = SPACES )
	   AND ( (Cdt_id of Cdt_typ of Ent_credit_set(1:3) NOT = 
							Csid_preferred_bank )
	   OR (Cdt_id of Cdt_typ of Ent_credit_set(4:1) NOT = ":" ) )
	THEN
	    %Beg
	    Csid_parse ^IN(Ent_credit_set.Cdt_typ.Cdt_id),
		 ^OPTION(^STRING<3>,":"), Csid_temp1_vstr, ^SPACE, /;
	    Csid_Compose ^OUT(Ent_credit_set.Cdt_typ.Cdt_id),
		 Csid_preferred_bank, ":", Csid_temp1_vstr, /;
	    %End
	END-IF.

%^ Perform the credit party lookup.
	%Beg  BREAK: Ent_c_adr_set ;  %End.
* Let's do a sanity check on the credit id.
	%Beg
	Csid_clip_compose ^OUT(Csid_party_id)
		Ent_credit_set.cdt_typ.cdt_id, / ;
	Csid_party_idtype = Ent_credit_set.cdt_typ.cdt_idtype ;
	Ent_credit_set.Cdt_adr_bnk_id = Ent_ftr_set.loc_info.Bank ;
	%End

	%^ For re-entrance, with no change, strip trailing / if present
	%^
	If Csid_party_id(csid_party_id_length:1) = "/" Then
		%^ we've already lookup this up on a prior pass, strip and
		%^ carry on, or exit?
		Set Success_is in Csid_second_cdt_pass_ws to True
		%beg csid_parse ^IN(ent_credit_set.cdt_typ.cdt_id) csid_party_id, "/",/;
		%end
	end-if.

%^ #108093 Use the credit party's country of residency or the menu_bnk_union.country_code
%^	   when the call to validate bban is made.  (Csid_iban_cntry_ws)
%^	   First try the country code of the Menu_bnk_union.  If that fails, then try the
%^	   country of residency of the Ent_credit_set.  If this also fails, then write the
%^	   warning message,  "Incorrect format in credit party".

	If (Src_code of Ent_ftr_set = "STO") Then %^ ONLY for STO's
		Move Spaces to Csid_iban_cntry_ws
		%Beg Csid_iban_cntry_ws =  ent_credit_set.bnp_mailing_country; %End
		    Perform X940_TAKEOUT_GARBAGE through X940_TAKEOUT_GARBAGE_END
		    If (Success_is in Csid_had_garbage)  And
		       (Src_code of Ent_ftr_set = "STO") And
		       Not(Success_is in Csid_val_iban_ret) 		 And
		       (Bnp_mailing_country of Ent_credit_set NOT = Country_code of Menu_bnk_union)
	   	    Then
	    		%Beg
			    Csid_iban_cntry_ws = Menu_bnk_union.Country_code;
	    		%End
	    		Perform X940_TAKEOUT_GARBAGE through X940_TAKEOUT_GARBAGE_END
	    	    End-if
	Else
		Move Spaces to Csid_iban_cntry_ws
		If Bnp_mailing_country of Ent_credit_set NOT = Spaces
		Then
			%Beg Csid_iban_cntry_ws = Ent_credit_set.bnp_mailing_country; %End
		Else
			%^ No country provided, try for On-Us
	    		%Beg
			    Csid_iban_cntry_ws = Menu_bnk_union.Country_code;
	    		%End
		End-if
		Perform X940_TAKEOUT_GARBAGE through X940_TAKEOUT_GARBAGE_END
	End-if.

	Set Failure_is in Csid_second_cdt_pass_ws to True. %^ flag only required for takeout_garbage

%^ #107870 If this is a STO and the validate_iban failed (csid_val_iban_ret),
%^	   the error is written	just as a warning and the STO will not be sent 
%^	   to an exceptions queue.

	If Success_is in Csid_bban_unstruct And
	   (Failure_Ignore_is in csid_val_iban_ret Or
	    Failure_Warning_is in csid_val_iban_ret)
	Then	%^ Could actually be a good account, lets see

		If csid_party_idtype = Spaces
		Then	%^ Try a D if no other type specified
			Move "D" to csid_party_idtype
		End-if
	
%^ Do the check-digit edit NOTE: Chkdgt changing the DDA is Should be supported here. 

		CALL "CHKDGT_EDIT" USING
		    by reference csid_party_idtype
       		    by reference csid_party_id
       		    by reference csid_party_id_length
		    by reference csid_gcheck_bank_id
		    by reference Csid_multibank_ws
	    	    by reference csid_temp1_vstr
	  	 RETURNING Csid_ret2_stat
		If Failure_is in Csid_ret2_stat		
	   		Set Success_is in Csid_had_garbage to true
		Else
			Set Failure_is in Csid_had_garbage to True
		END-IF
	End-if


	If (Success_is in Csid_had_garbage   )
	Then
	   If csid_struct_acct_ws = "Y" And
	      csid_party_idtype = " "
	   Then
		 %^ Add "*" to alow the IBAN/BBAN error message to take precidence
		 If csid_err_memo_length NOT = 0 Then
			%beg csid_save_err_memo = csid_err_memo; %end
		 end-if
		 %Beg
	    	 	Csid_compose ^OUT(Csid_err_memo)
	       	    		"*Incorrect format in credit party ", Ent_credit_set.cdt_typ, / ;
	   	%End
		Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
		%^ reset to IBAN check message will be present on join and be 1st
		%^ thing shown to operator
		if csid_save_err_memo_length NOT = 0 Then
			%beg csid_err_memo = csid_save_err_memo;
			     csid_save_err_memo = NULL;
			%end
		end-if
	    Else
	        %Beg
	    		Csid_compose ^OUT(Csid_err_memo)
	       	    		"Incorrect format in credit party ", Ent_credit_set.cdt_typ, / ;
	    	%End
	        Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
	    end-if

	    If Src_code of Ent_ftr_set = "STO" And
	       Not(Success_is in Csid_val_iban_ret) 
	    Then
		Continue
	    Else
		Move "*" to Csid_ovr
		%^ If there's an address pointer, hose it
                If  Cdt_rel_id of ent_credit_set not = 0 Or
		    Cdt_adr_ptr_ok of flgs3 of Ent_credit_set = "T"
		Then
                    %Beg
                	Ent_credit_set( .Cdt_rel_id        = <0> ,
                        	        .Cdt_adr_set_ptr DELETE ,
					.flgs3.cdt_adr_ptr_ok = Null) ;
                    %End
	 	End-if
	    	Move ZERO to Cdt_not_suspect_ls
            	%Beg
	    	    Ent_credit_set.Cdt_adr_bnk_id = Ent_ftr_set.Loc_info.Bank ; 
		%End
	    	GO TO B280_CREDIT_ADDR_CLEANUP
	    End-if
	END-IF.
	%^
	%^ Add the check here for the IBAN flag check. See if we need
	%^ to pushdown. 
	%^
	If ( Success_is in csid_iban_found) And 
	   ( idkey of Csid_bnk_code_rec_ws is NOT =  Spaces)  And
           ( Lock_cdt_party_ls = 0 )  	Then	%^ Don't mess with locked party
	   	%^ Fill in Pref Corr and setup for the Pushdown
		%^ First lets see if the Party is ON US
		Set Failure_is in csid_on_us_bnk_code to True
		If (idkey of Csid_bnk_code_rec_ws = Spaces)
		Then	%^ A little strange, but....
			Move csid_iban_cntry_ws to csid_bnk_code_bnk_ws
			%^ A little dual usage?
			Call "CUST_IS_ID_ON_US" using
				By Reference 	Csid_temp_party_id
				By Reference 	Csid_temp_party_id_length
				By Reference	csid_bnk_code_bnk_ws
			Returning  csid_on_us_bnk_code
			If success_is in Csid_on_us_bnk_code
			Then	%^ this is an on-us with no bank code,
				%^ use the temp as the Credit Party
				%beg Ent_credit_set.cdt_typ.cdt_id = csid_temp_party_id;
				     csid_party_id = csid_temp_party_id;
				%end
			End-if
		Else
			Call "CUST_IS_ID_ON_US" using
				By Reference 	idacc of idkey of csid_bnk_code_rec_ws
				By Reference 	idacc_length of csid_bnk_code_rec_ws_lengths
				By Reference	csid_bnk_code_bnk_ws
			Returning  csid_on_us_bnk_code
		End-if

		%^ 117071
		If Not (( Cross_Bank_Search OF Menu_cfg = "T" OR
		          Cross_Bank_Search OF Menu_cfg = "Y" ))  AND
		   (Csid_bnk_code_bnk_ws NOT =  Bank of Loc_info of Ent_ftr_set)
		THEN
			%^ Cross Bank not allowed, so Push down
			Set Failure_is in Csid_on_us_bnk_code to True
		End-if
		If Success_is in csid_on_us_bnk_code 
		Then
		   If csid_temp_party_id = cdt_id of cdt_typ of Ent_credit_set Then
		    	%^ On us bban, set D idtype and continue
			%beg csid_party_idtype = "D"; %end
		   Else
		      If (Csid_bnk_code_bnk_ws NOT =  Bank of Loc_info of Ent_ftr_set)
 			  %Beg    
	    			Csid_compose ^OUT(csid_pref_corr_rec.idkey)
					Csid_bnk_code_bnk_ws, ":", Csid_temp_party_id, / ;
		    	  %End
		      Else
			  %beg   csid_pref_corr_rec.idkey  = csid_temp_party_id;  %end
		      end-if
		      %^
		      %beg csid_pref_corr_rec.idtype = "D"; %end
	              Set SUBSTITUTE in Csid_do_pushdown to true
		      Set Failure_is in Csid_didansi_ws to TRUE
		      %^ was going to cleanup, 
	  	      Go To B280_CREDIT_ADDR_END
		    end-if
		Else 
			%beg
				ent_credit_set.cdt_typ.cdt_idtype = NULL; %^ clear for BBAN/IBAN
				csid_pref_corr_rec
					( .idkey  = csid_bnk_code_rec_ws.idkey,
					  .idtype = csid_bnk_code_rec_ws.idtype);
				Ent_ftr_set.change_fields(.CHG_BIC = "R",
							  .CHG_CDT = "R"); %^ 107268
			%end
			%^ IBAN Expansion check gave us a BIC, Push it
			Set PUSHDOWN in Csid_do_pushdown to TRUE
			%Beg
			    Csid_compose ^OUT(Csid_info_memo)
					"IBAN/BBAN Detected",
					Ent_credit_set.cdt_typ,
					" inserted  ",
					Csid_pref_corr_rec ,/ ;
			%End
			Perform X920_INFO_MEMO through X920_INFO_MEMO_END
		       Set Failure_is in Csid_didansi_ws to TRUE
	  	       %^ was going to cleanup, 
		       Go To B280_CREDIT_ADDR_END
		end-if
	end-if.

	If (Csid_party_idtype = "P" )
	   AND (Cdt_adv_typ of Ent_credit_set NOT = SPACES )
	   AND (Cdt_adv_flg of Flgs of Ent_ftr_set = "Y" )
	THEN
	    %^ Check to see if this a "P" equivalent advice type
%^ OBSELETE             Call "GET_PID_ADV_DATA" using

%^
%^ May beed a check on the CHANNEL allowable ID's
%^

	    IF Success_is in Csid_itsa_clearhouse
		%Beg
		Csid_temp1_vstr = NULL ;
		Csid_temp2_vstr = NULL ;
		Csid_temp3_vstr = NULL ;
		Csid_parse ^IN(Csid_party_id)
			^OPTION(Csid_temp1_vstr(^STRING<3>), ":" ),
			Csid_temp2_vstr, ^OPTION("/", Csid_temp3_vstr),
			^SPACE, / ;
		%End
		Subtract Csid_clrhs_suffix_length from Csid_temp2_vstr_length
			giving Csid_suffix_index
		Subtract 1 from Csid_suffix_index
%^ Check to see if suffix is already on P id; if not, and PID is numeric,
%^    assume we have a naked P_id and append the suffix.
		If (Csid_temp2_vstr(Csid_suffix_index:Csid_clrhs_suffix_length)
			   NOT = Csid_clrhs_suffix(1:Csid_clrhs_suffix_length ))
		   AND (Csid_temp2_vstr(1:Csid_temp2_vstr_length) is NUMERIC )
		THEN
		    If (Csid_temp1_vstr_length NOT = 0 )
		        %Beg
		        Csid_clip_compose ^OUT(Csid_party_id)
				Csid_temp1_vstr, ":", Csid_temp2_vstr,
				Csid_clrhs_suffix ;  %End
		    ELSE	
		        %Beg
		        Csid_clip_compose ^OUT(Csid_party_id)
				Csid_temp2_vstr, Csid_clrhs_suffix ;  %End
		    END-IF
		    IF (Csid_temp3_vstr_length NOT = 0 )
			%Beg
			Csid_clip_compose  "/", Csid_temp3_vstr, / ;  %End
		    ELSE
			%Beg
			Csid_clip_compose  / ;  %End
		    END-IF
		END-IF
	    END-IF
	END-IF.

	If (Cdt_id of Cdt_typ of Ent_credit_set NOT = Csid_party_id )
	    %Beg  Ent_credit_set.Cdt_typ.Cdt_id = Csid_party_id;  %end
	END-IF.
	If (Cdt_idtype of Cdt_typ of Ent_credit_set NOT = Csid_party_idtype )
	    %Beg  Ent_credit_set.Cdt_typ.Cdt_idtype = Csid_party_idtype;  %end
	END-IF.

	Set CDT in Relget_title_flag to TRUE
	Move SPACES to Csid_lookup_temp.
	%Beg  Csid_lookup_temp = Csid_party_id ;  %End

        If Failure_is in Csid_lcp_bypass_lookup  
        then

%^ #118341 If this is an ABA that is not on REL, but could be on AUX, then
%^	   set the Csid_party_idtype to "a" so that acct_lookup will begin
%^	   searching just the AUX file for the account.  Also do this for now
%^	   if this is a STO item.
%^ #107842 Include DFM also.

	    If (Src_code of Ent_ftr_set = ("STO" Or "DFM")) And
	       Csid_lcp_lookup_reason = 2      And
	       Csid_party_idtype = "A"		    	
	    Then
		Move "a" to Csid_party_idtype
	    End-if

	    Move "F" to Csid_lkup_pend_del
            Call "ACCT_LOOKUP" using               
                by reference Csid_party_idtype
                by reference Csid_lookup_temp
                by reference Csid_ovr
                by reference Csid_ambig_ws
                by reference Csid_multibank_ws
                by reference Credit_currency_ls
		by reference Csid_lkup_pend_del
              RETURNING Csid_ret_stat

	    If Csid_lkup_pend_del = "T"
		Set Success_is in Csid_credit_pend_del to TRUE
		Set Failure_is in Creditside_look_ls to TRUE
	    Else                                     %^ SPR 120610
		If (Success_is in Csid_ret_stat) or
		   (Relget_msgcode = Vmsg_dat_notonfile_wc ) then
		    If (Relget_return_key NOT = SPACES ) and 
		       (Relget_return_idtype = Csid_party_idtype) and
		       (Relget_return_key NOT = Csid_lookup_temp) then
			   %Beg Csid_parse ^IN(Relget_return_key),
				Ent_credit_set.cdt_typ.cdt_id, ^SPACE, /; %End
		    End-if
		End-if
            End-if 
	else
            %^ If we're bypassing the lookup of a locked credit party,
            %^ set up all the fields that Acct_lookup would normally
            %^ have returned.
	    Set Success_is in Csid_ret_stat to TRUE
            %Beg
            Csid_ovr = Ent_credit_set.cdt_typ.cdt_ovr;
	    BREAK: Relget_adr_set;
            Csid_lcp_adr_set EQUATE: Relget_adr_set (nomod);
            Relget_return_bank = Ent_credit_set.cdt_adr_bnk_id;
            Relget_return_idtype = Csid_party_idtype ;
            Relget_return_key = NULL;
            Relget_msgcode = NULL ;
            %End
        end-if.
	%^
	If ( Csid_ovr = " ") or
	   ( Relget_msgcode = Vmsg_dat_notonfile_wc ) Then
		%^ AUX HIT
		%beg Ent_credit_set.flgs3.cdt_adr_ptr_ok = "T"; %end
	end-if.

%^ Assume that there is no preferred correspondent (implied or otherwise).
	If (Csid_ovr = SPACE ) 
	    If (Bnk_id of Relget_adr_set NOT = SPACES )
		%Beg  
		Ent_credit_set.Cdt_adr_bnk_id = Relget_adr_set.bnk_id ;
                %End
            ELSE
		%Beg  
		Ent_credit_set.Cdt_adr_bnk_id = Ent_ftr_set.Loc_info.Bank ;
                %End
           END-IF
	   If (Relget_return_key NOT = SPACES )
		%Beg
		Csid_parse ^IN(Relget_return_key)
			Ent_credit_set.cdt_typ.cdt_id, ^SPACE, / ;
		%End
	   END-IF
	ELSE

%^ Check for lookup failed or ambiguous and clear credit party relation id 
%^     and stuff.
	    If %^ (Cdt_ovr of Cdt_typ of Ent_credit_set NOT = SPACE ) spr 113891
	       ( Csid_ovr NOT = Space) and 
	       ( Relget_msgcode NOT = Vmsg_dat_notonfile_wc ) THen
%^ NOF or ambiguous credit party. and NOT a direct AUX hit
		If %^ (Relget_msgcode NOT = Vmsg_dat_notonfile_wc ) AND
 		   (Cdt_shnam of Ent_credit_set NOT = SPACES )
		THEN
		    %Beg  Ent_credit_set.Cdt_shnam  = NULL ;  %End
		END-IF
		If (Cdt_rel_id of Ent_credit_set NOT = 0 )
		    %Beg
                    Ent_credit_set( .Cdt_rel_id       = <0> ,
                                    .Cdt_adr_set_ptr DELETE,
				    .flgs3.cdt_adr_ptr_ok = Null);
		    %End
		END-IF
		%^If (Relget_msgcode = Vmsg_dat_notonfile_wc ) Then
		%^	%beg
		%^	     break: ent_c_adr_set;
		%^	%end
		%^Else
		    %Beg
	                BREAK: Relget_adr_set;
       		        BREAK: Ent_c_adr_set;
		    %End
		%^End-if
	    END-IF

%^ If the party was not found in the REL, try an implied credit insertion
%^   of the 8 character ID.
	    If (Map_ho_insertion is = "C" OR "B")
	       AND (Cdt_idtype of Cdt_typ of Ent_credit_set = "S" )
	       AND (Ib1 of Ent_credit_set = SPACES )
	       AND (Ib1_name1 of Ent_credit_set = SPACES )
	    THEN	
	        PERFORM C680_CDT_SWF_PARENT thru C680_CDT_SWF_PARENT_END
		If (Idtype of Csid_pref_corr_rec NOT = SPACE )
* We have a pushdown, so go do it.
		    Set PUSHDOWN in Csid_do_pushdown to TRUE
		    Set Failure_is in Csid_didansi_ws to TRUE
		    %Beg
		    Csid_compose ^OUT(Csid_info_memo)
				"NOF Credit party ",
				Ent_credit_set.cdt_typ,
				" had home office ",
				Csid_pref_corr_rec, " on file."/ ;
		    %End
		    Perform X920_INFO_MEMO through X920_INFO_MEMO_END
		    GO TO B280_CREDIT_ADDR_CLEANUP
		END-IF
	    END-IF
	END-IF.

	IF (Csid_ovr NOT = SPACE )
	    If (Relget_msgcode = Vmsg_dat_notonfile_wc )
                If (Bnk_id of Relget_adr_set NOT = SPACES )
                    If Bnk_id of Relget_adr_set not = 
					      Cdt_adr_bnk_id of Ent_credit_set
                        %Beg
                        Ent_credit_set.Cdt_adr_bnk_id = Relget_adr_set.bnk_id ;
                        %End
                    end-if
                ELSE
                    If (Bank of Loc_info of Ent_ftr_set NOT = SPACES)
                        If Bank of Loc_info of Ent_ftr_set NOT =
                                Cdt_adr_bnk_id of Ent_credit_set
                            %Beg
                            Ent_credit_set.Cdt_adr_bnk_id = 
						    Ent_ftr_set.Loc_info.Bank ;
                            %End
                        END-IF
                    END-IF
                END-IF
	        If (Relget_return_key NOT = SPACES )
		    AND (Cdt_idtype of Cdt_typ of Ent_credit_set NOT = 
							Relget_return_idtype )
		THEN
	    	    %Beg
		    Ent_credit_set.cdt_typ.cdt_idtype = Relget_return_idtype ;
                    Csid_parse ^IN(Relget_return_key), 
			Ent_credit_set.cdt_typ.cdt_id, ^SPACE, / ;
		    %End
	        END-IF
%^ tc10007
%^ Should not default the channel  allow CHANNEL_DET to get it
%^
%^	        If (Cdt_idtype of Cdt_typ of Ent_credit_set = "A" )
%^		   AND (NOT (Src_code of Ent_ftr_set is = "FED")
%^		   	 AND (Incoming_msgtype of Ent_ftr_set (3:2) NOT = "31"))
%^		THEN
%^ If what we found was an ABA ID, change to an implicit fedwire.
%^		    %Beg
%^		    Ent_credit_set.cdt_adv_typ = "FED" ;
%^		    Ent_ftr_set.flgs.cdt_adv_flg = "Y" ;
%^		    %End
* Set fed bank preference if there is one
%^                    If (Preferred_fed_bnk_id of Menu_bnk_union not = SPACES ) and
%^                        Preferred_fed_bnk_id of Menu_bnk_union not =
%^                        Cdt_adr_bnk_id of Ent_credit_set then
%^                       %Beg
%^                        Ent_credit_set.cdt_adr_bnk_id =
%^                               Menu_bnk_union.preferred_fed_bnk_id;
%^                        %end
%^                        If ((Cdt_id of Cdt_typ of Ent_credit_set(1:3) NOT =
%^                                Cdt_adr_bnk_id of Ent_credit_set)
%^                        or (Cdt_id of Cdt_typ of Ent_credit_set(4:1) NOT = ":" ))
%^                        THEN
%^                            %Beg
%^                            Csid_parse ^IN(Ent_credit_set.Cdt_typ.Cdt_id),
%^                                ^OPTION(^STRING<3>,":"),
%^                                Csid_temp1_vstr, ^SPACE, /;
%^                            Csid_Compose ^OUT(Ent_credit_set.Cdt_typ.Cdt_id),
%^                                Menu_bnk_union.preferred_fed_bnk_id, ":",
%^                                Csid_temp1_vstr, /;
%^                            %End
%^                        END-IF
%^                     END-IF
%^	           END-IF
	    ELSE
	        If (Cdt_idtype of Cdt_typ of Ent_credit_set = "A" )
		   AND (Is_payment_ls NOT = 0 )
                   AND (Csid_ovr not = "?")
		THEN
* Not-on-file feds get caught here and booted to repair.
* It wasn't in the AUX or the REL so we have no FED Shortname
                    %^ If there's an address pointer, hose it
                    If  Cdt_rel_id of ent_credit_set not = 0  Or
		        Cdt_adr_ptr_ok of flgs3 of Ent_credit_set = "T"
		    then
                        %Beg
                        Ent_credit_set( .Cdt_rel_id        = <0> ,
                                        .Cdt_adr_set_ptr DELETE,
					.flgs3.cdt_adr_ptr_ok = Null) ;
                        %End
                    end-if
		    %Beg
                    Ent_credit_set.cdt_typ.cdt_ovr = Csid_ovr ;
                    Csid_compose ^OUT(Csid_err_memo)
			"Credit party ABA ", Ent_credit_set.Cdt_typ,
			" not found in REL or AUX.", / ;
		    %End
	            Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
		    Move ZERO to Cdt_not_suspect_ls 
		END-IF
            END-IF
%^ If a preferred FED/CHP bank id was inserted, make sure "Cdt_adr_bnk_id" 
%^ is in sync with the expanded Credit Id string.
	    Move SPACES to Csid_id_bank_ws
	    If (Csid_ovr = "*" )
                %Beg
		Csid_parse ^IN(Ent_credit_set.cdt_typ.cdt_id)
				Csid_id_bank_ws, ":", ^STRING, / ;
	        %End
	    END-IF
	    If (Csid_id_bank_ws = SPACES )
		%Beg  Csid_id_bank_ws = Ent_ftr_set.Loc_info.Bank ;  %End
	    END-IF
	    If (Cdt_adr_bnk_id of Ent_credit_set NOT = Csid_id_bank_ws )
		%Beg  Ent_credit_set.cdt_adr_bnk_id = Csid_id_bank_ws ;  %End
	    END-IF
	END-IF.

%^ If the credit party lookup is ambiguous and the second credit id is non-blank,
%^ attempt a lookup using the second credit id to resolve the ambiguity.
	If Csid_ovr = "?" and 
	        Relget_msgcode = Vmsg_ambig_lookup_wc and
		Second_cdt_id_ls > Spaces
	    If Second_cdt_id_ls(1:3) = "/BC"
	        Move Second_cdt_id_ls to Csid_temp1_vstr
		Move Second_cdt_id_leng_ls to Csid_temp1_vstr_length
	        %Beg
	        Csid_second_id = null;
                Csid_parse ^IN(Csid_temp1_vstr) 
                    ^STRING, "/BC", Csid_second_id,
                    ^ONEOF ( ("/", ^STRING, / ),
                             (/) );
	        %End

	        If Success_is in Csid_parse_status and Csid_second_id > Spaces
	            Perform C655_2ND_CREDIT_ID thru C655_2ND_CREDIT_ID_END

	            If Csid_qualified_rel not = Zero
%^ We have successfully disambiguated the credit address.	
		        %ace_conn_root_q Rel_index;
                        %Beg
		        BREAK: Relget_adr_set;
		        Rel_index ^SEARCH (Key = Csid_qualified_rel);
		        %End
		        If Success_is in Rel_index_status and
		                Object_is in Rel_index_cursor and
		                Address_is in Rel_type of Rel_index
		            %Beg
		            Rel_index CONN: Relget_adr_set(nomod);
		            Csid_ovr = " ";
		            Csid_parse ^IN(Ent_credit_set.Cdt_typ.Cdt_id)
			        Csid_id_bank_ws, ":", ^STRING, / ;
	            	    %End
		    	    If Csid_id_bank_ws = Spaces
			        %Beg  
			        Csid_id_bank_ws = Ent_ftr_set.Loc_info.Bank ;  
			        %End
			    End-if
		            %Beg  
		            Ent_credit_set.Cdt_adr_bnk_id = Csid_id_bank_ws ; 
		            %End
		        End-if
		    End-if
		End-if
	    End-if
	End-if.

	IF (Csid_ovr = "?" )
           AND (Relget_msgcode = vmsg_ambig_lookup_wc )
	   And (rel_id of Relget_adr_set NOT = 0)	%^ 122222 can't disambiguate an AUX by CUR
        THEN
	    Move ZERO to Csid_qualified_rel
	    If (Credit_currency_ls NOT = SPACES )
	    THEN
*  Credit party is ambiguous, so let's see if currency disambiguates it.
                Move Credit_currency_ls to Csid_currency_ws
	        PERFORM C660_FIND_ADR_CUR THRU C660_FIND_ADR_CUR_END
	    END-IF

	    If (Csid_qualified_rel NOT = 0 )
* We have successfully disambiguated the credit address.	
		%ace_conn_root_q Rel_index ;
                %Beg
		BREAK: Relget_adr_set ;
		Rel_index ^SEARCH (Key = Csid_qualified_rel);
		%end
		If (Success_is in Rel_index_status   )
		   AND (OBJECT_IS in Rel_index_cursor )
		   AND (ADDRESS_IS in Rel_type of Rel_index )
                THEN
		    %Beg
		    Rel_index CONN: Relget_adr_set(NOMOD) ;
		    Csid_ovr = " " ;
		    Csid_parse ^IN(Ent_credit_set.cdt_typ.cdt_id)
				Csid_id_bank_ws, ":", ^STRING, / ;
	            %End
		    If (Csid_id_bank_ws = SPACES )
			%Beg  
			Csid_id_bank_ws = Ent_ftr_set.Loc_info.Bank ;  
			%End
	    	    END-IF
		    %Beg  
		    Ent_credit_set.Cdt_adr_bnk_id = Csid_id_bank_ws ; 
		    %End
		END-IF
	    END-IF
	END-IF.
%^
%^ If the Shortname_search is T and the credit party lookup is ambiguous
%^ then attempt a lookup using the short name to resolve the ambiguity.
%^
        If (Search_shortname of Menu_cfg = "T" )
	   AND (Csid_ovr = "?")
	   AND (Relget_msgcode = vmsg_part_lookup_wc )
	   AND (Src_code of Ent_ftr_set = "SWF" or "FED")
	   AND (Failure_is in Csid_credit_pend_del)
	THEN
           Perform C690_Snam_Chck thru C690_Snam_Chck_end
            If (Csid_qualified_rel NOT = 0 )
* We have successfully disambiguated the credit address.
                %ace_conn_root_q Rel_index ;
                %Beg
                BREAK: Relget_adr_set ;
                Rel_index ^SEARCH (Key = Csid_rel_id);
                %end
                If (Success_is in Rel_index_status   )
                   AND (OBJECT_IS in Rel_index_cursor )
                   AND (ADDRESS_IS in Rel_type of Rel_index)
                THEN
                    %Beg
                    Rel_index CONN: Relget_adr_set(NOMOD) ;
                    Csid_ovr = " " ;
                    Csid_parse ^IN(Ent_credit_set.cdt_typ.cdt_idtype)
                                Csid_id_bank_ws, ":", ^STRING, / ;
                    %End
                    If (Csid_id_bank_ws = SPACES )
                        %Beg
                        Csid_id_bank_ws = Ent_ftr_set.Loc_info.Bank ;
                        %End
                    END-IF
                    %Beg
                    Ent_credit_set.Cdt_adr_bnk_id = Csid_id_bank_ws ;
                    %End
                END-IF
            END-IF
        END-IF.

        IF (Csid_ovr = "?" )
            If (Is_payment_ls NOT = 0 )
		If (Success_is in Csid_credit_pend_del)
	            %Beg
                    Csid_compose ^OUT(Csid_err_memo)
			    "Not Str Thru: Credit party marked for deletion ", 
				Csid_rel_id,  / ;
	            %End
                else
	            %Beg
                    Csid_compose ^OUT(Csid_err_memo)
				"Not Str Thru: Ambiguous credit party ", 
				Csid_rel_id,  / ;
	            %End
		END-IF
	        Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
		MOVE ZERO TO Cdt_not_suspect_ls
		Set Failure_is in Csid_credit_pend_del to TRUE

                %^ If there's an address pointer, hose it
                If  Cdt_rel_id of ent_credit_set not = 0 Or
		    Cdt_adr_ptr_ok of flgs3 of Ent_credit_set = "T"
		then
                    %Beg
                    Ent_credit_set( .Cdt_rel_id        = <0> ,
                                    .Cdt_adr_set_ptr DELETE,
				    .flgs3.cdt_adr_ptr_ok = Null) ;
                    %End
                end-if
                %Beg
                Ent_credit_set.cdt_typ.cdt_ovr = Csid_ovr ;
                Csid_compose ^OUT(Csid_err_memo)
                        "Not Str Thru: Ambiguous credit party ",
                        Ent_credit_set.cdt_typ,  / ;
                %End
                Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
                MOVE ZERO TO Cdt_not_suspect_ls
            END-IF
        END-IF.

B280_CREDIT_ADDR_CLEANUP.	
	%Beg  
	Ent_credit_set.cdt_typ.cdt_ovr = Csid_ovr ;
	BREAK: Csid_adr_set ;
	%End.
	IF (Cdt_ovr of Cdt_typ of Ent_credit_set = SPACE )
	    If (Cdt_adr_bnk_id of Ent_credit_set NOT = SPACES )
		AND (Cdt_adr_bnk_id of Ent_credit_set NOT = 
					Bank of Loc_info of Ent_ftr_set )
	    THEN
                %Beg  
		Csid_id_ws = Ent_credit_set.cdt_typ.cdt_id ;  
		Csid_parse ^IN(Csid_id_ws) ^STRING<3>, ":", ^STRING, / ;
		%End
		If (Failure_is in Csid_parse_status   )
%^ Must strip in the bank
		    %Beg
		    Csid_compose ^OUT(Ent_credit_set.cdt_typ.cdt_id)
				Ent_credit_set.Cdt_adr_bnk_id, ":",
				Csid_id_ws, / ;
		    %End
		END-IF
	    END-IF			
	    %Beg
		BREAK: Csid_adr_set;
		Relget_adr_set EQUATE: Csid_adr_set(NOMOD) ;  
		%^ For CREDIT_ADVICE_LOOKUP Maybe Obselete
		Relget_adr_set EQUATE: Ent_c_adr_set(NOMOD) ;
	    %End

	    %^ If we are On REL we need to set these earlier.
	    %^ I beleive they are cleared if we change parties.
	    %Beg
			Ent_credit_set( .Cdt_rel_id = Csid_adr_set.Rel_id,
		       		        .Cdt_adr_set_ptr POINT: Csid_adr_set,
					.flgs3.cdt_adr_ptr_ok = "T");
	    %End
	ELSE
	    If (Cdt_rel_id of Ent_credit_set = 0 )
		If (cdt_adr_ptr_ok of flgs3 of ent_credit_set = "T" ) Then
		     %^
		     %^ Need to check relget_adr_set status, Hybrid DDA id / BIC will not
		     %^ have suceeded if second time thru (eg retry server) If not connected, get it
		     %^
	   	     %Ace_is relget_adr_set connected;
		     If Failure_is in ace_status_wf
		     Then
		     	%beg 
			  ent_credit_set.cdt_adr_set_ptr CONN: relget_adr_set;
			%end
		     end-if
		     %beg 
			 %^ AUX record, leave connected to Prule setup
			 BREAK: Csid_adr_set;
			 Relget_adr_set EQUATE: Csid_adr_set(NOMOD) ;  
	     	      %end
		      Call "ACCTSUB_CDT_NOF"
		      %^ Reset now, after cleared by ACCTSUB_CDT_NOF
		      %beg ent_credit_set.flgs3.cdt_adr_ptr_ok = "T";
			   Ent_credit_set.Cdt_adr_set_ptr POINT: Relget_adr_set;
			   Relget_adr_set EQUATE: Ent_c_adr_set(NOMOD) ; 
	     	      %end
		Else
		        Call "ACCTSUB_CDT_NOF"
			%beg BREAK: RELGET_ADR_SET; %end
			If (cdt_idtype of Cdt_typ of Ent_credit_set = "S")  And
			   (Swift_adr_nof_warning of Menu_cfg = "T")
			THEN
				%Beg  csid_msg_mnemonic_ws =  "LKUP$_INV_SWIFT_ID";  %End
				Call "FORMAT_MSG_TO_TEXT" Using	
					By Reference csid_msg_mnemonic_ws
					By Reference csid_msg_mnemonic_ws_length
					by Value %siz(Csid_err_memo)
					by Reference Csid_err_memo
					By Reference Csid_err_memo_length
				%^
		        	Perform X900_error_memo THRU 
	           			X900_error_memo_end
			end-if
		end-if
		%beg
        	        BREAK: Ent_c_adr_set;
		%End
		If (Is_rptv_lookup_ls NOT = 0 )
		    Move "T" to Rptv_lookup_flg_ws
		ELSE
		    Move "F" to Rptv_lookup_flg_ws
		END-IF

	        MOVE "N" to Cdt_comm_charge_ws                             
	        MOVE "N" to Cdt_cbl_charge_ws
	    END-IF
	END-IF.

%^
%^ 	Attempt to get a Credit Country
%^
	If cdt_res_country of ent_credit_set = spaces
	    Initialize Csid_risk_country_ws, Csid_country_code_ws
	    If rel_id of relget_adr_set not = 0
		  %Ace_is relget_adr_set connected;
		  If success_is in ace_status_wf
	            Move risk_country of relget_adr_set to Csid_risk_country_ws
	            Move country_code of relget_adr_set to Csid_country_code_ws
		  end-if
	    end-if
	    Call "DETERM_RES_COUNTRY" using
	       by content "CDT"
	       by reference cdt_idtype of Ent_credit_set
	       by reference cdt_id of Ent_credit_set
	       by reference cdt_id_length of Ent_credit_set_lengths
	       by reference Csid_risk_country_ws
	       by reference Csid_country_code_ws
	       by reference cdt_res_country of Ent_credit_set
	       by reference Csid_res_country_ws
	    If Csid_res_country_ws not = spaces
	        %Beg Ent_credit_set.cdt_res_country = Csid_res_country_ws; %end
	    end-if
	end-if.

	If swf_subtype of relget_adr_set  = "BEID" or "CORP" or "MCCO" or "SMDP" or "TESP" or "TRCO"
	Then
		%beg  ent_credit_set.cdt_bei_flag = "Y"; %end
	else
		%beg  ent_credit_set.cdt_bei_flag = Null; %end
	end-if.

			
	%^ Update the Prule info
	Perform X980_CHANGE_CREDIT thru
		X980_CHANGE_CREDIT_END.

B280_CREDIT_ADDR_END.

   EXIT.

B300_SECOND_CREDIT.

%^ Paragraph checks credit address once we have decided on one against second
%^ credit identifier from message.  We return match status in
%^ Second_credit_matched_ls but we will continue trying to find account
%^ regardless.   Returned status has already been initialized to failure.
%^ It is possible that the second ID is null - this is the case if just an
%^ identifier type such as "FW" was specified as the payment method, with
%^ no ID - in that case, there is nothing to mis-match.
	If Csid_checkid_ws_length = 0 Then
	    Move 1 to Second_cdt_matched_ls
	    Go To B300_second_credit_end
	End-if.

	EVALUATE Csid_checkidt_ws
	    WHEN "N"
	        IF Csid_checkid_ws(1:Csid_checkid_ws_length) = 
			Sname_id of Csid_adr_set(1:Csid_checkid_ws_length)
	        THEN
		    Move 1 to Second_cdt_matched_ls
	        END-IF

	    WHEN "A"
	        IF Csid_checkid_ws(1:Csid_checkid_ws_length) = 
			Aba_id of Csid_adr_set
	        THEN
		    Move 1 to Second_cdt_matched_ls
	        END-IF
	
	    WHEN "S"

		If ( Success_is in Csid_swf_dualid_match6)
		Then	%^ Match on only the 1st 6 characters 132507
		        If Csid_checkid_ws(1:6) = Swift_id of Csid_adr_set(1:6)
		        Then
			    Move 1 to Second_cdt_matched_ls
		        End-if
		Else
		        IF Csid_checkid_ws(1:Csid_checkid_ws_length) = 
				Swift_id of Csid_adr_set(1:Csid_checkid_ws_length)
		        THEN
			    Move 1 to Second_cdt_matched_ls
		        END-IF
		End-if

	    WHEN "B"
	        IF Csid_checkid_ws(1:Csid_checkid_ws_length) = 
			Branch_id of Csid_adr_set
	        THEN
		    Move 1 to Second_cdt_matched_ls
	        END-IF

	    WHEN "C"
	        IF Csid_checkid_ws(1:Csid_checkid_ws_length) = 
		        Chips_uid_id of Csid_adr_set
	        THEN
		    Move 1 to Second_cdt_matched_ls
	        END-IF

	    WHEN "U"
	        IF Csid_checkid_ws(1:Csid_checkid_ws_length) = 
		        User_id of Csid_adr_set(1:Csid_checkid_ws_length)
	        THEN
		    Move 1 to Second_cdt_matched_ls
	        END-IF

	    WHEN "E"
		%beg
		BREAK: Relget_supp_id_seq;
		Csid_adr_set.Supplement_id_seq CONN: Relget_supp_id_seq ^FIRST (nomod);
		%end
		Move 0 to Second_cdt_matched_ls
		Perform until seq_end_is in Relget_supp_id_seq_cursor
			IF Csid_checkid_ws(1:Csid_checkid_ws_length) = 
				Idacc of Idkey of Rel_name_key of Relget_supp_id_seq
			  then	Move 1 to Second_cdt_matched_ls
				%beg
				END: Relget_supp_id_seq;
				%end
			  else	%beg
				NEXT: Relget_supp_id_seq;
				%end
			End-if
		End-perform

		If Second_cdt_matched_ls = 0
	        THEN
%^ Try a site-specific match if there is not an exact match
		    Call "CUST_MATCH_SECOND_ID" Using
			by content "CDT"
			by reference Csid_checkidt_ws
			by reference Csid_checkid_ws
			by reference Csid_checkid_ws_length
			by reference Csid_adr_set
		      RETURNING Csid_2nd_cdt_matched
		    IF Success_is in Csid_2nd_cdt_matched
			Move 1 to Second_cdt_matched_ls
		    ELSE
			Move ZERO to Second_cdt_matched_ls
		    END-IF
	        END-IF

	    WHEN "I"
	        IF Csid_checkid_ws(1:Csid_checkid_ws_length) = 
		        Interbnk_id of Csid_adr_set (1:Csid_checkid_ws_length)
	        THEN
		    Move 1 to Second_cdt_matched_ls
	        END-IF

	    WHEN "K"
	        IF Csid_checkid_ws(1:Csid_checkid_ws_length) = 
		        Customer_id of Csid_adr_set(1:Csid_checkid_ws_length)
      	        THEN
		    Move 1 to Second_cdt_matched_ls
       	        END-IF

            WHEN "P"
* Clearinghouse references are special.  If we have suffix(es), we must append
* each suffix to the P id and search for the result.
		%^ As of 1.2 the P idis no longer an account, check the
		%^ Participant field instead......
		%^
		If (Csid_suffixes_length = 0 )
* No suffixes.  Just use P Id.
		    If csid_checkid_ws =  Chips_id of Csid_adr_set
		    THEN
		        Move 1 to Second_cdt_matched_ls
		    END-IF
		ELSE
		    Perform UNTIL (Second_cdt_matched_ls NOT = 0)
				  OR (Csid_suffixes_length = 0 )
			%Beg
			Csid_parse ^IN(Csid_suffixes)
			    Csid_curr_suffix, ^ONEOF (
				    (",", Csid_more_suffixes(^STRING<-1>), / ),
				    (/) ) ;
			Csid_suffixes = Csid_more_suffixes ;
			Csid_compose ^OUT(Csid_temp1_vstr)
			    Csid_checkid_ws, Csid_curr_suffix, / ;
			%end
		        If csid_checkid_ws =  Chips_id of Csid_adr_set
		        THEN
		        	Move 1 to Second_cdt_matched_ls
		        END-IF
		    END-PERFORM
		END-IF
		If (Second_cdt_matched_ls NOT = 0)
                    %Beg
                    Ent_credit_set.cdt_typ.cdt_idtype = "P";
                    Csid_compose ^OUT(Ent_credit_set.cdt_typ.cdt_id)
			Csid_adr_set.Chips_id, / ;
                    %End
		END-IF

            WHEN OTHER
		%^ Could also be an IBAN,  Crack to account if possible.
		If csid_struct_acct_ws = "Y" Then
			Perform X2000_CHECK_SECOND_IBAN Thru
				X2000_CHECK_SECOND_IBAN_END
		End-if
		%^
		%^	If it's ours, csid_checkid_ws will be set to the cracked Account Number
		%^		
* Must be an account reference.  Check the account sequence for it.
		If Csid_checkidt_ws = SPACE
		    Move "D" to Csid_checkidt_ws
		END-IF
		%ACE_IS csid_adr_set connected giving Csid_conn_stat;
		%^ If not connected, leave as error status 96350
		If (Success_is in csid_conn_stat) 
		    %Beg
			Csid_adr_set.account_seq CONN: Csid_acc_seq(NOMOD) ;
 			SEARCH: Csid_acc_seq (GEQ, .Rel_name_key
						(.idbank = Csid_adr_set.Bnk_id,
						 .idtype = Csid_checkidt_ws,
						 .idkey  = Csid_checkid_ws ) ) ;
 		    %End
		    If (Success_is in Csid_acc_seq_status   ) And
		       (Csid_checkidt_ws = Idtype of Rel_name_key
		    				       of Csid_acc_seq) and
                       ( (Csid_checkid_ws(1:Csid_checkid_ws_length) =
		    	  Idacc of Idkey of Rel_name_key of Csid_acc_seq ) Or
			 (Csid_checkid_ws(1:Csid_checkid_ws_length) =
		    	  Idacc of Idkey of Rel_name_key
			of Csid_acc_seq(1:csid_checkid_ws_length) ))
		    THEN
		    	Move 1 to Second_cdt_matched_ls
                    	%Beg
                    	   Ent_credit_set.cdt_typ.cdt_idtype = Csid_checkidt_ws;
                    	   Csid_compose ^OUT(Ent_credit_set.cdt_typ.cdt_id)
			   Csid_checkid_ws, / ;
                    	%End
		    END-IF
		    %Beg  
			Csid_acc_seq(EQL) ;
			BREAK: Csid_acc_seq ;
		    %End
		end-if

	END-EVALUATE.

	If (Csid_checkidt_ws NOT = SPACE ) 
	   AND (Second_cdt_matched_ls = 0 )
	THEN
	    Set Success_is in Csid_bad_2nd_cdt to TRUE
            %Beg
            Csid_orig_credit.Csid_oc_idtype =
                                        Ent_credit_set.cdt_typ.cdt_idtype ;
            Csid_orig_credit.Csid_oc_id = Ent_credit_set.cdt_typ.cdt_id ;
            %End
	END-IF.

B300_SECOND_CREDIT_END.

   EXIT.
B320_SET_ADDRESS.
* Sets actual rel address linkages in Message's credit party.
        Move Priority_flg of Ent_ftr_set to Csid_hold_priority_ws
	Call "SET_CREDIT_ADDRESS" USING
	    By reference Is_rptv_lookup_ls
	  RETURNING Csid_ret_stat.

	%Beg
 	BREAK: Csid_acc_seq ;
	Ent_c_adr_set.account_seq CONN: Csid_acc_seq(NOMOD) ;
	%End

        If Priority_flg of Ent_ftr_set not = Csid_hold_priority_ws
            %Beg
            Csid_compose ^OUT(Csid_info_memo)
                    "Priority set to ", Ent_ftr_set.flgs.priority_flg,
                    " by credit party ",Ent_credit_set.cdt_typ(.cdt_idtype,
							    "/",.cdt_id) , / ;
            %End
            Perform X920_INFO_MEMO thru X920_INFO_MEMO_END
        End-if.

* Completed address setup.
	Set Success_is in Csid_set_address to TRUE.

B320_SET_ADDRESS_END.


   EXIT.
B330_PERFORM_FIND_ACC.

        Perform B340_FIND_ACCOUNT through 
		B340_FIND_ACCOUNT_END
%^ spr 43062 -see if there's an equivalent currency
%^            if so, try to get account in that currency			
        If (Csid_know_acc_id = SPACES )
         then
           Move Spaces to Csid_equiv_curr
           Call "GET_EQUIV_CURRENCY" USING
           By reference Csid_currency_ws
           By reference Csid_equiv_curr
              RETURNING Csid_equiv_status 
           If Success_is in Csid_equiv_status  
            then
              Move Csid_currency_ws to Csid_save_curr_ws
              Move Csid_equiv_curr to Csid_currency_ws
              Perform B340_FIND_ACCOUNT through 
	              B340_FIND_ACCOUNT_END
              If (Csid_know_acc_id = SPACES )
               then
                move Csid_save_curr_ws to Csid_currency_ws
              end-if
           end-if
        end-if.

B330_PERFORM_FIND_ACC_END.

   EXIT.
B340_FIND_ACCOUNT.
%^  Uses following algorithm to choose an account from our address:
%^	If address was found by using an account identifier ("D" or "G" or "F"
%^		or "V" or "P")                         
%^	    try the account which matches the identifier
%^	    If we find the account 
%^		    Check for another account with same id 
%^	ELSE
%^	    IF a specific account type has been requested
%^		look for an account of that type with a currency match
%^		If we find it
%^		    Check for another account of that type in that currency
%^		END-IF
%^	    ELSE  
%^	        look for the default account.
%^	        If we find it and its currency matches
%^		    We are done, since the default cannot be ambiguous.
%^	        ELSE
%^		    Fall through to search by currency below.
%^		END-IF
%^	    END-IF
%^	END-IF
%^ Search by currency:
%^	Step through the accounts for the address looking for a currency match.
%^	If we find it
%^	    Remember the account.
%^	    Continue searching for a second match (ambiguity detection).
%^	End-if
%^
%^ We return the account we found and the first ambiguous account.
%^ If the Csid_ambig_ws argument is "T", we will suppress ambiguity
%^ checking.
%^
%^ Default bank and currency for account search

	Move Cdt_acc_type_ls to Csid_idtype_ws.
	Move Cdt_acc_type_ls to Csid_idtype_ws.

	If Csid_irr_acc_type_ws Not = Space
	Then
		%^ override request with Channel Enforced Idtype
		Move csid_irr_acc_type_ws to Csid_idtype_ws
	end-if.
		
	%^ Check to see if this a "P" equivalent advice type
%^ 
%^Obselete  
%^%^        Call "GET_PID_ADV_DATA" using
%^
%^

        %Beg
        Csid_bank_curr_ws = Csid_bnk_union.Base_currency_id ;
        BREAK: Csid_acc_seq ;
        Ent_c_adr_set.account_seq CONN: Csid_acc_seq(NOMOD) ;
        %End.
%^ If we already know the account id, we can just exit
        If (Csid_know_acc_id NOT = SPACES)
	   AND (Csid_dupe_acc_ws = SPACES)
            GO TO B340_FIND_ACCOUNT_END
        end-if.
        %Beg
        Csid_dupe_acc_ws = NULL ;
        FIRST: Csid_acc_seq ;
        %End

	If (Failure_is in Csid_acc_seq_status   )
%^ We have no accounts for this address.
	    %Beg  BREAK: Csid_acc_seq ;  %End
	    If (Is_payment_ls NOT = 0 )
		AND (Success_is in Csid_musthave_acct   )
	    THEN
	        %Beg
                Csid_compose ^OUT(Csid_err_memo)
			"Not Str Thru: Credit party has no accounts.", / ;
		%End
	        Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
	    END-IF
	    GO TO B340_FIND_ACCOUNT_END
	END-IF.

	If (Cdt_idtype of Cdt_typ of Ent_credit_set =
					      "D" OR "G" OR "F" OR "V" OR "P" )
	THEN
%^ No account type restriction.  An account type was used to get the address.
%^ Let's try it.
	    Set Failure_is in Csid_found_account to TRUE
            %Beg
	    Csid_temp2_vstr = NULL ;
	    Csid_temp3_vstr = NULL ;
            Csid_parse ^IN(Ent_credit_set.cdt_typ.cdt_id),
                ^OPTION(Csid_temp2_vstr(^STR<3>),":"),
			Csid_acc_id_ws, ^ONEOF( ("/", Csid_temp3_vstr, /)
						(^SPACE, /) );
	    %End
	    If (Success_is in Csid_parse_status )
	      AND (Csid_acc_id_ws_length NOT = 0 )
	    THEN
	        If (Cdt_idtype of Cdt_typ of Ent_credit_set = "P")
		  AND (SUCCESS_IS in Csid_itsa_clearhouse)
		THEN
%^ Check for naked PID which needs suffix.
		    Subtract Csid_clrhs_suffix_length from
				Csid_acc_id_ws_length giving Csid_suffix_index
		    If (Csid_clrhs_suffix_length NOT = 0 )
		        Subtract Csid_clrhs_suffix_length from
					Csid_clrhs_max_length giving Csid_length
		        If ( (Csid_acc_id_ws_length < Csid_length )
			     OR (Csid_acc_id_ws_length = Csid_length ) )
 		          AND ( Csid_acc_id_ws(1:Csid_acc_id_ws_length) is
									NUMERIC)
		        THEN
%^ Append suffix to naked P/ID.
			    %Beg
			    Csid_temp1_vstr = Csid_acc_id_ws ;
			    Csid_compose ^OUT(Csid_acc_id_ws)
				  Csid_temp1_vstr, Csid_clrhs_suffix, / ;
			    %End
			    If (Csid_temp2_vstr_length NOT = 0 )
			        %Beg
			        Csid_compose ^OUT(Ent_credit_set.Cdt_typ.Cdt_id)
					Csid_temp2_vstr, ":", Csid_acc_id_ws ;
			        %End
			    ELSE
			        %Beg
			        Csid_compose ^OUT(Ent_credit_set.Cdt_typ.Cdt_id)
					Csid_acc_id_ws ;
			        %End
			    END-IF
		            If (Csid_temp3_vstr_length NOT = 0 )
			        %Beg
				Csid_compose "/", Csid_temp3_vstr, / ;  %End
			    ELSE
			        %Beg  Csid_compose  / ;  %End
			    END-IF
			END-IF
		    END-IF
		END-IF
	        %BEG
	        SEARCH: Csid_acc_seq ( FORWARD, GEQ, .Rel_name_key
			    ( .Idbank = Ent_credit_set.cdt_adr_bnk_id,
	    		      .Idtype = Ent_credit_set.cdt_typ.cdt_idtype,
			      .Idkey.Idacc = Csid_acc_id_ws ) ) ;
                %End
	        PERFORM UNTIL (Failure_is in Csid_acc_seq_status   )
			      OR (Success_is in Csid_found_account)
		    If (Success_is in Csid_acc_seq_status   )
		      AND (Idbank of Rel_name_key of Csid_acc_seq =
					Cdt_adr_bnk_id of Ent_credit_set )
		      AND (Idtype of Rel_name_key of Csid_acc_seq =
				  Cdt_idtype of Cdt_typ of Ent_credit_set )
		      AND (Idacc of Rel_name_key of Csid_acc_seq =
								Csid_acc_id_ws )
		    THEN
		        If (Disp_nof of Csid_acc_seq = "*") 
		          AND (Rtn_dflt_acct of Menu_cfg = "Y")
		        THEN
                            %Beg
 	    		    Csid_acc_seq EQUATE: Csid_accdef_seq(NOMOD);
			    SCAN: Csid_accdef_seq(NEQ, Key = " " ) ;
			    %End
                            If Success_is in Csid_accdef_seq_status   then
                                %beg
			        BREAK: Csid_acc_seq;
			        Csid_accdef_seq EQUATE: Csid_acc_seq(NOMOD);
			    	BREAK: Csid_accdef_seq;
			        %End
		                Perform X880_CHECK_CURRENCY through 
							X880_CHECK_CURRENCY_END
	    		        If (SUCCESS_IS in Csid_curr_ok_ws )
				    Set SUCCESS_IS in Csid_found_account to TRUE
				ELSE
			            %Beg
	        	            Csid_compose ^OUT(Csid_err_memo)
				    	"Default account ", 
				        Csid_acc_seq .rel_name_key.idtype, "/" ,
				    	Csid_acc_seq .rel_name_key.idkey.idacc,
				          " has an incompatible currency",/;
	        	            %End
	                            Perform X900_ERROR_MEMO through 
							X900_ERROR_MEMO_END
				    Set Failure_is in Creditside_look_ls to true
                                    %Beg BREAK: Csid_accdef_seq; %End
		    	            GO TO B340_FIND_ACCOUNT_END
			        END-IF
			    ELSE
			        %Beg
	        	     	Csid_compose ^OUT(Csid_err_memo)
				    "No default account assigned to replace ", 
				        Csid_acc_seq .rel_name_key.idtype,
					 "/" ,
				    Csid_acc_seq .rel_name_key.idkey.idacc,
					  /;
	        	    	%End
	                    	Perform X900_ERROR_MEMO through 
							    X900_ERROR_MEMO_END
		    	    	Set Failure_is in Creditside_look_ls to true
                            	%Beg BREAK: Csid_accdef_seq; %End
		    	    	GO TO B340_FIND_ACCOUNT_END
		 	    END-IF
       	    		    %Beg BREAK: Csid_accdef_seq; %End
		        END-IF
			If (FAILURE_IS in Csid_found_account)
		   	    If (Csid_acc_id_ws_length = 0 )
		                Perform X880_CHECK_CURRENCY through 
			    				X880_CHECK_CURRENCY_END
			        If (Csid_curr_ok_ws NOT = 0 )
				    Set SUCCESS_IS in Csid_found_account to TRUE
			        END-IF
			    ELSE
			        Set SUCCESS_IS in Csid_found_account to TRUE
			    END-IF
		        END-IF
		    END-IF
		    If (Failure_is in Csid_found_account)
		          %Beg  NEXT: Csid_acc_seq ;  %End
		    END-IF
	        END-PERFORM
	    END-IF

*  Should now have either matching account in correct currency or a miss.
	    If (Success_is in Csid_found_account)
*  It's a hit.
		%Beg
		Csid_know_acc_id.Idtype = 
				Csid_acc_seq.rel_name_key.idtype ;
		Csid_know_acc_id.Idbank = 
				Csid_acc_seq.rel_name_key.idbank ;
		Csid_know_acc_id.Idkey = 
				Csid_acc_seq.rel_name_key.idkey.idacc ;
		%End
		If (Csid_ambig_ws NOT = "T" )
		    Perform C740_CHECK_DUPE through C740_CHECK_DUPE_END
		END-IF
	    	GO TO B340_FIND_ACCOUNT_END
	    END-IF
	END-IF.	%^ End of Address gotten via Account Id

%^ If advice is via a clearinghouse
%^	IF Success_is in Csid_itsa_clearhouse
%^	Removed OBSELETE logic. Clearhouse accounts now come from Channel
%^	END-IF.


%^ TEMP setting F above, Test and clean up
%^ Need to try the Hierarchy defined by FOR, shoot for F first

	If Csid_idtype_ws = Space Then
		%^ First look for a DEfault in Currency
		Perform B345_FIND_DEFAULT_ACCOUNT Thru
		        B345_FIND_DEFAULT_ACCOUNT_END
		If Csid_know_acc_id NOT = Spaces Then
		    Go to B340_FIND_ACCOUNT_END
		Else
		    %^  Else fall into a Nostro in Currency
		    Move "F" to csid_idtype_ws
		end-if
	end-if.

	If (Csid_idtype_ws NOT = SPACE) Then
	    Set Failure_is in Csid_found_it to TRUE
%^ Need to find a specific idtype.
	    %Beg
	        BREAK: Csid_acc_seq ;	%^ Start Fresh again
        	Ent_c_adr_set.account_seq CONN: Csid_acc_seq(NOMOD) ;
	    	Csid_acc_seq EQUATE: Csid_acctyp_seq(NOMOD);
	    	SCAN: Csid_acctyp_seq (FORWARD, EQL, .Rel_name_key 
			                    (.Idkey = NULL,
					     .Idtype = Csid_idtype_ws )) ;
	    %End
	    If Success_is in Csid_acctyp_seq_status
		Perform B350_CHECK_ACCOUNT thru
			B350_CHECK_ACCOUNT_END
	    	If Csid_know_acc_id = Spaces Then
			%^ Shoot for a D then
			Move "D" to Csid_idtype_ws
		    	%beg
				Break: csid_acctyp_seq;
			    	Csid_acc_seq EQUATE: Csid_acctyp_seq(NOMOD);
				SCAN: Csid_acctyp_seq (FORWARD, EQL, .Rel_name_key 
				                    (.Idkey = NULL,
						     .Idtype = Csid_idtype_ws )) ;
			%End
			If (Failure_is in Csid_acctyp_seq_status) Then
				%^ Not found by type , just look for a match
				%beg break: csid_acctyp_seq; %end
				GO TO B340_FIND_ACCOUNT_EXIT
			Else
				Perform B350_CHECK_ACCOUNT thru
					B350_CHECK_ACCOUNT_END
				If csid_know_acc_id  Not = spaces Then
				   Go to B340_FIND_ACCOUNT_END
				end-if
			End-if
		end-if
	    Else
		%^ Shoot for a D then
		Move "D" to Csid_idtype_ws
		%beg
			Break: csid_acctyp_seq;
			Csid_acc_seq EQUATE: Csid_acctyp_seq(NOMOD);
			SCAN: Csid_acctyp_seq (FORWARD, EQL, .Rel_name_key 
				                    (.Idkey = NULL,
						     .Idtype = Csid_idtype_ws )) ;
		%End
		If (Failure_is in Csid_acctyp_seq_status) Then
			%^ Not found by type , just look for a match
			%beg break: csid_acctyp_seq; %end
			GO TO B340_FIND_ACCOUNT_EXIT
		Else
			Perform B350_CHECK_ACCOUNT thru
				B350_CHECK_ACCOUNT_END
			If csid_know_acc_id  Not = spaces Then
			   Go to B340_FIND_ACCOUNT_END
			end-if
		End-if
	    end-if
	    GO TO B340_FIND_ACCOUNT_END
	END-IF.

B340_FIND_ACCOUNT_EXIT.

* No account info specified -- just try for the default.
	Perform B345_FIND_DEFAULT_ACCOUNT thru
		B345_FIND_DEFAULT_ACCOUNT_END.
	If Csid_know_acc_id NOT = Spaces Then
	    Go to B340_FIND_ACCOUNT_END
	end-if.

* If we get here, we couldn't find a match on an account id (probably due to
*    currency mismatch) or we currency-mismatched with the default or there
*    was no default.  In any case, we would now like to try for a currency 
*    match.
        %Beg
        BREAK: Csid_acc_seq ;
        Ent_c_adr_set.account_seq CONN: Csid_acc_seq(NOMOD) ;
        FIRST: Csid_acc_seq ;
        %End.
	If (Xbank_account_ok_ls = 0 )
* Position ourselves into the correct bank -- it's the top of the key
	    Perform UNTIL ( (Failure_is in Csid_acc_seq_status   )
			    OR (Idtype of Rel_name_key 				%^ Don't allow L's
					    of Csid_acc_seq NOT = "P" AND "Y" AND "L") )
		%Beg  NEXT: Csid_acc_seq;  %End
	    END-PERFORM
	    Perform UNTIL (Idbank of Rel_name_key of Csid_acc_seq =
					      Cdt_adr_bnk_id of Ent_credit_set )
			  OR (Failure_is in Csid_acc_seq_status   )
		%Beg  NEXT: Csid_acc_seq ;  %End
		Perform UNTIL ( (Failure_is in Csid_acc_seq_status   )
			  	OR (Idtype of Rel_name_key 			%^ Don't allow L's
					   of Csid_acc_seq NOT = "P" AND "Y" AND "L" ) )
		    %Beg  NEXT: Csid_acc_seq;  %End
		END-PERFORM
	    END-PERFORM
	END-IF.
	PERFORM C760_FIND_ACC_CUR through C760_FIND_ACC_CUR_END
	If (Success_is in Csid_curr_ok_ws)
* We found one account.  Remember it.
	    %Beg
	    Csid_know_acc_id.Idtype = Csid_acc_seq.rel_name_key.idtype ;
	    Csid_know_acc_id.Idbank = Csid_acc_seq.rel_name_key.idbank ;
	    Csid_know_acc_id.Idkey = Csid_acc_seq.rel_name_key.idkey.idacc ;
	    %End
	    If (Csid_ambig_ws NOT = "T" )
	        %Beg  NEXT: Csid_acc_seq ;  %End
		Perform UNTIL ( (Failure_is in Csid_acc_seq_status   )
			       OR (Idtype of Rel_name_key 
					    of Csid_acc_seq NOT = "P" AND "Y" and "L") )
		    %Beg  NEXT: Csid_acc_seq;  %End
		END-PERFORM
	        If (Success_is in Csid_acc_seq_status   )
		   AND ( ( (Xbank_account_ok_ls = 0 )
                           AND ( Cdt_adr_bnk_id of Ent_credit_set  =
			      Idbank of Rel_name_key of Csid_acc_seq) )
			 OR (Xbank_account_ok_ls NOT = 0 ) )
		THEN
               	    PERFORM C760_FIND_ACC_CUR through C760_FIND_ACC_CUR_END
		    If (Success_is in Csid_curr_ok_ws)
* Alas, we have a second currency hit.
			%Beg
			Csid_dupe_acc_ws.Idtype =
				Csid_acc_seq.rel_name_key.idtype ;
			Csid_dupe_acc_ws.Idbank =
				Csid_acc_seq.rel_name_key.idbank ;
			Csid_dupe_acc_ws.Idkey =
				Csid_acc_seq.rel_name_key.idkey.idacc ;
			%End
		    END-IF
		END-IF
	    END-IF
	END-IF.
B340_FIND_ACCOUNT_END.

   EXIT.


B345_FIND_DEFAULT_ACCOUNT.

	%Beg
		BREAK: Csid_accdef_seq;
		Ent_c_adr_set.account_seq CONN: Csid_accdef_seq(NOMOD);
		SCAN: Csid_accdef_seq(NEQ, Key = " " ) ;
	%End
	If (Disp_default of Csid_accdef_seq NOT = SPACES )
	   AND (Idtype of Rel_name_key of Csid_accdef_seq NOT = "P" AND "Y" AND "L" )
	THEN
* There was a default account.
	    %Beg
		    BREAK: Csid_acc_seq ;
		    Csid_accdef_seq EQUATE: Csid_acc_seq;
		    BREAK: Csid_accdef_seq ;
	    %End
	    Perform X880_CHECK_CURRENCY through X880_CHECK_CURRENCY_END
	    If (Success_is in Csid_curr_ok_ws )
* It matches!
		%Beg
		Csid_know_acc_id.Idtype = Csid_accdef_seq.rel_name_key.idtype ;
	        Csid_know_acc_id.Idbank = Csid_accdef_seq.rel_name_key.idbank ;
		Csid_know_acc_id.Idkey =
				     Csid_accdef_seq.rel_name_key.idkey.idacc ;
		%End
	    ELSE
	   	%Beg  BREAK: Csid_acc_seq;  %End
	    END-IF
	else
		%beg Break: csid_accdef_seq; %end
	END-IF.

B345_FIND_DEFAULT_ACCOUNT_END.
	EXIT.

B350_CHECK_ACCOUNT.
%^
%^ IF FOUND BY TYPE, check for Dup and Currency Matche
%^
%^
	    %Beg
	    	BREAK: Csid_acc_seq ;
	    	Csid_acctyp_seq EQUATE: Csid_acc_seq(NOMOD);
	    	BREAK: Csid_acctyp_seq;
	    %End
	    PERFORM UNTIL (Success_is in Csid_found_it )
			  OR (Failure_is in Csid_acc_seq_status )
		If (Idtype of Rel_name_key of Csid_acc_seq = Csid_idtype_ws )
		    Set Success_is in Csid_found_it to TRUE
		END-IF
		If (Success_is in Csid_found_it )
		   AND (Xbank_account_ok_ls = 0 )
		   AND (Idbank of Rel_name_key of Csid_acc_seq NOT =
					      Cdt_adr_bnk_id of Ent_credit_set )
		THEN
		    Set Failure_is in Csid_found_it to TRUE
		END-IF
		If (Success_is in Csid_found_it)
		    Perform X880_CHECK_CURRENCY through X880_CHECK_CURRENCY_END
		    If (Failure_is in Csid_curr_ok_ws )
			Set Failure_is in Csid_found_it to TRUE
		    END-IF
		END-IF

* We have a winner.
	       If (Success_is in Csid_found_it ) Then

		  If (Csid_know_acc_id = SPACES )
		  Then
		    %^ First time around
		    %Beg
		        Csid_know_acc_id.Idtype = Csid_acc_seq.rel_name_key.idtype ;
		        Csid_know_acc_id.Idbank = Csid_acc_seq.rel_name_key.idbank ;
		        Csid_know_acc_id.Idkey =
					Csid_acc_seq.rel_name_key.idkey.idacc ;
		    %End
		    If (Csid_ambig_ws NOT = "T" )
		    Then	
			If (Disp_default of Csid_acc_seq = SPACES )
			Then	%^ If Disp_default is set, use the default 
				%^ Keep going so we can look for an ambiguity.
				Set Failure_is in Csid_found_it to TRUE
			End-if
		    END-IF
		  ELSE
		    If Disp_default of Csid_acc_seq NOT = spaces
		    Then %^ We have found a default, so no dups use default Tc9542
			%beg
				Csid_know_acc_id.Idtype = Csid_acc_seq.rel_name_key.idtype ;
			        Csid_know_acc_id.Idbank = Csid_acc_seq.rel_name_key.idbank ;
			        Csid_know_acc_id.Idkey =
						Csid_acc_seq.rel_name_key.idkey.idacc ;
				Csid_dupe_acc_ws = Null;
			%end
		    Else
			    %^ We have a duplicate.
			    %Beg
			        Csid_dupe_acc_ws.Idtype = Csid_acc_seq.rel_name_key.idtype ;
			        Csid_dupe_acc_ws.Idbank = Csid_acc_seq.rel_name_key.idbank ;
			        Csid_dupe_acc_ws.Idkey = 
					   Csid_acc_seq.rel_name_key.idkey.idacc ;
			    %End
			    %^ Still need to keep going, we may have a default avaiable 
			    Set Failure_is in Csid_found_it to True
		    end-if
		  END-IF
		End-if
		If Failure_is in Csid_found_it then
		    %Beg  NEXT: Csid_acc_seq;  %End
		END-IF
	    END-PERFORM.

B350_CHECK_ACCOUNT_END.
	EXIT.
B360_SET_ACCOUNT.
%^ Finds actual credit account set, hooks it up, and copies necessary info.
	%ACE_IS Ent_c_acc_set connected giving Csid_conn_stat;
	If (Failure_is in Csid_conn_stat)
	    %ace_conn_root_q Rel_acc_index ;
	    %Beg
	    SEARCH: Rel_acc_index (FORWARD, GEQ, .Rel_name_key 
				(.Idbank        = Csid_know_acc_id.Idbank,
				 .Idtype        = Csid_know_acc_id.Idtype,
				 .Idkey (.Idacc = Csid_know_acc_id.Idkey,
				         .Idadr = NULL,
					 .Idpad = NULL ) ) ) ;
            %End
	    If (Failure_is in Rel_acc_index_status   )
	       OR (Idbank of Rel_name_key of Rel_acc_index NOT =
						Idbank of Csid_know_acc_id )
	       OR (Idtype of Rel_name_key of Rel_acc_index NOT =
						Idtype of Csid_know_acc_id )
	       OR (Idacc of Idkey of Rel_name_key of Rel_acc_index NOT =
						Idkey of Csid_know_acc_id )
	    THEN
	        %Beg
	        Csid_compose ^OUT(Csid_err_memo)
		     "Cannot connect to credit account ", Csid_know_acc_id, / ;
	        %End
	        Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
		%Beg  	Rel_acc_index (EQL) ;  %End
	        GO TO B360_SET_ACCOUNT_END
	    END-IF
	    %Beg  Rel_acc_index CONN: Ent_c_acc_set(NOMOD,
			REG: Ent_c_acc_rel_reg (NOMOD)) ;
	    %End
	    If (Failure_is in Rel_acc_index_status   )
	       OR (Failure_is in Ent_c_acc_set_status   )
	    THEN
 	        %Beg
	        Csid_compose ^OUT(Csid_err_memo)
			    "Cannot connect to credit account ", 
			    Csid_know_acc_id, / ;
	        %End
	        Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
		%Beg  	Rel_acc_index (EQL) ;  %End
		GO TO B360_SET_ACCOUNT_END
	    END-IF 
	END-IF.

        Call "SET_CREDIT_ACCOUNT" USING
	        By reference Credit_account_ls
	        By reference Is_rptv_lookup_ls
		By reference Special_fee_key_ls
	RETURNING Csid_ret_stat.

* Completed account setup.
	Set Success_is in Csid_set_account to TRUE
	Add 1 to Advice_parties_ls
	Move Currency_id of Ent_c_acc_set to Cdt_currency_found_ls
	If (Cdt_currency_found_ls = SPACES )
	THEN
	    Move Base_currency_id of Csid_bnk_union to Cdt_currency_found_ls
	END-IF.
	%Beg  	Rel_acc_index (EQL) ;  %End.
B360_SET_ACCOUNT_END.

   EXIT.
B380_MAGIC_BNP.
* The second credit check failed against the original credit party,
* we are doing CHIPS qualification at the BNP level, and the BNP is blank.
* The second credit id could be the BNP id via the CHIPS QUALIFICATION 
* lookup.
	Set Failure_is in Csid_found_it to true.
	Set Failure_is in Csid_chips_candidate to true.
	Set Failure_is in Csid_multi_party to true.
	Set Failure_is in Csid_chips_party to true.
	Set Failure_is in Csid_chips_override to true.
	Move SPACE to Csid_savcdt_idt
	%Beg  Csid_savcdt_id = NULL ;  %End
	If (Failure_is in Csid_try_chips)
* We can just let "normal" CHIPS qualification take care of validating the
*   second credit id as a possible BNP and then skip the formatting.
	    %ACE_IS Ent_c_adr_set connected giving Csid_conn_stat;
	    If (Success_is in Csid_conn_stat)
	        %Beg
	        BREAK: Csid_acctyp_seq ;
	        Ent_c_adr_set.account_seq CONN: Csid_acctyp_seq(NOMOD) ;
	        SCAN: Csid_acctyp_seq ( FORWARD, EQL,
			.Rel_name_key (.Idtype = "P",
					    .Idkey ( .Idacc = NULL,
				       		     .Idadr = NULL,
				       		     .Idpad = NULL ) ) ) ;
		Csid_chips_stat = Csid_acctyp_seq status ;
		BREAK: Csid_acctyp_seq ;

	        %End
	        If (Success_is in Csid_chips_stat   )
		    %Beg
		    Csid_savcdt_idt = Ent_credit_set.Cdt_typ.Cdt_idtype ;
		    Csid_savcdt_id = Ent_credit_set.Cdt_typ.Cdt_id ;		
		    Ent_credit_set.Cdt_typ.Cdt_idtype = "P" ;
		    Ent_credit_set.Cdt_typ.Cdt_id = 
			       Csid_acctyp_seq .Rel_name_key.Idkey.Idacc ;
		    %End
                    Move Credit_currency_ls to Csid_savcdt_currency
		ELSE
   		    GO TO B380_MAGIC_BNP_END
		END-IF
	    ELSE
		GO TO B380_MAGIC_BNP_END
	    END-IF
        ELSE
* For CHIPS, we always do the rolldown.
            Move SPACES to Csid_party_id
            %Beg
            Csid_party_idtype = Csid_2aid_idt ;
            Csid_party_id = Csid_2id_ws ;
            %End
            Perform C600_UPDATE_BNP through C600_UPDATE_BNP_END
            %Beg
            Csid_compose ^OUT(Csid_info_memo)
                "Second credit ID ", Csid_2id_ws, " rolled down to BNF.", / ;
            %End
            Perform X920_INFO_MEMO through X920_INFO_MEMO_END
	END-IF.
	Move Csid_2aid_idt to Csid_idtype_ws.
	Call "CUST_EXTENDED_ID_QUAL"  USING
	    by Reference Csid_2aid_idt
	    by Reference Csid_2aid_id
	    by Reference Csid_2aid_id_length
	    by Reference Csid_2aid_idt
	    by Reference Csid_2aid_id
	    by Reference Csid_2aid_id_length
	    by Reference Bnp_idtype of Ent_credit_set
	    by Reference Bnp_id of Ent_credit_set
	    by Reference Bnp_id_length of Ent_credit_set_lengths
	  returning Csid_temp_stat

	CALL "CHIPS_QUALIFICATION" USING
	    By reference Csid_2aid_idt
	    By reference Csid_2aid_id
	  RETURNING Csid_ret_stat
	If (Success_is in Csid_ret_stat   )
	   AND ( Success_is in  Csid_chp_qual_cand)
	THEN
	    If (Csid_savcdt_id_length NOT = 0 )
%^ Pseudo_qualification
            	If (Swift_id of Relget_adr_set NOT = SPACES )
		   OR (Aba_id of Relget_adr_set NOT = SPACES )
		THEN
		    Set Success_is in Csid_found_it to true
		    If (Swift_id of Relget_adr_set NOT = SPACES )
			%Beg 
			Csid_idtype_ws = "S" ;
			Csid_id_ws = Relget_adr_set.Swift_id ;
			%End
		    ELSE
			%Beg 
			Csid_idtype_ws = "A" ;
			Csid_id_ws = Relget_adr_set.ABA_id ;
			%End
		    END-IF
                    If (Success_is in Csid_found_it   )
                        %Beg
                        Csid_compose ^OUT(Csid_info_memo)
                                "Second credit ID ", Csid_2id_ws,
                                " rolled down to BNF.", / ;
                        %End
                        Perform X920_INFO_MEMO through X920_INFO_MEMO_END
                    END-IF
		END-IF
	    ELSE
%^ It really is CHIPS.
                Set Success_is in Csid_found_it to true
                If (Csid_2aid_idt = "C" OR "S" )
                   AND (Csid_2bid_idt = "C" OR "S" )
		THEN
%^ Could be a common UID
                    If (Cdt_rel_id of Ent_credit_set NOT = 0 )
                        AND ( ( (Csid_2aid_idt = "S" )
                                 AND (Csid_2aid_id(1:8) =
                                        Swift_id of Ent_c_adr_set(1:8) ) )
                              OR ( (Csid_2bid_idt = "S" )
                                 AND (Csid_2bid_id(1:8) =
                                        Swift_id of Ent_c_adr_set(1:8) ) ) )
                    THEN
* Initialize Configuration lookup key
			%Beg
			Csid_union_key_ws(.Idname = "FED_CHIP_TABLES",
					  .Idprod = "MTS", 	   
			 		  .Idbank =  Menu_bnk_union.Bnk_id,    
			 		  .Idloc  = null,    	   
			 		  .Idcust = null);		  
   			Csid_compose ^OUT(Csid_item_key_ws),
						"CHP_COMMON_UIDS:", /; 
		 	Csid_seq_ordinal_ws = <1>;
			%End       
                        If (Csid_2aid_idt = "C" )
			    %Beg
			    Csid_compose ^OUT(Csid_match_key_ws),
					 		    Csid_2aid_id, /;
			    %End
			ELSE
			    %Beg
			    Csid_compose ^OUT(Csid_match_key_ws),
					 		    Csid_2bid_id, /;
			    %End
			END-IF
			Call "CFG_MATCH_ITEM" USING
			    BY Reference Idname of Csid_union_key_ws
			    BY Reference Idprod of Csid_union_key_ws
			    BY Reference Idbank of Csid_union_key_ws
			    BY Reference Idloc of Csid_union_key_ws
			    BY Reference Idcust of Csid_union_key_ws
			    BY Reference Csid_item_key_ws
			    BY Reference Csid_match_key_ws
			    BY Reference Csid_match_key_ws_length
			    BY Reference Csid_seq_ordinal_ws
			    BY Reference Csid_error_msg_ws
			    BY Reference Csid_error_msg_ws_length
            		  RETURNING Csid_chips_party
			IF Success_Is in Csid_chips_party
			    If (Csid_2aid_idt = "C" )
                                %Beg
                                Csid_id_ws = Csid_2id_ws ;
                                Csid_idtype_ws = Csid_2aid_idt ;
                                %End
			    ELSE
                                %Beg
                                Csid_compose ^OUT(Csid_id_ws )
                                        Csid_2bid_id, "/BC", Csid_2aid_id ;
                                Csid_idtype_ws = Csid_2bid_idt ;
                                %End
			    END-IF
                        END-IF
                    END-IF
                ELSE
                    If (Failure_is in Csid_chips_party   )
	        	Call "CUST_EXTENDED_ID_QUAL"  USING
			    by Reference Csid_2aid_idt
			    by Reference Csid_2aid_id
			    by Reference Csid_2aid_id_length
			    by Reference Csid_2aid_idt
			    by Reference Csid_2aid_id
			    by Reference Csid_2aid_id_length
			    by Reference Csid_tmp_flg_ws
			    by Reference Csid_temp1_vstr
			    by Reference Csid_temp1_vstr_length
		          returning Csid_temp_stat
                         %Beg  Csid_temp1_vstr = NULL ;  %End
                        Call "CHIPS_QUALIFICATION_IDSTR"  USING
                            By reference Csid_2aid_idt
                            By reference Csid_2id_ws
                            By reference Csid_2id_ws_length
                            By reference Csid_id_ws
                            By reference Csid_id_ws_length
                          Returning Csid_chips_party

%^                        If (Success_is in Csid_chips_party   )
%^                            %Beg Ent_credit_set.bnp_id_overflow CHANGE ;  %End
%^                        END-IF
                    END-IF
                    If Success_is in Csid_chips_party  
                        Move 1 to Chips_qualified_ls
                    END-IF
                END-IF
	    END-IF
        ELSE
            If (Csid_savcdt_id_length = 0 )
* Real CHIPS case.  See if we have an override qualification.
                Perform C780_CHIPS_OVERRIDE through C780_CHIPS_OVERRIDE_END
                If Success_is in Csid_ret_stat  
                    Set BNP in Relget_title_flag to TRUE
		    Move Spaces to Csid_lkup_pend_del	
                    Call "ACCT_LOOKUP" USING
                        by reference Csid_party_idtype
                        by reference Csid_party_id
                        by reference Csid_ovr
                        by reference Csid_ambig_ws
                        by reference Csid_multibank_ws
                        by reference Credit_currency_ls
			by reference Csid_lkup_pend_del
                      RETURNING Csid_ret_stat
                    If (Relget_msgcode = Vmsg_dat_notonfile_wc)
                        OR (Csid_ovr = SPACE )
                    THEN
                        Set Success_is in Csid_found_it to true
		        Set Success_is in Csid_chips_override to true
		        Move 1 to Chips_qualified_ls
		    END-IF
		END-IF
	    END-IF
	END-IF.
        If (Success_is in Csid_found_it   )
	    Set Failure_is in Csid_do_rolldown to TRUE
	    Set Failure_is in Csid_try_chips to TRUE
        END-IF.
*  Replace our credit party divot.
	If (Csid_savcdt_id_length NOT = 0 )
	    Move SPACES to Cdt_id of Cdt_typ of Ent_credit_set
	    %Beg
	    Ent_credit_set.cdt_typ (.cdt_idtype = Csid_savcdt_idt,
				    .cdt_id = Csid_savcdt_id ) ;
	    %End 
            Move Csid_savcdt_currency to Credit_currency_ls
	END-IF.
	If (Success_is in Csid_found_it   )
%^ Copy in address information.
	    Call "SET_BNP_PARTY" USING
	        By reference Csid_idtype_ws
	        By reference Csid_id_ws
	        By reference Csid_id_ws_length
	        By reference Bank of Loc_info of Ent_ftr_set
	      RETURNING Csid_ret_stat
	    Add 1 to Advice_parties_ls
	END-IF.
B380_MAGIC_BNP_END.
	EXIT.

B390_DO_SECOND_ID.
%^
%^ Compare the Secondary ID for consistency
%^

* Original credit party.

	If (Cdt_ovr of Cdt_typ of Ent_credit_set NOT = SPACE)  AND
	   NOT(Relget_msgcode = Vmsg_dat_notonfile_wc) %^ Aux hit
	Then
	    IF ( NOT ((Cdt_ovr of Cdt_typ of Ent_credit_set = "*" )
                        AND (Cdt_idtype of Cdt_typ of Ent_credit_set = "A" )
			AND (Cdt_adv_typ of Ent_credit_set = "FED" )))
	       AND (Csid_2aid_id_length NOT = 0 )
	    THEN
		If (Cdt_idtype of Ent_credit_set = "E" )
%^ Try a site-specific match if there is not an exact match
		    Call "CUST_MATCH_SECOND_ID" Using
			by content "CDT"
			by reference Csid_2aid_idt
			by reference Csid_2aid_id
			by reference Csid_2aid_id_length
			by reference Csid_adr_set
		      RETURNING Csid_2nd_cdt_matched
		    IF Success_is in Csid_2nd_cdt_matched
			Move 1 to Second_cdt_matched_ls
		    ELSE
			Move ZERO to Second_cdt_matched_ls
		    END-IF
	        END-IF
		If (Second_cdt_matched_ls = 0 )
 		    MOVE SPACES to Csid_party_id
		    %Beg
		    Csid_compose ^OUT(Csid_party_id),
			Ent_credit_set.cdt_typ.cdt_id, Csid_second_id, / ;
		    Csid_party_idtype = Ent_credit_set.cdt_typ.cdt_idtype ;  
		    %End
		    If Success_is in Csid_compose_status  
		        PERFORM X960_SHUFFLE_IDS through X960_SHUFFLE_IDS_END
		        If (Csid_party_idtype = SPACE )
			    Move "D" to Csid_party_idtype
		        END-IF
		        If (Csid_party_id_length > 64 )
                            Move 64 to Csid_party_id_length
		        END-IF
		        %Beg  
		        Ent_credit_set.cdt_typ(
					    .cdt_id     = Csid_party_id,
					    .cdt_idtype = Csid_party_idtype ) ;
		        %End
		    END-IF
                    %Beg
                    Csid_compose ^OUT(Csid_err_memo)
                    	"Credit party ", Ent_credit_set.cdt_typ,
                    	" not on file", /;
                    %End
                    Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
                    Move ZERO to Cdt_not_suspect_ls
		END-IF
	    END-IF
%^ Break the Relget_adr_set to avoid bogus AIN's left over from Debitside
            %Beg BREAK: Relget_adr_set; %End
	ELSE
	    If (Csid_2aid_id_length NOT = 0 )
	    Then
		If Not((Relget_msgcode = Vmsg_dat_notonfile_wc)  And %^ Skip Aux hit
		      (csid_party_idtype = "D" or " "))     	   %^ and Account match
	   	Then
			%Beg  
			Csid_checkid_ws = Csid_2aid_id ;  
			Csid_checkidt_ws = Csid_2aid_idt ;
			%End
			Perform B300_SECOND_CREDIT through B300_SECOND_CREDIT_END
			Set Failure_is in Csid_do_rolldown to TRUE
			If (Success_is in Csid_bad_2nd_cdt )
			    Set Success_is in Csid_do_rolldown to TRUE
			    Set Failure_is in Csid_bad_2nd_cdt to TRUE
			END-IF
			If (Csid_2bid_id_length NOT = 0 )
* We must also check the second second id.
			    Move Second_cdt_matched_ls to Csid_wascheck_ws
	       	            Move ZERO to Second_cdt_matched_ls
			    %Beg
				    Csid_checkid_ws = Csid_2bid_id ;
				    Csid_checkidt_ws = Csid_2bid_idt ;
			    %End
			    Perform B300_SECOND_CREDIT through  B300_SECOND_CREDIT_END
               		    If (Second_cdt_matched_ls NOT = Csid_wascheck_ws )
%^ Inconsistent results are a real no-no.
	   	      	 	 %Beg
		        		Csid_compose ^OUT(Csid_err_memo)
			    			"Inconsistent second credit IDs ", Csid_2aid_idt,
			    			"/", Csid_2aid_id, " and ", Csid_2bid_idt, "/", 
			    			Csid_2bid_id, / ;
		        	%End
	   			Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
		    		Add 1 to Csid_ambig_parties
                    	    END-IF
                	END-IF
	    	Else
 		    	MOVE SPACES to Csid_party_id
		    	%Beg
		    		Csid_compose ^OUT(Csid_party_id),
					Ent_credit_set.cdt_typ.cdt_id, Csid_second_id, / ;
		    		Csid_party_idtype = Ent_credit_set.cdt_typ.cdt_idtype ;  
		    	%End
		    	If Success_is in Csid_compose_status  
		       		PERFORM X960_SHUFFLE_IDS through X960_SHUFFLE_IDS_END
		        	If (Csid_party_idtype = SPACE )
			    		Move "D" to Csid_party_idtype
		        	END-IF
		        	If (Csid_party_id_length > 64 )
                           		Move 64 to Csid_party_id_length
		        	END-IF
		        	%Beg  
		        		Ent_credit_set.cdt_typ(
						    	.cdt_id     = Csid_party_id,
					    		.cdt_idtype = Csid_party_idtype ) ;
			        %End
			END-IF
		    	%Beg
         		  Csid_compose ^OUT(Csid_err_memo)
				"Second credit ID ", Csid_second_id, " not in credit party ", 
				Csid_orig_credit, / ;
	   	    	%End
                  	Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
                  	Move ZERO to Cdt_not_suspect_ls
		End-if
	    End-if
	END-IF.

B390_DO_SECOND_ID_END.
    EXIT.


B400_SET_ADVICE.

* Do not reset advice type if SCK.

	If (Cdt_adv_typ of ent_credit_set = "SCK") Or
	   (Is_payment_ls = 0) %^ adm type, no advice type 96190
	then
	   GO TO B400_SET_ADVICE_END
	End-if.

%^ #106399 similar to creditside_screen logic.
* Sets up advice type for new credit party.

	If (Cdt_adv_flg of Ent_ftr_set = "Y" )
	   AND (Cdt_adv_typ of Ent_credit_set = SPACES )
	THEN
	    %Beg  Ent_ftr_set.flgs.Cdt_adv_flg = " " ;  %End
	END-IF.

* Sets up advice type for new credit party.
	If (Csid_ain_advice NOT = SPACES )	

%^ #106399 use the same logic as in creditside_screen, include the "and"

           AND (Csid_opr_advice = SPACES )
	THEN
* Set up AIN override to look to Cdt_adv_lookup routine like operator override.
	    Move Csid_ain_advice to Cdt_adv_typ of Ent_credit_set
	    Move "Y" to Cdt_adv_flg of Ent_ftr_set
	END-IF.
	%^
	%^ First time through, this may not be set yet. Tentatively set to allow
	%^ SI's to be properly evaluated. #75468
	%^
	If (Bnp_bnk_flg of Ent_credit_set = SPACE OR "N" )
 	  AND (Bnp_idtype of bnp of ent_credit_set  = "B" OR "A" OR "S" )
	THEN
            %Beg  Ent_credit_set.Bnp_bnk_flg = "Y";  %End
	END-IF.
%^
%^
%^ This may not be our first pass. If CSID_KNOW_ACC_ID is filled, and the
%^ credit_account_ls is blank, clear the csid_know_acc_id field. It is
%^ leftover from an old channel
%^ SPR 105294
	If Csid_know_acc_id NOT = Spaces And
	   Credit_account_ls = Spaces Then
		%beg csid_know_acc_id = Null;
		     csid_chan_acc_ws = Null;
		%end
	end-if.

       	Set Success_is in Csid_musthave_acct to true.


	Perform X1010_PRECALC_CVD thru X1010_PRECALC_CVD_END.
        
	Call "CHANNEL_DETERMINATION" Using By reference Csid_false_ws
					   By Reference Csid_false_ws
					   By Content "   "
					   By Reference csid_chan_acc_ws
					   By Reference csid_chan_acc_ws_lengths
					   By Reference Csid_disable_AIN_ws
		returning Csid_chdet_stat_ws.

%^ JC moved this up to here to see if can fix trap on boa retest of 117492
	If (Failure_is in Csid_chdet_stat_ws) Then
                %^ Let alone, we still want to do AIN processing
		%^ Set Failure_is in Creditside_look_ls to true
		Go to B400_set_advice_end
	end-if.

	%^ Regardless, insert the account.
	%^
	If (Csid_know_acc_id = Spaces AND
	    Csid_chan_acc_ws NOT = Spaces) And
	   NOT(tran_type of Ent_ftr_set = "DDR") Then
	    If idkey of Csid_Chan_acc_ws NOT = Spaces
	    THen
		%^ Insert the Account returned from Channel_Determination
        	Set Failure_is in Csid_musthave_acct to true
		%beg Csid_know_acc_id(.idbank = Csid_chan_acc_ws.idbank,
				      .idtype = Csid_chan_acc_ws.idtype,
				      .idkey  = Csid_chan_acc_ws.idkey ) ; 
		%end
	    Else
		%^ ID type only returned, enforce that as account type to enforce
		If idtype of Csid_chan_acc_ws NOT = Spaces %^ Better not be spaces...
		Then
			%beg Csid_irr_acc_type_ws = Csid_chan_acc_ws.idtype; %end
		End-if
	end-if.

	Set ID_IS in csid_prchan_mode to True.
	If Cdt_adr_bnk_id of Ent_credit_set not = spaces then
		%Beg
		csid_chan_ident_ws.Idbank = Ent_credit_set.Cdt_adr_bnk_id;
		%End
	Else
		%Beg
		csid_chan_ident_ws.Idbank = Ent_ftr_set.Loc_info.Bank;
		%End
	End-if.

	%Beg
		csid_chan_ident_ws.idkey = Ent_credit_set.Cdt_adv_typ;
	%End
		
	Call "GET_CHANNEL" using
			By Reference 	Csid_prchan_mode
			By Reference	Csid_chan_ident_ws
			By Reference 	Csid_chan_ident_ws_lengths
		returning Csid_got_channel_ws.

	If (Failure_is in Csid_chdet_stat_ws) Then
                %^ Let alone, we still want to do AIN processing
		%^ Set Failure_is in Creditside_look_ls to true
		Go to B400_set_advice_end
	end-if.


%^	Call "CREDIT_ADVICE_LOOKUP" using by Value 1.
%^      Call "SI_COPY_ADV".

	If (Csid_opr_advice = SPACES )
	   AND (Cdt_adv_flg of Ent_ftr_set = "Y" )
	THEN
* Put operator override flag back if we set up an AIN override.	
	    Move SPACE to Cdt_adv_flg of Ent_ftr_set
	END-IF.

* Force ABA if we are paying via FED
        If (Cdt_adv_typ of Ent_credit_set = "FED" )
           AND (Cdt_ovr of Cdt_typ of Ent_credit_set = SPACE )
        THEN
            If (Cdt_idtype of Cdt_typ of Ent_credit_set NOT = "A" )
                AND (Aba_id of Relget_adr_set NOT = SPACES )
            THEN
		%Beg  Ent_credit_set.cdt_typ.cdt_idtype = "A";  %End
		If (Bnk_id of Relget_adr_set not = 
			Bank of Loc_info of Ent_ftr_set )		THEN
		    %Beg
		    Csid_compose  ^OUT(Ent_credit_set.Cdt_typ.Cdt_id)
			Relget_adr_set.bnk_id, ":", Relget_adr_set.Aba_id, / ;
		    %End
		ELSE
		    %Beg
		    Ent_credit_set.cdt_typ.cdt_id = Relget_adr_set.Aba_id ;
                    %End
	        END-IF
            END-IF
	END-IF.

	Set Failure_is in Csid_itsa_clearhouse to True.
%^


%^ Need to see if the Channel has set us up with a clearing account,
	If ((RTGS_IS in Endpoint_type of Rchan_channel_set) or
	   (clrhouse_is in Endpoint_type of Rchan_channel_set))
	    And (csid_chan_acc_ws Not = Spaces)	Then
		%^ Channel Determination provided an account number use, it
		%beg
		   Ent_Credit_set.cdt_adr_bnk_id = Csid_chan_acc_ws.idbank;
		   Ent_credit_set.cdt_account(.idbank = Csid_chan_acc_ws.idbank,
					      .idtype = Csid_chan_acc_ws.idtype,
					      .idkey  = Csid_chan_acc_ws.idkey ) ;
		%end
		Set Success_is in csid_chan_imposed_acct to True
		Set Failure_is in Csid_itsa_clearhouse to True


		%^ Force P if we are paying via CHP or equivalent clearing house

		Call "GET_IDTYPE_FROM_CHAN" Using		%^ 130629 
			By Reference Csid_temp_idtype,
			By Reference csid_lookup_temp,
			By Reference Csid_lookup_temp_length
		Returning csid_ret_stat

		If Success_is in csid_ret_stat  And
		   Csid_temp_idtype = "P"
		Then
			%^ have found a good Participant Id  use it
			%beg ent_credit_set.cdt_typ.cdt_idtype = Csid_temp_idtype;
  			     Csid_compose ^OUT(Ent_credit_set.Cdt_typ.Cdt_id)
					    Csid_lookup_temp,/;
			%end
		End-if

	end-if.

%^
%^ Channel contains all that we need from the
%^
%^
%^ All of the below may be OBSELETE.
%^
%^ Remove call to GET_PID_ADV_DATA


B400_SET_ADVICE_END.

   EXIT.
B405_SET_IDTYPE_FROM_CHAN.
%^
%^ Now that the Credit id is final, set to a good value.
%^
	Call "GET_IDTYPE_FROM_CHAN" Using
		By Reference Csid_temp_idtype,
		By Reference csid_lookup_temp,
		By Reference Csid_lookup_temp_length
	Returning csid_ret_stat.

	If Success_is in csid_ret_stat Then
		%^ have have a good ID use it
		%beg ent_credit_set.cdt_typ.cdt_idtype = Csid_temp_idtype;
  		     Csid_compose ^OUT(Ent_credit_set.Cdt_typ.Cdt_id)
				    Csid_lookup_temp,/;
		%end
	end-if.

B405_SET_IDTYPE_FROM_CHAN_END.
	EXIT.

B420_GET_NEWPARTY.

* If another routine has already found a preferred correspondent for a
* not on file account, just exit.  C680_CDT_SWF_PARENT also finds 
* correspondents for NOF accounts.
        If ( ( (Csid_ovr NOT = spaces) 
	      AND (Csid_pref_corr_rec NOT = spaces) )
	     OR (Success_is in Csid_disable_ain_ws)
	     OR (Lock_cdt_party_ls NOT = 0) )
        Then
	    Move 2 to Csid_onscreen
	    Call "CUST_PAYTO_NETWORK" using
	        by reference Cdt_adv_typ of Ent_credit_set
	        by reference Csid_onscreen
	        by reference Csid_pref_corr_rec
	        by reference Csid_pref_corr_rec_lengths
	        by reference Csid_do_pushdown
	        by reference Csid_corr_derivation
	        by reference Csid_ain_advice
	        by reference Csid_prm_secwir_ws
	        by reference Csid_net_memo
	        by reference Csid_net_memo_length
	        by reference Cdt_err_memo_count_ls
	        by reference Creditside_look_ls
	      Returning Csid_net_stat

	    %Beg
	    Csid_pref_corr_rec( .Idtype change,
			    .Idkey change ) ;
	    %End
            Go to B420_GET_NEWPARTY_END
        end-if.

        If (Csid_ovr NOT = spaces and Csid_pref_corr_rec NOT = spaces) OR
	   ( Success_is in Csid_disable_ain_ws)
        Then
                Go to B420_GET_NEWPARTY_END
        end-if.

	%Beg
	Csid_pref_corr_2id_rec = NULL;
	Csid_pref_corr_rec = NULL;
	Csid_pref_next_id_rec = NULL;
	%End

* Checks preferred correspondent table and SI chain to see if we have a new
* credit party.
	Call "GLOBAL_PREF_CORR" USING
	    By reference Csid_pref_corr_rec
	    By reference Csid_pref_corr_rec_lengths
	  RETURNING Csid_ret_stat.


     	If (Success_is in csid_ret_stat)
	    %Beg
		Csid_pref_corr_rec( .Idtype change,
				    .Idkey change ) ;
	    %End
            Set PUSHDOWN in Csid_do_pushdown to TRUE
	    Move "GBL" to Csid_corr_derivation
	    %Beg
	    Csid_compose ^OUT(Csid_info_memo)
				"Credit party ",
				Ent_credit_set.cdt_typ,
				" had INTRTL global pref corr ",
				Csid_pref_corr_rec, / ;
	    %End
	    Perform X920_INFO_MEMO through X920_INFO_MEMO_END
            GO TO B420_GET_NEWPARTY_END
        end-if.


* No global preferred correspondent, so see if we have an AIN
	CALL "CUST_SETUP_CREDIT_AINS"
	  Returning Csid_dummy_status.
	Set Failure_is in Csid_didansi_ws to TRUE
	Set Success_is in Csid_retry_cdtain to TRUE
	If Csid_num_AINSIs Not = 1 Then		%^ COR/AIN if
		%^ Must be 2, we need to look for COR and AINS
		%^ COR first
		%beg 
		Csid_pr_type_ws = NULL;
		csid_compose ^out(csid_pr_type_ws) 
			"COR",/;
		csid_pr_ordinal_ws = <0>;
		%end
		Set Bad_ml in Csid_pr_search_level to true
		Set Bad_is in Csid_pr_search_source to true
		Call "PRULE_MSG_RULE_MATCH_FROM" using
				By Reference csid_pr_type_ws
				By Reference csid_pr_type_ws_length
				By Reference Csid_pr_credit_side
				By Reference Csid_pr_search_level
				By Reference Csid_pr_search_source
				by Reference csid_pr_ordinal_ws
				by Reference csid_pr_level
				By Reference csid_pr_source
				by reference csid_pr_subtype_ws
				by reference csid_pr_subtype_ws_length
				By Reference Csid_pr_memo
				by reference csid_pr_memo_length
			returning csid_pr_stat_ws
		If Not(Success_is in Csid_pr_stat_ws) Then
			%^ No Cor present, Look for an AIN
			%beg 
			Csid_pr_type_ws = NULL;
			csid_compose ^out(csid_pr_type_ws)
				"CDTAIN",/;
			csid_pr_ordinal_ws = <0>;
			%end
			Set Bad_ml in Csid_pr_search_level to true
			Set Bad_is in Csid_pr_search_source to true

		    Perform UNTIL (Failure_is in Csid_retry_cdtain)
		        Set Bad_ml in Csid_pr_search_level to true
		        Set Bad_is in Csid_pr_search_source to true
		        Set Failure_is in Csid_retry_cdtain to TRUE
		        Call "PRULE_MSG_RULE_MATCH_FROM" using
				By Reference csid_pr_type_ws
				By Reference csid_pr_type_ws_length
				By Reference Csid_pr_credit_side
				By Reference Csid_pr_search_level
				By Reference Csid_pr_search_source
				by Reference csid_pr_ordinal_ws
				by Reference csid_pr_level
				By Reference csid_pr_source
				by reference csid_pr_subtype_ws
				by reference csid_pr_subtype_ws_length
				By Reference Csid_pr_memo
				by reference csid_pr_memo_length
			      returning csid_pr_stat_ws
			If (Success_is in Csid_pr_stat_ws)
			    Call "CUST_FILTER_CREDIT_AINS" using
				by Reference csid_pr_level
				By Reference csid_pr_source
				by Reference csid_pr_subtype_ws
				by Reference csid_pr_subtype_ws_length
			      Returning Csid_pr_stat_ws
			    If (Failure_is in Csid_pr_stat_ws)
				Set Success_is in Csid_retry_cdtain to TRUE
			    END-IF
			END-IF
		    END-PERFORM
		End-if
		
	else
		%^ Only scanning for AIN's
		%beg csid_compose ^out(csid_pr_type_ws) "CDTAIN",/;
		     csid_pr_ordinal_ws = <0>;
		%end
		Set Bad_ml in Csid_pr_search_level to true
		Set Bad_is in Csid_pr_search_source to true
		Perform UNTIL (Failure_is in Csid_retry_cdtain)
		    Set Bad_ml in Csid_pr_search_level to true
		    Set Bad_is in Csid_pr_search_source to true
		    Set Failure_is in Csid_retry_cdtain to TRUE
		    Call "PRULE_MSG_RULE_MATCH_FROM" using
				By Reference csid_pr_type_ws
				By Reference csid_pr_type_ws_length
				By Reference Csid_pr_credit_side
				By Reference Csid_pr_search_level
				By Reference Csid_pr_search_source
				by Reference csid_pr_ordinal_ws
				by Reference csid_pr_level
				By Reference csid_pr_source
				by reference csid_pr_subtype_ws
				by reference csid_pr_subtype_ws_length
				By Reference Csid_pr_memo
				by reference csid_pr_memo_length
			returning csid_pr_stat_ws
		    If (Success_is in Csid_pr_stat_ws)
		        Call "CUST_FILTER_CREDIT_AINS" using
			    by Reference csid_pr_level
			    By Reference csid_pr_source
			    by Reference csid_pr_subtype_ws
			    by Reference csid_pr_subtype_ws_length
		          Returning Csid_pr_stat_ws
		        If (Failure_is in Csid_pr_stat_ws)
			    Set Success_is in Csid_retry_cdtain to TRUE
		        END-IF
		    END-IF
		END-PERFORM
	end-if.


	If (Success_is in Csid_pr_stat_ws)
	Then
		Perform Get_exec_params Thru
			Get_exec_params_end

	        If (Csid_pr_type_ws = "COR" )
		    Set Success_is in Csid_cor_found to true		
		    If (Cor_done of Si_flgs of Ent_ftr_set = SPACE )
			%Beg  Ent_ftr_set.Si_flgs.Cor_done = "P" ;  %End
		    END-IF
		    GO TO B420_GET_NEWPARTY_END
		END-IF
%^ Found a matching AIN SI.
	    	If (Csid_pr_type_ws = "CDTAIN" )
		    If (Csid_prm_method_ws = "BKT" )
		        %Beg
		        Csid_compose ^OUT(Csid_err_memo)
			     "Found credit AIN SI with RRT-only BKT method", / ;
	 	        %End
		        Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
		        Set Failure_is in Creditside_look_ls to true
		        GO TO B420_GET_NEWPARTY_END
                    END-IF
		    %^ 83550 - Already have done the substitution
	            If (idtype of csid_pref_corr_rec =
			cdt_idtype of cdt_typ of ent_credit_set) Then
			    If idtype of csid_pref_corr_rec = "D" or "F" or "V" or "G"  Then
				Move Cdt_id_length of Ent_credit_set_lengths to csid_tmp_fin_pos_ws
				If cdt_id of cdt_typ of ent_credit_set(csid_tmp_fin_pos_ws:1) = "/"
				Then	%^ Discount the trailing / if present
					Subtract 1 from cdt_id_length of Ent_credit_set_lengths giving
						csid_tmp_fin_pos_ws
				End-if 
				%^ First, if replacing with a larger key, don't bother checking
				%^ for dup
				%^ If our bank, strip for the comparision
				If idkey of csid_pref_corr_rec(4:1) = ":" and
				   (idkey of csid_pref_corr_rec(1:3) =  bnk_id of menu_bnk_union Or
				    idkey of csid_pref_corr_rec(1:3) = cdt_adr_bnk_id of ent_credit_set)
				Then
					Move 5 to Csid_tmp_start_pos_ws
				Else
					Move 1 to Csid_tmp_start_pos_ws
				end-if
				Move idkey_length of csid_pref_corr_rec_lengths to csid_tmp_corr_len_ws
			        If (idkey of csid_pref_corr_rec(csid_tmp_start_pos_ws:csid_tmp_corr_len_ws) =
				     cdt_id of cdt_typ of ent_credit_set(1:Csid_tmp_fin_pos_ws))
				Then
				    %^Check in length -1 due to addition of / at end of account number
				    %^ Bypass, we have a circular reference, replacing
				    %^ same with same.
				    %^ All done, clear the corr rec
				    %beg csid_pref_corr_rec = NULL; %end
				    Go to B420_GET_NEWPARTY_END
				end-if
			    Else
				If (idkey of csid_pref_corr_rec  =
				    cdt_id of cdt_typ of ent_credit_set) Then
				    %^ Bypass, we have a circular reference, replacing
				    %^ same with same.
				    %beg csid_pref_corr_rec = NULL; %end
				    Go to B420_GET_NEWPARTY_END
				end-if
			    end-if
		    end-if
	            Set Success_is in Csid_didansi_ws to TRUE

		    Move "REL" to Csid_corr_derivation

                    Evaluate TRUE
		        When Csid_pr_subtype_ws = "SUB"
	                    Set SUBSTITUTE in Csid_do_pushdown to TRUE

		        When Csid_pr_subtype_ws = "INS"
	                When Csid_pr_subtype_ws = SPACES
			    Set PUSHDOWN in Csid_do_pushdown to TRUE

		        When Other
	        	    %Beg
		            Csid_compose ^OUT(Csid_err_memo)
			           "Illegal submethod ",
				   Csid_pr_subtype_ws, " in SI ",
				   Csid_pr_ordinal_ws, " for ", 
				   Ent_credit_set.Cdt_typ, /;
	 		    %End
			    Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
		            Set Failure_is in Creditside_look_ls to true
			    GO TO B420_GET_NEWPARTY_END
		    END-EVALUATE
                    GO TO B420_GET_NEWPARTY_END
	        ELSE
		    %Beg  Csid_pref_corr_rec = NULL ;  %End
	        END-IF
        ELSE
                %Beg  Csid_pref_corr_rec = NULL ;  %End
	END-IF.

        If Idtype of Csid_pref_corr_rec not = spaces
          then  GO TO B420_GET_NEWPARTY_END
        end-if.

%^ Get account suffixes to pass to the special preferred correspondent routine
	Perform C730_GET_PID_SUFFIXES thru C730_GET_PID_SUFFIXES_end.

%^ See if there's a site specific preferred correspondent
	If (Credit_currency_ls = SPACES OR Message_currency_ls )
	    Move Message_currency_ls to Csid_pref_curr
	    Move Message_amount_ls to Csid_pref_amount
	ELSE
	    Move Credit_currency_ls to Csid_pref_curr
	    If (Message_amount_ls = 0 )
		Move ZERO to Csid_pref_amount
	    ELSE
	        Call "CONVERT_SI_AMOUNT" using
	            by reference Message_currency_ls
	            by reference Message_amount_ls
		    by reference Base_currency_ID of Menu_bnk_union
	            by reference Csid_pref_curr
                    by reference Csid_pref_amount
		    by reference Base_cur_precision of Menu_bnk_union
	          returning Csid_ret2_stat
%^ If the amount couldn't be calculated pass a zero.
        	If Failure_is in Csid_ret2_stat then
		    Move ZERO to Csid_pref_amount
		END-IF
	    END-IF
	END-IF.
        CALL "CUST_SPEC_PREF_CORR" USING
           BY REFERENCE Csid_pref_corr_rec
           BY REFERENCE Csid_pref_corr_rec_lengths
           BY REFERENCE Csid_preferred_advice
           BY REFERENCE Csid_pref_submethod
	   BY REFERENCE Csid_pref_next_id_rec
	   BY REFERENCE Csid_pref_next_id_rec_lengths
           BY REFERENCE Csid_pref_corr_2id_rec
           BY REFERENCE Csid_pref_corr_2id_rec_lengths
	   BY REFERENCE Csid_suffixes 
	   BY REFERENCE Csid_suffixes_length
	   BY REFERENCE Csid_wire_svc_bits
	   BY REFERENCE Csid_pref_curr
	   BY REFERENCE Csid_pref_amount
	   BY REFERENCE Credit_currency_ls
	   BY REFERENCE Csid_second_id
	   BY REFERENCE Csid_second_id_length
         RETURNING Csid_Spec_Stat.

	%Beg
	Csid_pref_corr_rec( .Idtype change,
			    .Idkey change ) ;
	Csid_pref_next_id_rec( .Idtype change,
			    .Idkey change ) ;
	Csid_pref_corr_2id_rec( .Idtype change,
			    .Idkey change ) ;
	%End.

        If Success_is in Csid_Spec_Stat  
          then
            %Beg
            Csid_compose ^OUT(Csid_info_memo)
                                "Credit party ",
                                Ent_credit_set.cdt_typ,
                                " had INTRTL special pref corr ",
                                Csid_pref_corr_rec, / ;
            %End
            Perform X920_INFO_MEMO through X920_INFO_MEMO_END
            If (Csid_preferred_advice NOT = SPACES )
                %Beg
                Ent_credit_set.cdt_adv_typ = Csid_preferred_advice ;
                Ent_ftr_set.flgs.cdt_adv_flg = "Y";
                Csid_ain_advice = Csid_preferred_advice ;
                Csid_opr_advice = Csid_preferred_advice ;
                %End
%^ #106399 This "else" is not done in the creditside_screen module.
              else
                %Beg
                Csid_opr_advice = "   ";
                Ent_ftr_set.flgs.cdt_adv_flg= " ";
                %End
            END-IF

	    Move "SPC" to Csid_corr_derivation

            Evaluate Csid_pref_submethod

                When "SUB"
                    Set SUBSTITUTE in Csid_do_pushdown to true

                When "INS"
                When SPACES
                    Set PUSHDOWN in Csid_do_pushdown to true

                When Other
                    %Beg
                    Csid_compose ^OUT(Csid_err_memo),
                           "Illegal submethod ",
                           Csid_pref_submethod,
                           " returned from Intrtl_spec_pref_corr routine", /;
                    %End
                    Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
                    Set Failure_is in Creditside_look_ls to true
                    GO TO B420_GET_NEWPARTY_END

            END-EVALUATE

        END-IF.

        If Idtype of Csid_pref_corr_rec not = spaces
          then  GO TO B420_GET_NEWPARTY_END
        end-if.

        PERFORM C710_CDT_NIA_PRF thru
		C710_CDT_NIA_PRF_END.

        If Idtype of Csid_pref_corr_rec not = spaces
          then  GO TO B420_GET_NEWPARTY_END
        end-if.

	Move 2 to Csid_onscreen.
	Call "CUST_PAYTO_NETWORK" using
	    by reference Cdt_adv_typ of Ent_credit_set
	    by reference Csid_onscreen
	    by reference Csid_pref_corr_rec
	    by reference Csid_pref_corr_rec_lengths
	    by reference Csid_do_pushdown
	    by reference Csid_corr_derivation
	    by reference Csid_ain_advice
	    by reference Csid_prm_secwir_ws
	    by reference Csid_net_memo
	    by reference Csid_net_memo_length
	    by reference Cdt_err_memo_count_ls
	    by reference Creditside_look_ls
	  Returning Csid_net_stat.

	%Beg
	Csid_pref_corr_rec( .Idtype change,
			    .Idkey change ) ;
	%End.

        If Idtype of Csid_pref_corr_rec not = spaces
          then  GO TO B420_GET_NEWPARTY_END
        end-if.

	Set Failure_is in Csid_didansi_ws to TRUE.
%^	Removed relget_ain check. obselete

B420_GET_NEWPARTY_END.

   EXIT.

%^ the
GET_EXEC_PARAMS.
%^
%^ Retrieve the Execution Parameters All params are supported here
%^
%^
	Move Spaces to csid_prm_method_ws, csid_prm_secwir_ws, csid_acctg_method_ws.
	Move 0 to Lcl_prms_remaining_ws.
	Move Spaces to Lcl_param_name_ws.
	Perform with test after until Failure_is in Lcl_scan_Stat_ws
		Call "PRULE_MSG_READEX_PARM" using
			by reference Lcl_Param_name_ws
			by reference Lcl_Param_name_ws_length
			by reference Lcl_Param_type_ws
			by reference Lcl_prms_remaining_ws
			by reference Lcl_Param_value_ws
			by reference Lcl_Param_value_ws_length
			returning Lcl_scan_stat_ws
		If Success_is in Lcl_scan_stat_ws then
			%^ All are alpha, copy use full fields
			Evaluate Lcl_Param_name_ws
			    when "MTS$PARTY"
				%^ Parse the party ID/ should be Idtype/Id
				%beg Csid_parse ^in(Lcl_param_value_ws)
					Csid_pref_corr_rec.Idtype , "/" ,
					Csid_pref_corr_rec.Idkey,/;
				%end
				%^ Parse should be enough but...
				If Not (Success_is in csid_parse_status) Then
					%^ lets jut move it in, maybe the / is missing
					Move Lcl_param_value_ws(1:Lcl_param_value_ws_length) to
					     csid_pref_corr_rec	%^ should be format
					%Beg	Csid_pref_corr_rec( .Idtype change,
				    				    .Idkey change ) ;
					%End
				end-if
			    when "MTS$METHOD"
			    when "MTS$PAYMENT_CHANNEL"
				Move Lcl_param_value_ws(1:Lcl_param_value_ws_length) to
				     csid_prm_method_ws
			    when "MTS$SEND_SECWIR"
				Move Lcl_param_value_ws(1:Lcl_param_value_ws_length) to
				     csid_prm_secwir_ws
			    When "MTS$ACCTG_METHOD"
				Move Lcl_param_value_ws to csid_acctg_method_ws
			    When "MTS$DISABLE_AIN"
				Set Success_is in Csid_disable_ain_ws to True	%^ TGT2
			    When "MTS$TARGET_SUBPARTICIPANT"
				%^ Store the value, write it when we complete the AIN
				Set Success_is in TGT2_subpartic to True

			    When "MTS$TARGET_ACCOUNT_BIC"
				Move Lcl_param_value_ws_length
				     		  to Csid_tgt_account_bic_length
	
				Move Lcl_param_value_ws(1:Lcl_param_value_ws_length) to
				     Csid_tgt_account_bic

			End-evaluate
		End-if
	End-perform.
GET_EXEC_PARAMS_END.

   EXIT.
B440_SETUP_2ND_ID.

* Parses second id argument into its components if it is present.
	Move SPACE to Csid_2aid_idt.
	Move SPACE to Csid_2bid_idt.
	Move SPACES to Csid_2aid_id.
	Move SPACES to Csid_2bid_id.
	Move SPACES to Csid_party_id.
	%Beg
	Csid_2aid_id = NULL ;
	Csid_2bid_id = NULL ;
	Csid_2id_ws = NULL ;
	%End
	If (Csid_second_id_length = 0 )
	    GO TO B440_SETUP_2ND_ID_END
	END-IF.
	%Beg
	Csid_party_id = NULL ;
	Csid_party_extype = NULL ;
	Csid_parse ^IN(Csid_second_id)
		Csid_2id_oneof( ^ONEOF(
			("/AC",|Csid_party_id, ^SPACE, /),
			("/", |Csid_party_extype(^STRING<2>(<CHAR$M_ALPHA>)),
						    |Csid_party_id ^SPACE, /),
			(/) ));
        %End.
 	If (Failure_is in Csid_parse_status  )
	    %Beg
	    Csid_compose ^OUT(Csid_err_memo)
			"Incorrect second credit ID ", Csid_second_id, / ;
	    %End
	    Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
	    Add 1 to Csid_ambig_parties
	    Set Failure_is in Csid_bad_2nd_cdt to TRUE
	    Set Failure_is in Creditside_look_ls to true
	    GO TO B440_SETUP_2ND_ID_END
        END-IF.

	If (Csid_2id_oneof = 1 ) 
	   AND (Csid_party_extype = "FW")
	   AND (Csid_party_id_length = 0) 
	THEN
%^ Forces FED advice type
	    %Beg
	    Ent_credit_set.cdt_adv_typ = "FED" ;
	    Ent_ftr_set.flgs.cdt_adv_flg = "Y" ;                       
	    %End
	    GO TO B440_SETUP_2ND_ID_END
        END-IF.

 	EVALUATE TRUE
	    When (Csid_2id_oneof = 0 )
		Move "D" to Csid_party_idtype
	    When (Csid_2id_oneof = 2 )
		Move Space to Csid_party_idtype
	    When Csid_party_extype = "BC"
		Move "S" to Csid_party_idtype
	    When Csid_party_extype = "CH"
		Move "C" to Csid_party_idtype
	    When Csid_party_extype = "FW"
		Move "A" to Csid_party_idtype

	    When Other
		%^ Must search for a clearinghouse record which matches on
		%^ SWIFT ID.  If so, get its list of account suffixes.
		If (Cdt_adr_bnk_id of Ent_credit_set = SPACES )
		    Move Bank of Loc_info of Ent_ftr_set to Csid_acc_bank_ws
		ELSE
		    Move Cdt_adr_bnk_id of Ent_credit_set to Csid_acc_bank_ws
		END-IF
		CALL "GET_SUFFIX_FROM_XIDTYPE" Using
		    By reference Csid_acc_bank_ws
		    By reference Csid_party_extype
		    By reference Csid_suffixes
		    By reference Csid_suffixes_length
		  Returning Csid_suffix_count
		If (Csid_suffix_count NOT = 0)
		    Move "P" to Csid_party_idtype
		ELSE
		    Move "E" to Csid_party_idtype
		    %Beg
		    Csid_clip_compose ^OUT(Csid_temp1_vstr)
			Csid_party_id, / ;
		    %End
		    Move Csid_temp1_vstr(1:Csid_temp1_vstr_length) To
			Csid_party_id (3:)
		    Move Csid_party_extype To Csid_party_id (1:2)
		    Add 2 To Csid_party_id_length
		END-IF

	END-EVALUATE.
	Set Success_is in Csid_gcheck_actodd to true
	Perform X940_TAKEOUT_GARBAGE through X940_TAKEOUT_GARBAGE_END.
	Set Failure_is in Csid_gcheck_actodd to true
	If (Success_is in Csid_had_garbage   )
            If (Failure_is in Csid_bad_dda   )
                %Beg
                Csid_compose ^OUT(Csid_err_memo)
			"Incorrect second credit ID ", Csid_second_id, / ;
                %End
                Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
                Add 1 to Csid_ambig_parties
                Set Failure_is in Csid_bad_2nd_cdt to TRUE
                Set Failure_is in Creditside_look_ls to true
            ELSE
                Set Success_is in Csid_bad_2nd_cdt to TRUE
            END-IF
	    GO TO B440_SETUP_2ND_ID_END
        END-IF.

	%Beg
	Csid_2aid_id = NULL ;
	Csid_2bid_id = NULL ;
	Csid_party_extype2 = NULL;
	Csid_parse ^IN(Csid_party_id) Csid_2aid_id, 
		Csid_twoof_acchfw (^ONEOF (	
			("/AC",|Csid_2bid_id, ^SPACE, /),
			("/",  |Csid_party_extype2(^STRING<2>(<CHAR$M_ALPHA>)),
			  			    |Csid_2bid_id ^SPACE, / ),
			(^SPACE, /) ));
	%End.
	Move Csid_party_idtype to Csid_2aid_idt.
	If (Failure_is in Csid_parse_status  )
	    %Beg
	    Csid_2aid_id = NULL ;
	    Csid_2bid_id = NULL ;
	    Csid_parse ^IN(Csid_party_id) 
			Csid_2aid_id, ^SPACE, /  ;
	    %End
	    GO TO B440_SETUP_2ND_ID_END
	END-IF.
	If (Csid_twoof_acchfw = 2 )
	    %Beg
	    Csid_2bid_id = NULL ;
	    Csid_2bid_idt = NULL ;
	    Csid_party_extype2 = NULL ;
	    %End
	ELSE
	    Evaluate True
		When Csid_twoof_acchfw = 0
		    Move "D" to Csid_2bid_idt
		When Csid_party_extype2 = "BC"
		    Move "S" to Csid_2bid_idt
		When Csid_party_extype2 = "CH"
		    Move "C" to Csid_2bid_idt
		When Csid_party_extype2 = "FW"
		    Move "A" to Csid_2bid_idt
		When Other
		    %^ Must search for a clearinghouse record which matches on
		    %^ SWIFT ID.  If so, get its list of account suffixes.
		    If (Cdt_adr_bnk_id of Ent_credit_set = SPACES )
		        Move Bank of Loc_info of Ent_ftr_set to Csid_acc_bank_ws
		    ELSE
		        Move Cdt_adr_bnk_id of Ent_credit_set to
								Csid_acc_bank_ws
		    END-IF
		    CALL "GET_SUFFIX_FROM_XIDTYPE" Using
		        By reference Csid_acc_bank_ws
		        By reference Csid_party_extype
		        By reference Csid_suffixes
		        By reference Csid_suffixes_length
		      Returning Csid_suffix_count
		    If (Csid_suffix_count NOT = 0)
		        Move "P" to Csid_2bid_idt
		    ELSE
		        Move "E" to Csid_2bid_idt
			%Beg
			Csid_clip_compose ^OUT(Csid_temp1_vstr)
			    Csid_2bid_id, / ;
			%End			
		        Move Csid_temp1_vstr(1:Csid_temp1_vstr_length) To
				Csid_2bid_id (3:)
		        Move Csid_party_extype2 To Csid_2bid_id (1:2)
		        Add 2 To Csid_party_id_length
		    END-IF

	    END-EVALUATE
	END-IF.

	If (Csid_2aid_id_length > 34 )			%^ CHECK FOR 34, IBAN MAX LENGTH
	   OR (Csid_2bid_id_length > 34 )		%^ CR 2563
	THEN
%^ Illegal identifier.
	    Move SPACE to Csid_2aid_idt
	    Move SPACE to Csid_2bid_idt
	    Move SPACES to Csid_2aid_id
	    Move SPACES to Csid_2bid_id
	    %Beg
	    Csid_2aid_id = NULL ;
	    Csid_2bid_id = NULL ;
	    Csid_compose ^OUT(Csid_err_memo)
			"Illegal format in second credit ID ", 
			Csid_second_id, / ;
	    %End
	    Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
	    Add 1 to Csid_ambig_parties
	    Set Failure_is in Csid_bad_2nd_cdt to TRUE
	    Set Failure_is in Creditside_look_ls to true
	    GO TO B440_SETUP_2ND_ID_END
        END-IF.

B440_SETUP_2ND_ID_END.

   EXIT.
B460_SET_2ND_AGAIN.
* Parses second id argument components for rolldown into lower parties.

	Move SPACE to Csid_2aid_idt.
	Move SPACE to Csid_2bid_idt.
	Move SPACES to Csid_2aid_id.
	Move SPACES to Csid_2bid_id.
	Move SPACES to Csid_party_id.
	%Beg
	Csid_2aid_id = NULL ;
	Csid_2bid_id = NULL ;
	Csid_2id_ws = NULL ;
	%End
	If (Csid_second_id_length = 0 )
	    GO TO B460_SET_2ND_AGAIN_END
	END-IF.           
	%Beg
	Csid_parse ^IN(Csid_2id_ws)
		Csid_2id_oneof( ^ONEOF(
			("/AC",|Csid_party_id, ^SPACE, /),
			("/", |Csid_party_extype (^STRING<2>(<CHAR$M_ALPHA>)),
						    |Csid_party_id ^SPACE, /),
			(/) ));
	%End
 	If (Failure_is in Csid_parse_status  )
	  OR ( (Csid_2id_oneof = 1 ) 
		AND (Csid_party_extype = "FW") 
		AND (Csid_party_id_length = 0))
	THEN
	    GO TO B460_SET_2ND_AGAIN_END
        END-IF.
 	EVALUATE TRUE
	    When (Csid_2id_oneof = 0 or 2)
		Move SPACE to Csid_party_idtype
	    When  Csid_party_extype = "BC"
		Move "S" to Csid_party_idtype
	    When Csid_party_extype = "CH"
		Move "C" to Csid_party_idtype
	    When Csid_party_extype = "FW"
		Move "A" to Csid_party_idtype
	    When Other
%^ Must search for a clearinghouse record which matches on SWIFT ID.
%^ If so, get its list of account suffixes.  However, note that we will not
%^ actually use the suffixes,  just the Boolean status that says it's an active
%^ clearinghouse
		If (Cdt_adr_bnk_id of Ent_credit_set = SPACES )
		    Move Bank of Loc_info of Ent_ftr_set to Csid_acc_bank_ws
		ELSE
		    Move Cdt_adr_bnk_id of Ent_credit_set to Csid_acc_bank_ws
		END-IF
		CALL "GET_SUFFIX_FROM_XIDTYPE" Using
		    By reference Csid_acc_bank_ws
		    By reference Csid_party_extype
		    By reference Csid_suffixes
		    By reference Csid_suffixes_length
		  Returning Csid_suffix_count
		If (Csid_suffix_count NOT = 0)
		    Move "P" to Csid_party_idtype
		ELSE
		    Move "E" to Csid_party_idtype
		    %Beg
		    Csid_clip_compose ^OUT(Csid_temp1_vstr)
			Csid_party_id, / ;
		    %End
		    Move Csid_temp1_vstr(1:Csid_temp1_vstr_length) To
			Csid_party_id(3:)
		    Move Csid_party_extype To Csid_party_id(1:2)
		    Add 2 To Csid_party_id_length
		END-IF
	END-EVALUATE.
	Perform X940_TAKEOUT_GARBAGE through X940_TAKEOUT_GARBAGE_END.
	If (Success_is in Csid_had_garbage   )
	    GO TO B460_SET_2ND_AGAIN_END
        END-IF.

	%Beg
	Csid_party_extype2 = NULL;
	Csid_parse ^IN(Csid_party_id) Csid_2aid_id, 
		Csid_twoof_acchfw (^ONEOF (	
			("/AC",|Csid_2bid_id, ^SPACE, /),
			("/",  |Csid_party_extype2(^STRING<2>(<CHAR$M_ALPHA>)),
						    |Csid_2bid_id ^SPACE, /),
			(^SPACE, /) ));
	%End.
	Move Csid_party_idtype to Csid_2aid_idt.
	If Failure_is in Csid_parse_status  
	    %Beg
	    Csid_2aid_id = NULL ;
	    Csid_2bid_id = NULL ;
	    Csid_parse ^IN(Csid_party_id) 
			Csid_2aid_id, ^SPACE, /  ;
	    %End
	    GO TO B460_SET_2ND_AGAIN_END
	END-IF.
	If (Csid_twoof_acchfw = 2 )
	    %Beg
	    Csid_2bid_id = NULL ;
	    Csid_party_extype2 = NULL ;
	    %End
	ELSE
	    Evaluate True
		When Csid_twoof_acchfw = 0
		    Move SPACE to Csid_2bid_idt
		When Csid_party_extype2 = "BC"
		    Move "S" to Csid_2bid_idt
		When Csid_party_extype2 = "CH"
		    Move "C" to Csid_2bid_idt
		When Csid_party_extype2 = "FW"
		    Move "A" to Csid_2bid_idt

		When Other
		    %^ Must search for a clearinghouse record which matches on
		    %^ SWIFT ID.  If so, get its list of account suffixes.
		    If (Cdt_adr_bnk_id of Ent_credit_set = SPACES )
		        Move Bank of Loc_info of Ent_ftr_set to Csid_acc_bank_ws
		    ELSE
		        Move Cdt_adr_bnk_id of Ent_credit_set to
								Csid_acc_bank_ws
		    END-IF
		    CALL "GET_SUFFIX_FROM_XIDTYPE" Using
		        By reference Csid_acc_bank_ws
		        By reference Csid_party_extype
		        By reference Csid_suffixes
		        By reference Csid_suffixes_length
		      Returning Csid_suffix_count
		    If (Csid_suffix_count NOT = 0)
		        Move "P" to Csid_2bid_idt
		    ELSE
		        Move "E" to Csid_2bid_idt
			%Beg
			Csid_clip_compose ^OUT(Csid_temp1_vstr)
			    Csid_2bid_id, / ;
			%End
		        Move Csid_temp1_vstr(1:Csid_temp1_vstr_length) to
				Csid_2bid_id (3:)
		        Move Csid_party_extype2 To Csid_2bid_id(1:2)
		        Add 2 To Csid_party_id_length
		    END-IF

	    END-EVALUATE
	END-IF.
	If (Csid_2aid_id_length > 34 )			%^ CHECK FOR 34, IBAN MAX LENGTH
	   OR (Csid_2aid_id_length < 1 )		%^ CR 2563
	   OR (Csid_2bid_id_length > 34 )
	THEN
%^ Illegal identifier.
	    Move SPACE to Csid_2aid_idt
	    Move SPACE to Csid_2bid_idt
	    Move SPACES to Csid_2aid_id
	    Move SPACES to Csid_2bid_id
	    Move SPACES to Csid_2id_ws
	    %Beg
	    Csid_2aid_id = NULL ;
	    Csid_2bid_id = NULL ;
	    Csid_2id_ws = NULL ;
	    %End
	    GO TO B460_SET_2ND_AGAIN_END
        END-IF.

B460_SET_2ND_AGAIN_END.

   EXIT.
B480_FX_ACCOUNT.
* Looks up FX account and inserts it as credit party.
	%Beg
	Csid_union_key_ws(.Idname = "FIELD_EDIT_TABLES",
			  .Idprod = "MTS", 	   
			  .Idbank =  Menu_bnk_union.Bnk_id,    
	 		  .Idloc  = null,    	   
	 		  .Idcust = null);
	Csid_compose ^OUT(Csid_item_key_ws),
			"FX_INSERTION_ACCT:", /; 
	Csid_compose ^OUT(Csid_match_key_ws),
			Menu_bnk_union.Bnk_ID, / ;
	Csid_seq_ordinal_ws = <1>;
	%End       
	Call "CFG_MATCH_ITEM" USING
	    BY Reference Idname of Csid_union_key_ws
	    BY Reference Idprod of Csid_union_key_ws
	    BY Reference Idbank of Csid_union_key_ws
	    BY Reference Idloc of Csid_union_key_ws
	    BY Reference Idcust of Csid_union_key_ws
	    BY Reference Csid_item_key_ws
	    BY Reference Csid_match_key_ws
	    BY Reference Csid_match_key_ws_length
	    BY Reference Csid_seq_ordinal_ws
	    BY Reference Csid_error_msg_ws
	    BY Reference Csid_error_msg_ws_length
          RETURNING Csid_ret_stat.
	If Failure_Is in Csid_ret_stat
* No FX account for this bank.
	    GO TO B480_FX_ACCOUNT_END
	END-IF.

	%Beg  Csid_item_type_ws = "VSTR(256)" ;  %End
	Call "CFG_GET_ITEM" USING
	    BY Reference Idname of Csid_union_key_ws
	    BY Reference Idprod of Csid_union_key_ws
	    BY Reference Idbank of Csid_union_key_ws
	    BY Reference Idloc of Csid_union_key_ws
	    BY Reference Idcust of Csid_union_key_ws
	    BY Reference Csid_item_key_ws
            By Reference Csid_seq_ordinal_ws
            By Reference Csid_item_type_ws
            By Reference Csid_item_data_ws
            By Reference Csid_item_data_ws_length
            By Reference Csid_error_msg_ws
            By Reference Csid_error_msg_ws_length
          RETURNING Csid_ret_stat.
	If Failure_Is in Csid_ret_stat
	    GO TO B480_FX_ACCOUNT_END
	END-IF.
*
	%Beg
	Csid_Parse ^IN(Csid_fx_ws),
			Csid_match_bank_ws,"/",Csid_fx_acct_idt_ws,"/",
			Csid_fx_acct_id_ws,/;
	%End
	Set CDT in Relget_title_flag to TRUE
	%Beg
	Csid_pref_corr_rec.idtype = Csid_fx_acct_idt_ws ;
	Csid_pref_corr_rec.idkey  = Csid_fx_acct_id_ws ;
	%End.
 	Move "F" to Csid_lkup_pend_del.
	Call "ACCT_LOOKUP" using
            by reference Idtype of Csid_pref_corr_rec
            by reference Idkey of Csid_pref_corr_rec
    	    by reference Csid_ovr
    	    by content "F"
    	    by reference Csid_multibank_ws
    	    by reference Credit_currency_ls
	    by reference Csid_lkup_pend_del
 	  RETURNING Csid_ret_stat

      	If (Csid_ovr NOT = SPACE )
	    If (Csid_lkup_pend_del = "T" )
%^ FX account address is pending delete!
	        %Beg
	        Csid_compose ^OUT(Csid_err_memo)
			       "FX address ", Csid_fx_acct_idt_ws, "/", 
				Csid_fx_acct_id_ws, " is pending delete" / ;
 	    	%End
	    ELSE
%^ Lookup failed - give memo
	    	%Beg
	    	Csid_compose ^OUT(Csid_err_memo)
			       "Lookup failed for FX address "
				Csid_fx_acct_idt_ws, "/", 
				Csid_fx_acct_id_ws, / ;
 	    	%End
	    END-IF
	    Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
	    Move 1 to Csid_ambig_parties
	    Set Failure_is in Creditside_look_ls to true
    	    GO TO B480_FX_ACCOUNT_END
	END-IF
%^     The ID is in the REL file.  
	%Beg  Ent_ftr_set.si_flgs.fx_found = "Y";  %End
	If Rel_id of Relget_adr_set = Cdt_rel_id of Ent_credit_set
	    GO TO B480_FX_ACCOUNT_END
	END-IF.
* FX account is not already the credit party.  Insert it.
	%Beg
	BREAK: Csid_adr_set ;
	Relget_adr_set EQUATE: Csid_adr_set(NOMOD) ;
        BREAK: Relget_adr_set ;
	Csid_conn_stat = Ent_c_adr_set State.Conn ;
	%End.
	If (Csid_conn_stat NOT = 0 )
	    %Beg  
	    Ent_c_adr_set EQUATE: Relget_adr_set(NOMOD) ;
	    BREAK: Ent_c_adr_set ;
	    %End
	ELSE
	    Move ZERO to Rel_id of Relget_adr_set
	END-IF.
	Set Failure_is in Csid_push_error to TRUE
	PERFORM C800_PUSH_CREDIT through C800_PUSH_CREDIT_END.
	If Success_is in Csid_push_error
* OOPSIE.  No room to push
	    GO TO B480_FX_ACCOUNT_END
        END-IF.

* If we pushed down an idtype of "D" clear it out since we do not
* want to perform edits on the lower-level party pushed down.
	If Cdt_idtype of cdt_typ of Ent_credit_set = "D" then
	   Evaluate credit_depth_ls

		WHEN 1
	         %Beg Ent_credit_set.ib1.ib1_idtype = ""; %End

		WHEN 2
	         %Beg Ent_credit_set.ibk.ibk_idtype = ""; %End

		WHEN 3
	         %Beg Ent_credit_set.bbk.bbk_idtype = ""; %End

		WHEN 4
	         %Beg Ent_credit_set.bnp.bnp_idtype = ""; %End
	    End-evaluate
	End-if.

	%Beg
	BREAK: Relget_adr_set;
	Csid_adr_set EQUATE: Relget_adr_set(NOMOD) ;
	Csid_adr_set EQUATE: Ent_c_adr_set(NOMOD) ;
	BREAK: Csid_adr_set;
	%End
	PERFORM C720_COPY_ADDRESS through C720_COPY_ADDRESS_END.
	If (Relget_return_key NOT = SPACES )
	    %Beg
	    Csid_parse ^IN(Relget_return_key)
				 Csid_pref_corr_rec.idkey, ^SPACE, / ;
	    %End
	END-IF.
%^ And now let's add an info memo saying what happened                  
	%Beg
	Csid_compose ^OUT(Csid_info_memo)
		"FX Account ", Csid_pref_corr_rec.idtype,"/",
		Csid_pref_corr_rec.idkey, 
		" inserted -> ", Ent_credit_set.Cdt_typ.Cdt_idtype,"/", 
		Ent_credit_set.Cdt_typ.Cdt_id, / ;
	%End
	Perform X920_INFO_MEMO through X920_INFO_MEMO_END
 	%Beg
	Ent_credit_set.Cdt_adr_bnk_id = Relget_adr_set.bnk_id ;
	Csid_id_ws = Csid_pref_corr_rec.idkey ;
	%End
	If (Cdt_adr_bnk_id of Ent_credit_set NOT = SPACES )
	    AND (Cdt_adr_bnk_id of Ent_credit_set NOT =
				Bank of Loc_info of Ent_ftr_set )
	THEN
	    %Beg
	    Csid_parse ^IN(Csid_pref_corr_rec.Idkey), 
				^STRING<3>, ":", ^STRING, / ;
	    %End
	    If (Failure_is in Csid_parse_status   )
		%Beg
		Csid_compose ^OUT(Csid_id_ws)
				Ent_credit_set.cdt_adr_bnk_id, ":",
				Csid_pref_corr_rec.Idkey, / ;
		%End
	    END-IF
	END-IF.
	%Beg
 	Ent_credit_set.Cdt_typ (.Cdt_ovr    = Csid_ovr,
 				.Cdt_idtype = Csid_pref_corr_rec.Idtype,
				.Cdt_id     = Csid_id_ws ) ;
	BREAK: Ent_c_adr_set ;
	%^ OBSELETE	Relget_adr_set.adv_seq CONN: Ent_adv_seq(NOMOD) ;
	Relget_adr_set EQUATE: Ent_c_adr_set(NOMOD) ;
	%End
	Perform B400_SET_ADVICE through B400_SET_ADVICE_END.
        %^ The search currency may need to change as the result of
        %^   a preferred correspondent
B480_FX_ACCOUNT_END.

   EXIT.
B500_DEBIT_SIS.
*  Paragraph processes PRE SI.
	If (Pre_found of Si_flgs of Ent_ftr_set = "Y" )
	    PERFORM B510_DEBIT_CHECK_SI through B510_DEBIT_CHECK_SI_END
	    GO TO B500_DEBIT_SIS_END
	END-IF.
	%Beg 
	Break: Relget_adr_set; 
	Ent_d_adr_set EQUATE: Relget_adr_set(NOMOD);
	%End.
%^	Move 1 to Csid_number_SIs.
%^	Move SPACES to Csid_previce_vstr.
%^	%Beg  
%^	Csid_SI_types = "PRE" ;  
%^	Csid_previce_vstr = "";                            
%^      Csid_si_defer_ws = <0>;
%^	%End.
	Set Failure_is in csid_ret_stat to True.
	%beg csid_compose ^out(csid_pr_type_ws) "PRE",/;
	     csid_pr_ordinal_ws = <0>;
	%end
	Call "PRULE_MSG_RULE_MATCH_FROM" using
			by reference Csid_pr_type_ws
			by reference Csid_pr_type_ws_length
			by reference dbt_search_side_wc
			by reference Csid_pr_search_level
			by reference Csid_pr_search_source
			by reference Csid_pr_ordinal_ws
			by reference csid_pr_level
			by reference csid_pr_source
			by reference csid_pr_subtype_ws
			by reference csid_pr_subtype_ws_length
			by reference csid_pr_memo
			by reference csid_pr_memo_length
	returning csid_ret_stat

	If (Success_is in Csid_pre_codeword) And
	   (Failure_is in csid_ret_stat)
	Then
	   %Beg	      
	    Csid_compose ^OUT(Csid_err_memo)
		    "PREVICE codeword but no pre SI for "
	    	    Ent_debit_set.Dbt_typ.Dbt_idtype,"/",
	    	    Ent_debit_set.Dbt_typ.Dbt_id, / ; 
	   %End
	   Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
	   Set NO_PREVICE_SI in Csid_previce_si_ind to TRUE	%^SPR29440
           Move ZERO to cdt_not_suspect_ls			%^SPR29440
	   Set Failure_is in Creditside_look_ls to true
	   PERFORM B510_DEBIT_CHECK_SI through B510_DEBIT_CHECK_SI_END
	   GO TO B500_DEBIT_SIS_END
	End-if

	If Success_is in Csid_ret_stat   then  
%^ Found a matching PRE SI.
%^ Retreive the Exec Param
	   Move Spaces to csid_acctg_method_ws		%^ clear it
	   Perform GET_EXEC_PARAMS thru
		   GET_EXEC_PARAMS_END
	   %Beg  Ent_ftr_set.Si_flgs.Pre_found = "Y" ;  %End
	   If csid_acctg_method_ws = " " Then	%^^Si_p1 of Ent_cnf_set = " " then
		move "P" to csid_acctg_method_ws
	    %^    else
	    %^	move Si_p1 of Ent_cnf_set to csid_acctg_method_ws
	   end-if
	   %Beg  
	   BREAK: Csid_tmp_acc_set(NOMOD);
	   BREAK: Csid_tmp_grp_set;
	   BREAK: Csid_tmp_rel_reg;
	   Csid_temp_conn = Ent_d_acc_set state.conn;
	   %End
	   Set Failure_is in Csid_got_group to TRUE
	   If Csid_temp_conn = 0
	      %Beg 
	      ALLOC_TEMP: Csid_tmp_acc_set(MOD);
	      Csid_tmp_acc_set.Preadv_limit = <0>;
	      %End
	   ELSE
	      %Beg
	      Ent_d_acc_set EQUATE: Csid_tmp_acc_set(NOMOD,
			REG: Csid_tmp_rel_reg(NOMOD)) ;
	      %End
	      If (Dbt_concen_acc of Ent_debit_set NOT = SPACES )
		 %ace_conn_root_q Rel_acc_index ;
		 %Beg
		 SEARCH: Rel_acc_index (FORWARD, GEQ, .Rel_name_key 
			(.Idbank        = Ent_debit_set.Dbt_concen_acc.Idbank,
			 .Idtype        = Ent_debit_set.Dbt_concen_acc.Idtype,
			 .Idkey (.Idacc = Ent_debit_set.Dbt_concen_acc.Idkey,
				 .Idadr = NULL,
			         .Idpad = NULL ) ) ) ;
		 %End
	         If (Success_is of Rel_acc_index_status )
	            AND (Idbank of Rel_name_key of Rel_acc_index =
				   Idbank of Dbt_concen_acc of Ent_debit_set )
	            AND (Idtype of Rel_name_key of Rel_acc_index =
				Idtype of Dbt_concen_acc of Ent_debit_set )
	            AND (Idacc of Idkey of Rel_name_key of Rel_acc_index =
				  Idkey of Dbt_concen_acc of Ent_debit_set )
		 THEN
		    %Beg  
		    BREAK: Csid_tmp_acc_set;
		    Rel_acc_index CONN: Csid_tmp_acc_set;
		    %End
		 END-IF
	      ELSE
		 If (Group_preadvise of Menu_cfg = "T" ) Then
%^ Connect debit party on file group subjects if necessary.
		     If Grp_id of Csid_tmp_rel_reg is not = spaces
	  		%beg
			Csid_tmp_rel_reg(
		 	    .Grp_join CONN: Csid_grp_acc_seq(NOMOD));
			%End
			%ACE_IS Csid_grp_acc_seq connected giving
								Csid_got_group;
			If (Success_is in Csid_got_group)
			    %Beg
		  	    Csid_grp_acc_seq TOP: Csid_tmp_rel_union(
		   			NOMOD,
		   			.Grp_set CONN: Csid_tmp_grp_set(NOMOD));
			    BREAK: Csid_tmp_rel_union;
			    BREAK: Csid_grp_acc_seq;
			    %End
			END-IF
		     END-IF
		     %Beg  BREAK: Csid_tmp_rel_reg;  %End
		END-IF
	      END-IF
	   END-IF
	   If (Check_preadv_limit of Menu_cfg = "T" )
                     and (csid_acctg_method_ws = "P")
	   THEN
	      If (Success_is in Csid_got_group )
	          If (Preadv_limit of Csid_tmp_grp_set = 0) then
	             %Beg
	             Ent_debit_set.Flgs.Dbt_ps_elig_flg = "L" ;
		     BREAK: Csid_tmp_grp_set;
		     BREAK: Csid_tmp_acc_set;
	             Csid_compose ^OUT(Csid_info_memo)
	    	      	"Found PRE SI with no preadvise limit",/;
	             %End
	             Perform X920_INFO_MEMO through X920_INFO_MEMO_END
	             PERFORM B510_DEBIT_CHECK_SI through B510_DEBIT_CHECK_SI_END
	             GO TO B500_DEBIT_SIS_END
	          End-if 

                  If (Preadv_limit_exp_date of Csid_tmp_grp_set
                            		not = zero and < Menu_date_ws) then
	              %Beg	      
		      BREAK: Csid_tmp_acc_set;
		      BREAK: Csid_tmp_grp_set;
	              Ent_debit_set.Flgs.Dbt_ps_elig_flg = "X" ;
	              Csid_compose ^OUT(Csid_err_memo)
	    	    	    "Found PRE SI but group ", Csid_tmp_grp_set.Grp_id,
		    	    " preadvise limit expired.",/; 
	              %End
	              Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
                      If ((Pre_explimit_rsk of Menu_cfg = "C" or "S" or "V") or
                          (Pre_nolimit_rpr  of Menu_cfg = "T"))
		      then
                          Subtract 1 from Cdt_err_memo_count_ls
			  PERFORM B510_DEBIT_CHECK_SI through B510_DEBIT_CHECK_SI_END
			  GO TO B500_DEBIT_SIS_END
                      End-if
	              Move 1 to Csid_ambig_parties
		      PERFORM B510_DEBIT_CHECK_SI through B510_DEBIT_CHECK_SI_END
		      GO TO B500_DEBIT_SIS_END
		  End-if
	      ELSE
	          If (Preadv_limit of Csid_tmp_acc_set = 0) then
	             %Beg
	             Ent_debit_set.Flgs.Dbt_ps_elig_flg = "L" ;
		     BREAK: Csid_tmp_acc_set;
	             Csid_compose ^OUT(Csid_info_memo)
	    	      	"Found PRE SI with no preadvise limit",/;
	             %End
	             Perform X920_INFO_MEMO through X920_INFO_MEMO_END
		     PERFORM B510_DEBIT_CHECK_SI through B510_DEBIT_CHECK_SI_END
		     GO TO B500_DEBIT_SIS_END
	          End-if 

                  If (Preadv_limit_exp_date of Csid_tmp_acc_set
                            		not = zero and < Menu_date_ws) then
	             %Beg	      
		     BREAK: Csid_tmp_acc_set;
	             Ent_debit_set.Flgs.Dbt_ps_elig_flg = "X" ;
	             Csid_compose ^OUT(Csid_err_memo)
	    	    		"Found PRE SI but ", 
				Ent_debit_set.Dbt_typ.Dbt_idtype,"/",
	    	    		Ent_debit_set.Dbt_typ.Dbt_id, 
		    		" preadvise limit expired.",/; 
	             %End
	             Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
                     If ((Pre_explimit_rsk of Menu_cfg = "C" or "S" or "V") or
                          (Pre_nolimit_rpr  of Menu_cfg = "T"))
		     then
                         Subtract 1 from Cdt_err_memo_count_ls
			 PERFORM B510_DEBIT_CHECK_SI through B510_DEBIT_CHECK_SI_END
			 GO TO B500_DEBIT_SIS_END
                     End-if
	             Move 1 to Csid_ambig_parties
		     PERFORM B510_DEBIT_CHECK_SI through B510_DEBIT_CHECK_SI_END
		     GO TO B500_DEBIT_SIS_END
		 End-if
	      End-if 

	      %Beg  
	      BREAK: Csid_tmp_acc_set;
	      BREAK: Csid_tmp_grp_set;
               Ent_debit_set.Flgs.Dbt_ps_elig_flg = csid_acctg_method_ws;
	       Csid_compose ^OUT(Csid_info_memo)
	    	    "Found PRE SI and preadvise limit",/;
	       %End
	       Perform X920_INFO_MEMO through X920_INFO_MEMO_END
	   ELSE
	       %Beg  
               Ent_debit_set.Flgs.Dbt_ps_elig_flg = csid_acctg_method_ws;
	       Csid_compose ^OUT(Csid_info_memo)
	    	    "Found PRE SI",/;
	       %End
	       Perform X920_INFO_MEMO through X920_INFO_MEMO_END
	   END-IF
	END-IF.

	PERFORM B510_DEBIT_CHECK_SI through B510_DEBIT_CHECK_SI_END.

B500_DEBIT_SIS_END.

   EXIT.
B510_DEBIT_CHECK_SI.
	If ( (Failure_is in Csid_chk_codeword    )
	     AND (Cdt_adv_typ of Ent_credit_Set NOT = "SCK" )  )
	   OR (Check_found of Si_flgs of Ent_ftr_set = "Y" )
	THEN
	    GO TO B510_DEBIT_CHECK_SI_END
	END-IF.
	If (Bbk_id of Bbk of Ent_credit_set NOT = SPACES )
	   OR ( (Bbk_name1_length of Ent_credit_set_lengths NOT = 0 ) 
	        AND (Bbk_name1 of Ent_credit_set NOT = SPACES ) )
	THEN
* Too many parties -- cannot do SWIFTCHECK.
	    GO TO B510_DEBIT_CHECK_SI_END
	END-IF.	
%^	Move 1 to Csid_number_SIs.
%^	Move SPACES to Csid_previce_vstr
%^	%Beg  
%^	Csid_SI_types = "CHK" ;  
%^	Csid_previce_vstr = NULL ;
%^       Csid_si_defer_ws = <0>;  
%^	%End.
%^
%^
	%beg csid_compose ^out(csid_pr_type_ws) "CHK",/;
	     csid_pr_ordinal_ws = <0>;
	%end
	Call "PRULE_MSG_RULE_MATCH" Using
			By Reference csid_pr_type_ws
			By Reference csid_pr_type_ws_length
			by Reference csid_pr_ordinal_ws
			by Reference csid_pr_level
			By Reference csid_pr_source
			by reference csid_pr_subtype_ws
			by reference csid_pr_subtype_ws_length
			By Reference Csid_pr_memo
			by reference csid_pr_memo_length
		returning csid_ret_stat.

%^ Support international version where advice type may be CHQ.
	If ((Intnatl_ena of Menu_cfg is NOT = low-values)
	   AND (Failure_is in Csid_ret_stat ))
	then
	%beg csid_compose ^out(csid_pr_type_ws) "CHQ",/;
	     csid_pr_ordinal_ws = <0>;
	%end
	Call "PRULE_MSG_RULE_MATCH" Using
			By Reference csid_pr_type_ws
			By Reference csid_pr_type_ws_length
			by Reference csid_pr_ordinal_ws
			by Reference csid_pr_level
			By Reference csid_pr_source
			by reference csid_pr_subtype_ws
			by reference csid_pr_subtype_ws_length
			By Reference Csid_pr_memo
			by reference csid_pr_memo_length
		returning csid_ret_stat.

	If Failure_is in Csid_ret_stat   then
	    GO TO B510_DEBIT_CHECK_SI_END
	END-IF.
	%beg csid_pref_corr_rec = NULL; %end
	Perform GET_EXEC_PARAMS Thru
		GET_EXEC_PARAMS_END
	If csid_pref_corr_rec = spaces Then
		%beg
		        Csid_compose ^OUT(Csid_err_memo)
				       "Missing Party for CHK,CHQ RULE "
					csid_pr_ordinal_ws,/ ;
 	        %End
	        Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
	    	Move 1 to Csid_ambig_parties
	    	Set Failure_is in Creditside_look_ls to true
	    	GO TO B510_DEBIT_CHECK_SI_END
	end-if.
%^
%^ Found a matching CHK or CHQSI.
	%Beg
		Ent_ftr_set.Si_flgs.Check_found = "Y" ;
	%End.
	Set CDT in Relget_title_flag to TRUE.
	%Beg  Csid_lookup_temp = Csid_pref_corr_rec.idkey ;  %End.
 	Move "F" to Csid_lkup_pend_del.
	Call "ACCT_LOOKUP" using
	    by reference Idtype of Csid_pref_corr_rec
	    by reference Csid_lookup_temp
    	    by reference Csid_ovr
    	    by content "F"
    	    by reference Csid_multibank_ws
    	    by reference Credit_currency_ls
	    by reference Csid_lkup_pend_del
 	  RETURNING Csid_ret_stat.

      	If (Csid_ovr NOT = SPACE )
	    If (Csid_lkup_pend_del = "T" )
%^ SCK account address is pending delete!
	        %Beg
	        Csid_compose ^OUT(Csid_err_memo)
			       "SCK address ", Csid_fx_acct_idt_ws, "/", 
				Csid_fx_acct_id_ws, " is pending delete" / ;
 	    	%End
	    ELSE
%^ Lookup failed - give memo
	        %Beg
	        Csid_compose ^OUT(Csid_err_memo)
			       "Lookup failed for SCK address "
				Csid_pref_corr_rec.Idtype, "/", 
				Csid_pref_corr_rec.idkey, / ;
 	        %End
	    END-IF
	    Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
	    Move 1 to Csid_ambig_parties
	    Set Failure_is in Creditside_look_ls to true
	    GO TO B510_DEBIT_CHECK_SI_END
	END-IF.
%^     The ID is in the REL file.  
	If Rel_id of Relget_adr_set = Cdt_rel_id of Ent_credit_set
	    GO TO B510_DEBIT_CHECK_SI_END
	END-IF.
* CHK account is not already the credit party.  Insert it.
	%Beg
	BREAK: Csid_adr_set ;
	Relget_adr_set EQUATE: Csid_adr_set(NOMOD) ;
        BREAK: Relget_adr_set ;
	%End.
	%ACE_IS Ent_c_adr_set connected giving Csid_conn_stat;

	If (Success_is in Csid_conn_stat)
	    %Beg  
	    Ent_c_adr_set EQUATE: Relget_adr_set(NOMOD) ;
	    BREAK: Ent_c_adr_set ;
	    %End
	ELSE
	    Move ZERO to Rel_id of Relget_adr_set
	END-IF.
	Set Failure_is in Csid_push_error to TRUE.
	PERFORM C800_PUSH_CREDIT through C800_PUSH_CREDIT_END.
	If Success_is in Csid_push_error
* OOPSIEs.  No room to push
	    GO TO B510_DEBIT_CHECK_SI_END
        END-IF.
	%Beg
	BREAK: Relget_adr_set;
	Csid_adr_set EQUATE: Relget_adr_set(NOMOD) ;
	Csid_adr_set EQUATE: Ent_c_adr_set(NOMOD) ;
	BREAK: Csid_adr_set;
	%End.
	PERFORM C720_COPY_ADDRESS through C720_COPY_ADDRESS_END.
	If (Relget_return_key NOT = SPACES )
	    %Beg
	    Csid_parse ^IN(Relget_return_key)
				 Csid_pref_corr_rec.idkey, ^SPACE, / ;
	    %End
	END-IF.
%^ And now lets add an info memo saying what happened
	%Beg
		Ent_credit_set.Cdt_adv_typ = "SCK";
		Ent_ftr_set.Flgs.Cdt_adv_flg = "Y" ;
		Ent_ftr_set.si_flgs.check_found = "Y";
		Csid_compose ^OUT(Csid_info_memo)
		    	"CHK SI inserted ", Csid_pref_corr_rec.idtype, "/",
			Csid_pref_corr_rec.idkey, " -> ", 
			Ent_credit_set.Cdt_typ.Cdt_idtype,"/", 
			Ent_credit_set.Cdt_typ.Cdt_id, / ;
		csid_know_acc_id = NULL;	
	%End
	Perform X920_INFO_MEMO through X920_INFO_MEMO_END
 	%Beg
		Ent_credit_set.Cdt_adr_bnk_id = Relget_adr_set.bnk_id ;
		Csid_id_ws = Csid_pref_corr_rec.idkey ;
	%End
	If (Cdt_adr_bnk_id of Ent_credit_set NOT = SPACES )
	    AND (Cdt_adr_bnk_id of Ent_credit_set NOT =
				Bank of Loc_info of Ent_ftr_set )
	THEN
	    %Beg
	    Csid_parse ^IN(Csid_pref_corr_rec.Idkey), 
				^STRING<3>, ":", ^STRING, / ;
	    %End
	    If (Failure_is in Csid_parse_status   )
		%Beg
		Csid_compose ^OUT(Csid_id_ws)
				Ent_credit_set.cdt_adr_bnk_id, ":",
				Csid_pref_corr_rec.Idkey, / ;
		%End
	    END-IF
	END-IF.

	%Beg
	 	Ent_credit_set.Cdt_typ (.Cdt_ovr    = Csid_ovr,
 					.Cdt_idtype = Csid_pref_corr_rec.Idtype,
					.Cdt_id     = Csid_id_ws ) ;
		Ent_credit_set(.cdt_rel_id = Relget_adr_set.rel_id,
		               .flgs3.cdt_adr_ptr_ok = "T",
			       .cdt_adr_set_ptr POINT: Relget_adr_set);
		BREAK: Ent_c_adr_set ;
		Relget_adr_set EQUATE: Ent_c_adr_set(NOMOD) ;
	%End.

	Set Success_is in csid_musthave_acct to True.


	PERFORM X980_CHANGE_CREDIT thru
		X980_CHANGE_CREDIT_END.

%^ NO Need to call, SCK is already set. Perform B400_SET_ADVICE through B400_SET_ADVICE_END.

%^B500_DEBIT_SIS_END.
B510_DEBIT_CHECK_SI_END.

   EXIT.
B520_RECONNECT.
* Makes sure that Ent_c_adr_set and other necessities are connected properly
*  for SI processing.

	%Beg  BREAK: Csid_acc_seq ;  %End.

	If (Cdt_ovr of Cdt_typ of Ent_credit_set = SPACE) 
	   AND (Cdt_rel_id of Ent_credit_set NOT = 0 )
	THEN
*  Hook up address set - we will need it.
	    %ACE_IS Ent_c_adr_set connected giving Csid_conn_stat;
	    If (Failure_is in Csid_conn_stat)
		If (Cdt_rel_id of Ent_credit_set NOT = 0 )
		    %ace_conn_root_q Rel_index ;
                    %Beg
		    BREAK: Relget_adr_set ;
		    Rel_index ^SEARCH (Key = Ent_credit_set.cdt_rel_id);
		    %end
		    If (Success_is in Rel_index_status   )
		       AND (OBJECT_IS in Rel_index_cursor )
		       AND (ADDRESS_IS in Rel_type of Rel_index)
                    THEN
		        %Beg  
			Rel_index CONN: Ent_c_adr_set(NOMOD) ;          
		        %End
			%ACE_IS Ent_c_adr_set connected giving Csid_conn_stat;
                    END-IF
		END-IF
	    END-IF
	    If (Failure_is in Csid_conn_stat)
* We really DON'T have a credit party.
                If (Cdt_rel_id of Ent_credit_set NOT = 0 )
                    %Beg
                    Ent_credit_set( .Cdt_shnam  = NULL ,
				    .Cdt_name1  = NULL ,
                                    .Cdt_name2  = NULL ,
                                    .Cdt_name3  = NULL ,
                                    .Cdt_name4  = NULL ) ;
                    %End
                    %^ Clear all the other stuff left over from previous
                    %^   on-file address
                    Call "ACCTSUB_CDT_NOF"
                    MOVE "N" to Cdt_comm_charge_ws
                    MOVE "N" to Cdt_cbl_charge_ws
                END-IF
		%Beg  
		Ent_credit_set.cdt_typ.Cdt_ovr = "*" ;		
		Ent_credit_set( .Cdt_rel_id 	   = <0> ,
			        .Cdt_adr_set_ptr DELETE,
				.flgs3.cdt_adr_ptr_ok = Null) ;
                BREAK: Relget_adr_set ;
		BREAK: Ent_c_adr_set ;
                %End
	    ELSE
		%Beg
		Ent_c_adr_set.account_seq CONN: Csid_acc_seq (NOMOD) ;
		BREAK: Relget_adr_set ;
		Ent_c_adr_set EQUATE: Relget_adr_set(NOMOD) ;
	    	%End
 	    END-IF
            Perform B420_GET_NEWPARTY through B420_GET_NEWPARTY_END
	END-IF
	If (Cdt_ovr of Cdt_typ of Ent_credit_set = SPACE) then
	    Set Failure_is in Csid_didansi_ws to TRUE
	END-IF.

B520_RECONNECT_END.


   EXIT.
C600_UPDATE_BNP.
* Paragraph to update BNP id from contents of Csid_party_id/idtype.
* Removed overflow logic  - obsolete

	If (Bnp_id of Bnp of Ent_credit_set NOT = Csid_party_id )
		%Beg  Ent_credit_set.Bnp.Bnp_id = Csid_party_id ;  %End
	END-IF.

	If Bnp_idtype of Bnp of Ent_credit_set NOT = Csid_party_idtype 
	    %Beg  Ent_credit_set.bnp.bnp_idtype = Csid_party_idtype ;  %End
	END-IF.
	If (Bnp_bnk_flg of Ent_credit_set = SPACE OR "N" )
	  AND (Csid_party_idtype = "B" OR "A" OR "S" )
	THEN
            %Beg  Ent_credit_set.Bnp_bnk_flg = "Y";  %End
	END-IF.
*	Set the bnp_bnk_flg for E/Ids 
	IF Csid_party_idtype = "E" 
	THEN
	    Call "CHK_E_ID_BANK" using
	    	by reference bnp_idtype of Ent_credit_set
	       	by reference bnp_id     of Ent_credit_set
	      returning Csid_temp_stat
	    If Success_is in Csid_temp_stat
            then
		%Beg  Ent_credit_set.Bnp_bnk_flg = "Y";  %End
	    else
		%Beg  Ent_credit_set.Bnp_bnk_flg = "N";  %End
	    end_if
	END-IF.

	If bnp_res_country of ent_credit_set = spaces
	    Initialize Csid_risk_country_ws, Csid_country_code_ws
	    Call "DETERM_RES_COUNTRY" using
	       by content "BNP"
	       by reference bnp_idtype of Ent_credit_set
	       by reference bnp_id of Ent_credit_set
	       by reference bnp_id_length of Ent_credit_set_lengths
	       by reference Csid_risk_country_ws
	       by reference Csid_country_code_ws
	       by reference bnp_res_country of Ent_credit_set
	       by reference Csid_res_country_ws
	    If Csid_res_country_ws not = spaces
	        %Beg Ent_credit_set.bnp_res_country = Csid_res_country_ws; %end
	    end-if
	end-if.

C600_UPDATE_BNP_END.

   EXIT.
C610_UPDATE_BBK.
* Paragraph to update BBK id from contents of Csid_party_id/idtype.
* Removed overflow logic - obsolete
	If (Bbk_id of Bbk of Ent_credit_set NOT = Csid_party_id )
		%Beg  Ent_credit_set.Bbk.Bbk_id = Csid_party_id ;  %End
	END-IF.

	If Bbk_idtype of Bbk of Ent_credit_set NOT = Csid_party_idtype 
	    %Beg  Ent_credit_set.bbk.bbk_idtype = Csid_party_idtype ;  %End
	END-IF.

	If bbk_res_country of ent_credit_set = spaces and 
	   Bbk_idtype of Bbk of Ent_credit_set NOT = Spaces and
	   Bbk_id of Bbk of Ent_credit_set NOT = Spaces
	Then
	    Initialize Csid_risk_country_ws, Csid_country_code_ws
	    If rel_id of relget_adr_set not = 0
	    Then
		  %Ace_is relget_adr_set connected;
		  If success_is in ace_status_wf
	            Move risk_country of relget_adr_set to Csid_risk_country_ws
	            Move country_code of relget_adr_set to Csid_country_code_ws
		  end-if
	    end-if
	    Call "DETERM_RES_COUNTRY" using
	       by content "BBK"
	       by reference bbk_idtype of Ent_credit_set
	       by reference bbk_id of Ent_credit_set
	       by reference bbk_id_length of Ent_credit_set_lengths
	       by reference Csid_risk_country_ws
	       by reference Csid_country_code_ws
	       by reference bbk_res_country of Ent_credit_set
	       by reference Csid_res_country_ws
	    If Csid_res_country_ws not = spaces
	    Then
	        %Beg Ent_credit_set.bbk_res_country = Csid_res_country_ws; %end
	    end-if
	end-if.

C610_UPDATE_BBK_END.

   EXIT.
C620_UPDATE_IBK.
* Paragraph to update IBK id from contents of Csid_party_id/idtype.
* Removed overflow logic - obsolete
	If (Ibk_id of Ibk of Ent_credit_set NOT = Csid_party_id )
		%Beg  Ent_credit_set.Ibk.Ibk_id = Csid_party_id ;  %End
	END-IF.
	If Ibk_idtype of Ibk of Ent_credit_set NOT = Csid_party_idtype 
	    %Beg  Ent_credit_set.ibk.ibk_idtype = Csid_party_idtype ;  %End
	END-IF.

	%^	Ensure that we fill in res_country if possible

	If ibk_res_country of ent_credit_set = spaces
	    Initialize Csid_risk_country_ws, Csid_country_code_ws
	    If rel_id of relget_adr_set not = 0
		  %Ace_is relget_adr_set connected;
		  If success_is in ace_status_wf
	            Move risk_country of relget_adr_set to Csid_risk_country_ws
	            Move country_code of relget_adr_set to Csid_country_code_ws
		  end-if
	    end-if
	    Call "DETERM_RES_COUNTRY" using
	       by content "IBK"
	       by reference ibk_idtype of Ent_credit_set
	       by reference ibk_id of Ent_credit_set
	       by reference ibk_id_length of Ent_credit_set_lengths
	       by reference Csid_risk_country_ws
	       by reference Csid_country_code_ws
	       by reference ibk_res_country of Ent_credit_set
	       by reference Csid_res_country_ws
	    If Csid_res_country_ws not = spaces
	        %Beg Ent_credit_set.ibk_res_country = Csid_res_country_ws; %end
	    end-if
	end-if.

C620_UPDATE_IBK_END.

   EXIT.
C630_UPDATE_IB1.
* Paragraph to update IB1 id from contents of Csid_party_id/idtype.
* Removed overflow logic - obsolete
	If (Ib1_id of Ib1 of Ent_credit_set NOT = Csid_party_id )
		%Beg  Ent_credit_set.Ib1.Ib1_id = Csid_party_id ;  %End
	END-IF.
	If Ib1_idtype of Ib1 of Ent_credit_set NOT = Csid_party_idtype 
	    %Beg  Ent_credit_set.ib1.ib1_idtype = Csid_party_idtype ;  %End
	END-IF.

	%^ Ensure that we fill in res_country if possible

	If ib1_res_country of ent_credit_set = spaces
	    Initialize Csid_risk_country_ws, Csid_country_code_ws
	    If rel_id of relget_adr_set not = 0
		  %Ace_is relget_adr_set connected;
		  If success_is in ace_status_wf
	            Move risk_country of relget_adr_set to Csid_risk_country_ws
	            Move country_code of relget_adr_set to Csid_country_code_ws
		  end-if
	    end-if
	    Call "DETERM_RES_COUNTRY" using
	       by content "IB1"
	       by reference ib1_idtype of Ent_credit_set
	       by reference ib1_id of Ent_credit_set
	       by reference ib1_id_length of Ent_credit_set_lengths
	       by reference Csid_risk_country_ws
	       by reference Csid_country_code_ws
	       by reference ib1_res_country of Ent_credit_set
	       by reference Csid_res_country_ws
	    If Csid_res_country_ws not = spaces
	        %Beg Ent_credit_set.ib1_res_country = Csid_res_country_ws; %end
	    end-if
	end-if.

C630_UPDATE_IB1_END.

   EXIT.

C650_LOOKUP_BBK_ADDRESS.

%^ If the secondary wire flag has a chance of being defaulted to "Y",
%^ then do a REL lookup of the BBK address.  Valdate_edit will determine if
%^ preadvising needs to be done for the message, and if so, Ftrscr_edits will
%^ set the Bbk_secwir flag to "Y".  If the Bbk_secwir flag is set to "Y",
%^ the REL will then be needed for destination info.
%^ Look for a SWIFT ID with no parenthesis
* Removed overflow from compose - obsolete
        %Beg
        Csid_compose ^OUT(Csid_temp1_vstr)
                        Ent_credit_set.Bbk.Bbk_id, / ;
        Csid_parse ^IN(Csid_temp1_vstr)
                        ^STRING, "/BC", Csid_temp2_vstr,
                        ^ONEOF ( ("/", ^STRING, / ),
                                 (/) ) ;
        %End.

%^ If there's a SWIFT ID, we don't need to lookup the REL Address.
        If (Success_is in Csid_parse_status   )
            Go to C650_LOOKUP_BBK_ADDRESS_end
        END-IF.

%^ Look for a SWIFT ID with parentheses
        %Beg
        Csid_parse ^IN(Csid_temp1_vstr),
                        ^STRING, "/(BC", Csid_temp2_vstr,
                        ^ONEOF ( ("/", ^STRING, / ),
                                 (")", ^STRING, / ),
                                 (/) ) ;
        %End.

%^ If there's a SWIFT ID, we don't need to lookup the REL Address.
        If (Success_is in Csid_parse_status   )
            Go to C650_LOOKUP_BBK_ADDRESS_end
        END-IF.

%^ Set up the temporary Idtype and ID
        %Beg
        Csid_parse ^IN(Csid_temp1_vstr)
            Csid_lookup_temp, ^ONEOF ( ("/", ^STRING, / ),
                                       ("(", ^STRING, / ),
                                       (/) ) ;
        Csid_temp_idtype = Ent_credit_set.Bbk.Bbk_idtype ;
        %End.

%^ If there's no idtype, look for a CH, FW or CP second party
        If Csid_temp_idtype = " " then
            %Beg
            Csid_parse ^IN(Csid_temp1_vstr)
                ^STRING,
                Csid_oneof_bbk( ^ONEOF(
                          ("/CH",|Csid_temp2_vstr, ^SPACE, /),
                          ("/(CH",|Csid_temp2_vstr, ^SPACE, /),
                          ("/FW",|Csid_temp2_vstr, ^SPACE, /),
                          ("/(FW",|Csid_temp2_vstr, ^SPACE, /),
                          ("/CP",|Csid_temp2_vstr, ^SPACE, /)
                          ("/(CP",|Csid_temp2_vstr, ^SPACE, /) ));
            %End
            If Success_is in Csid_parse_status  
                %Beg
                Csid_parse ^IN(Csid_temp2_vstr)
                    Csid_lookup_temp, ^ONEOF ( ("/", ^STRING, / ),
                                               (")", ^STRING, / ),
                                               ("(", ^STRING, / ),
                                               (/) ) ;
                %End
                Evaluate TRUE
                    When Csid_oneof_bbk = 0 or 1
                        Move "C" to Csid_temp_idtype
                    When Csid_oneof_bbk = 2 or 3
                        Move "A" to Csid_temp_idtype

		    When (Csid_oneof_bbk = 4 or 5)
			If (Cdt_adr_bnk_id of Ent_credit_set NOT = SPACES )
			    %Beg
			    Csid_acc_bank_ws = Ent_credit_set.Cdt_adr_bnk_id;
			    %End
			ELSE
			    %Beg
			    Csid_acc_bank_ws = Ent_ftr_set.Loc_info.Bank;
			    %End
			END-IF
			Call "IS_SWF_CLEARHOUSE" Using
			    By Reference Csid_acc_bank_ws
			    By content "CP"
			  Returning Csid_itsa_clearhouse
			If (Success_is in Csid_itsa_clearhouse)
			    Move "P" to Csid_temp_idtype
		 	ELSE
%^ Else set up "CP" as an extended ID
			    Move "E" to Csid_temp_idtype
			    %Beg
			    Csid_clip_compose ^OUT(Csid_temp1_vstr)
			        Csid_lookup_temp, / ;
			    %End
			    Move Csid_temp1_vstr to Csid_lookup_temp(3:)
			    Move "CP" To Csid_lookup_temp(1:2)
			    Add 2 To Csid_lookup_temp_length
			END-IF

                END-EVALUATE
              ELSE
                go to C650_LOOKUP_BBK_ADDRESS_end
            end-if
        end-if.

%^ If the idtype is E, look for a CH, FW or CP party
        If Csid_temp_idtype = "E" then
            %Beg
            Csid_parse ^IN(Csid_temp1_vstr)
                Csid_oneof_bbk( ^ONEOF(
                          ("CH",|Csid_temp2_vstr, ^SPACE, /),
                          ("FW",|Csid_temp2_vstr, ^SPACE, /),
                          ("CP",|Csid_temp2_vstr, ^SPACE, /) ));
            %End
            If Success_is in Csid_parse_status  
                %Beg
                Csid_parse ^IN(Csid_temp2_vstr)
                    Csid_lookup_temp, ^ONEOF ( ("/", ^STRING, / ),
                                               (")", ^STRING, / ),
                                               ("(", ^STRING, / ),
                                               (/) ) ;
                %End
                Evaluate TRUE
                    When Csid_oneof_bbk = 0
                        Move "C" to Csid_temp_idtype
                    When Csid_oneof_bbk = 1
                        Move "A" to Csid_temp_idtype

		    When Csid_oneof_bbk = 2
			If (Cdt_adr_bnk_id of Ent_credit_set NOT = SPACES )
			    %Beg
			    Csid_acc_bank_ws = Ent_credit_set.Cdt_adr_bnk_id;
			    %End
			ELSE
			    %Beg
			    Csid_acc_bank_ws = Ent_ftr_set.Loc_info.Bank;
			    %End
			END-IF
			Call "IS_SWF_CLEARHOUSE" Using
			    By Reference Csid_acc_bank_ws
			    By content "CP"
			  Returning Csid_itsa_clearhouse
			If (Success_is in Csid_itsa_clearhouse)
			    Move "P" to Csid_temp_idtype
		 	ELSE
%^ Else set up "CP" as an extended ID
			    Move "E" to Csid_temp_idtype
			    %Beg
			    Csid_clip_compose ^OUT(Csid_temp1_vstr)
			        Csid_lookup_temp, / ;
			    %End
			    Move Csid_temp1_vstr to Csid_lookup_temp(3:)
			    Move "CP" To Csid_lookup_temp(1:2)
			    Add 2 To Csid_lookup_temp_length
			END-IF

                END-EVALUATE
              ELSE
                go to C650_LOOKUP_BBK_ADDRESS_end
            end-if
        end-if.

 	Move SPACES to Csid_lkup_pend_del.
        Call "ACCT_LOOKUP" using
            by reference Csid_temp_idtype
            by reference Csid_lookup_temp
            by reference Csid_ovr
            by reference Csid_ambig_ws
            by reference Csid_multibank_ws
            by reference Credit_currency_ls
	    by reference Csid_lkup_pend_del
          RETURNING Csid_ret_stat.

        If (Csid_ovr = SPACE)
            %Beg
            Ent_credit_set(.Bbk_rel_id = Relget_adr_set.rel_id,
            		   .Bbk_adr_set_ptr POINT: Relget_adr_set,
			   .flgs3.bbk_adr_ptr_ok = "T");
		
            %End
        END-IF.

C650_LOOKUP_BBK_ADDRESS_end.
   EXIT.

C655_2ND_CREDIT_ID.
%^
%^ We have an ambiguous credit party address and a non-blank second credit id
%^ which we can use to resolve the  ambiguity.  We will scan through all of the 
%^ addresses and check for a swift id that matches the second credit id.  If we
%^ find only one address with a matching swift id, we have successfully 
%^ disambiguated.  
%^
	Move Zero to Csid_qualified_rel, Csid_rel_id.
	Set Success_is in Csid_next_status to True.

	Perform Until Failure_is in Csid_next_status
	    If Swift_id of Relget_adr_set = Csid_second_id	%^ found a match
		If Csid_qualified_rel = Zero 			%^ no hit yet
		    Move Rel_id of Relget_adr_set to Csid_qualified_rel, Csid_rel_id
		    If Csid_ambig_ws = "T"     			%^ first hit is acceptable, we're done
		        Go to C655_2ND_CREDIT_ID_END
		    End-if
		else						%^ already have a hit, we're still ambiguous
		    Move Zero to Csid_qualified_rel, Csid_rel_id
		    Set Failure_is in Csid_next_status to True
	        End-if
	    End-if
	    If Success_is in Csid_next_status
	        Call "NEXT_ACCT_LOOKUP" using
		    By reference Cdt_idtype of Cdt_typ of Ent_credit_set
		    By reference Cdt_id of Cdt_typ of Ent_credit_set
		    By reference Csid_ovr
		    Returning Csid_next_status
	    End-if
	End-perform.

%^ If we get here and we're still ambiguous, reset the rel index to first ambiguous credit party
	If Csid_qualified_rel = Zero
	    Move "F" to Csid_lkup_pend_del
            Call "ACCT_LOOKUP" using               
                By reference Csid_party_idtype
                By reference Csid_lookup_temp
                By reference Csid_ovr
                By reference Csid_ambig_ws
                By reference Csid_multibank_ws
                By reference Credit_currency_ls
		By reference Csid_lkup_pend_del
                Returning Csid_ret_stat
	    If Csid_lkup_pend_del = "T"
		Set Success_is in Csid_credit_pend_del to True
		Set Failure_is in Creditside_look_ls to True
            End-if 
	End-if.

C655_2ND_CREDIT_ID_END.
	EXIT.

C660_FIND_ADR_CUR.
*
*  We have an ambiguous credit party address.
*  We also have a non-blank currency which we can use to resolve the
*  ambiguity.  We will scan through all of the addresses and check
*  the currencies on their associated accounts.  If we find only one
*  address with a matching currency, we have successfully disambiguated.
*  If we are in "nocheck_ambig" mode, we will return the first address
*  with an account in the correct currency.
        
	%ace_conn_root_q Rel_index ;
	Set Success_is in Csid_next_status to true.
	Move ZERO to Csid_qualified_rel.
	PERFORM WITH TEST BEFORE UNTIL (Failure_is in Csid_next_status   )
	    Move Rel_id of Relget_adr_set to Csid_rel_id
	    %Beg
	    BREAK: Csid_adr_set ;
	    BREAK: Csid_acc_seq ;
	    Rel_index ^SEARCH (Key = Csid_rel_id);
	    %End
	    If (Success_is in Rel_index_status   )
		AND (OBJECT_IS in Rel_index_cursor )
		AND (ADDRESS_IS in Rel_type of Rel_index)
	    THEN
		%Beg
		Rel_index CONN: Csid_adr_set(NOMOD) ;
		Csid_adr_set.account_seq CONN: 
					Csid_acc_seq ^FIRST (NOMOD) ;
                %End
		Set Failure_is in Csid_found_it to true

		If (Xbank_account_ok_ls = 0 )
* Position ourselves into the correct bank -- it's the top of the key
	    	    Perform UNTIL 
			(Idbank of Rel_name_key of Csid_acc_seq =
					Cdt_adr_bnk_id of Ent_credit_set )
			  OR (Failure_is in Csid_acc_seq_status   )
			%Beg  NEXT: Csid_acc_seq ;  %End
	    	    END-PERFORM
		END-IF
		PERFORM with TEST BEFORE UNTIL
				(Failure_is in Csid_acc_seq_status   )
				OR (Success_is in Csid_found_it   )
		                OR ( (Xbank_account_ok_ls = 0 )
                                    AND ( Bnk_id of Csid_adr_set NOT =
			      Idbank of Rel_name_key of Csid_acc_seq ) )
*  Truck through the account sequence looking for a matching currency.
		    PERFORM X880_CHECK_CURRENCY through X880_CHECK_CURRENCY_END
		    If (Success_is in Csid_curr_ok_ws)
*  Found account with matching currency.
			If (Csid_qualified_rel = 0 )
			    Move Rel_id of Csid_adr_set to Csid_qualified_rel
			    If (Csid_ambig_ws = "T" )
* First hit is acceptable, so we are done.
				GO TO C660_FIND_ADR_CUR_CLEANUP
			    END-IF
			ELSE
* We already have a hit.  Shucky darns, we are still ambiguous.
			    Move ZERO to Csid_qualified_rel
			    GO TO C660_FIND_ADR_CUR_CLEANUP
			END-IF
		    END-IF
                    %Beg  NEXT: Csid_acc_seq ;  %End
		END-PERFORM
            END-IF
	    Call "NEXT_ACCT_LOOKUP" using
	        by reference Cdt_idtype of Cdt_typ of Ent_credit_set
	        by reference Cdt_id of Cdt_typ of Ent_credit_set
	        by reference Csid_ovr
	      RETURNING Csid_next_status
        END-PERFORM.
C660_FIND_ADR_CUR_CLEANUP.
	%Beg
	BREAK: Csid_adr_set ;
	BREAK: Csid_acc_seq ;
        %End.
C660_FIND_ADR_CUR_END.


   EXIT.
C670_CHECK_COMMON_UID.

* Check for the case of a COMMON UID and SWIFT TID.

	If (Csid_party_idtype = "C" OR "S" OR space)
	  AND (Success_is in Csid_multi_party   )
	  THEN
	        If (Csid_party_idtype = "S" )
		    %Beg
		    Csid_parse ^IN(Csid_party_id )
		    	    Csid_party_swfid, "/", Csid_temp1_vstr,
			    ^SPACE, / ;
        	    %End
	        ELSE
		    %Beg
		    Csid_parse ^IN(Csid_party_id )
	    		    Csid_temp1_vstr, "/BC", Csid_party_swfid, 
			    ^SPACE, / ;
        	    %End
   	        END-IF
		%Beg Csid_party_uid = Relget_adr_set.Chips_uid_id; %End
	        If (Success_is in Csid_parse_status   ) 
		    AND (Csid_party_swfid_length = 8 OR 11 )
	        THEN 
		    If (Cdt_rel_id of Ent_credit_set NOT = 0 )
	               AND (Csid_party_swfid(1:8) = Swift_id of 
				Ent_c_adr_set(1:8) ) 
	            THEN
			%Beg
			Csid_union_key_ws(.Idname = "FED_CHIP_TABLES",
					  .Idprod = "MTS", 	   
			 		  .Idbank =  Menu_bnk_union.Bnk_id,    
			 		  .Idloc  = null,    	   
			 		  .Idcust = null);		  
   			Csid_compose ^OUT(Csid_item_key_ws),
						"CHP_COMMON_UIDS:", /; 
		 	Csid_seq_ordinal_ws = <1>;
			Csid_compose ^OUT(Csid_match_key_ws),
					 		    Csid_party_uid, /;
			%End
			Call "CFG_MATCH_ITEM" USING
			    BY Reference Idname of Csid_union_key_ws
			    BY Reference Idprod of Csid_union_key_ws
			    BY Reference Idbank of Csid_union_key_ws
			    BY Reference Idloc of Csid_union_key_ws
			    BY Reference Idcust of Csid_union_key_ws
			    BY Reference Csid_item_key_ws
			    BY Reference Csid_match_key_ws
			    BY Reference Csid_match_key_ws_length
			    BY Reference Csid_seq_ordinal_ws
			    BY Reference Csid_error_msg_ws
			    BY Reference Csid_error_msg_ws_length
            		  RETURNING Csid_chips_party
			IF Success_Is in Csid_chips_party
* Match is implied if the first part of SWIFT ID on the next party is the same
* as the credit party; i.e. the bank to which we are making the payment
* is repeated in the SWIFT ID of the next party
	    		    %Beg
 	   		    Csid_compose ^OUT(Csid_info_memo)
			      "Message had common CHIPS UID and SWF TID match", 
				/ ;
    			    %End
    			    Perform X920_INFO_MEMO through 
						X920_INFO_MEMO_END
			    If (Csid_party_idtype = "S" )
* Reverse the fields to put the common UID first.
			        %Beg
			        Csid_party_idtype = "C" ;
			        Csid_compose ^OUT(Csid_party_id )
				        Csid_party_uid, "/BC", 
				        Csid_party_swfid, / ;
			        %End
			    ELSE
				If Csid_party_idtype = spaces
				    %Beg
				    Csid_temp1_vstr = Csid_party_id;
				    Csid_compose ^OUT(Csid_party_id)
					Csid_temp1_vstr,
					"/(CH",Csid_party_uid,")",/;
				    %END
				END-IF
			    END-IF
		        END-IF			
		    END-IF
        	END-IF
	END-IF.
                    
C670_CHECK_COMMON_UID_end.


   EXIT.
C680_CDT_SWF_PARENT.
%^    If the SWIFT key length is 11, then try a lookup by the 1st 8 characters.
%^    If found, and there is a DDA, then assume that the parent can become the
%^ credit party and the branch will be moved down to the IBK.
%^ If name/address of the original credit party was found on auxiliary database,
%^     copy it
	%Beg
	Csid_id_ws = NULL ;
	Compose ^Out(Csid_tmp_id_ws) Ent_credit_set.cdt_typ.cdt_id,/;
	Csid_Parse ^IN(Csid_tmp_id_ws),
	 	^ONEOF( (^STRING, ":", Csid_id_ws, ^ONEOF(/, "/")),
	  		(Csid_id_ws, ^ONEOF(/, "/")) );
	%End.
	If (Csid_id_ws_length NOT = 11)
	    GO TO C680_CDT_SWF_PARENT_END
	END-IF.

	If ( Csid_ovr = "*" )
        and (Relget_msgcode = Vmsg_dat_notonfile_wc )
                THEN
* We actually did get a AUX db hit, so let's copy the address.
                    Perform C720_COPY_ADDRESS through C720_COPY_ADDRESS_END
        end-if.

%^ Try lookup using 8 character key
	Set CDT in Relget_title_flag to TRUE.
	Move spaces to Csid_id_ws(9:3).
	Move 8 to Csid_id_ws_length.
 	Move "F" to Csid_lkup_pend_del.
	Call "ACCT_LOOKUP" using
	    by reference Cdt_idtype of Cdt_typ of Ent_credit_set
	    by reference Csid_id_ws
	    by reference Csid_2nd_ovr
	    by content "F"
	    by reference Csid_multibank_ws
	    by reference Credit_currency_ls
	    by reference Csid_lkup_pend_del
	 RETURNING Csid_ret2_stat.

	If (Csid_lkup_pend_del = "T")
%^ Parent address is pending delete!
	    %Beg
	    Csid_compose ^OUT(Csid_err_memo)
		"Credit party ", Ent_credit_set.Cdt_typ.Cdt_idtype, "/",
			Ent_credit_set.Cdt_typ.Cdt_id, " parent "
			Csid_id_ws, " is marked for delete", / ;
 	    %End
	    Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
	    Move 1 to Csid_ambig_parties
	    Set Failure_is in Creditside_look_ls to true
        End-if. 

%^ Check for an on-file DDA account for this address.
	If (Csid_2nd_ovr  = SPACE )
	    %ace_is Relget_adr_set connected returning Ace_status_wf ;
	    If Success_is in Ace_status_wf            
	        %Beg
	        Relget_adr_set.Account_seq CONN: Csid_acctyp_seq(NOMOD);
	        SCAN: Csid_acctyp_seq(Key = "D");
	        %End
	    ELSE	
	        MOVE SPACES to Csid_acctyp_seq
	    END-IF
	END-IF.

%^ Lookup failed - no action, remove side effects so caller copies name & addr
	If (Csid_2nd_ovr Not = SPACE )
	   OR (Idtype of Rel_name_key of Csid_acctyp_seq NOT = "D" )
	   OR (Disp_nof of Csid_acctyp_seq NOT = SPACES )
	THEN
* Just replace our divot by re-doing the initial lookup
	    %Beg  BREAK: Csid_acctyp_seq;  %End
	    Set CDT in Relget_title_flag to TRUE
 	    Move "F" to Csid_lkup_pend_del
	    Call "ACCT_LOOKUP" using
	        by reference Cdt_idtype of Cdt_typ of Ent_credit_set
	        by reference Cdt_id of Cdt_typ of Ent_credit_set
	        by reference Csid_ovr
	        by reference Csid_ambig_ws 
	        by reference Csid_multibank_ws
	        by reference Credit_currency_ls
	        by reference Csid_lkup_pend_del
	      RETURNING Csid_ret_stat
	    GO TO C680_CDT_SWF_PARENT_END
	ELSE
	    %Beg  BREAK: Csid_acctyp_seq;  %End
	END-IF.

%^     The 8 character ID is in the REL file.  Make it the preferred corresp.
        Set PUSHDOWN in Csid_do_pushdown to true
	%Beg
	Csid_pref_corr_rec.Idtype = "S" ;
	Csid_pref_corr_rec.Idkey = Csid_id_ws ;
%^ And now lets add an info memo saying what happened
	Csid_compose ^OUT(Csid_info_memo)
		"SWF branch ", Csid_pref_corr_rec.idkey, 
			" inserted -> ", Ent_credit_set.Cdt_typ.Cdt_idtype,"/", 
			Ent_credit_set.Cdt_typ.Cdt_id," pushed down. " , / ;
	%End.
	Perform X920_INFO_MEMO through X920_INFO_MEMO_END.
	If (Bnk_id of Relget_adr_set NOT = SPACES )
	    %Beg  
	    Ent_credit_set.Cdt_adr_bnk_id = Relget_adr_set.bnk_id ;
            %End
        ELSE
	    %Beg  
	    Ent_credit_set.Cdt_adr_bnk_id = Ent_ftr_set.Loc_info.Bank ;
            %End
        END-IF.
	%^ Still need to reset the CDT party to it's original,
	%^ pef corr loop will re-lookup after push
	Set CDT in Relget_title_flag to TRUE
 	Move "F" to Csid_lkup_pend_del
	Call "ACCT_LOOKUP" using
	        by reference Cdt_idtype of Cdt_typ of Ent_credit_set
	        by reference Cdt_id of Cdt_typ of Ent_credit_set
	        by reference Csid_ovr
	        by reference Csid_ambig_ws 
	        by reference Csid_multibank_ws
	        by reference Credit_currency_ls
	        by reference Csid_lkup_pend_del
	RETURNING Csid_ret_stat.

C680_CDT_SWF_PARENT_END.


   EXIT.
C690_SNAM_CHCK.
        Move ZERO to Csid_qualified_rel,
                            Csid_rel_id.

	If Cdt_name1 of Ent_credit_set = Spaces
           go to C690_SNAM_CHCK_END
	End-if.

	%Beg
	Csid_name1_ws = Ent_credit_set.cdt_name1;
	Csid_sname_ws = NULL;
	%End.

        Call "AUTONAM" using
	    By reference Csid_name1_ws
	    By reference Csid_name1_ws_length
            by reference Csid_sname_ws
            by reference Csid_sname_ws_length.

        Set Success_is in Csid_next_status to true.
        PERFORM WITH TEST BEFORE UNTIL (Failure_is in Csid_next_status   )
           If Csid_sname_ws = Sname_id of Relget_adr_set
              If Csid_qualified_rel  not = 0
                 Move ZERO to Csid_qualified_rel,
				     Csid_rel_id
                 go to C690_SNAM_CHCK_END
               Else
                 Move rel_id of Relget_adr_set  to Csid_qualified_rel,
                                                   Csid_rel_id
              End-if
           End-if
           Call "NEXT_ACCT_LOOKUP" using
                by reference Cdt_idtype of Cdt_typ of Ent_credit_set
                by reference Cdt_id of Cdt_typ of Ent_credit_set
                by reference Csid_ovr
              RETURNING Csid_next_status
        End-Perform.

C690_SNAM_CHCK_END.



   EXIT.
C700_CHECK_SWIFT_QUAL.
%^ SPR 25062
%^  If SWF TID is present in Csid_part_id, try to qualify it again.
%^  If qualification is successful, this should go to REPAIR, since
%^  the SWF TID has a different UID.
%^  If it is not qualified, it should go straight thru qualified by 
%^  ACC NO.

%^  try to find a SWIFT TID
	If (Csid_party_idtype = "C" OR "S" OR space)
	  AND (Success_is in Csid_multi_party   )
	  THEN
	        If (Csid_party_idtype = "S" )
		    %Beg
		    Csid_parse ^IN(Csid_party_id )
		    	    Csid_party_swfid, "/", Csid_temp1_vstr,
			    ^SPACE, / ;
        	    %End
	        ELSE
		    %Beg
		    Csid_parse ^IN(Csid_party_id )
	    		    Csid_temp1_vstr, "/BC", Csid_party_swfid, 
			    ^SPACE, / ;
        	    %End
   	        END-IF
  	        If (Success_is in Csid_parse_status   ) 
		    AND (Csid_party_swfid_length = 8 OR 11 )
	        THEN
     	         Call "CHIPS_QUALIFICATION"  USING
 		     By content "S"
	             By reference Csid_party_swfid
	           RETURNING Csid_ret_stat
	         If (Success_is in Csid_ret_stat   )
                  then
%^ Send it to REPAIR
	           %Beg
		   Csid_compose ^OUT(Csid_err_memo)
		    	"CHIPS payment; A/C NO and SWIFT on different UIDs.", /;
	           %End
		   Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
		   Move 0 to Cdt_not_suspect_ls
		   Set Failure_is in Creditside_look_ls to true
		   Set Failure_is in Csid_try_chips to TRUE
		  else
%^ accept it as qual
%^ reset relget_adr-set
     	            Call "CHIPS_QUALIFICATION"  USING
		        By reference Csid_party_idtype
	                By reference Csid_party_id    
	              RETURNING Csid_ret_stat
		   set Success_is in Csid_chips_party to true
                 END-IF
                END-IF
        END-IF.
C700_CHECK_SWIFT_QUAL_END.


   EXIT.
C705_CHIPS_DOUBLE_ID.
%^ MPER 48548 / SPR 37490 -this is called when CHIPS_DOUBLE_ID_FLAG = "Y"
%^             and the primary id is found on AUX but the second id
%^             does not agree.
%^  - This routine looks for two specific cases:
%^  - if Account/UID, drop the UID and map the account number- with Memo
%^  - if UID/BIC,     drop the BIC and map the UID - with Memo. 
%^     In these case, allow it to go straight thru as unqualified.
%^     by setting Csid_chips_party to SUCCESS
%^  - Anything else, no change  


%^ -a. if UID and BIC, drop BIC       
	If (Csid_party_idtype = "C" )
	  AND (Success_is in Csid_multi_party)
	  THEN
	    %Beg
              Csid_parse ^IN(Csid_party_id )
	        Csid_temp1_vstr, "/BC", Csid_party_swfid, 
			 ^SPACE, / ;
            %End
  	     If (Success_is in Csid_parse_status ) 
	      AND (Csid_party_swfid_length = 8 OR 11 )
	      THEN 
               %beg
                Csid_party_id = Csid_temp1_vstr;
                Csid_compose ^OUT(Csid_info_memo)
                 "Double Id -Swift id ", Csid_party_swfid,
                 " dropped.", / ; 
               %end
               Perform X920_INFO_MEMO thru X920_INFO_MEMO_END
               set Success_is in Csid_chips_party to TRUE
               Go to C705_CHIPS_DOUBLE_ID_END
             End-if
        End-if.

%^ -b. if Account and UID, drop the UID
	If (Csid_party_idtype = "D" or " "  )
	  AND (Success_is in Csid_multi_party)
	  THEN
	    %Beg
              Csid_parse ^IN(Csid_party_id )
	        Csid_temp1_vstr, "/CH", Csid_party_uid, 
			 ^SPACE, / ;
            %End
  	     If (Success_is in Csid_parse_status) 
	      AND (Csid_party_uid_length = 6 )
	      THEN 
               %beg
                Csid_party_id = Csid_temp1_vstr;
                Csid_compose ^OUT(Csid_info_memo)
                 "Double Id -Chips uid id ", Csid_party_uid,
                 " dropped.", / ; 
               %end
               Perform X920_INFO_MEMO thru X920_INFO_MEMO_END
               set Success_is in Csid_chips_party to TRUE
               Go to C705_CHIPS_DOUBLE_ID_END
             End-if
        End-if.
C705_CHIPS_DOUBLE_ID_END.


   EXIT.
C710_CDT_NIA_PRF.

       CALL "CUST_NIA_PREF_CORR" USING
         BY REFERENCE Csid_New_Idtype_Ws
         BY REFERENCE Csid_New_Id_Ws_Length
         BY REFERENCE Csid_New_Id_Ws
         RETURNING Csid_Nia_Stat.
       IF (Success_is in Csid_Nia_Stat  )
       THEN
           Set CDT in Relget_title_flag to TRUE
*           The ID is in the REL file.  Make it the preferred corresp.
           SET PUSHDOWN in Csid_do_Pushdown to true
           %BEG
               Csid_Pref_Corr_Rec.Idtype = Csid_New_Idtype_Ws;
               Csid_Pref_Corr_Rec.Idkey = Csid_New_Id_Ws;

%^               And now lets add an info memo saying what happened
               Csid_Compose ^OUT (Csid_Info_Memo)
                   "Pref correspondent ",Csid_Pref_Corr_Rec.Idtype,
                   "/",Csid_Pref_Corr_Rec.Idkey,
                   " inserted -> ", Ent_Credit_Set.Cdt_Typ.Cdt_Idtype,"/",
                   Ent_Credit_Set.Cdt_Typ.Cdt_Id," pushed down. " , / ;
               BREAK: Csid_acctyp_seq;
           %End
           Perform X920_INFO_MEMO through X920_INFO_MEMO_END
       END-IF.

C710_CDT_NIA_PRF_END.


   EXIT.
C720_COPY_ADDRESS.
%^ Copies address from Relget_adr_set to Credit party.  Also does zip code.
%^      Do not increment database to initialize fields
	If (Adr_name_length of Relget_adr_set_lengths = ZERO )
           AND (Cdt_name1_length of Ent_credit_set_lengths NOT = ZERO )
	THEN
	    %Beg  Ent_credit_set.Cdt_name1 = NULL;  %End
	END-IF.
	If (Adr1_length of Relget_adr_set_lengths = ZERO )
	   AND (Cdt_name2_length of Ent_credit_set_lengths NOT = ZERO )
	THEN
             %Beg  Ent_credit_set.Cdt_name2 = NULL;  %End
	END-IF.
	If (Adr2_length of Relget_adr_set_lengths = ZERO )
	    AND (Cdt_name3_length of Ent_credit_set_lengths NOT = ZERO )
	THEN
            %Beg  Ent_credit_set.Cdt_name3 = NULL;  %End
	END-IF.
	If (Adr3_length of Relget_adr_set_lengths = ZERO )
	    AND (Cdt_name4_length of Ent_credit_set_lengths NOT = ZERO )
        THEN
 	    %Beg  Ent_credit_set.Cdt_name4 = NULL;  %End
        END-IF.
	If (Fed_short_name_length of Relget_adr_set_lengths = ZERO )
	THEN
 	    %Beg  Ent_credit_set.Cdt_shnam = NULL;  %End
	END-IF.
	%Beg
	Csid_Compose Relget_adr_set (
	  .Adr_name (^IF_NOTNULL(^OUT(Ent_credit_set.Cdt_name1), ^_, /)),
	  .Adr1 (^IF_NOTNULL(^OUT(Ent_credit_set.Cdt_name2), ^_, /)),
	  .Adr2 (^IF_NOTNULL(^OUT(Ent_credit_set.Cdt_name3), ^_, /)),
	  .Adr3(^IF_NOTNULL(^OUT(Ent_credit_set.Cdt_name4), ^_, /)),
	  .Fed_short_name(^IF_NOTNULL(^OUT(Ent_credit_set.Cdt_shnam),^_, /))) ;
%^ Build a CDT_ADR_TYPE field from country code and 
%^   ADR_TYPE field of Relget_adr_set
	Csid_Compose ^OUT(Ent_credit_set.Cdt_adr_type),
		Relget_adr_set.Country_code(^STRING<2>),
		Relget_adr_set.Adr_type, /;
	%End.

%^ copy in the zip code too
	If (Zip of Relget_adr_set NOT = SPACES )
	    Call "ZIPSUB" Using
		by reference Cdt_name4 of Ent_credit_set
		by reference Cdt_name4_length of Ent_credit_set_lengths
		by reference Cdt_name3 of Ent_credit_set
		by reference Cdt_name3_length of Ent_credit_set_lengths
		by reference Zip of Relget_adr_set
		by reference Line_flg_ws

	    EVALUATE Line_flg_ws
		WHEN "4"
		    %Beg  Ent_credit_set.Cdt_name4 CHANGE;  %End

		WHEN "3"
		    %Beg  Ent_credit_set.Cdt_name3 CHANGE;  %End

	    END-EVALUATE
	END-IF.

	%^ Beleived to be redundant, already called in
	%^ b280_credit_addr
	%^	PERFORM X980_CHANGE_CREDIT thru
	%^	X980_CHANGE_CREDIT_END.

C720_COPY_ADDRESS_END.


   EXIT.
C730_GET_PID_SUFFIXES.

%^ This routine builds a list of all the 3 character suffixes of P
%^ accounts connected to the address.  The suffixes are delimited by commas.
	%Beg
	Csid_suffixes = NULL;
	BREAK: Csid_acc_seq;
	%End.
	%ACE_IS Csid_adr_set connected giving Csid_conn_stat;
	If (Failure_is in Csid_conn_stat)
	    GO TO C730_GET_PID_SUFFIXES_END
	END-IF.
	%Beg
	BREAK: Csid_acc_seq;
	Csid_adr_set.account_seq CONN: Csid_acc_seq(NOMOD) ;
	FIRST: Csid_acc_seq;
	Csid_compose ^OUT(Csid_suffixes);
	%End.
	Set Failure_is in Csid_found_it to TRUE.
	PERFORM UNTIL (Failure_is in Csid_acc_seq_status )
	    If (Idtype of Rel_name_key of Csid_acc_seq = "P")
		%Beg
		Csid_clip_compose ^OUT(Csid_temp1_vstr),
		    Csid_acc_seq.Rel_name_key.Idkey.Idacc, / ;
	  	%End
		CALL "GET_SUFFIX_FROM_PID" Using
		    By Reference Bnk_id of Csid_adr_set
		    By Reference Csid_temp1_vstr
		    By Reference Csid_temp1_vstr_length
		    By Reference Csid_temp2_vstr
		    By Reference Csid_temp2_vstr_length
		  Returning Csid_itsa_clearhouse
		If Success_is in Csid_itsa_clearhouse
		   AND Csid_temp1_vstr_length NOT = 0
		THEN
		    If (Failure_is in Csid_found_it )
			%Beg  Csid_compose Csid_temp2_vstr;  %End
			Set Success_is in Csid_found_it to TRUE
		    ELSE
			%Beg  Csid_compose ",", Csid_temp2_vstr;  %End
		    END-IF
		END-IF
	    END-IF
	    %Beg  NEXT: Csid_acc_seq;  %End
	END-PERFORM.
	%Beg  Csid_compose /;  %End.
			
C730_GET_PID_SUFFIXES_END.
	

   EXIT.
C740_CHECK_DUPE.
* Checks for a duplicate account.
	Move SPACES to Csid_scr_adr_id.
	%Beg 
	Csid_scr_adr_id = NULL ;
	NEXT: Csid_acc_seq ;
	Csid_scr_adr_id = Csid_acc_seq .Rel_name_key;
	PREV: Csid_acc_seq ;
	%End.
	If (Idtype of Csid_scr_adr_id = Idtype of Csid_know_acc_id )
	    AND (Idacc of Idkey of Csid_scr_adr_id = 
						    Idkey of Csid_know_acc_id ) 
	THEN
	    %Beg  Csid_dupe_acc_ws = Csid_know_acc_id ;  %End
	END-IF.

C740_CHECK_DUPE_END.

   EXIT.

C750_BBK_TO_BNP.
%^
%^ For Collection processing, the BBK should be copied to the 
%^ BNP when not present.
%^ Question, since this is POST  bbk lookup, should all connection be
%^ Made" or just copy down the info and allow BNP processing to take care of it.
	%beg
		Ent_credit_set(
	       	     .Bnp(.Bnp_idtype = ent_credit_set.bbk.bbk_idtype,
		    .Bnp_id = ent_credit_set.bbk.bbk_id),
		       .Bnp_name1 = Ent_credit_set.bbk_name1,
		       .Bnp_name2 = Ent_credit_set.bbk_name2,
		       .Bnp_name3 = Ent_credit_set.bbk_name3,
		       .Bnp_name4 = Ent_credit_set.bbk_name4,
		       .Bnp_res_country = ent_credit_set.bbk_res_country) ;
	%End.
C750_BBK_TO_BNP_END.
	EXIT.

C760_FIND_ACC_CUR.
%^ Scans through DBSA account sequence from present location (so we can use
%^  same paragraph to find ambiguities) looking for an account which is a
%^  currency match.  Just checks current position and keeps stepping until
%^  account currency matches message currency.
%^ Input:
	Set Failure_is in Csid_curr_ok_ws to TRUE.
	PERFORM UNTIL (Success_is in Csid_curr_ok_ws) 
		      OR (Failure_is in Csid_acc_seq_status   )
		      OR ( (Xbank_account_ok_ls = 0 )
                           AND ( Cdt_adr_bnk_id of Ent_credit_set NOT =
		      Idbank of Rel_name_key of Csid_acc_seq ) )
	    Perform X880_CHECK_CURRENCY through X880_CHECK_CURRENCY_END
	    If (Failure_is in Csid_curr_ok_ws)
                %Beg  NEXT: Csid_acc_seq ;  %End
		Perform UNTIL ( (Failure_is in Csid_acc_seq_status   )
				OR (Idtype of Rel_name_key 
					     of Csid_acc_seq NOT = "P" ) )
		    %Beg  NEXT: Csid_acc_seq;  %End
		END-PERFORM
	    END-IF
	END-PERFORM.
C760_FIND_ACC_CUR_END.


   EXIT.
C780_CHIPS_OVERRIDE.
%^ Applies various arcane CHIPS qualification criteria to override the
%^    normal process.
	%Beg
	Csid_party_swfid = NULL ;
	Csid_party_uid = NULL ;
	%End
        Set Failure_is in Csid_ret_stat to true.

	If (Csid_party_idtype = space)			%^ 101894 - if acct and bic, set csid_party_swfid
	   AND (Success_is in Csid_multi_party   )
		%Beg
		Csid_parse ^IN(Csid_party_id )
		    Csid_temp1_vstr, "/BC", Csid_party_swfid, ^SPACE, / ;
		%End
	End-if.

	If (Csid_party_idtype = "C" OR "S" )
	   AND (Success_is in Csid_multi_party   )
	THEN
	    If (Csid_party_idtype = "C" )
		%Beg
		Csid_parse ^IN(Csid_party_id )
		    Csid_party_uid, "/BC", Csid_party_swfid, ^SPACE, / ;
	        %End
            ELSE

		%Beg
		Csid_parse ^IN(Csid_party_id )
		    Csid_party_swfid, "/CH", Csid_party_uid, ^SPACE, / ;
	        %End
            END-IF
	    If (Failure_is in Csid_parse_status   )
		OR (Csid_party_uid_length NOT = 6 )
		OR (Csid_party_swfid_length NOT = 8 AND 11 )
	    THEN
		%Beg
		Csid_party_uid = NULL ;
		Csid_party_swfid = NULL ;
		%End
	    END-IF
        END-IF.

%^ The Swf_dda_qual_edt and Swf_swfid_qual_edt flags only apply to sources
%^ SWF andink_gmx_srcs.
        If (Src_code of Ent_ftr_set = "SWF" )
            Set Success_is in Csid_qual_edt_source to true
          ELSE
	    %Beg
	    Csid_union_key_ws(.Idname = "SOURCE_CODE_TABLES",
			      .Idprod = "MTS", 	   
			      .Idbank =  Menu_bnk_union.Bnk_id,    
			      .Idloc  = null,    	   
			      .Idcust = null);		  
   	    Csid_compose ^OUT(Csid_item_key_ws),
				"SWIFTLIKE_SRCS:", /;
	    Csid_seq_ordinal_ws = <1>;
	    Csid_compose ^OUT(Csid_match_key_ws), Ent_ftr_set.Src_code, / ;
	    %End
	    Call "CFG_MATCH_ITEM" USING
		BY Reference Idname of Csid_union_key_ws
		BY Reference Idprod of Csid_union_key_ws
		BY Reference Idbank of Csid_union_key_ws
		BY Reference Idloc of Csid_union_key_ws
		BY Reference Idcust of Csid_union_key_ws
		BY Reference Csid_item_key_ws
		BY Reference Csid_match_key_ws
		BY Reference Csid_match_key_ws_length
		BY Reference Csid_seq_ordinal_ws
		BY Reference Csid_error_msg_ws
		BY Reference Csid_error_msg_ws_length
              RETURNING Csid_qual_edt_source
         END-IF.

	EVALUATE TRUE
	    WHEN ( (Csid_party_idtype = SPACE )
		  AND (Failure_is in Csid_multi_party   )
                  AND (Success_is in Csid_qual_edt_source   ) )
%^ Item is unqualified, and is not in UID database using the DDA provided, and
%^  there is only 1 id.
%^ Allow to go straight through based on SWF_DDA_QUAL_EDT config flag
		    If (Swf_dda_qual_edt of Menu_cfg is not = "T" )
	    		%Beg
	    		Csid_compose ^OUT(Csid_info_memo)
				"SWF DDA qualification edit configured off", / ;
	    		%End
	    		Perform X920_INFO_MEMO through X920_INFO_MEMO_END
		    ELSE
		        GO TO C780_CHIPS_OVERRIDE_END
		    END-IF

* Check config flag to see same SWIFT address in credit and next parties:
	    WHEN ( (Csid_party_idtype = "S") 
		 AND (Failure_is in Csid_multi_party   )
                  AND (Success_is in Csid_qual_edt_source   ) )
* Item is unqualified, but next party id is SWIFT
* from an A format address, let it go straight through unqualified
		    If (Swf_swfid_qual_edt of Menu_cfg is not = "T" )
	    		%Beg
	    		Csid_compose ^OUT(Csid_info_memo)
			     "SWF SWFID qualification edit configured off", / ;
	    		%End
	    		Perform X920_INFO_MEMO through X920_INFO_MEMO_END
		 	If (Failure_is in Csid_found_it   )
%^ This should always be true.
			    Move "$" to Csid_temp_idtype
 			    Move SPACES to Csid_lkup_pend_del
			    Call "ACCT_LOOKUP" USING
				by reference Csid_temp_idtype
	    			by reference Csid_party_id
	    			by reference Csid_ovr
	    			by reference Csid_ambig_ws 
	    			by reference Csid_multibank_ws
      	    			by reference Credit_currency_ls
	    			by reference Csid_lkup_pend_del
	  		      RETURNING Csid_ret2_stat

			    If (Csid_ovr = "?" )
* An ambiguous case -- kick it back to the operator.
	    			%Beg
			        Csid_compose ^OUT(Csid_err_memo)
		      			"Not Str Thru: Ambiguous party ", 
		      			Csid_ovr, 
					Csid_party_idtype, "/",
					Csid_party_id, / ;
	    			%End
			    	Perform X900_ERROR_MEMO through 
					X900_ERROR_MEMO_END
			    	Add 1 to Csid_ambig_parties
	    			GO TO C780_CHIPS_OVERRIDE_END
			    END-IF
			    If (Relget_msgcode = Vmsg_dat_notonfile_wc)
	    			OR (Csid_ovr = SPACE )
			    THEN
			        Set Success_is in Csid_found_it to true
 			    END-IF
			END-IF			
		    ELSE
		        GO TO C780_CHIPS_OVERRIDE_END
		    END-IF

%^ spr 25062 straight thru rules addition
%^ If both account and Swift tid are provided
%^ Allow to go straight through based on SWF_STR_THRU_QUAL_EDT config flag
	    WHEN ( (Csid_party_swfid_length  = 8 OR 11 ) AND
		   (Success_is in Csid_multi_party   ) )
                    If (Swf_str_thru_qual_edt of Menu_cfg = "T") then
	    		%Beg
	    		Csid_compose ^OUT(Csid_info_memo)
			   "SWF straight thru qualification edit configured on",
				/ ;
	    		%End
	    		Perform X920_INFO_MEMO through X920_INFO_MEMO_END
		    ELSE
		        GO TO C780_CHIPS_OVERRIDE_END
		    END-IF

	    WHEN OTHER
* Unqualified, and not the special case of an unqualified DDA or SWIFT ID or 
* FED ABA: prevent straight through
		    GO TO C780_CHIPS_OVERRIDE_END

	END-EVALUATE.

* Anything which survives to get to here is valid.
	Set Success_is in Csid_ret_stat to true.

C780_CHIPS_OVERRIDE_END.

   EXIT.
C800_PUSH_CREDIT.

* Checks to make sure that there's an available creditside slot.
* Then calls PUSH_CREDIT_PARTY to push credit party down.

	If (Ib1_id of Ib1 of Ent_credit_set NOT = SPACES )
	    %^  No place to push into.
	    Set Failure_is in Csid_ret_stat to true
	ELSE
	    If second_cdt_id_ls NOT = Spaces Then     
  		%^ Perform rebuild secondary ID code
		Perform C805_REBUILD_2ID  Thru
			C805_REBUILD_2ID_END
	    end-if	
	    CALL "PUSH_CREDIT_PARTY" USING
		By reference Bank of Loc_info of Ent_ftr_set
		By reference Csid_pref_next_id_rec
		By reference Csid_pref_next_id_rec_lengths
		By reference Csid_pushed_credit
	      RETURNING Csid_ret_stat
	END-IF.

	If (Success_is in Csid_ret_stat)
	    AND (Credit_depth_ls = 0 )
	THEN
	    Move Csid_pushed_credit to Credit_depth_ls
        END-IF.

	If (Failure_is in Csid_ret_stat)
	    %^  No place to push into.
	    %Beg
	    Csid_compose ^OUT(Csid_err_memo)
		"No creditside slots for preferred corr ",
			Csid_pref_corr_rec, / ;
	    %End
	    Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
	    Set Success_is in Csid_push_error to TRUE
	    Move ZERO to Cdt_not_suspect_ls
            %^ Reconnect the current Ent_c_adr_set if necessary
            If (Cdt_rel_id of Ent_credit_set not = 0) or
	       (cdt_adr_ptr_ok of flgs3 of ent_credit_set = "T") Then
		%ACE_IS Ent_c_adr_set connected giving Csid_conn_stat;
                If (Failure_is in Csid_conn_stat)
                THEN
                    %Beg
		    Ent_c_adr_set(NOTRAP);
		    Ent_credit_set(NOTRAP);
                    Ent_credit_set.Cdt_adr_set_ptr CONN: Ent_c_adr_set(NOMOD) ;
		    Ent_c_adr_set(ETRAP);
		    Ent_credit_set(ETRAP);
                    %End
		    %ACE_IS Ent_c_adr_set connected giving Csid_conn_stat;
                END-IF
		%ACE_IS Relget_adr_set connected giving Csid_conn2_stat;
                If (Failure_is in Csid_conn2_stat) or
		   (Rel_id of Relget_adr_set not = Rel_id of Ent_c_adr_set)
                THEN
		    Set Success_is in Csid_conn2_stat to TRUE
                    %Beg
        	    BREAK: Relget_adr_set;
        	    Ent_c_adr_set EQUATE: Relget_adr_set(NOMOD) ;
                    %End
		    Initialize Relget_adr_set
                END-IF
	      ELSE
		%Beg      
                    Ent_credit_set( .Cdt_rel_id        = <0> ,
                                    .Cdt_adr_set_ptr DELETE,
				    .flgs3.cdt_adr_ptr_ok = Null) ;
            
			BREAK: Ent_c_adr_set;
			BREAK: Relget_adr_set;
		%End
		Move zeroes to Rel_id of Relget_adr_set
		Set Failure_is in Csid_conn_stat to TRUE
		Set Failure_is in Csid_conn2_stat to TRUE
	    END-IF
	END-IF.

	%^ If Not Expanding an IBAN, need to push down change flags
	%^ Moot for mappers.
	If Failure_is in Csid_iban_expanded and
	   Chg_cdt of Change_fields of Ent_ftr_set not = SPACES then
		Evaluate TRUE
		   When  (Ib1_id of Ib1 of Ent_credit_set NOT = SPACES or
	      		  Ib1_name1_length of Ent_credit_set_lengths NOT = ZERO)
				%Beg 
				Ent_ftr_set.Change_fields.Chg_ib1 = Ent_ftr_set.change_fields.Chg_cdt;
				%^Ent_ftr_set.change_fields.Chg_cdt = NULL; 
				%End
		   When  (Ibk_id of Ibk of Ent_credit_set NOT = SPACES or
	          	  Ibk_name1_length of Ent_credit_set_lengths NOT = ZERO)
				%Beg 
				Ent_ftr_set.Change_fields.Chg_ibk = Ent_ftr_set.change_fields.Chg_cdt;
				%^Ent_ftr_set.change_fields.Chg_cdt = NULL; 
				%End
		
		   When  (Bbk_id of Bbk of Ent_credit_set NOT = SPACES or
		          Bbk_name1_length of Ent_credit_set_lengths NOT = ZERO)
				%Beg 
				Ent_ftr_set.Change_fields.Chg_Bbk = Ent_ftr_set.change_fields.Chg_cdt;
				%^Ent_ftr_set.change_fields.Chg_cdt = NULL; 
				%End
		   When  (Bnp_id of Bnp of Ent_credit_set NOT = SPACES or
		      	  Bnp_name1_length of Ent_credit_set_lengths NOT = ZERO)
				%Beg 
				Ent_ftr_set.Change_fields.Chg_Bnp = Ent_ftr_set.change_fields.Chg_cdt;
				%^Ent_ftr_set.change_fields.Chg_cdt = NULL; 
				%End
		end-evaluate
		%^
		If not(Success_is in csid_iban_expanded)
		Then
			%beg Ent_ftr_set.change_fields.Chg_cdt = NULL; %end
		end-if
	End-if.



	If Success_is in TGT2_subpartic
	Then
		Set Failure_is in TGT2_subpartic to True
		  %Beg 
	 	  Compose ^OUT(csid_prm_name_ws) "MTS$TARGET_SUBPARTICIPANT", /; 
		  Compose ^OUT(csid_prm_value_ws) "Y", /;
		  csid_Prm_level_wo msg_is;
		  csid_Prm_source_wo msg_is;
		  csid_Prm_edit_wo Text_is;
		  %End
		  Initialize csid_prm_time_on_ws, csid_prm_time_off_ws
		  Initialize csid_prm_remaining_ws
		  Set Success_is in csid_prm_mode_wf to True
		  Call "PRULE_MSG_UPDATE_PARAM" using
			   by reference csid_prm_name_ws,	  %^ vstr(40)
			   by reference csid_prm_name_ws_length,  %^ length
			   by reference csid_prm_level_wo, 	  %^ PRULE_LEVEL_ONEOF.DDF
			   by reference csid_prm_source_wo, 	  %^ PRULE_SOURCE_ONEOF.DDF
			   by reference csid_prm_time_on_ws,	  %^ time
			   by reference csid_prm_time_off_ws,	  %^ time
			   by reference csid_prm_edit_wo, 	  %^ PR_PARAM_EDIT_ONEOF.DDF
			   by reference csid_prm_mode_wf,	  %^ boolean
			   by reference csid_prm_remaining_ws	  %^ long
			   by reference csid_prm_value_ws,	  %^ vstr(80)
			   by reference csid_prm_value_ws_length, %^ length
			   by reference csid_prm_present_wf, 	  %^ boolean
			   by reference csid_prm_memo_ws,	  %^ vstr(ACE$_MSG_STR_SIZE)
			   by reference csid_prm_memo_ws_length	  %^ length
			   returning csid_prm_status_wf		  %^ boolean
	End-if.

	If (Csid_tgt_account_bic NOT = SPACES)
	Then
		  %Beg 
	 	  Compose ^OUT(csid_prm_name_ws) 
			"MTS$TARGET_ACCOUNT_BIC", / ;
		  csid_Prm_level_wo msg_is;
		  csid_Prm_source_wo msg_is;
		  csid_Prm_edit_wo Text_is;
		  %End
		  Initialize csid_prm_time_on_ws, csid_prm_time_off_ws
		  Initialize csid_prm_remaining_ws
		  Set Success_is in csid_prm_mode_wf to True
		  Call "PRULE_MSG_UPDATE_PARAM" using
			   by reference csid_prm_name_ws,	  %^ vstr(40)
			   by reference csid_prm_name_ws_length,  %^ length
			   by reference csid_prm_level_wo, 	  %^ PRULE_LEVEL_ONEOF.DDF
			   by reference csid_prm_source_wo, 	  %^ PRULE_SOURCE_ONEOF.DDF
			   by reference csid_prm_time_on_ws,	  %^ time
			   by reference csid_prm_time_off_ws,	  %^ time
			   by reference csid_prm_edit_wo, 	  %^ PR_PARAM_EDIT_ONEOF.DDF
			   by reference csid_prm_mode_wf,	  %^ boolean
			   by reference csid_prm_remaining_ws,	  %^ long
			   by reference Csid_tgt_account_bic,	  %^ value
			   by reference Csid_tgt_account_bic_length, %^ length
			   by reference csid_prm_present_wf, 	  %^ boolean
			   by reference csid_prm_memo_ws,	  %^ vstr(ACE$_MSG_STR_SIZE)
			   by reference csid_prm_memo_ws_length	  %^ length
			   returning csid_prm_status_wf		  %^ boolean
		%Beg  Csid_tgt_account_bic = NULL;  %End
	End-if.

	Set Failure_is in Dual_rpr_id To True.


C800_PUSH_CREDIT_END.

   EXIT.

C805_REBUILD_2ID.
	If (Cdt_idtype of Cdt_typ of Ent_credit_set = " " or "D") And
	   Csid_second_id(1:3) = "/BC" Then
		Move Csid_second_id(4:second_cdt_id_leng_ls) to  Csid_tmp_id_ws
		Subtract 3 from Csid_second_id_length giving Csid_tmp_id_ws_length
		%beg Csid_compose ^out(csid_acc_id_arg) Csid_tmp_id_ws,"/AC",
 				Ent_credit_set.cdt_typ.cdt_id,/;
		     Csid_compose ^out(ent_credit_set.cdt_typ.cdt_id) csid_acc_id_arg,/;
		     ent_credit_set.cdt_typ.cdt_idtype = "S";
		%end
	else
		If Cdt_idtype of Ent_credit_set = "S" And
		Csid_2aid_id Not = Spaces and Csid_2aid_idt = "D" or "G" or "F" or "V" or " "
		Then
			%^ Need to push secondary Id, we had a BIC/ACC switch
			%beg
				Csid_compose ^out(csid_tmp_id_ws) ent_credit_set.cdt_typ.cdt_id,
								 "/AC",csid_2aid_id,/;
				Ent_credit_set.cdt_typ.cdt_id = csid_tmp_id_ws;
			%end
		Else			%^ don't append 2nd id to cdt party if same as cdt party
		    %beg csid_tmp_id_ws = Csid_second_id; %end
		    If Csid_tmp_id_ws(1:3) = "/AC" and
			    Csid_tmp_id_ws(4:) = Cdt_id of Cdt_typ of Ent_credit_set
			%Beg
			Csid_compose ^OUT(Csid_acc_id_arg), Ent_credit_set.cdt_typ.cdt_id, "/",/;
			Ent_credit_set.Cdt_typ.Cdt_id = Csid_acc_id_arg;
			%End
		    else
			%^ No Accounts involved, just leave the primary in place and
			%^ concatenate the rest
			    %beg	Csid_compose ^out(csid_acc_id_arg) ent_credit_set.cdt_typ.cdt_id,
						csid_tmp_id_ws,/;
				Ent_credit_set.cdt_typ.cdt_id = csid_acc_id_arg;
			    %end 
		    End-if
		End-if
	End-if.

	Move Spaces to Second_cdt_id_ls.	%^ clear the field, it is about to be pushed.


C805_REBUILD_2ID_END.
	EXIT.

C810_ROLL_DOWN.
* U.S. CHIPS only:
* We have a second credit id which doesn't match the credit party
* and we are about to try a CHIPS qualification, so we can relate 
* multiple ID's for the same party together.  If the second credit party
* ID is compatible and doesn't already exist in our lower creditside party
* and if adding it won't result in an ID that is too long, we will roll
* it down and append it on to our ID.  Then we will reshuffle ID's since
* they may now be in the wrong order.
* Note: this is only called when CHIPS qualification is being done, in
* which case the rolled-down account can be checked for validity at the
* credit-party via the CHIPS directory. If not a U.S. Chips environment,
* the CHIPS-specific code in this paragraph does not get invoked.
*
* Begin by checking ID's and lengths to see if we can roll down.
		
	If ( (Csid_second_id_length + Csid_party_id_length ) > 48)
	    %Beg
	    Csid_compose ^OUT(Csid_err_memo)
			"Roll down of ", Csid_second_id, "is too long.", / ; 
	    %End
	    Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
	    Move 0 to Cdt_not_suspect_ls
	    GO TO C810_ROLL_DOWN_END
	END-IF.
	%Beg
	Csid_parse ^IN(Csid_second_id)
		Csid_2id_oneof( ^ONEOF(
            		  (/),
            		  ("/AC",|Csid_temp2_vstr, ^SPACE, /),
            		  ("/BC",|Csid_temp2_vstr, ^SPACE, /),
            		  ("/CH",|Csid_temp2_vstr, ^SPACE, /),
            		  ("/FW",|Csid_temp2_vstr, ^SPACE, /),
            		  ("/CP",|Csid_temp2_vstr, ^SPACE, /) ));
	%End
	If (Failure_is in Csid_parse_status   )
	    Move 0 to Csid_2id_oneof
	END-IF.
	EVALUATE TRUE
	    When (Csid_2id_oneof = 1)
		%Beg
		Csid_parse ^IN(Csid_party_id) 
			"/AC", Csid_temp2_vstr, ^SPACE, / ;
		%End
		If ( (Csid_party_idtype is NOT = SPACE )
                     AND (Failure_is in Csid_parse_status   ) )
		THEN
		    Set Failure_is in Csid_do_rolldown to TRUE
                END-IF


	    When (Csid_2id_oneof = 2)
		%Beg
		Csid_parse ^IN(Csid_party_id) 
			"/BC", Csid_temp2_vstr, ^SPACE, / ;
		%End
		If ( (Csid_party_idtype is NOT = "S" )
                     AND (Failure_is in Csid_parse_status   ) )
		THEN
		    Set Failure_is in Csid_do_rolldown to TRUE
                END-IF


	    When (Csid_2id_oneof = 3)
		%Beg
		Csid_parse ^IN(Csid_party_id) 
			"/CH", Csid_temp2_vstr, ^SPACE, / ;
		%End
		If ( (Csid_party_idtype is NOT = "C" )
                     AND (Failure_is in Csid_parse_status   ) )
		THEN
		    Set Failure_is in Csid_do_rolldown to TRUE
                END-IF


	    When (Csid_2id_oneof = 4)
		%Beg
		Csid_parse ^IN(Csid_party_id) 
			"/FW", Csid_temp2_vstr, ^SPACE, / ;
		%End
		If ( (Csid_party_idtype is NOT = "A" )
                     AND (Failure_is in Csid_parse_status   ) )
		THEN
		    Set Failure_is in Csid_do_rolldown to TRUE
                END-IF


	    When (Csid_2id_oneof = 5)
		%Beg
		Csid_parse ^IN(Csid_party_id) 
			"/CP", Csid_temp2_vstr, ^SPACE, / ;
		%End
		If ( (Csid_party_idtype is NOT = "P" )
                     AND (Failure_is in Csid_parse_status   ) )
		THEN
		    Set Failure_is in Csid_do_rolldown to TRUE
                END-IF
	END-EVALUATE.
	If (Failure_is in Csid_do_rolldown)
	THEN
	    Move SPACES to Csid_temp1_vstr
	    %Beg
	    Csid_compose ^OUT(Csid_temp1_vstr)
			Csid_party_id, Csid_second_id, / ;
	    %End
	    If (Failure_is in Csid_compose_status   )
		Set Success_is in Csid_do_rolldown to TRUE
	    END-IF
	END-IF.
	If (Success_is in Csid_do_rolldown)
	THEN
%^ Can't do roll-down.
	    %Beg
	    Csid_compose ^OUT(Csid_err_memo)
			"Cannot roll down second id ", Csid_second_id, / ;
	    %End
	    Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
	    Move 0 to Cdt_not_suspect_ls
	    GO TO C810_ROLL_DOWN_END
	END-IF.
	%Beg  Csid_party_id = Csid_temp1_vstr ;  %End.
	PERFORM X960_SHUFFLE_IDS through X960_SHUFFLE_IDS_END.
	%Beg
	Csid_compose ^OUT(Csid_info_memo)
		"Second credit ID ", Csid_second_id, " rolled down.", / ;
	%End.
	Perform X920_INFO_MEMO through X920_INFO_MEMO_END.
	Set Success_is in Csid_multi_party to true.
C810_ROLL_DOWN_END.

   EXIT.

C820_LOWER_CREDIT.

* Finds subsidiary creditside party which may be identified by multiple IDs. 
* Full ID is in Csid_party_idtype and Csid_party_id.  Status of lookup is 
* returned in Csid_ret_stat and Csid_ovr.  All IDs must agree for the lookup to
* succeed and have its address used (Csid_ovr = SPACE, Csid_ret_stat SUCCESS).
* If any ID cannot be done, name and address should not be used but lookup
* has not failed, either.  Csid_ret_stat is success, but Csid_ovr is *.
* If no ID could be done, name and address do not exist but lookup has not
* failed.  Csid_ret_stat is FAILURE and Csid_ovr is *.
* If any two IDs conflict, Csid_ret_stat is FAILURE and Csid_ovr is ?.
* If Csid_lc_secwir is "Y", any aux lookups are forced into the REL.
* (If we are sending a secwir, then we want to find the party in the REL so
*  that we can use the destination information.)
*
%^ We still need to try the lookup
	Move "*" to Csid_ovr.
	Set Success_is in Csid_ret_stat to true.
	Set Failure_is in Csid_itsa_clearhouse to TRUE.
	Set Failure_is in Csid_lc_nowadr to TRUE.
	%Beg  
	Csid_lc_aba = NULL ;
	Csid_lc_account = NULL ;
	Csid_lc_partic = NULL ;
	Csid_lc_swift = NULL ;
	Csid_lc_uid = NULL ;
        Csid_lc_user = NULL ;
	Csid_lc_extid = NULL ;
	Csid_party_extype = NULL ;
	Csid_lc_flg_aba = " " ;
	Csid_lc_flg_account = " " ;
	Csid_lc_flg_partic = " " ;
	Csid_lc_flg_swift = " " ;
	Csid_lc_flg_uid = " " ;
        Csid_lc_flg_user = " " ;
	Csid_lc_flg_extid = " " ;
	Csid_acchfwid = NULL ;
	Csid_id_ws = NULL ;
	Csid_lc_adridt = NULL ;
	Csid_lc_adrid = NULL ;
%^ Could be a compound id with an /AC, /BC, /CH, or /FW or similar form
	Csid_Parse ^In(Csid_party_id), Csid_id_ws,
		    Csid_oneof_acchfw (^ONEOF (	
			("///",|Csid_acchfwid, ^SPACE, /),
			("/AC",|Csid_acchfwid, ^SPACE, /),
			("/", |Csid_party_extype (^STRING<2>(<CHAR$M_ALPHA>)),
			   			   |Csid_acchfwid, ^SPACE, /),
			(/) ));
        %End.

	If Failure_is in Csid_parse_status  
	    %Beg  Csid_acchfwid = NULL;  Csid_party_extype = NULL; %End
	    Move 4 To Csid_oneof_acchfw
	END-IF.

	Move 2 to Csid_twoof_acchfw.		%^ Default is 2-char subtype
	Evaluate TRUE
	    When Csid_party_idtype = "D"
		Move 0 to Csid_twoof_acchfw
		Move "AC" To Csid_party_extype2

	    When Csid_party_idtype = SPACE
		Move 1 to Csid_twoof_acchfw
		Move "AC" To Csid_party_extype2

	    When Csid_party_idtype = "S"
		Move "BC" To Csid_party_extype2

	    When Csid_party_idtype = "C"
		Move "CH" To Csid_party_extype2

	    When (Csid_party_idtype = "P" )
%^ NOTE: if the ID is in P-form, it must already have any necessary suffix.
%^ Since this is a lower creditside party, we're just trying to get its
%^ extended Id form
		If Cdt_adr_bnk_id of Ent_credit_set = SPACES
		    Move Bank of Loc_info of Ent_ftr_set to Csid_acc_bank_ws
		ELSE
		    Move Cdt_adr_bnk_id of Ent_credit_set to Csid_acc_bank_ws
		END-IF
		CALL "GET_XIDTYPE_FROM_SUFFIX" Using
		    By reference Csid_acc_bank_ws
		    By reference Csid_id_ws
		    By Reference Csid_id_ws_length
		    By Reference Csid_party_extype2
		  Returning Csid_itsa_clearhouse

	    When Csid_party_idtype = "A"
		Move "FW" To Csid_party_extype2

	    When Csid_party_idtype = "E"
%^ #45981 If the string following the code word of the extended ID sub-type of
%^        "ID" were alpha characters, an ambiguous error message was written for
%^        the beneficiary.  By moving a "3" to Csid_oneof_acchfw and 
%^        Csid_twoof_acchfw, the ambiguous conditions are not encountered.
                If Csid_id_ws (1:2) = "ID"
		Then
                    Move 3 to Csid_oneof_acchfw
                    Move 3 to Csid_twoof_acchfw
		End-if			
		Move Csid_id_ws(1:2) To Csid_party_extype2
		%Beg
		Csid_clip_compose ^OUT(Csid_temp1_vstr)
		    Csid_id_ws, / ;
		%End
		Subtract 2 from Csid_temp1_vstr_length
		Move Csid_temp1_vstr(3:Csid_temp1_vstr_length) To Csid_id_ws
		If Csid_id_ws_length > 1 Then 
		    Subtract 2 From Csid_id_ws_length 
		End-if

            When Csid_party_idtype = "U"  	%^ User Name
	        %^ Is this a multi-party id?
                %Beg
                Csid_parse ^IN(Csid_id_ws)
                    ^STRING, "/", ^STRING, /;
                %end
                If Failure_is in Csid_parse_status   then
		    %^ Single-Party
                    Move 4 to Csid_twoof_acchfw
                  else
                    %^ Multi-Party
                    Move 3 to Csid_twoof_acchfw
                end-if
                Move Spaces To Csid_party_extype2

            When OTHER
		Move 3 to Csid_twoof_acchfw
		Move Spaces To Csid_party_extype2

	END-EVALUATE.

	Perform UNTIL ( Csid_id_ws_length = 0 )

	    Evaluate Csid_twoof_acchfw
		When 1
* It's a foreign account
		    If (Csid_lc_account_length NOT = 0 )
			Move "?" to Csid_ovr
			Set Failure_is in Csid_ret_stat to true
			GO TO C820_LOWER_CREDIT_END
		    END-IF
		    %Beg  
		    Csid_lc_account = Csid_id_ws ;
		    Csid_lc_flg_account = "F" ;
		    %End

		When 2
* It's a network id with a 2-character subtype equivalent
		  Evaluate Csid_party_extype2
		   When "BC"					%^SWIFT TID
		    If (Csid_lc_swift_length NOT = 0 )
			Move "?" to Csid_ovr
			Set Failure_is in Csid_ret_stat to true
			GO TO C820_LOWER_CREDIT_END
		    END-IF
		    Move SPACES to Csid_lc_swift
		    %Beg  
		    Csid_lc_swift = Csid_id_ws ;
		    Csid_lc_flg_swift = "F" ;
		    %End

		  When "CH"				%^ It's a CHIPS UID
		    If (Csid_lc_uid_length NOT = 0 )
			Move "?" to Csid_ovr
			Set Failure_is in Csid_ret_stat to true
			GO TO C820_LOWER_CREDIT_END
		    END-IF
		    %Beg  
		    Csid_lc_uid = Csid_id_ws ;
		    Csid_lc_flg_uid = "F" ;
		    %End

		  When "FW"				%^ It's a FED ABA
		    If (Aba_is in Csid_fed_index_flg)
		    	If (Csid_lc_aba_length NOT = 0 )
				Move "?" to Csid_ovr
				Set Failure_is in Csid_ret_stat to true
				GO TO C820_LOWER_CREDIT_END
		    	END-IF
		    	%Beg  
		    		Csid_lc_aba = Csid_id_ws ;
		    		Csid_lc_flg_aba = "F" ;
		    	%End
		     Else	%^ Treat FW as an EXT
		        If (Csid_lc_extid_length NOT = 0 )
			   Move "?" to Csid_ovr
			   Set Failure_is in Csid_ret_stat to true
			   GO TO C820_LOWER_CREDIT_END
		        END-IF
			%Beg  
			    Csid_compose ^Out(Csid_lc_extid), 
				Csid_party_extype2, Csid_id_ws, /;
		    	    Csid_lc_flg_extid = "F" ;
		    	 %End
		     End-if

		  When Other				
%^ Other 2-char external ID
		    If (Csid_lc_extid_length NOT = 0 )
			Move "?" to Csid_ovr
			Set Failure_is in Csid_ret_stat to true
			GO TO C820_LOWER_CREDIT_END
		    END-IF
		    %Beg  
		    Csid_compose ^Out(Csid_lc_extid), 
			Csid_party_extype2, Csid_id_ws, /;
		    Csid_lc_flg_extid = "F" ;
		    %End

	         END-EVALUATE

             When 4
* It's a User Name
                 If (Csid_lc_user_length NOT = 0 )
                     Move "?" to Csid_ovr
                     Set Failure_is in Csid_ret_stat to true
                     GO TO C820_LOWER_CREDIT_END
                 END-IF
                 %Beg
                 Csid_lc_user = Csid_id_ws ;
                 Csid_lc_flg_user = "F" ;
                 %end

	    END-EVALUATE

	    %Beg
	    Csid_temp1_vstr = Csid_acchfwid ;
	    Csid_acchfwid = NULL ;
	    Csid_id_ws = NULL ;
	    Csid_twoof_acchfw = Csid_oneof_acchfw ;
	    Csid_party_extype2 = Csid_party_extype;
	    Csid_oneof_acchfw = <0> ;
	    %End
	    If (Csid_temp1_vstr_length NOT = 0 )
		%Beg
		Csid_Parse ^In(Csid_temp1_vstr), Csid_id_ws,
		    Csid_oneof_acchfw (^ONEOF (	
			("///",|Csid_acchfwid, ^SPACE, /),
			("/AC",|Csid_acchfwid, ^SPACE, /),
			("/", |Csid_party_extype (^STRING<2>(<CHAR$M_ALPHA>)),
			   			    |Csid_acchfwid, ^SPACE, /),
			(/) ));
                %End
	    END-IF

	END-PERFORM.

* We now have parsed the entire lower creditside id set.  So now we want to
* look it up, somehow.
	If Csid_lc_flg_uid = "F"	
* We have a CHIPS UID, so let's use this as our primary key
	    %Beg
	    Csid_temp_idtype = "c" ;
	    Csid_id_ws = Csid_lc_uid ;
	    %End
	    Move Spaces to Csid_lkup_pend_del	
 	    Call "ACCT_LOOKUP" USING
	    	by reference Csid_temp_idtype
		by reference Csid_id_ws
		by reference Csid_ovr
		by reference Csid_ambig_ws 
		by reference Csid_multibank_ws
	      	by reference Credit_currency_ls
		by reference Csid_lkup_pend_del
	      RETURNING Csid_ret2_stat
*
* If not found on AUX then try on REL
*
	    If NOT ( (Csid_ovr = "*" )
		 AND (Relget_msgcode = Vmsg_dat_notonfile_wc ) )
	    THEN
	       %Beg Csid_temp_idtype = "C" ; %End
	       Call "ACCT_LOOKUP" USING
	    	   by reference Csid_temp_idtype
		   by reference Csid_id_ws
		   by reference Csid_ovr
		   by reference Csid_ambig_ws 
		   by reference Csid_multibank_ws
	      	   by reference Credit_currency_ls
		   by reference Csid_lkup_pend_del
	       RETURNING Csid_ret2_stat

            End-if

	    If (Csid_ovr = SPACE)
		Move "Y" to Csid_lc_flg_uid
		%Beg
		Csid_lc_adridt = Csid_temp_idtype;
		Csid_lc_adrid = Csid_id_ws;
		%End
		Set Success_is in Csid_lc_nowadr to TRUE
		Perform D840_MATCH_IDS_TO_REL through D840_MATCH_IDS_TO_REL_END 
		GO TO C820_LOWER_CREDIT_CLEANUP
	    END-IF
	    If ( (Csid_ovr = "*" )
		AND (Relget_msgcode = Vmsg_dat_notonfile_wc ) )
	    THEN
		Move "Y" to Csid_lc_flg_uid
		%Beg
		Csid_lc_adridt = Csid_temp_idtype;
		Csid_lc_adrid = Csid_id_ws;
		%End
		Set Success_is in Csid_lc_nowadr to TRUE
		If (Csid_lc_flg_swift NOT = SPACE )
		    If (Csid_lc_swift(1:11) = 
			Swift_id of Relget_adr_set(1:11) )
		    THEN
			Move "Y" to Csid_lc_flg_swift
		        If (Csid_lc_flg_aba NOT = SPACE )
			    Perform D860_SWIFT_TO_ABA through
                                 D860_SWIFT_TO_ABA_END
			    If (Success_is in Csid_ret2_stat   )
				If (Csid_lc_aba(1:9) = Idkey of Disp_id
					of Csid_aux_index(1:9))
				THEN
				    Move "Y" to Csid_lc_flg_aba
				ELSE
				    Move "N" to Csid_lc_flg_aba
				END-IF
			    END-IF   
			END-IF
		    ELSE
                        If (Swift_id_length of Relget_adr_set_lengths NOT = 0 )
                           AND (Swift_id of Relget_adr_set NOT = SPACES )
                        THEN
                            Move "N" to Csid_lc_flg_swift
                        END-IF
		    END-IF
		END-IF
	    END-IF
	    GO TO C820_LOWER_CREDIT_CLEANUP
	END-IF.

	If (Csid_lc_flg_ABA = "F" )
* NOTE: We know that we cannot have a chips UID, though we can have the
*	others.
	    %Beg
	    Csid_temp_idtype = "A" ;
	    Csid_id_ws = Csid_lc_aba ;
	    %End
	    Move Spaces to Csid_lkup_pend_del	
	    Call "ACCT_LOOKUP" USING
	    	by reference Csid_temp_idtype
		by reference Csid_id_ws
		by reference Csid_ovr
		by reference Csid_ambig_ws 
		by reference Csid_multibank_ws
	      	by reference Credit_currency_ls
		by reference Csid_lkup_pend_del
	      RETURNING Csid_ret2_stat
	    If (Csid_ovr = SPACE)
		Move "Y" to Csid_lc_flg_aba
		%Beg
		Csid_lc_adridt = Csid_temp_idtype;
		Csid_lc_adrid = Csid_id_ws;
		%End
		Set Success_is in Csid_lc_nowadr to TRUE
		Perform D840_MATCH_IDS_TO_REL through D840_MATCH_IDS_TO_REL_END 
		GO TO C820_LOWER_CREDIT_CLEANUP
	    END-IF
	    If ( (Csid_ovr = "*" )
		AND (Relget_msgcode = Vmsg_dat_notonfile_wc ) )
	    THEN
		Move "Y" to Csid_lc_flg_aba
		%Beg
		Csid_lc_adridt = Csid_temp_idtype;
		Csid_lc_adrid = Csid_id_ws;
		%End
		Set Success_is in Csid_lc_nowadr to TRUE
		If (Csid_lc_flg_swift NOT = SPACE )
		    Perform D860_SWIFT_TO_ABA through D860_SWIFT_TO_ABA_END
		    If (Success_is in Csid_ret2_stat   )
			If (Csid_lc_aba(1:9) = Idkey of Disp_id
					of Csid_aux_index(1:9))
			THEN
			    Move "Y" to Csid_lc_flg_swift
			ELSE
			    Move "N" to Csid_lc_flg_swift
			END-IF
		    END-IF
		END-IF
	    ELSE
		Set Failure_is in Csid_lc_nowadr to TRUE
	    END-IF
	    GO TO C820_LOWER_CREDIT_CLEANUP
	END-IF.

	If (Csid_lc_flg_partic = "F" )
%^ NOTE: We know that we cannot have a chips UID or an ABA, though we can have 
%^       a chips participant.
	    %Beg
	    Csid_temp_idtype = "P" ;
	    Csid_id_ws = Csid_lc_partic ;
	    %End
	    Move Spaces to Csid_lkup_pend_del	
	    Call "ACCT_LOOKUP" USING
	    	by reference Csid_temp_idtype
		by reference Csid_id_ws
		by reference Csid_ovr
		by reference Csid_ambig_ws 
		by reference Csid_multibank_ws
	      	by reference Credit_currency_ls
		by reference Csid_lkup_pend_del
	      RETURNING Csid_ret2_stat
	    If (Csid_ovr = SPACE)
		Move "Y" to Csid_lc_flg_partic
		%Beg
		Csid_lc_adridt = Csid_temp_idtype;
		Csid_lc_adrid = Csid_id_ws;
		%End
		Set Success_is in Csid_lc_nowadr to TRUE
		Perform D840_MATCH_IDS_TO_REL through D840_MATCH_IDS_TO_REL_END 
* Since we don't have chips participants in the AUX database, we are done.
	    ELSE
		Set Failure_is in Csid_lc_nowadr to TRUE
	    END-IF
	    GO TO C820_LOWER_CREDIT_CLEANUP
	END-IF.

        If (Csid_lc_flg_user = "F" )		%^ User Name
            %Beg
            Csid_temp_idtype = "U" ;
            Csid_id_ws = Csid_lc_user ;
            %End
	    %^ Look up address
	    Move Spaces to Csid_lkup_pend_del	
            Call "ACCT_LOOKUP" USING            
                by reference Csid_temp_idtype
                by reference Csid_id_ws
                by reference Csid_ovr
                by reference Csid_ambig_ws
                by reference Csid_multibank_ws
                by reference Credit_currency_ls
		by reference Csid_lkup_pend_del
              RETURNING Csid_ret2_stat

            Move "N" to Csid_lc_flg_user

            If (Csid_ovr not = SPACE)
		Set Failure_is in Csid_lc_nowadr to TRUE
                GO TO C820_LOWER_CREDIT_CLEANUP
            END-IF
	    %Beg
	    Csid_lc_adridt = Csid_temp_idtype;
	    Csid_lc_adrid = Csid_id_ws;
	    %End
	    Set Success_is in Csid_lc_nowadr to TRUE

            %^ Change to preferred idtype - leave universal types alone
            IF (Csid_temp_idtype = "S" OR "C" OR "P" OR "A") THEN
                Move "Y" to Csid_lc_flg_user
              else
                %^ Change to best available universal key using values in
                %^ Relget_adr_set
                CALL "FIND_ADR_ID" USING
                    BY REFERENCE
                        Csid_temp_idtype
                        Csid_find_adr_idtype_ws
                        Csid_find_adr_id_ws
                        Csid_find_adr_id_ws_length
                    RETURNING Csid_ret2_stat
                IF Success_is in Csid_ret2_stat  
                  then
                    %Beg
                    Csid_party_idtype = csid_find_adr_idtype_ws;
                    Csid_party_id = Csid_find_adr_id_ws;
                    %End
                    Move "Y" to Csid_lc_flg_user
                end-if
            END-IF
        END-IF.

%^ Extended ids
        If (Csid_lc_flg_extid = "F" )
            If (Csid_lc_secwir = "Y" )            %^try REL first, if secwir
                %Beg                              %^ to use dest set
                Csid_temp_idtype = "E" ;
                Csid_id_ws = Csid_lc_extid ;
                %End
		Move Spaces to Csid_lkup_pend_del	
		Move Csid_ambig_ws to Csid_ambig_save_ws

                Call "ACCT_LOOKUP" USING
                    by reference Csid_temp_idtype
                    by reference Csid_id_ws
                    by reference Csid_ovr
                    by reference Csid_ambig_ws
                    by reference Csid_multibank_ws
                    by reference Credit_currency_ls
		    by reference Csid_lkup_pend_del
                  RETURNING Csid_ret2_stat

		Move Csid_ambig_save_ws to Csid_ambig_ws 

                If (Csid_ovr = SPACE )
                    Move "Y" to Csid_lc_flg_extid
		    %Beg
		    Csid_lc_adridt = Csid_temp_idtype;
		    Csid_lc_adrid = Csid_id_ws;
		    %End
		    Set Success_is in Csid_lc_nowadr to TRUE
                    Perform D840_MATCH_IDS_TO_REL through
                            D840_MATCH_IDS_TO_REL_END
                    GO TO C820_LOWER_CREDIT_CLEANUP
		ELSE
		    Set Failure_is in Csid_lc_nowadr to TRUE
                END-IF
            END-IF

%^ Csid_lc_secwir not = Y, or not found on REL
            %Beg
            Csid_temp_idtype = "e" ;    %^ look in Aux_ext_id_index
            Csid_id_ws = Csid_lc_extid ;
            %End
	    Move Spaces to Csid_lkup_pend_del	
            Call "ACCT_LOOKUP" USING
                by reference Csid_temp_idtype
                by reference Csid_id_ws
                by reference Csid_ovr
                by reference Csid_ambig_ws
                by reference Csid_multibank_ws
                by reference Credit_currency_ls
		by reference Csid_lkup_pend_del
              RETURNING Csid_ret2_stat
            If ( (Csid_ovr = "*" )
                AND (Relget_msgcode = Vmsg_dat_notonfile_wc ) )
            THEN
                Move "Y" to Csid_lc_flg_extid   %^found on Aux_ext_id_index
		%Beg
			Csid_lc_adridt = Csid_temp_idtype;
			Csid_lc_adrid = Csid_id_ws;
		%End
                Perform D840_MATCH_IDS_TO_REL through
                        D840_MATCH_IDS_TO_REL_END
		Set Success_is in Csid_lc_nowadr to TRUE
                GO TO C820_LOWER_CREDIT_CLEANUP
            ELSE	%^ secwir = N or " "
                %Beg                      %^ search REL for extended_id
                Csid_temp_idtype = "E" ;
                Csid_id_ws = Csid_lc_extid ;
                %End
		Move SPACES to Csid_lkup_pend_del	
		Move Csid_ambig_ws to Csid_ambig_save_ws
                Call "ACCT_LOOKUP" USING
                    by reference Csid_temp_idtype
                    by reference Csid_id_ws
                    by reference Csid_ovr
                    by reference Csid_ambig_ws
                    by reference Csid_multibank_ws
                    by reference Credit_currency_ls
		    by reference Csid_lkup_pend_del
                  RETURNING Csid_ret2_stat

		Move Csid_ambig_save_ws to Csid_ambig_ws 

                If Csid_ovr = SPACE
                    Move "Y" to Csid_lc_flg_extid
		    %Beg
			    Csid_lc_adridt = Csid_temp_idtype;
			    Csid_lc_adrid = Csid_id_ws;
		    %End
		    Set Success_is in Csid_lc_nowadr to TRUE
		    Perform D840_MATCH_IDS_TO_REL through
                            D840_MATCH_IDS_TO_REL_END
                    GO TO C820_LOWER_CREDIT_CLEANUP
                ELSE
                    If ( (Csid_ovr = "*" )
                        AND (Relget_msgcode = Vmsg_dat_notonfile_wc ) )
                    THEN
                        Move "Y" to Csid_lc_flg_extid
			%Beg
				Csid_lc_adridt = Csid_temp_idtype;
				Csid_lc_adrid = Csid_id_ws;
			%End
			Perform D840_MATCH_IDS_TO_REL through
                        	D840_MATCH_IDS_TO_REL_END
			Set Success_is in Csid_lc_nowadr to TRUE
                        GO TO C820_LOWER_CREDIT_CLEANUP
		    ELSE
			Set Failure_is in Csid_lc_nowadr to TRUE
                    END-IF
                END-IF
            END-IF
%^ done with comparison
	    GO TO C820_LOWER_CREDIT_CLEANUP
        END-IF.

	If (Csid_lc_flg_swift = "F" )
%^ NOTE: We know that we cannot have a chips UID or participant or an ABA, 
%^	so this had better just be a SWIFT
            If (Csid_lc_secwir = "Y" )
%^ We are sending a secwir, so let's try the REL database first.
                %Beg
%^ This searches for the SWIFT TID in the AUX SWIFT database
                Csid_temp_idtype = "S" ;
                Csid_id_ws = Csid_lc_swift ;
                %End
		Move Spaces to Csid_lkup_pend_del	
                Call "ACCT_LOOKUP" USING
                    by reference Csid_temp_idtype
                    by reference Csid_id_ws
                    by reference Csid_ovr
                    by reference Csid_ambig_ws
                    by reference Csid_multibank_ws
                    by reference Credit_currency_ls
		    by reference Csid_lkup_pend_del
                  RETURNING Csid_ret2_stat
* Look for an on_rel so that we have dests for the secwir
                If (Csid_ovr = SPACE )
		    %Beg
		    Csid_lc_adridt = Csid_temp_idtype;
		    Csid_lc_adrid = Csid_id_ws;
		    %End
		    Set Success_is in Csid_lc_nowadr to TRUE
                    Move "Y" to Csid_lc_flg_swift
%^ 
%^ The match to the REL id's should be taken are of by the prior
%^ ID processing  We are only validing the BIC's existence at this point.
%^
%^                    Perform D840_MATCH_IDS_TO_REL through
%^                               D840_MATCH_IDS_TO_REL_END
                    GO TO C820_LOWER_CREDIT_CLEANUP
                END-IF
            END-IF
	    %Beg
%^ This searches for the SWIFT TID in the AUX SWIFT database
	    Csid_temp_idtype = "$" ;
	    Csid_id_ws = Csid_lc_swift ;
	    %End
	    Move Spaces to Csid_lkup_pend_del	
	    Call "ACCT_LOOKUP" USING
	    	by reference Csid_temp_idtype
		by reference Csid_id_ws
		by reference Csid_ovr
		by reference Csid_ambig_ws 
		by reference Csid_multibank_ws
	      	by reference Credit_currency_ls
		by reference Csid_lkup_pend_del
	      RETURNING Csid_ret2_stat
* Cannot get an on-rel hit here; only on-aux.
	    If ( (Csid_ovr = "*" )
		AND (Relget_msgcode = Vmsg_dat_notonfile_wc ) )
	    THEN
		%Beg
		Csid_lc_adridt = Csid_temp_idtype;
		Csid_lc_adrid = Csid_id_ws;
		%End
		Set Success_is in Csid_lc_nowadr to TRUE
* Let us take shameless advantage of the fact that there cannot
*   be any more idtypes to cross-check.
		Move "Y" to Csid_lc_flg_swift
	    ELSE
		%Beg
%^ This searches for the SWIFT TID in the CHIPS UID database
		Csid_temp_idtype = "s" ;
		Csid_id_ws = Csid_lc_swift ;
		%End
		Move Spaces to Csid_lkup_pend_del	
	        Call "ACCT_LOOKUP" USING
	    	    by reference Csid_temp_idtype
		    by reference Csid_id_ws
		    by reference Csid_ovr
		    by reference Csid_ambig_ws 
		    by reference Csid_multibank_ws
	      	    by reference Credit_currency_ls
		    by reference Csid_lkup_pend_del
	          RETURNING Csid_ret2_stat
* Cannot get an on-rel hit here; only on-aux.
	        If ( (Csid_ovr = "*" )
		    AND (Relget_msgcode = Vmsg_dat_notonfile_wc ) )
	        THEN
		    %Beg
		    Csid_lc_adridt = Csid_temp_idtype;
		    Csid_lc_adrid = Csid_id_ws;
		    %End
		    Set Success_is in Csid_lc_nowadr to TRUE
* Let us take shameless advantage of the fact that there cannot
*   be any more idtypes to cross-check.
		    Move "Y" to Csid_lc_flg_swift
	        ELSE
		    %Beg
%^ This searches for the SWIFT TID in the REL database
		    Csid_temp_idtype = "S" ;
		    Csid_id_ws = Csid_lc_swift ;
		    %End
		    Move Spaces to Csid_lkup_pend_del	
	            Call "ACCT_LOOKUP" USING
	    	        by reference Csid_temp_idtype
		        by reference Csid_id_ws
		        by reference Csid_ovr
		        by reference Csid_ambig_ws 
		        by reference Csid_multibank_ws
	      	        by reference Credit_currency_ls
			by reference Csid_lkup_pend_del
	              RETURNING Csid_ret2_stat
                    If Csid_ovr = SPACE
			%Beg
			Csid_lc_adridt = Csid_temp_idtype;
			Csid_lc_adrid = Csid_id_ws;
			%End
			Set Success_is in Csid_lc_nowadr to TRUE
		        Move "Y" to Csid_lc_flg_swift
	            ELSE
			If ( (Csid_ovr = "*" )
			    AND (Relget_msgcode = Vmsg_dat_notonfile_wc ) )
	        	THEN
		            Move "Y" to Csid_lc_flg_swift
			    %Beg
			    Csid_lc_adridt = Csid_temp_idtype;
			    Csid_lc_adrid = Csid_id_ws;
			    %End
			    Set Success_is in Csid_lc_nowadr to TRUE
			ELSE
			    Set Failure_is in Csid_lc_nowadr to TRUE
			END-IF
		    END-IF
		END-IF
	    END-IF
	END-IF.


C820_LOWER_CREDIT_CLEANUP.
* See how we fared.
	Set Failure_is in Csid_ret_stat to true
	If (Csid_lc_flg_aba = "N" )
           OR (Csid_lc_flg_account = "N" )
           OR (Csid_lc_flg_partic = "N" )
           OR (Csid_lc_flg_swift = "N" )
	   OR (Csid_lc_flg_uid = "N" )
	   OR (Csid_lc_flg_extid = "N" )
           OR (Csid_lc_flg_user = "N" )
	THEN
* Hard failure -- we have a conflict.
            Move "?" to Csid_ovr
	    GO TO C820_LOWER_CREDIT_END
	END-IF.
	If (Csid_lc_flg_aba NOT = "Y" )
           AND (Csid_lc_flg_account NOT = "Y" )
           AND (Csid_lc_flg_partic NOT = "Y" )
           AND (Csid_lc_flg_swift NOT = "Y" )
	   AND (Csid_lc_flg_uid NOT = "Y" )
	   AND (Csid_lc_flg_extid NOT = "Y" )
           AND (Csid_lc_flg_user NOT = "Y" )
	THEN
* Soft failure -- we have no hits.
	    Move "*" to Csid_ovr
	    GO TO C820_LOWER_CREDIT_END
	END-IF.

	Set Success_is in Csid_ret_stat to true
	If (Csid_lc_flg_aba NOT = "F" )
           AND (Csid_lc_flg_account NOT = "F" )
           AND (Csid_lc_flg_partic NOT = "F" )
           AND (Csid_lc_flg_swift NOT = "F" )
	   AND (Csid_lc_flg_uid NOT = "F" )
	   AND (Csid_lc_flg_extid NOT = "F" )
           AND (Csid_lc_flg_user NOT = "F" )
	THEN
* Hard success -- We could look up everything we found
	    Move SPACE to Csid_ovr
	ELSE
* Soft success -- We have some leftovers.
	    Move "*" to Csid_ovr	%^ 136705 was set back to * from "?"
	    If (Csid_lc_adrid_length NOT = 0 )
	      AND (Csid_lc_adrid NOT = SPACES )
	      AND (Failure_is in Csid_lc_nowadr)
	    THEN
%^ Get the name and address info back in the relget_adr_set.
		Move Spaces to Csid_lkup_pend_del
                Call "ACCT_LOOKUP" USING
                    by reference Csid_lc_adridt
                    by reference Csid_lc_adrid
                    by reference Csid_ovr
                    by reference Csid_ambig_ws
                    by reference Csid_multibank_ws
                    by reference Credit_currency_ls
		    by reference Csid_lkup_pend_del
                  RETURNING Csid_temp_stat
	    END-IF
   	END-IF.
C820_LOWER_CREDIT_END.
   EXIT.


C830_SWAP_CREDIT_IDS.
	%Beg
	Csid_parse ^IN(Ent_credit_set.Cdt_typ.Cdt_idtype)
	    Csid_swf_part1_id, ^ONEOF( ("/", /), (/) );
	Csid_clip_compose ^OUT(Csid_swf_part1_full_id)
	    "BC", Csid_swf_part1_id, /;
	Csid_parse ^IN(Csid_second_id)
	    "/", Csid_swf_part2_subtype, Csid_swf_part2_id, /;
	%End
	Move "*" to Csid_swf_part2_idtype 
	Evaluate TRUE
	  When (Csid_swf_part2_subtype = "AC")
	    Move "D" to Csid_swf_part2_idtype
	  When (Csid_swf_part2_subtype = "CH")
	    Move "C" to Csid_swf_part2_idtype
	  When (Csid_swf_part2_subtype = "CP")
	    Move "P" to Csid_swf_part2_idtype
	  When (Csid_swf_part2_subtype = "FW")
	    Move "A" to Csid_swf_part2_idtype
	  When OTHER
	    Move "E" to Csid_swf_part2_idtype
	    %Beg
	    Csid_clip_compose ^OUT(Csid_swf_part2_full_id)
	    	Csid_swf_part2_subtype, Csid_swf_part2_id, /;
	    Csid_swf_part2_id = Csid_swf_part2_full_id;
	    %End
	End-Evaluate.
	%Beg
	Csid_compose ^OUT(Csid_second_id)
		"/", Csid_swf_part1_full_id, /;
	Ent_credit_set.Cdt_typ.Cdt_idtype = Csid_swf_part2_idtype;
	Ent_credit_set.Cdt_typ.Cdt_id = Csid_swf_part2_id;
	%End.
C830_SWAP_CREDIT_IDS_END.
	Exit.

%^D100_BCC_LKUP_BIC.
%^
%^ OBSELETE, But, leave here for a while just in case. 
%^
%^ If configured, replace "E" BCC Code with the BIC

%^ Assume successful processing without BCC replacement
%^	Set Success_is in Bcc_lkup_status to true.
%^	Set Failure_is in Bcc_now_bic to true.

%^ Exit if not valid for processing 
%^	IF (Lkup_bic_by_bcc_ws = "C" OR "B") AND
%^	   (Relget_return_idtype = "E")
%^	    Continue
%^	ELSE
%^	    Go to D100_BCC_LKUP_BIC_END
%^	END-IF.

%^ If SWIFT ID not available, set error;
%^ Otherwise, replace BCC with BIC
%^ FTRSCR_EDITS will perform final validation
%^	IF Swift_id of Relget_adr_set = spaces 
%^	    Set Failure_is in Csid_ret_stat to true
%^	    Set Failure_is in Csid_found_it to true
%^	    %Beg
%^	    Csid_compose ^OUT(Csid_err_memo)
%^			"SWIFT ID required: ", Bcc_lkup_party, " party.", / ;
%^	    %End
%^	    Perform X900_ERROR_MEMO through X900_ERROR_MEMO_END
%^	    Set Failure_is in Bcc_lkup_status to true
%^	ELSE
%^	    %Beg
%^	    Csid_party_idtype = "S";
%^	    Csid_compose ^OUT(Csid_party_id),
%^			Relget_adr_set.Swift_id, /;
%^	    Relget_return_idtype = "S";
%^	    Csid_compose ^OUT(Relget_return_key),
%^			Relget_adr_set.Swift_id, /;
%^	    %End
%^	    Set Success_is in Bcc_now_bic to true
%^	END-IF.
%^
%^D100_BCC_LKUP_BIC_END.
%^   EXIT.

D840_MATCH_IDS_TO_REL.

* Paragraph takes relget_adr_set and matches any "F"(ound) flagged IDs to
*  it if it can.

	If (Csid_lc_flg_aba = "F" )
	    If (Csid_lc_aba(1:Csid_lc_aba_length) = Aba_id of Relget_adr_set )
		Move "Y" to Csid_lc_flg_aba
	    ELSE
		Move "N" to Csid_lc_flg_aba
	    END-IF
	END-IF.

	If (Csid_lc_flg_partic = "F" )
	    %Beg
	    BREAK: Csid_acc_seq ;
	    Relget_adr_set.account_seq CONN: Csid_acc_seq(NOMOD) ;
 	    SEARCH: Csid_acc_seq (EQL, .Rel_name_key
					(.idbank = Relget_adr_set.Bnk_id,
					 .idtype = "P",
					 .idkey = Csid_lc_partic ) ) ;
            Csid_ret2_stat = Csid_acc_seq status ;
	    BREAK: Csid_acc_seq ;
 	    %End
	    If (Success_is in Csid_ret2_stat   )
		Move "Y" to Csid_lc_flg_partic
	    ELSE	      
		Move "N" to Csid_lc_flg_partic
	    END-IF
	END-IF.
			
	If (Csid_lc_flg_swift = "F" )

	    If ( Csid_lc_swift(1:11) = Swift_id of Relget_adr_set(1:11) ) Or
	       ( Success_is in Csid_swf_dualid_match6 And %^ 132507
		 Csid_lc_swift(1:6) = Swift_id of Relget_adr_set(1:6)
		)
	    Then
		Move "Y" to Csid_lc_flg_swift
	    ELSE
		Move "N" to Csid_lc_flg_swift
	    END-IF
	END-IF.

	If (Csid_lc_flg_uid = "F" )
	    If (Csid_lc_uid(1:Csid_lc_uid_length) = 
					      Chips_uid_id of Relget_adr_set )
		Move "Y" to Csid_lc_flg_uid
	    ELSE
		Move "N" to Csid_lc_flg_uid
	    END-IF
	END-IF.

	If (Csid_lc_flg_extid = "F" )
		%beg
		BREAK: Relget_supp_id_seq;
		Relget_adr_set.Supplement_id_seq CONN: Relget_supp_id_seq ^FIRST (nomod);
		%end
		Move "N" to Csid_lc_flg_extid
		Perform until seq_end_is in Relget_supp_id_seq_cursor
			If Csid_lc_extid(1:Csid_lc_extid_length) =
				Idacc of Idkey of Rel_name_key of Relget_supp_id_seq
			  then	Move "Y" to Csid_lc_flg_extid
				%beg
				END: Relget_supp_id_seq;
				%end
			  else	%beg
				NEXT: Relget_supp_id_seq;
				%end
			End-if
		End-perform
	END-IF.

D840_MATCH_IDS_TO_REL_END.

   EXIT.
D860_SWIFT_TO_ABA.
* Paragraph to look up SWIFT ID in the SWIFT to ABA INDEX.
* If we got a hit, Csid_ret2_stat is SUCCESS and the ABA is in Disp_id of
*    Csid_aux_index.
	%ACE_IS Csid_aux_set connected returning Ace_status_wf ;.
	If Failure_is in Ace_status_wf
	    %Beg  dat_root_set.Aux_db_set CONN: Csid_aux_set(NOMOD);  %End
	END-IF.
	Move SPACES to Csid_scr_adr_id.
	%Beg
	BREAK: Csid_aux_index ;
	Csid_scr_adr_id.Idtype = "S" ;
	Csid_compose ^OUT(Csid_scr_adr_id.idkey.idacc), 
				    Csid_lc_swift, / ;
	Csid_aux_set(notrap);
	Csid_aux_set(.Swf_to_aba_index CONN: Csid_aux_index ^SEARCH
			(READ_ONLY, 
			 EQL,
			 .Rel_name_key = Csid_scr_adr_id ) );
	Csid_ret2_stat = Csid_aux_index Status;
	Csid_aux_set(etrap);
	BREAK: Csid_aux_index ;
	%End.
D860_SWIFT_TO_ABA_END.

   EXIT.
D870_LOCKED_CREDIT_PARTY.
 
%^ This routine determines whether a locked credit party on a repetitive is
%^ still set up correctly, or if something has changed that should cause it
%^ to be looked up again.
	Set Failure_is in Csid_lcp_bypass_lookup to true.
	Move 0 to Csid_lcp_lookup_reason.
	Move 0 to Csid_lcp_conn_stat.
	Move spaces to Csid_lcp_key_ws.
	Move spaces to Csid_lcp_bnk_ws.
	Move spaces to Csid_lcp_acc_ws.
	Move spaces to Csid_lcp_adr_ws.
	Move spaces to Csid_lcp_index_type_ws.

%^ Save the original credit party fields so we can write out
%^   a memo if a locked credit party had to be changed
	%Beg
	Csid_lcp_orig_rel_id  = Ent_credit_set.cdt_rel_id;
	Csid_lcp_orig_cdt_typ = Ent_credit_set.cdt_typ;
	Csid_lcp_orig_cdt_acct = Ent_credit_set.cdt_account;
	%End.
 
%^ If this isn't a locked repetitive
	If (Lock_cdt_party_ls = 0) 
	  then
	    Move 1 to Csid_lcp_lookup_reason
	    Go to D870_LOCKED_CREDIT_PARTY_END	%^ Do a normal account lookup
	end-if.
 
%^ If this is NOT an on-file cdt party
	If Cdt_rel_id of Ent_credit_set = 0 or
	   Cdt_ovr of Ent_credit_set not = spaces or
	   Cdt_idtype of Ent_credit_set = spaces or
	   Cdt_id of Ent_credit_set = spaces or
	   Cdt_adr_bnk_id of Ent_credit_set = spaces
	  then
	    Move 2 to Csid_lcp_lookup_reason
	    Go to D870_LOCKED_CREDIT_PARTY_END	%^ Do a normal account lookup
	end-if.
 
%^ If the Cdt_typ is missing a required bbb: prefix
	If Dbt_adr_bnk_id of Ent_debit_set not = spaces and
	   Cdt_adr_bnk_id of Ent_credit_set not =
			Dbt_adr_bnk_id of Ent_debit_set
	  then
	    If Cdt_id of Ent_credit_set (1:3) not =
			Cdt_adr_bnk_id of Ent_credit_set or
	       Cdt_id of Ent_credit_set (4:1) not = ":"
	      then
		Move 3 to Csid_lcp_lookup_reason
		%^ Do a normal account lookup
		Go to D870_LOCKED_CREDIT_PARTY_END  
	    end-if
	end-if.
 
%^ If the Cdt_typ is missing a required bbb: prefix
	If Bank of Loc_info of Ent_ftr_set not = spaces and
	   Cdt_adr_bnk_id of Ent_credit_set not =
			Bank of Loc_info of Ent_ftr_set
	  then
	    If Cdt_id of Ent_credit_set (1:3) not =
			Cdt_adr_bnk_id of Ent_credit_set or
	       Cdt_id of Ent_credit_set (4:1) not = ":"
	      then
		Move 4 to Csid_lcp_lookup_reason
		%^ Do a normal account lookup
		Go to D870_LOCKED_CREDIT_PARTY_END  
	    end-if
	end-if.
 
%^ If the Cdt_typ has an invalid BBB: prefix
	If Cdt_id of Ent_credit_set (4:1) = ":"
	  then
	    If Cdt_adr_bnk_id of Ent_credit_set =
			Bank of Loc_info of Ent_ftr_set or
	       Cdt_adr_bnk_id of Ent_credit_set =
			Dbt_adr_bnk_id of Ent_debit_set or
	       Cdt_adr_bnk_id of Ent_credit_set not =
			Cdt_id of Ent_credit_set (1:3)
	      then
		Move 5 to Csid_lcp_lookup_reason
		%^ Do a normal account lookup
		Go to D870_LOCKED_CREDIT_PARTY_END  
	    end-if
	end-if.
 
	%Beg
	Csid_lcp_bnk_ws = NULL;
	Csid_lcp_acc_ws = NULL;
	Csid_lcp_adr_ws = NULL;
	Csid_parse ^IN(Ent_credit_set.cdt_typ.cdt_id),
	    ^SPACE,
	    ^OPTION(Csid_lcp_bnk_ws, ":" ),
	    Csid_lcp_acc_ws,
	    ^ONEOF(
		("/", Csid_lcp_adr_ws, ^SPACE, /),
		(^SPACE, /) );
	%End.
 
%^ If we couldn't even parse the credit party
	If Failure_is in Csid_parse_status  
	  then
	    Move 6 to Csid_lcp_lookup_reason
	    Go to D870_LOCKED_CREDIT_PARTY_END	%^ Do a normal account lookup
	end-if.
 
	%Beg
	Csid_lcp_key_ws.idbank = Csid_lcp_bnk_ws;
	Csid_lcp_key_ws.idtype = Ent_credit_set.cdt_typ.cdt_idtype;
	Csid_lcp_key_ws.idkey  = Csid_lcp_acc_ws;
	%End
 
	If Csid_lcp_bnk_ws = spaces
	  then
	    %Beg Csid_lcp_key_ws.idbank = Ent_credit_set.cdt_adr_bnk_id; %End
	end-if.
 
	If (Idtype of Csid_lcp_key_ws = "D" or "F" or "G" or "P" or "V") and
	    Csid_lcp_adr_ws not = spaces
	   then
	    %Beg Csid_lcp_key_ws.idkey.idadr = Csid_lcp_adr_ws; %End
	end-if.
 
	%Beg BREAK: Csid_lcp_index; %End.
 
	Evaluate Idtype of Csid_lcp_key_ws
 
	  when "D"
		%Ace_conn_root_q Dda_index to Csid_lcp_index;
		Move "A" to Csid_lcp_index_type_ws
	  when "G"
		%Ace_conn_root_q Gl_index to Csid_lcp_index;
		Move "A" to Csid_lcp_index_type_ws
	  when "F"
		%Ace_conn_root_q Nostro_index to Csid_lcp_index;
		Move "A" to Csid_lcp_index_type_ws
	  when "V"
		%Ace_conn_root_q Sav_index to Csid_lcp_index;
		Move "A" to Csid_lcp_index_type_ws
 
	  when "P"
		%Ace_conn_root_q Chips_index to Csid_lcp_index;
		Move "R" to Csid_lcp_index_type_ws
	  when "N"
		%Ace_conn_root_q Sname_index to Csid_lcp_index;
		Move "R" to Csid_lcp_index_type_ws
	  when "A"
		%Ace_conn_root_q Aba_index to Csid_lcp_index;
		Move "R" to Csid_lcp_index_type_ws
	  when "S"
		%Ace_conn_root_q Swift_index to Csid_lcp_index;
		Move "R" to Csid_lcp_index_type_ws
	  when "B"
		%Ace_conn_root_q Branch_index to Csid_lcp_index;
		Move "R" to Csid_lcp_index_type_ws
	  when "C"
		%Ace_conn_root_q Chips_uid_index to Csid_lcp_index;
		Move "R" to Csid_lcp_index_type_ws
	  when "U"
		%Ace_conn_root_q User_index to Csid_lcp_index;
		Move "R" to Csid_lcp_index_type_ws
	  when "I"
		%Beg Csid_lcp_key_ws.idbank = NULL; %End
		%Ace_conn_root_q Rel_interbnk_index to Csid_lcp_index;
		Move "R" to Csid_lcp_index_type_ws
	  when "K"
		%Beg Csid_lcp_key_ws.idbank = NULL; %End
		%Ace_conn_root_q Rel_customer_index to Csid_lcp_index;
		Move "R" to Csid_lcp_index_type_ws
 
	  when "M"
		%Ace_conn_root_q Mac_index to Csid_lcp_index;
		Move "D" to Csid_lcp_index_type_ws
	  when "T"
		%Ace_conn_root_q Dial_index to Csid_lcp_index;
		Move "D" to Csid_lcp_index_type_ws
	  when "X"
		%Ace_conn_root_q Ans_index to Csid_lcp_index;
		Move "D" to Csid_lcp_index_type_ws
	  when "Z"
		%Ace_conn_root_q Cable_index to Csid_lcp_index;
		Move "D" to Csid_lcp_index_type_ws
 
	  when other			%^ If it's any other idtype
		Move 7 to Csid_lcp_lookup_reason
		%^ Do a normal account lookup
		Go to D870_LOCKED_CREDIT_PARTY_END  
 
	end-evaluate.
 
	%Beg Csid_lcp_index ^SEARCH (eql, Key = Csid_lcp_key_ws); %End
 
%^ If we couldn't find an index entry...
	If Failure_is in Csid_lcp_index_status  
	  then
	    Move 8 to Csid_lcp_lookup_reason
	    Go to D870_LOCKED_CREDIT_PARTY_END	%^ Do a normal account lookup
	end-if.
 
	Perform until 
	  Failure_is in Csid_lcp_index_status   or
	  Csid_lcp_key_ws not = Rel_name_key of Csid_lcp_index or
	  Cdt_rel_id of Ent_credit_set = Rel_id of Csid_lcp_index
	    %Beg Csid_lcp_index ^NEXT; %End
	end-perform.
 
%^ If we couldn't find the right rel_id...
	If Failure_is in Csid_lcp_index_status   or
	   Csid_lcp_key_ws not = Rel_name_key of Csid_lcp_index or
	   Cdt_rel_id of Ent_credit_set not = Rel_id of Csid_lcp_index
	    Move 9 to Csid_lcp_lookup_reason
	    Go to D870_LOCKED_CREDIT_PARTY_END	%^ Do a normal account lookup
	end-if.
 
	%Beg BREAK: Csid_lcp_adr_set; %End.
 
	Evaluate Csid_lcp_index_type_ws
 
%^ Account type indices.
	  when "A"
		%Beg
		Csid_lcp_index(
		 CONN: Csid_lcp_nul_seq(
		  NOMOD,
		  TOP: Csid_lcp_union(
		   nomod,
		   .adr_set CONN: Csid_lcp_adr_set(nomod) ) ) );
		BREAK: Csid_lcp_union;
		BREAK: Csid_lcp_nul_seq;
		%End
 
%^ Destination type indices.
	  when "D"
		%Beg
		Csid_lcp_index(
		 CONN: Csid_lcp_nul_set(
		  nomod,
		  TOP: Csid_lcp_union(
		   nomod,
		   .adr_set CONN: Csid_lcp_adr_set(nomod) ) ) );
		BREAK: Csid_lcp_union;
		BREAK: Csid_lcp_nul_set;
		%End
 
%^ Routing and group type indices.
	  when other
		%Beg
		Csid_lcp_index(
		 CONN: Csid_lcp_adr_set(nomod) );
		%End
 
	end-evaluate.
 
	%Beg Csid_lcp_conn_stat = Csid_lcp_adr_set State.CONN; %End.
 
	If (Csid_lcp_conn_stat = 0 )   or
	   Rel_id of Csid_lcp_adr_set not = Cdt_rel_id of Ent_credit_set
	  then
	    Move 10 to Csid_lcp_lookup_reason
	    Go to D870_LOCKED_CREDIT_PARTY_END	%^ Do a normal account lookup
	end-if.
 
%^ Everything's OK on the locked credit party, so can bypass looking it up again
 
	Set Success_is in Csid_lcp_bypass_lookup to true.
 
D870_LOCKED_CREDIT_PARTY_END.

* Utility paragraphs.


   EXIT.
X880_CHECK_CURRENCY.
* Checks currency of account in Csid_acc_seq against message.  If they 
* match, Success_is is returned in Csid_curr_ok_ws.  Else Csid_curr_ok_ws is
* returned as Failure_is.

	If (Csid_currency_ws = SPACES )
* Message currency is unknown /don't care.
	    Set Success_is in Csid_curr_ok_ws to TRUE
	    GO TO X880_CHECK_CURRENCY_END
	END-IF.

	If (Disp_cur of Csid_acc_seq NOT = SPACES )
	    Move Disp_cur of Csid_acc_seq to Csid_acc_curr_ws
	ELSE
	   If  Cdt_adr_bnk_id of Ent_credit_set =
	       Bnk_id of Menu_bnk_union
	   Then
		Move Base_currency_id of Menu_bnk_union to 
		     csid_acc_curr_ws
	   else
		%Beg
	        	BREAK: Csid_bnk_union ;
	   		SEARCH: Bnk_index 
		 	 		(Key = Ent_credit_set.Cdt_adr_bnk_id ) ;
		%end
	        If Failure_is in Bnk_index_status  
	        	Move SPACES to Csid_acc_curr_ws
	        ELSE
	        	%Beg  Bnk_index CONN: Csid_bnk_union (NOMOD) ; %End
	            	Move Base_currency_id of Csid_bnk_union to 
			     Csid_acc_curr_ws
			%beg break: csid_bnk_union; %end %^ safety first
	         END-IF
            end-if
	END-IF.
	If (Csid_acc_curr_ws = Csid_currency_ws )
	    Set Success_is in Csid_curr_ok_ws to TRUE
	ELSE
	    Set Failure_is in Csid_curr_ok_ws to TRUE
	END-IF.
X880_CHECK_CURRENCY_END.

   EXIT.
X900_ERROR_MEMO.
*  This paragraph writes an error memo using the text string in Csid_err_memo.
%^ #116931 If the function is "MRE", the errors should not be written to the message
%^	   history, but are now being displayed on the screen.  MRE calls
%^	   creditside_lookup, instead of creditside_screen, because the Operator has 
%^	   very little control with respect to data being entered.

	If Csid_err_memo_length = 0 Or
	   Idfunc of Menu_next_function = "MRE"
	Then 
	    GO TO X900_ERROR_MEMO_END
	END-IF.
	Move SPACES to Csid_temp_memo
	If Csid_err_memo_length > 80
	    Move 80 to Csid_temp_memo_length
	ELSE
	    Move Csid_err_memo_length to Csid_temp_memo_length
	END-IF
	Move Csid_err_memo(1:Csid_temp_memo_length) to 
		Csid_temp_memo(1:Csid_temp_memo_length)
	%Beg
	ALLOC_END: Ent_msg_history (mod,
			.qname (
				.Idbank = Ent_ftr_set.loc_info.bank,
				.Idloc = NULL,
				.Idname = "*SYS_MEMO"),
			.memo   = Csid_temp_memo,
			.qtype	= "OBJTYP$_NULL");
	%End.
	ADD 1 TO Cdt_err_memo_count_ls.
X900_ERROR_MEMO_END.

   EXIT.
X920_INFO_MEMO.
*  This paragraph writes an informational trace memo using the text string
*      in Csid_info_memo.
	If Csid_info_memo_length = 0 
	    GO TO X920_INFO_MEMO_END
	END-IF.
	Move SPACES to Csid_temp_memo
	If Csid_info_memo_length > 80
	    Move 80 to Csid_temp_memo_length
	ELSE
	    Move Csid_info_memo_length to Csid_temp_memo_length
	END-IF
	Move Csid_info_memo(1:Csid_temp_memo_length) to 
		Csid_temp_memo(1:Csid_temp_memo_length)
	%Beg
	ALLOC_END: Ent_msg_history (mod,
			.qname (
				.Idbank = Ent_ftr_set.loc_info.bank,
				.Idloc = NULL,
				.Idname = "*SYS_MEMO"),
			.memo   = Csid_temp_memo,
			.qtype	= "OBJTYP$_NULL");
	%End.
	Add 1 to Csid_info_count.
X920_INFO_MEMO_END.

   EXIT.
X940_TAKEOUT_GARBAGE.

* This paragraph does sanity checks on a full id string passed for a creditside
* party by a mapper.  This id string contains not only the initial id but also,
* appended to it, the overflow or second ids.  Since all that we are doing is
* a sanity check on each address id token, it doesn't matter that the credit
* party second id may actually wind up in a lower creditside position in the
* message.
* There are two components to the check, though they are done together in a
* single pass through the Csid_party_idtype and the Csid_party_id strings.
* First we validate the ids by idtype as we encounter them (correct number of 
* characters, correct numeric/alpha) and we also search for a 
* "start of garbage" identifier "/??".
* If we find a "start of garbage" we compress it out of the string and return
* Csid_had_garbage as SUCCESS.  
* If any id fails its validation test we stop scanning and return 
* Csid_had_garbage as SUCCESS
* Otherwise we return Csid_had_garbage as FAILURE.
* Csid_gcheck_processed is constructed in parallel as our modified string.

	Set Failure_is in Csid_had_garbage to true.
        Set Failure_is in Csid_bad_dda to true.

%^ Determine if the Id has a bbb: prefix.  If so, strip it off and check it
%^ against the bank index to determine if it's valid.
        %Beg
        Csid_parse ^IN(Csid_party_id)
            Csid_party_bank_id, ":", Csid_gcheck_remain2, /;
        %End
        If Success_is in Csid_parse_status   then
            %Beg SEARCH: Bnk_index (Key = Csid_party_bank_id); %End
            If Failure_is in Bnk_index_status  
                Set Success_is in Csid_had_garbage to true
		Go to X940_TAKEOUT_GARBAGE_END	
            END-IF
        ELSE
            %Beg 
	    Csid_party_bank_id = NULL; 
	    Csid_gcheck_remain2 = Csid_Party_id;
	    %End
        END-IF.
        If ( Csid_party_bank_id_length = 0 ) 
	   OR (Csid_party_bank_id = SPACES )
	THEN
	    If (Cdt_adr_bnk_id of Ent_credit_set = SPACES )
		%Beg  Csid_gcheck_bank_id = Ent_ftr_set.Loc_info.Bank;  %End
	    ELSE
		%Beg  Csid_gcheck_bank_id = Ent_credit_set.Cdt_adr_bnk_id;  %End
	    END-IF		
	ELSE
	    %Beg  Csid_gcheck_bank_id = Csid_party_bank_id;  %End
	END-IF.

	%Beg
	Csid_party_extype2 = NULL ;
	Csid_party_extype = NULL ;
	Csid_party_intro = NULL ;
	Csid_party_intro2 = NULL ;
	%End

	Evaluate TRUE
	    When Csid_party_idtype = "D"
%^ Indicates an on-us account ID
		Set GCHT_DDA in Csid_gcheck_states to TRUE
	    When Csid_party_idtype = "G"
%^ Indicates an on-us account ID
		Set GCHT_GL in Csid_gcheck_states to TRUE
	    When Csid_party_idtype = "F"
%^ Indicates an on-us account ID
		Set GCHT_NOSTRO in Csid_gcheck_states to TRUE
	    When Csid_party_idtype = "V"
%^ Indicates an on-us account ID
		Set GCHT_SAV in Csid_gcheck_states to TRUE
	    When Csid_party_idtype = " "
%^ Indicates another bank's account ID
		Set GCHT_AC in Csid_gcheck_states to TRUE
	    When Csid_party_idtype = "S"
		Set GCHT_SWF in Csid_gcheck_states to TRUE
	    When Csid_party_idtype = "C"
		Set GCHT_CHUSER in Csid_gcheck_states to TRUE
	    When Csid_party_idtype = "A"
		Set GCHT_FED in Csid_gcheck_states to TRUE
	    When Csid_party_idtype = "P"
%^ We must get the extended ID for this.
		CALL "GET_XIDTYPE_FROM_SUFFIX" Using
		    By content "   "
		    By reference Csid_gcheck_remain2
		    By Reference Csid_gcheck_remain2_length
		    By Reference Csid_party_extype2
		  Returning Csid_itsa_clearhouse
		If Failure_is in Csid_itsa_clearhouse
		    Set GCHT_NONE in Csid_gcheck_states to TRUE
		ELSE
		    If (Csid_party_extype = "CP")
			Set GCHT_CHIPS in Csid_gcheck_states to TRUE
		    ELSE
			Set GCHT_CLEAR in Csid_gcheck_states to TRUE
		    END-IF
		END-IF
		
	    When Csid_party_idtype = "E"
%^ Parse subtype later

		Set GCHT_EXTEND in Csid_gcheck_states to TRUE

            When OTHER
%^ No interesting IDTYPE
		Set GCHT_NOMATCH in Csid_gcheck_states to TRUE
	END-EVALUATE.

	If (Csid_gcheck_remain2(1:1) = "/" )
%^ Flush any duplicate mode indicator with a null actual id.
	    %Beg
	    Csid_temp1_vstr = Csid_gcheck_remain2 ;
%^ NOTE: ONEOF's below must match states for defined oneof Csid_gcheck_states
	    Csid_parse ^IN(Csid_temp1_vstr)
		Csid_gcheck_twoof( ^ONEOF(
		(/),                                     %^GCHT_NONE
            	("///",|Csid_gcheck_remain2, ^SPACE, /), %^GCHT_DDA
       		("///",|Csid_gcheck_remain2, ^SPACE, /), %^GCHT_SAV
       		("///",|Csid_gcheck_remain2, ^SPACE, /), %^GCHT_GL
            	("///",|Csid_gcheck_remain2, ^SPACE, /), %^GCHT_NOSTR
            	("/AC",|Csid_gcheck_remain2, ^SPACE, /), %^GCHT_AC
            	("/BC",|Csid_gcheck_remain2, ^SPACE, /), %^GCHT_SWF
            	("/CH",|Csid_gcheck_remain2, ^SPACE, /), %^GCHT_CHUSER
            	("/FW",|Csid_gcheck_remain2, ^SPACE, /), %^GCHT_FED
            	("/CP",|Csid_gcheck_remain2, ^SPACE, /), %^GCHT_CHIPS
            	("///",|Csid_gcheck_remain2, ^SPACE, /), %^GCHT_CLEAR
            	("/??",|Csid_gcheck_remain2, ^SPACE, /), %^GCHT_GARBAGE
		("/",                                    %^GCHT_EXTEND
		     |Csid_party_extype2 (^String<2>(<CHAR$M_ALPHA>)),
					       |Csid_gcheck_remain2, ^SPACE, /),
            	(/) ));
	    %End
            If (Csid_gcheck_twoof NOT = Csid_gcheck_states )
%^ Do not eat next mode indicator in id
		%Beg  Csid_gcheck_remain2 = Csid_temp1_vstr;  %End
	    END-IF
	END-IF.

	Move 1 to Csid_gcheck_first.
	%Beg  
	Csid_gcheck_processed = NULL ;
	Csid_gcheck_twoof = Csid_gcheck_states ;
	%End.
* If the idtype is "E", initialize for the loop below by stripping off the 
* 2-character subtype now that the bank prefix (if any) has been removed. 
* This also avoids messing with CSID_PARTY_ID in case that will be returned 
* intact
	If Csid_party_idtype = "E" Then
	    Move Csid_gcheck_remain2(1:2) To Csid_party_extype2
	    If (Csid_party_bank_id_length NOT = 0 )
		AND (Csid_party_bank_id NOT = SPACES )
	    THEN
	    	%Beg  
	    	Csid_compose ^OUT(Csid_gcheck_processed)
			Csid_party_bank_id, ":",  Csid_party_extype2, / ;
	        %End
	    ELSE
		%Beg  Csid_gcheck_processed = Csid_party_extype2 ;  %End
	    END-IF
	    %Beg
	    Csid_clip_compose ^OUT(Csid_temp1_vstr)
		Csid_gcheck_remain2, / ;
	    %End
	    Subtract 2 from Csid_temp1_vstr_length
	    Move Csid_temp1_vstr(3:Csid_temp1_vstr_length) To
							    Csid_gcheck_remain2
	    If Csid_gcheck_remain2_length > 1
		Subtract 2 From Csid_gcheck_remain2_length 
	    END-IF
	ELSE
	    If (Csid_party_bank_id_length NOT = 0 )
		AND (Csid_party_bank_id NOT = SPACES )
	    THEN
	    	%Beg  
	    	Csid_compose ^OUT(Csid_gcheck_processed)
			Csid_party_bank_id, ":", / ;
	        %End
	    END-IF
	END-IF.


	If csid_struct_acct_ws = "Y" Then
		If ((GCHT_NOMATCH in Csid_gcheck_states) Or
		    (GCHT_AC	  in Csid_gcheck_states)) and
		    (csid_party_id NOT = Spaces)
		Then
			%^ GCHT_AC also has the possiblity
			%^ GCHT_NOMATCH has the possibility of being an IBAN,
			%^ Check to see if we can do anything with it
			%^ KB
			Perform X970_CHECK_FOR_IBAN thru X970_CHECK_FOR_IBAN_END
			GO TO X940_TAKEOUT_GARBAGE_END
		end-if
	end-if.

	If ( (GCHT_NOMATCH in Csid_gcheck_states) And (csid_party_id = Spaces) ) Or
	   ( (GCHT_AC      in Csid_gcheck_states) And (csid_party_id = Spaces) ) Or
	   ( (GCHT_EXTEND in Csid_gcheck_states)
		AND (Csid_party_extype2 = "ID" ) )
	THEN
%^ Don't know how to check it, so just add it onto the output string and exit
	    %Beg
	    Csid_compose ^OUT(Csid_temp1_vstr)
		Csid_gcheck_processed, Csid_gcheck_remain2, / ;
	    Csid_gcheck_processed = Csid_temp1_vstr ;
	    %End
	    GO TO X940_TAKEOUT_GARBAGE_END
	END-IF.	    

	Perform UNTIL (Csid_gcheck_remain2_length = 0 )
		      OR  (Success_is in Csid_had_garbage   )
		      OR  (Csid_gcheck_twoof = 0 )

	    Move Csid_gcheck_twoof to Csid_gcheck_oneof
	    %Beg  
	    Csid_gcheck_states = Csid_gcheck_oneof; 
	    Csid_party_extype = Csid_party_extype2;
	    Csid_party_intro = Csid_party_intro2 ;
	    Csid_gcheck_remain = Csid_gcheck_remain2 ;
	    Csid_party_intro2 = NULL ;
	    Csid_gcheck_remain2 = NULL ;
	    Csid_gcheck_id = NULL ;
	    Csid_party_extype2 = NULL ;
	    Csid_gcheck_adr_id = NULL ;
	    %End

	    If (GCHT_DDA in Csid_gcheck_states )
		OR (GCHT_SAV in Csid_gcheck_states )
		OR (GCHT_GL in Csid_gcheck_states)
		OR (GCHT_NOSTRO in Csid_gcheck_states)
		OR (GCHT_CLEAR in Csid_gcheck_states)
		OR (GCHT_CHIPS in Csid_gcheck_states)
	    THEN
		%Beg
		Csid_gcheck_adrof = <0> ;
		Csid_gcheck_remain2 = NULL ;
		Csid_temp3_vstr = NULL ;
	        Csid_parse ^IN(Csid_gcheck_remain)
		    Csid_gcheck_id, Csid_gcheck_adrof( ^ONEOF(
			(^SPACE, /),
			("/", / ),
			("/", ^SPACE, / ),
                        ("/", |Csid_temp3_vstr, "/", |Csid_gcheck_remain2, 
				^SPACE, / ),
                        ("/", |Csid_temp3_vstr, ^SPACE, / ) ) ) ;
		%End
		If (Success_is in Csid_parse_status   )
		    Evaluate Csid_gcheck_adrof
			When 0
			    %Beg  
			    Csid_gcheck_remain = Csid_gcheck_id ;
			    %End

			When 1
			When 2
			    %Beg  
			    Csid_gcheck_adr_id = "/" ;  
			    Csid_gcheck_remain = Csid_gcheck_id ;
			    %End

			When 3
			    If (Csid_temp3_vstr_length > 0 )
				AND (Csid_temp3_vstr_length < 6 )
		    	    THEN
%^ This case drops the address id.  The implicit "ELSE" case retains it.
				%Beg
				Csid_compose ^OUT(Csid_gcheck_adr_id)
				    "/", Csid_temp3_vstr, / ;
				Csid_compose ^OUT(Csid_gcheck_remain)
				    Csid_gcheck_id, "/", 
							Csid_gcheck_remain2, / ;
				%End
			    END-IF

			When 4
			    If (Csid_temp3_vstr_length > 0 )
				AND (Csid_temp3_vstr_length < 6 )
		    	    THEN
				%Beg
				Csid_compose ^OUT(Csid_gcheck_adr_id)
				    "/", Csid_temp3_vstr, / ;
				Csid_gcheck_remain = Csid_gcheck_id ;
				%End
			    END-IF
                   END-EVALUATE
		END-IF
	    END-IF

            If (Csid_gcheck_remain_length NOT = 0 )
		%Beg
		Csid_gcheck_remain2 = NULL ;

%^ NOTE: ONEOF's below must match states for defined oneof Csid_gcheck_states
	        Csid_parse ^IN(Csid_gcheck_remain)
		    Csid_gcheck_id, Csid_gcheck_twoof( ^ONEOF(
			(^SPACE, /),                             %^GCHT_NONE
            		("///",|Csid_gcheck_remain2, ^SPACE, /), %^GCHT_DDA
            		("///",|Csid_gcheck_remain2, ^SPACE, /), %^GCHT_SAV
            		("///",|Csid_gcheck_remain2, ^SPACE, /), %^GCHT_GL
            		("///",|Csid_gcheck_remain2, ^SPACE, /), %^GCHT_NOSTR
            		("/AC",|Csid_gcheck_remain2, ^SPACE, /), %^GCHT_AC
            		("/BC",|Csid_gcheck_remain2, ^SPACE, /), %^GCHT_SWF
            		("/CH",|Csid_gcheck_remain2, ^SPACE, /), %^GCHT_CHUSER
            		("/FW",|Csid_gcheck_remain2, ^SPACE, /), %^GCHT_FED
            		("/CP",|Csid_gcheck_remain2, ^SPACE, /), %^GCHT_CHIPS
            		("///",|Csid_gcheck_remain2, ^SPACE, /), %^GCHT_CLEAR
            		("/??",|Csid_gcheck_remain2, ^SPACE, /), %^GCHT_GARBAGE
			("/",                                    %^GCHT_EXTEND
			  |Csid_party_extype2 (^STRING<2>(<CHAR$M_ALPHA>)),
					       |Csid_gcheck_remain2, ^SPACE, /),
            		(/) ));
	    	%End

            END-IF
	    If (Failure_is in Csid_parse_status  )
%^ Note: this checks the earlier parse if Csid_gcheck_remain was reset to NULL
		Set Success_is in Csid_had_garbage to true
%^  Didn't parse it properly in the first place, so just stick it back.
		If (Csid_gcheck_processed_length = 0 )
		    %Beg  Csid_gcheck_processed = Csid_gcheck_remain ;  %End
		ELSE
		    %Beg
		    Csid_temp1_vstr = Csid_gcheck_processed ;
		    Csid_compose ^OUT(Csid_gcheck_processed)
			Csid_temp1_vstr, Csid_gcheck_remain, / ;
		    %End
		END-IF
	    ELSE
		If (Csid_gcheck_twoof = 0 )
		    %Beg  Csid_party_intro2 = NULL;  %End
		ELSE
%^ Save the slash and 2 following characters
	            Add 1 to Csid_gcheck_id_length giving Csid_temp_long 
		    Move Csid_gcheck_remain(Csid_temp_long:3) 
							   to Csid_party_intro2
		    Move 3 to Csid_party_intro2_length
		END-IF
		If (Success_is in Csid_gcheck_actodd   )
		    If (GCHT_AC in Csid_gcheck_states )
			Set GCHT_DDA in Csid_gcheck_states to TRUE
		    END-IF
		END-IF

		EVALUATE TRUE 
		    When GCHT_DDA in Csid_gcheck_states
			%^ It's an on-us DDA account
			If csid_struct_acct_ws = "Y"
			Then
				%^ Always treat as a " " id and flow thru
				%^ IBAN logic
				%^ Move csid_party_idtype to Csid_temp_idtype
				%^ Need to allow for a D account on-us check, just not the first pass
				%^ cdt_iban means we have been here before,
				If (cdt_iban of flgs3 of Ent_credit_set = "T" or
				    Success_is in Csid_second_cdt_pass_ws) And
				   csid_party_idtype = "D" 
				Then
					Move csid_party_idtype  To Csid_acc_idtype_ws %^ Check for ON-US inserted first
					Perform X950_CHECK_ACCOUNT through
						X950_CHECK_ACCOUNT_END
					If Success_is in Csid_had_garbage
					Then
						Set Failure_is in Csid_had_garbage to True	%^ Reset
						Move " " to csid_party_idtype
						Perform X970_CHECK_FOR_IBAN thru
							X970_CHECK_FOR_IBAN_END
				 		If (Not(Success_is in Csid_val_iban_ret) And
					     	     Csid_valid_Iban_flg_ws = "N" or "S") Or %^ Reset to D only on Fail
					    	   (Lock_cdt_party_ls = 1) Then
							%^ reset to allow for Autotreive call
							Move "D" to csid_party_idtype
						end-if
					end-if
				Else
					Move csid_party_idtype  To Csid_acc_idtype_ws 	%^ Check for ON-US inserted  first
					Perform X950_CHECK_ACCOUNT through
						X950_CHECK_ACCOUNT_END
					If Failure_is in csid_had_garbage Then
						%^ Country of party is US, no matter what else is there
						%beg csid_iban_cntry_ws = Menu_bnk_union.country_code; %end
					end-if
					%^ Normal Path
					Set Failure_is in Csid_had_garbage to True	%^ Reset
					Move " " to csid_party_idtype
					Perform X970_CHECK_FOR_IBAN thru
						X970_CHECK_FOR_IBAN_END
			 		If (Success_is in Csid_val_iban_ret And
				     	     Csid_valid_Iban_flg_ws = "N" or "S") Or %^ Reset to D only on Fail
				    	   (Lock_cdt_party_ls = 1) Then
						%^ reset to allow for Autotreive call
						Move "D" to csid_party_idtype
					end-if
				end-if
			Else
				Move "D" To Csid_acc_idtype_ws
				Perform X950_CHECK_ACCOUNT through
					X950_CHECK_ACCOUNT_END
				If Failure_is in Csid_had_garbage
                           		Set Success_is in Csid_bad_dda to true
				end-if
			END-IF

		    When GCHT_SAV in Csid_gcheck_states
			Move "V" To Csid_acc_idtype_ws
			Perform X950_CHECK_ACCOUNT through
							X950_CHECK_ACCOUNT_END

		    When GCHT_GL in Csid_gcheck_states
			Move "G" To Csid_acc_idtype_ws
			Perform X950_CHECK_ACCOUNT through
							X950_CHECK_ACCOUNT_END

		    When GCHT_NOSTRO in Csid_gcheck_states
			Move "F" To Csid_acc_idtype_ws
			Perform X950_CHECK_ACCOUNT through
							X950_CHECK_ACCOUNT_END

		    When GCHT_SWF in Csid_gcheck_states
%^ It's a SWIFT 2-character id-subtype
			CALL "VALIDATE_SWIFT" USING
			    By reference Csid_gcheck_id
                            By reference Csid_gcheck_id_length
			  RETURNING Csid_ret2_stat
			If Failure_is in Csid_ret2_stat  
			    Set Success_is in Csid_had_garbage to true
			END-IF

		    When GCHT_CHUSER in Csid_gcheck_states
%^ It's a CHIPS UID
			If (Csid_gcheck_id_length = 6 )
                            CALL "VALIDATE_UID" USING
                                By reference Csid_gcheck_id
                              RETURNING Csid_ret2_stat
                            If (Failure_is in Csid_ret2_stat  )
                                Set Success_is in Csid_had_garbage to true
                            END-IF
			ELSE
                            Set Success_is in Csid_had_garbage to true
			END-IF

		    When GCHT_FED in Csid_gcheck_states
%^ It's a FEDWIRE ABA
			If (Csid_gcheck_id_length = 9 )
			    CALL "VALIDATE_ABA" USING
			        By reference Csid_gcheck_id
			      RETURNING Csid_ret2_stat
			    If (Failure_is in Csid_ret2_stat  )
			        Set Success_is in Csid_had_garbage to true
			    END-IF
			ELSE
			    Set Success_is in Csid_had_garbage to true
		        END-IF


%^		    When GCHT_CHIPS in Csid_gcheck_states
%^ It's a CHIPS participant number in a non-U.S. environment
%^			If (Csid_gcheck_id_length NOT = 4)
%^			   OR (Csid_gcheck_id(1:Csid_gcheck_id_length) 
%^								Is Not Numeric)
%^			THEN
%^			    Set Success_is in Csid_had_garbage to true
%^			END-IF

		    When GCHT_CHIPS in Csid_gcheck_states   %^ CUST_P_CHECK_DIGIT now supports CHIPS 80943
		    When GCHT_CLEAR in Csid_gcheck_states
%^ Its a non-CHIPS "P" idtype
			CALL "CUST_P_CHECK_DIGIT" USING
			    BY REFERENCE Bnk_id of Menu_bnk_union
			    BY REFERENCE Csid_gcheck_id
			    BY REFERENCE Csid_gcheck_id_length
			    BY REFERENCE Csid_check_stat
			  RETURNING Csid_ret2_stat
			If Failure_is in Csid_check_stat   Then
			    Set Success_is in Csid_had_garbage to true
		        END-IF

                    When GCHT_GARBAGE in Csid_gcheck_states
%^ Throw away the introducer and flag as garbage
			%Beg  Csid_party_intro = NULL;  %End
 			Set Success_is in Csid_had_garbage to true

 		    When GCHT_EXTEND in Csid_gcheck_states
			CALL "CUST_XTEND_ID_EDIT" using
			    BY REFERENCE Csid_party_extype
			    BY REFERENCE Csid_gcheck_id
			    BY REFERENCE Csid_gcheck_id_length
			    BY REFERENCE Csid_temp1_vstr
			    By REFERENCE Csid_temp1_vstr_length
			    By REFERENCE Csid_delay_change
			    BY REFERENCE Csid_got_advice
			    By Reference Csid_extnd_country
			    BY REFERENCE Csid_error_memo
			    BY REFERENCE Csid_error_memo_length
			    By REFERENCE Csid_error_code
			    By REFERENCE Csid_error_code_length
			    BY REFERENCE Csid_check_stat
			    BY REFERENCE Csid_not_garbage
			  RETURNING Csid_ret2_stat
			If (Failure_is in Csid_not_garbage)
			    If (Success_is in Csid_ret2_stat)
			       AND (Success_is in Csid_check_stat)
			    THEN
				Set Success_is in Csid_had_garbage to TRUE
			    END-IF
			END-IF
			If (Failure_is in Csid_check_stat)
			   OR (Failure_is in Csid_ret2_stat )
			THEN
			    Set Success_is in Csid_had_garbage to TRUE
			END-IF			    
			If (Failure_is in Csid_had_garbage)
			   AND (Csid_temp1_vstr_length NOT = 0 )
			   AND (Failure_is in Csid_delay_change)
			THEN
			    %Beg  Csid_gcheck_id = Csid_temp1_vstr;  %End
			END-IF
	
		END-EVALUATE
%^ Now reconstruct the part of the input ID that we just processed.
%^ Now concatenate any address id back on.
	 	If (Csid_gcheck_adr_id_length NOT = 0 )
		    %Beg
		    Csid_gcheck_dda_id = Csid_gcheck_id ;
		    Csid_compose ^OUT(Csid_gcheck_id)
			Csid_gcheck_dda_id, Csid_gcheck_adr_id, / ;
		    %End
		END-IF
		If (Success_is in Csid_had_garbage  )
		    If (Csid_gcheck_processed_length = 0 )
		        %Beg
		        Csid_compose ^OUT(Csid_gcheck_processed)
			    Csid_party_intro, Csid_gcheck_id, 
			    Csid_party_intro2, Csid_gcheck_remain2, / ;
		        %End
		    ELSE
		        %Beg
		        Csid_temp1_vstr = Csid_gcheck_processed ;
		        Csid_gcheck_processed = NULL ;
		        Csid_compose ^OUT(Csid_gcheck_processed)
			    Csid_temp1_vstr, Csid_party_intro, 
			    Csid_gcheck_id, Csid_party_intro2,
			    Csid_gcheck_remain2, / ;
		        %End
		    END-IF
		ELSE
		    If (Csid_gcheck_processed_length = 0 )
		        %Beg
		        Csid_compose ^OUT(Csid_gcheck_processed)
			    Csid_party_intro, Csid_gcheck_id, / ;
		        %End
		    ELSE
		        %Beg
		        Csid_temp1_vstr = Csid_gcheck_processed ;
		        Csid_gcheck_processed = NULL ;
		        Csid_compose ^OUT(Csid_gcheck_processed)
			    Csid_temp1_vstr, Csid_party_intro, 
							    Csid_gcheck_id, / ;
		        %End
		    END-IF
		END-IF
	    END-IF
	END-PERFORM.

	If (Success_is in Csid_had_garbage   )
%^ Make sure that we haven't left a "/??" embedded in the id string
	    %Beg
	    Csid_temp1_vstr = NULL ;
	    Csid_parse ^IN(Csid_gcheck_processed)
		^OPTION(Csid_temp1_vstr), "/??", Csid_temp2_vstr, / ;
	    %End
	    Perform UNTIL (Failure_is in Csid_parse_status   )
		%Beg
		Csid_compose ^OUT(Csid_gcheck_processed)
			Csid_temp1_vstr, Csid_temp2_vstr, / ;
	        Csid_parse ^IN(Csid_gcheck_processed)
		        Csid_temp1_vstr, "/??", Csid_temp2_vstr, / ;
		%End
	    END-PERFORM
	END-IF.
	%Beg  Csid_party_id = Csid_gcheck_processed;  %End.

	If csid_gcheck_remain2_length = 0 And
	   (csid_party_intro2 = "/RT" or "/FW")
	Then
		%^ We have a code with no ID, only valid for a clearing codes RT or FW
		%^ we need to pass this along.
		%beg
		Csid_compose ^out(csid_party_id) Csid_gcheck_processed,csid_party_intro2,/;
		%end
	End-if.


X940_TAKEOUT_GARBAGE_END.  


   EXIT.
X950_CHECK_ACCOUNT.
%^ Common code to call check digit for an account.
%^ Csid_acc_idtype_ws contains the account IDTYPE.
%^ Looked-up (and possibly modified) account id is returned in Csid_gcheck_id.
%^ Csid_had_garbage is returned SUCCESS if checkdigit edit fails.
	%Beg Csid_gcheck_dda_id = Csid_gcheck_id; %End.
%^ Do the check-digit edit, possibly changing an old style DDA to new
	CALL "CHKDGT_EDIT" USING
	    by reference Csid_acc_idtype_ws
            by reference Csid_gcheck_id
            by reference Csid_gcheck_id_length
	    by reference Csid_gcheck_bank_id
	    by reference Csid_multibank_ws
	    by reference Csid_temp1_vstr
	  RETURNING Csid_ret2_stat
	If Failure_is in Csid_ret2_stat  
	   Set Success_is in Csid_had_garbage to true
	END-IF.
X950_CHECK_ACCOUNT_END.

   EXIT.
X960_SHUFFLE_IDS.

%^ This paragraph shuffles the multiple id string in Csid_id_ws and moves
%^ a space into Csid_idtype_ws.  We have an /AC foreign account id as a
%^ second (or third or ...) id.  It will be shuffled into the first
%^ position and whatever we have instead will move down.
	%Beg
	Csid_parse ^IN(Csid_party_id)
		Csid_shuffle_alt, "/(", Csid_shuffle_parens, / ;
	%End.
	If (Failure_is in Csid_parse_status   )
	    %Beg  
	    Csid_shuffle_parens = NULL ;  
	    Csid_shuffle_alt = Csid_party_id ;
	    %End
	END-IF.

	Move SPACE to Csid_shuffle_idt
	%Beg
	Csid_shuffle_part1 = NULL ;
	Csid_shuffle_part2 = NULL ;
	Csid_shuffle_acct = NULL ;
	Csid_shuffle_oneof = <0> ;
	Csid_parse ^IN(Csid_shuffle_alt)
		Csid_shuffle_part1, "/AC", Csid_shuffle_acct, 
		Csid_shuffle_oneof ( ^ONEOF (	
            		  ("///",|Csid_shuffle_part2, ^SPACE, /),
            		  ("///",|Csid_shuffle_part2, ^SPACE, /),
            		  ("/BC",|Csid_shuffle_part2, ^SPACE, /),
            		  ("/CH",|Csid_shuffle_part2, ^SPACE, /),
            		  ("/FW",|Csid_shuffle_part2, ^SPACE, /),
            		  ("/CP",|Csid_shuffle_part2, ^SPACE, /),
            		  ("/??",|Csid_shuffle_part2, ^SPACE, /),
            		  (/)));

        %End.
	If (Failure_is in Csid_parse_status  )
%^ Try for an account instead
	    Move "C" to Csid_shuffle_idt
	    %Beg
	    Csid_shuffle_part1 = NULL ;
	    Csid_shuffle_part2 = NULL ;
	    Csid_shuffle_acct = NULL ;
	    Csid_shuffle_oneof = <0> ;
	    Csid_parse ^IN(Csid_shuffle_alt)
		Csid_shuffle_part1, "/CH", Csid_shuffle_acct, 
		Csid_shuffle_oneof ( ^ONEOF (	
            		  ("///",|Csid_shuffle_part2, ^SPACE, /),
            		  ("/AC",|Csid_shuffle_part2, ^SPACE, /),
            		  ("/BC",|Csid_shuffle_part2, ^SPACE, /),
            		  ("///",|Csid_shuffle_part2, ^SPACE, /),
            		  ("/FW",|Csid_shuffle_part2, ^SPACE, /),
            		  ("/CP",|Csid_shuffle_part2, ^SPACE, /),
            		  ("/??",|Csid_shuffle_part2, ^SPACE, /),
            		  (/)));

            %End
	    If (Failure_is in Csid_parse_status  )
%^  This is, after all, just cleanup.
	        GO TO X960_SHUFFLE_IDS_END
	    END-IF
	END-IF.
	EVALUATE TRUE
	    WHEN Csid_party_idtype = SPACE OR "D"
%^ Leave it alone
	        GO TO X960_SHUFFLE_IDS_END

	    WHEN Csid_party_idtype = "S"
		Move "BC" to Csid_shuffle_type

	    WHEN Csid_party_idtype = "C"
		Move "CH" to Csid_shuffle_type

	    WHEN Csid_party_idtype = "A"
		Move "FW" to Csid_shuffle_type


	    WHEN Csid_party_idtype = "P"
%^ NOTE: if the ID is in P-form, it must already have any necessary suffix.
%^ Since this is a lower creditside party, we're just trying to get its
%^ extended Id form
		CALL "GET_XIDTYPE_FROM_SUFFIX" Using
		    By content "   "
		    By reference Csid_id_ws
		    By Reference Csid_id_ws_length
		    By Reference Csid_shuffle_type
		  Returning Csid_itsa_clearhouse

	    WHEN OTHER
		GO TO X960_SHUFFLE_IDS_END
	END-EVALUATE.

	If (Csid_shuffle_parens_length = 0 )
	    %Beg
	    Csid_compose ^OUT(Csid_party_id)
		Csid_shuffle_acct, "/", Csid_shuffle_type, Csid_shuffle_part1,
		Csid_shuffle_oneof ( ^ONEOF ( (""),	
					      ("/AC"),
            		  		      ("/BC"),
            		  		      ("/CH"),
            		  		      ("/FW"),
            		  		      ("/CP"),
            		  		      ("/??"),
					      ("") ) ),

		Csid_shuffle_part2, / ;
	    %End
	ELSE
	    %Beg
	    Csid_compose ^OUT(Csid_party_id)
		Csid_shuffle_acct, "/", Csid_shuffle_type, Csid_shuffle_part1,
		Csid_shuffle_oneof ( ^ONEOF ( (""),	
					      ("/AC"),
            		  		      ("/BC"),
            		  		      ("/CH"),
            		  		      ("/FW"),
            		  		      ("/CP"),
            		  		      ("/??"),
					      ("") ) ),
		Csid_shuffle_part2, "/(", Csid_shuffle_parens, / ;
	    %End	
	END-IF.
	Move Csid_shuffle_idt to Csid_party_idtype.

X960_SHUFFLE_IDS_END.
	EXIT.

X970_CHECK_FOR_IBAN.
	%^
	%beg csid_temp_party_id = csid_party_id; %end
	%^
	Set Failure_is in Csid_iban_found to True
	Call "VALIDATE_IBAN" Using
		by Reference csid_temp_party_id
		by Reference csid_temp_party_id_length
		by Reference csid_iban_cntry_ws
		by Reference csid_iban_bnk_ws
		by Reference csid_iban_bnk_ws_length
		by Reference csid_iban_brnch_ws
		by Reference csid_iban_brnch_ws_length
		by Reference csid_iban_curr_ws
		By Reference csid_bnk_code_rec_ws
		By Reference csid_bnk_code_rec_ws_lengths
		By Reference csid_valid_iban_flg_ws
	returning Csid_val_iban_ret
	%^
	%^ Since we con;t care what party we are here for, We will set same flags
	%^ and let our caller determine the IBAN's fate This should only be present
	%^ for Credit or BNP. ID is customer accounts, not banks(right??)
	%^
	Evaluate True 	%^ 	Csid_val_iban_ret
		When  Failure_blocking_is in Csid_val_iban_ret
			%^Or      Failure_warning_is  in Csid_val_iban_ret
			%^ Fail       - possible Invalid Account
			%^ TODO -  Need to add new message indicating bad IBAN/BBAN
			%^
			Set Success_is in Csid_had_garbage to True
			
			Evaluate Csid_valid_iban_flg_ws
					When "I"	%^ Bad IBAN
						%beg csid_msg_mnemonic_ws = "LKUP$_IBAN_FAILURE_B"; %end
					When "N"	%^ Bad BBAN
						%beg csid_msg_mnemonic_ws = "LKUP$_BBAN_FAILURE_B"; %end
					When "R"	%^ Iban Required
						%beg csid_msg_mnemonic_ws = "IVAL$_IBAN_REQ_B"; %end
					When other
						%beg csid_msg_mnemonic_ws = "LKUP$_BBAN_FAILURE_B"; %end
			end-evaluate

			Call "FORMAT_MSG_TO_TEXT" Using	
					By Reference csid_msg_mnemonic_ws
					By Reference csid_msg_mnemonic_ws_length
					by Value %siz(Csid_err_memo)
					by Reference Csid_err_memo
					By Reference Csid_err_memo_length
			%^
		        Perform X900_error_memo THRU 
	           		X900_error_memo_end
			%^
			If Success_is in csid_bban_cntry_req_ws And	%^ 109636
			   csid_iban_cntry_ws = Spaces	And %^ ensure not an IBAN
			   bnp_mailing_country of Ent_credit_set = Spaces
			Then
				%beg csid_msg_mnemonic_ws = "LKUP$_COUNTRY_REQ"; %end
				Call "FORMAT_MSG_TO_TEXT" Using	
						By Reference csid_msg_mnemonic_ws
						By Reference csid_msg_mnemonic_ws_length
						by Value %siz(Csid_err_memo)
						by Reference Csid_err_memo
						By Reference Csid_err_memo_length

				Perform X900_error_memo THRU 
		           		X900_error_memo_end
			end-if
			%^
			Set Success_is in Csid_had_garbage to True
			%^
		When	Failure_warning_is in Csid_val_iban_ret
			%^ 117335 - Need to see if we have been thru via ENT
			%^ or RPR/EXC functions. If so, this is a retry and we can
			%^ skip
			%^
			Perform X1200_CHECK_SOURCES thru X1200_CHECK_SOURCES_END
			%^
			If Failure_is in Csid_already_warned_ws
			Then
				%^
				Evaluate Csid_valid_iban_flg_ws
					When "I"	%^ Bad IBAN
						%beg csid_msg_mnemonic_ws = "LKUP$_IBAN_FAILURE_W"; %end
					When "N"	%^ Bad BBAN
						%beg csid_msg_mnemonic_ws = "LKUP$_BBAN_FAILURE_W"; %end
					When "R"	%^ Iban Required
						%beg csid_msg_mnemonic_ws = "IVAL$_IBAN_REQ_W"; %end
					When Other
						%beg csid_msg_mnemonic_ws = "LKUP$_BBAN_FAILURE_W"; %end
				end-evaluate			

				Call "FORMAT_MSG_TO_TEXT" Using	
						By Reference csid_msg_mnemonic_ws
						By Reference csid_msg_mnemonic_ws_length
						by Value %siz(Csid_err_memo)
						by Reference Csid_err_memo
						By Reference Csid_err_memo_length
				%^
			        Perform X900_error_memo THRU 
		           		X900_error_memo_end
				%^
				If Success_is in csid_bban_cntry_req_ws And	%^ 109636
				   csid_iban_cntry_ws = Spaces	And %^ ensure not an IBAN
				   bnp_mailing_country of Ent_credit_set = Spaces
				Then
					%beg csid_msg_mnemonic_ws = "LKUP$_COUNTRY_REQ"; %end
					Call "FORMAT_MSG_TO_TEXT" Using	
							By Reference csid_msg_mnemonic_ws
							By Reference csid_msg_mnemonic_ws_length
							by Value %siz(Csid_err_memo)
							by Reference Csid_err_memo
							By Reference Csid_err_memo_length		

					Perform X900_error_memo THRU 
			           		X900_error_memo_end
				end-if
				%^
				Set Success_is in Csid_had_garbage to True
				%^
			End-if
			%^ 
		When 	Success_is in Csid_val_iban_ret
			%^ Pass       - Valid IBAN/BBAN
			%^ Now we must perform IBAN specific Insertion/pushup checking
			%^ save for parameter addtion later
			%beg	Csid_parse ^in(csid_party_id) csid_orig_iban_ws,"/",^str,/; %end
			If Failure_is in Csid_parse_status
			Then
				%beg csid_orig_iban_ws = csid_party_id; %end
			end-if
			Set Success_is in csid_iban_found to True
			%beg ent_credit_set.flgs3.cdt_iban = "T"; %end
			If csid_bnk_code_rec_ws NOT = Spaces Then
			    %^ Most likely an On-us non bank code DDA
			    %^ keave as DDA for Autotreive to figure out
			    move "*" to csid_ovr
			    Move spaces to csid_party_idtype  %^ clear the IBAN for push
			  %^Else
				%^   If( Csid_valid_iban_flg_ws  = "N") Then	%^ bad BBAN
				%^    Set to "D" and let Autotreive take a shot
				%^    Move "D" to csid_party_idtype
				%^   end-if
			end-if
			Set Failure_is in Csid_had_garbage to True  %^ clear error if present
			%^
		When Failure_ignore_is in csid_val_iban_ret  %^ Fail/Pass  - Not on us lower party data
			%^ Can't figure out number, let it pass
			%Beg
	  			Csid_compose ^OUT(Csid_temp1_vstr)
					Csid_gcheck_processed, Csid_gcheck_remain2, / ;
    				Csid_gcheck_processed = Csid_temp1_vstr ;
    			%End
			If Success_is in csid_bban_cntry_req_ws And %^ 109636
			   Csid_valid_iban_flg_ws = "N" And
			   bnp_mailing_country of Ent_credit_set = Spaces
			Then
				%beg csid_msg_mnemonic_ws = "LKUP$_COUNTRY_REQ"; %end
				Call "FORMAT_MSG_TO_TEXT" Using	
						By Reference csid_msg_mnemonic_ws
						By Reference csid_msg_mnemonic_ws_length
						by Value %siz(Csid_err_memo)
						by Reference Csid_err_memo
						By Reference Csid_err_memo_length

				Perform X900_error_memo THRU 
		           		X900_error_memo_end
			end-if
			%^ Just add an informational message:
			Evaluate Csid_valid_iban_flg_ws
				When "I"	%^ Bad IBAN
					%beg csid_msg_mnemonic_ws = "LKUP$_IBAN_FAILURE_I"; %end
				When "N"	%^ Bad BBAN
					%beg csid_msg_mnemonic_ws = "LKUP$_BBAN_FAILURE_I"; %end
				When "R"	%^ Iban Required
					%beg csid_msg_mnemonic_ws = "IVAL$_IBAN_REQ_I"; %end
			end-evaluate
			If Csid_valid_iban_flg_ws Not = "S"
			Then
				Call "FORMAT_MSG_TO_TEXT" Using	
						By Reference csid_msg_mnemonic_ws
						By Reference csid_msg_mnemonic_ws_length
						by Value %siz(Csid_info_memo)
						by Reference Csid_info_memo
						By Reference Csid_info_memo_length	

				Perform X920_info_memo THRU 
		           		X920_info_memo_end
				Subtract 1 from csid_info_count %^ discount, do not trigger error flag 117876
			End-if
	End-evaluate.


X970_CHECK_FOR_IBAN_END.
	EXIT.

X980_CHANGE_CREDIT.
	%^
	%ACE_IS Relget_adr_set connected giving Csid_conn_stat;
	%^
	%Beg
	BREAK: Prulepty_rule_seq(NOMOD);
	BREAK: Prulepty_party_adr_set(NOMOD);
	%End
	If Success_is in Csid_conn_stat Then
		%beg Prulepty_source rel_is;
		     Prulepty_party_adr_ok Success_is;
	     	     Relget_adr_set.adr_proc_rule CONN:
						      Prulepty_rule_seq(NOMOD);
		     Relget_adr_set EQUATE: Prulepty_party_adr_set(NOMOD);
		%end
		If (Rel_id of Relget_adr_set = 0 )
		    %Beg  Prulepty_source aux_is;  %End
		end-if
	Else
		%beg Prulepty_source host_is;
		     Ent_credit_set.Cdt_proc_rule CONN:
						       Prulepty_rule_seq(NOMOD);
		     BREAK: tmp_party_seq;
		     Prulepty_party_adr_ok Failure_is;
		%end
		Initialize Prulepty_party_adr_set
	end-if.

	%beg
	    Csid_id_bank_ws = Ent_credit_set.Cdt_adr_bnk_id;
	    Prulepty_bank_prof_rec = NULL;
	%end
	If (Csid_id_bank_ws = SPACES)
	    %Beg  Csid_id_bank_ws = Ent_ftr_set.Loc_info.Bank;  %End
	end-if

	If (Csid_id_bank_ws = Bnk_id of Menu_bnk_union)
		%beg
		     Prulepty_bank_prof_rec =
					     Menu_bnk_union.Bnk_profile_id_rec;
		%end
	else
		%Beg
		   BREAK: Csid_bnk_union ;
		   SEARCH: Bnk_index 
			   (Key = Csid_id_bank_ws );
		%end
 		If (Success_is in Bnk_index_status)
			%Beg Bnk_index CONN: Csid_bnk_union(NOMOD); %end
		end-if
		%beg
  		   Prulepty_bank_prof_rec = Csid_bnk_union.Bnk_profile_id_rec;
		%End
	end-if.

	Call "PRULE_CHANGE_CREDIT" returning Csid_ret_stat.
	%^If Failure_is in Csid_ret_stat Then
	%^	Display "CHANGE Credit_failed"
	%^End-if.

X980_CHANGE_CREDIT_END.
	EXIT.

X990_IBAN_BBK_INSERT.
%^
%^	Perform the check for insert/overwrite the
%^	BBK party when an IBAN is processed
%^
%^
%^	BBK Insert may be a deceptive name here.. If there is no BBK,
%^	the Credit Party should be considered as the BBK So we need to
%^ 	decide up front who we are working on.
%^
	If (Bbk_id of Ent_credit_set = Spaces and
	    Bbk_name1 of Ent_credit_set = Spaces) OR
	    Csid_bnk_code_rec_ws = Spaces
	Then
		%^ BBK is Empty, Or we have no insertable parties
		%^ Perhaps force thru the Pref_corr logic 
		Go To X990_IBAN_BBK_INSERT_END
	end-if.

	Set Success_is in csid_set_chg_flg_ws to True.


	If Bbk_idtype of Ent_credit_set = "S"	%^ BIC,  A format
	Then
		%^ Parse the id to see if it contains more than a BIC.
	    	%^ If it does, do not perform replacement logic.

	    	%beg 
	    	Csid_Parse ^IN(Ent_credit_set.bbk.bbk_id)
		    Csid_tmp_id_ws, "/", Csid_tmp_id2_ws, /;			
 	    	%end
	    	If Success_is in Csid_parse_status
	    	Then
			%^ Exit without replacing
			Go to X990_IBAN_BBK_INSERT_END
	    	end_if
		If ( Success_is in Csid_swf_dualid_match6) And
		   ( idkey of csid_bnk_code_rec_ws(1:6)  =
		     bbk_id of bbk of Ent_credit_set(1:6)
		   )
		Then
			%^ first 6 match, leave id alone.
			Set Failure_is in csid_lookup_bban to True
			Go to X990_IBAN_BBK_INSERT_END
		End-if
		%^ perform replacement logic

		%beg csid_compose ^out(csid_prm_name) "MTS$REP_BBK_AFORMAT",/;
		     csid_prm_values_remain = <0>;
		%end
		Call "PRULE_MSG_GET_PARAM" Using
			by Reference	csid_prm_name
			by Reference 	csid_prm_name_length
			by Reference 	csid_prm_level
			by Reference 	csid_pr_source
			by reference 	csid_prm_edit_type
			by reference 	csid_prm_values_remain
			by reference 	csid_prm_value
			by reference 	csid_prm_value_length
		returning csid_pr_ret_stat
		If Not(Success_is in Csid_pr_ret_stat) Or
		      (csid_prm_value NOT = "Y")
		Then
			%^ If not present, Exit without replacing
			Set Failure_is in csid_lookup_bban to True
			Go to X990_IBAN_BBK_INSERT_END
		Else
			%beg csid_compose ^out(csid_info_memo)
				"Rule MTS$REP_BBK_AFORMAT -  ",
				Ent_credit_set.bbk.bbk_idtype,"/",
				Ent_credit_set.bbk.bbk_id," Replaced as BBK.",/;
			%end
			%^
			%^ See if we are replacing a VALID BIC. If so, do not set the CHG flags.
			%^
			If bbk_adr_ptr_ok of flgs3 of ent_credit_set = "T" Then
				%^ don't set the flag
				Set Failure_is in csid_set_chg_flg_ws to True
			End-if
		end-if
	Else
		If Not(Bbk_id of Ent_credit_set = Spaces)
			%^ OK we have BBK ID data already  Do NOT replace.
			%^ Send along the FULL IBAN to the next party and let them
			%^ expand upon it.
			Go to X990_IBAN_BBK_INSERT_END
		End-if
		If Bbk_name1 of Ent_credit_set NOT = SPACES Then
			%^ BBK  D format check Flag and Override or Ignore
			%^ Call get_param for REP_BBK_DFORMAT
			%beg csid_compose ^out(csid_prm_name) "MTS$REP_BBK_DFORMAT",/;
	     		     csid_prm_values_remain = <0>;
			%end
			Call "PRULE_MSG_GET_PARAM" Using
				by Reference	csid_prm_name
				by Reference 	csid_prm_name_length
				by Reference 	csid_prm_level
				by Reference 	csid_pr_source
				by reference 	csid_prm_edit_type
				by reference 	csid_prm_values_remain
				by reference 	csid_prm_value
				by reference 	csid_prm_value_length
			returning csid_pr_ret_stat
			If Not(Success_is in Csid_pr_ret_stat) Or
	  		      (csid_prm_value NOT = "Y")
			Then
				%^ If Present then replace party
				%^ If not present, Exit without replacing
				Set Failure_is in csid_lookup_bban to True
				Go to X990_IBAN_BBK_INSERT_END
			Else
				%beg csid_compose ^out(csid_info_memo)
				"Rule MTS$REP_BBK_DFORMAT -  Replaced BBK.",/;
				%end
			end-if
		End-if
	end-if.
	%^
	%^ populate the BBK field with the returned BIC and
	%^ set up for the update
	%^
	%^ We need to be sure that the BIC returned is NOT the
	%^ same as the Current CDT party. We may be here after a push
	%^ from CDT to BNP
	%^
	If (Idkey of csid_bnk_code_rec_ws = Spaces)  Or
	   ((Idkey of csid_bnk_code_rec_ws Not = Spaces) AND	    %^ avoid multiple replacements
	    (Cdt_idtype of Cdt_typ of Ent_credit_set
				= Idtype of csid_bnk_code_rec_ws) And
	    (Cdt_id of Cdt_typ of Ent_credit_set
				= Idkey of csid_bnk_code_rec_ws)) Then
		%^
		%^ IBAN OK, BUT bank_code not found, leave as is
		%^
		Set Failure_is in csid_lookup_bban to True
		%^
	Else
		%^ Note the replacement
		Perform X920_INFO_MEMO Thru X920_INFO_MEMO_END
		Subtract 1 from csid_info_count %^ Do NOT count in error path.
		%^
		%^ Validate IBAN has returned us a bank code
		%^
		%beg
			Ent_credit_set(.bbk
					 (.bbk_id     = csid_bnk_code_rec_ws.idkey,
				 	  .bbk_idtype = csid_bnk_code_rec_ws.idtype),
				       .bbk_res_country = csid_iban_cntry_ws);
		%end

		If Success_is in  csid_set_chg_flg_ws
		Then		%^ 116909
		    %beg
			Ent_ftr_set.change_fields(.CHG_BBK = "R",
						  .CHG_BIC = "R");	%^ 107268
		    %end
		End-if

		If  csid_iban_curr_ws not = Spaces Then
			%beg Ent_credit_set.cdt_currency = csid_iban_curr_ws; %end
		end-if
		%^ Add the BBK with the returned info
		PERFORM B220_BBK THRU B220_BBK_END
		%^ Secondary wire code to inserted party Copied from inline post-b220_bbk code
	    	If Relget_reject_flag = "M"
		    Go to X990_IBAN_BBK_INSERT_END
	    	End-if
    	        If Csid_next_function not = Menu_next_function
			%^ Blast out of here, 
	        	Go to X990_IBAN_BBK_INSERT_END
		end-if
		%^ If the secondary wire flag has a chance of being defaulted
		%^   to "Y", then look up the BBK address.
		If date_time of Cdt_value_date of Ent_credit_set NOT = 0 Then
			%beg tmp_value_date_ws =
			   	Ent_credit_set.cdt_value_date.date_time;
			%end
		else
			%beg tmp_value_date_ws = Null; %end
		end-if
                If (Def_secwir_if_pre_spl of Menu_cfg = "Y")
		    and (Bbk_rel_id of Ent_credit_set = 0)
       	            and (Dbt_ps_elig_flg of Ent_debit_set = "P" or "S")
       	            and (tmp_value_date_ws > Menu_date_ws)
       	            and (Bbk_idtype of Ent_credit_set not = "S")
       	            and ((Bbk_id of ent_credit_set not = spaces) or
                         (Bbk_name1 of ent_credit_set not = spaces))
                    and (Bbk_secwir of ent_credit_set = SPACE)
                    and (Ib1_secwir of ent_credit_set not = "Y")
                    and (Ibk_secwir of ent_credit_set not = "Y")
                    	Perform C650_LOOKUP_BBK_ADDRESS thru
                       	        C650_LOOKUP_BBK_ADDRESS_end
                end-if
		%beg
			%^ We are leaving the BNP ID INTACT, Reset it	
			Csid_party_id = Ent_credit_set.bnp.bnp_id ; 
			Csid_party_idtype = Ent_credit_set.Bnp.Bnp_idtype ;
			%^ Dump the bbk info in relget_adr_set
			BREAK: Relget_adr_set;
		%end
		Initialize relget_adr_set
	end-if.


X990_IBAN_BBK_INSERT_END.
	EXIT.


X1000_CHECK_IBAN_BNP.
%^
%^ See if the BNP is a valid iban. If so, we should replace the Credit party
%^ if the proper Prule flags are set.
%^
%^
%^
%^ I think we may need to do a lookahead to see if we could be replacing
%^ the CDT party, if no BBK is present Let's check and see ONLY when 
%^ structured accounts are being enforced
	If Not((BBK_id of Ent_credit_set = Spaces) and
	       (BBK_name1 of Ent_credit_set = Spaces) ) OR
	      Not ( Lock_cdt_party_ls = 0 )  			%^ Don't mess with locked party
	Then
		%^ No check required.
		Go to X1000_CHECK_IBAN_BNP_END
	End-if
	%^
	Initialize Csid_res_country_ws
	%^ Check the Credit Party
	If Cdt_idtype of Cdt_typ of Ent_credit_set = "S" Then
	    If  Cdt_id of Cdt_typ of Ent_credit_set(4:1) = ":"
	    Then    %^ Skip over the bank
		Move Cdt_id of Cdt_typ of Ent_credit_set(9:2) to Csid_res_country_ws 
	    Else
	    	Move Cdt_id of Cdt_typ of Ent_credit_set(5:2) to Csid_res_country_ws 
	    End-if
	Else
	    If (Cdt_adr_ptr_ok of flgs3 of ent_credit_set = "T")
	    Then
		%beg break: csid_tmp_adr_set;
   			     Ent_credit_set.Cdt_adr_set_ptr CONN: csid_tmp_adr_set;
     			     break: csid_tmp_adr_set;
		%end
		If (Swift_id of csid_tmp_adr_set Not = Spaces)
		Then
		    Move Swift_id of  csid_tmp_adr_set(5:2) to Csid_res_country_ws
		end-if
	    Else
		If Cdt_idtype of cdt_typ of Ent_credit_set = "E"
		Then
			%beg
				Csid_parse ^in(ent_credit_set.cdt_typ.cdt_id)
					Csid_party_extype (^STRING<2>),
					csid_gcheck_id,/;
			%end
			CALL "CUST_XTEND_ID_EDIT" using
				BY REFERENCE Csid_party_extype
   				BY REFERENCE Csid_gcheck_id
   	     			BY REFERENCE Csid_gcheck_id_length
    				BY REFERENCE Csid_temp1_vstr
    				By REFERENCE Csid_temp1_vstr_length
    				By REFERENCE Csid_delay_change
    				BY REFERENCE Csid_got_advice
    				By Reference Csid_extnd_country
    				BY REFERENCE Csid_error_memo
    				BY REFERENCE Csid_error_memo_length
    				By REFERENCE Csid_error_code
    				By REFERENCE Csid_error_code_length
    				BY REFERENCE Csid_check_stat
    				BY REFERENCE Csid_not_garbage
  			RETURNING Csid_ret2_stat
			If Success_is in Csid_ret2_stat And
			   Csid_extnd_country NOT = Spaces
			Then
				%beg csid_res_country_ws = csid_extnd_country; %end
			end-if
			%^ get country for Extended IDs table
		end-if
	    end-if
	end-if

	Move Spaces to Csid_iban_cntry_ws
	If Csid_res_country_WS NOT = Spaces
	Then
     		    %Beg Csid_iban_cntry_ws = Csid_res_country_ws; %End
	Else
		If Bnp_mailing_country of Ent_credit_set NOT = Spaces
		Then
			%Beg Csid_iban_cntry_ws = Ent_credit_set.bnp_mailing_country; %End
		Else
			%^ No country provided, try for On-Us
	   		%Beg
			    Csid_iban_cntry_ws = Menu_bnk_union.Country_code;
	   		%End
		end-if
	end-if.

	%beg csid_temp_party_id = Ent_credit_set.bnp.bnp_id; %end

	Set Failure_is in Csid_iban_found to True
	Call "VALIDATE_IBAN" Using
		by Reference csid_temp_party_id
		by Reference csid_temp_party_id_length
		by Reference csid_iban_cntry_ws
		by Reference csid_iban_bnk_ws
		by Reference csid_iban_bnk_ws_length
		by Reference csid_iban_brnch_ws
		by Reference csid_iban_brnch_ws_length
		by Reference csid_iban_curr_ws
		By Reference csid_bnk_code_rec_ws
		By Reference csid_bnk_code_rec_ws_lengths
		By Reference csid_valid_iban_flg_ws
	returning Csid_val_iban_ret
	%^
	If Success_is in Csid_val_iban_ret AND
	   csid_bnk_code_rec_ws NOT = SPACES
	Then
		%^ Success represents a completly valid IBAN/BBAN, withbank codes
		%^ If rules are set, replace the CDT party with it.
		If Cdt_idtype of Ent_credit_set = "S"
		Then
			%^ Do not replace if there is a second id.
			If (Second_cdt_id_ls > SPACES) OR
		           (Idkey of csid_bnk_code_rec_ws  =
		  	      cdt_id of cdt_typ of Ent_credit_set)
			Then 
			    %^ Exit without replacing
			    Go to X1000_CHECK_IBAN_BNP_END
		    	end-if
			If ( Success_is in Csid_swf_dualid_match6) And
			   ( idkey of csid_bnk_code_rec_ws(1:6)  =
		  	     cdt_id of cdt_typ of Ent_credit_set(1:6)
			   )
			Then
			    %^ first 6 match, leave id alone.
			    Go to X1000_CHECK_IBAN_BNP_END
			End-if
		    	%^ perform replacement logic

			%beg csid_compose ^out(csid_prm_name) "MTS$REP_BBK_AFORMAT",/;
			     csid_prm_values_remain = <0>;
			%end
			Call "PRULE_MSG_GET_PARAM" Using
				by Reference	csid_prm_name
				by Reference 	csid_prm_name_length
				by Reference 	csid_prm_level
				by Reference 	csid_pr_source
				by reference 	csid_prm_edit_type
				by reference 	csid_prm_values_remain
				by reference 	csid_prm_value
				by reference 	csid_prm_value_length
			returning csid_pr_ret_stat
			If Not(Success_is in Csid_pr_ret_stat) Or
			      (csid_prm_value NOT = "Y")
			Then
				Go to X1000_CHECK_IBAN_BNP_END
			Else
				%beg csid_compose ^out(csid_info_memo)
				"Rule MTS$REP_BBK_AFORMAT -	",
				ent_credit_set.cdt_typ," Replaced.",/;
				%end
			end-if
			%^ Now we need to see if the Cdt_id BIC is a valid BIC or not.
			%^
			%beg
				Csid_temp_idtype = "S" ;
		    		Csid_id_ws = Ent_credit_set.cdt_typ.cdt_id ;
		    	%End
			%beg break: relget_adr_set; %end
			Move Spaces to Csid_lkup_pend_del	
	            	Call "ACCT_LOOKUP" USING
	    	       	 	by reference Csid_temp_idtype
		       		by reference Csid_id_ws
		        	by reference Csid_ovr
		        	by reference Csid_ambig_ws 
		        	by reference Csid_multibank_ws
	      	        	by reference Credit_currency_ls
				by reference Csid_lkup_pend_del
	              	RETURNING Csid_ret2_stat
			If Success_is in csid_ret2_stat 
			   OR (Relget_msgcode = Vmsg_dat_notonfile_wc)
			Then
				%beg break: relget_adr_set; %end
				%^ Do not set if on REL/AUX
				Set Failure_is in csid_set_chg_flg_ws to True
			end-if
		Else
			If Not(CDT_id of Ent_credit_set = Spaces)
				%^ OK we have BBK ID data already  Do NOT replace.
				%^ Send along the FULL IBAN to the next party and let them
				%^ expand upon it.
				Go to X1000_CHECK_IBAN_BNP_END
			End-if
			If Cdt_name1 of Ent_credit_set NOT = SPACES Then
				%^ BBK  D format check Flag and Override or Ignore
				%^ Call get_param for REP_BBK_DFORMAT
				%beg csid_compose ^out(csid_prm_name) "MTS$REP_BBK_DFORMAT",/;
	     			     csid_prm_values_remain = <0>;
				%end
				Call "PRULE_MSG_GET_PARAM" Using
					by Reference	csid_prm_name
					by Reference 	csid_prm_name_length
					by Reference 	csid_prm_level
					by Reference 	csid_pr_source
					by reference 	csid_prm_edit_type
					by reference 	csid_prm_values_remain
					by reference 	csid_prm_value
					by reference 	csid_prm_value_length
				returning csid_pr_ret_stat
				If Not(Success_is in Csid_pr_ret_stat) Or
	  			      (csid_prm_value NOT = "Y")
				Then
					%^ No flag, no action
					Go to X1000_CHECK_IBAN_BNP_END
				Else
				%beg csid_compose ^out(csid_info_memo)
					"Rule MTS$REP_BBK_DFORMAT - ",
					" Replaced CDT party - see original message",/;
				%end
				end-if
			End-if
		end-if
		%^ If we get here, we need to replace the credit party with the BBAN/IBAN
		%^
		Perform X920_INFO_MEMO Thru X920_INFO_MEMO_END
		Subtract 1 from csid_info_count
		%^
		%^ We may need to split the BNP id into a 2 part id for the credit party
		%^ Account number first, BIC in the secondary
		%^
		%Beg  Csid_party_id = Ent_credit_set.bnp.bnp_id;  %End
		PERFORM X960_SHUFFLE_IDS through X960_SHUFFLE_IDS_END
		If Csid_shuffle_acct = Spaces Then %^ If we have an account, it is the IBAN
		   	%^
			%beg Ent_credit_set.cdt_typ.cdt_idtype  = ent_credit_set.bnp.bnp_idtype;
			     Ent_credit_set.cdt_typ.cdt_id	= ent_credit_set.bnp.bnp_id;
			%end
			%^
			%^ If we had a Secondary ID, flush that too
			%^
			Move Spaces to Second_cdt_id_ls
			Move 0 to Second_cdt_id_leng_ls
			%^ 
		Else	%^ Multiples present, split em up in to Secondary ID
			%^ Hose the original Second_cdt_id_ls
			Move Spaces to Second_cdt_id_ls
			Move 0 to Second_cdt_id_leng_ls
			%^ 
			%beg
			     Ent_credit_set.cdt_typ.cdt_idtype  = csid_shuffle_idt;
			     Ent_credit_set.cdt_typ.cdt_id	= Csid_shuffle_acct;
			%end
			Move "/BC" to Second_cdt_id_ls(1:3)
			Move Csid_shuffle_part1 to Second_cdt_id_ls(4:csid_shuffle_part1_length)
			Add 3 to Csid_shuffle_part1_length giving Second_cdt_id_leng_ls
			%^			
		End-if
		%^
		%beg
		     Ent_credit_set( .Cdt_shnam  = NULL ,
				    .Cdt_name1  = Ent_credit_set.Bnp_name1 ,
                                    .Cdt_name2  = Ent_credit_set.Bnp_name2 ,
                                    .Cdt_name3  = Ent_credit_set.Bnp_name3 ,
                                    .Cdt_name4  = Ent_credit_set.Bnp_name4,
				    .cdt_res_country = Ent_credit_set.bnp_res_country) ;
		     Ent_credit_set(.bnp.bnp_id	= NULL,
				    .bnp.bnp_idtype = Null,
				    .bnp_name1  = NULL ,
                                    .bnp_name2  = NULL ,
                                    .bnp_name3  = NULL ,
                                    .bnp_name4  = NULL ,
				    .bnp_res_country = NULL) ;
		%end
		%^
		%^ Need country to allow a re-evelaution of the BBAN
		If Bnp_mailing_country of Ent_credit_set = SPACES then
		    %Beg Ent_credit_set.bnp_mailing_country = csid_iban_cntry_ws; %End
		End-if
		
		If Csid_valid_iban_flg_ws NOT = "I" and	%^ 117314
		   Bnp_mailing_country of Ent_credit_set = SPACES 	%^ JC 117739
		Then
			%beg ent_credit_set.bnp_mailing_country = csid_iban_cntry_ws; %end
		end-if
	end-if.
X1000_CHECK_IBAN_BNP_END.
	EXIT.

X1010_PRECALC_CVD.

	If csid_precalc_cvd_ws = "T" and Date_Time of Cdt_value_date of Ent_credit_set = ZERO Then
	   Call "PRECALC_CDT_VALUE_DATE" Using By reference  Csid_error_msg_ws
					       By reference  Csid_error_msg_ws_length
					       Returning  Csid_ret_stat
	   If Failure_is in Csid_ret_stat
	      %Beg
	       Csid_compose ^OUT(Csid_err_memo)
				    "Unable to pre-calc the CVD - ", 
				    Csid_error_msg_ws, / ;
	      %End
	      Perform X900_ERROR_MEMO 
				through X900_ERROR_MEMO_END
	      Set Failure_is in Creditside_look_ls to true
	   End-if
	End-if.	

X1010_PRECALC_CVD_END.
	EXIT.

X1100_CHECK_FOR_FED.
%^
%^ If FED is available as an Advice type, look  E/FW id's on the ABA index 
%^ If FED is NOT available, treat FW as an Extended_id type
%^
%^ Now see if FED is a valid advice type.
	%Beg
	    Csid_union_key_ws(.Idname = "FIELD_EDIT_TABLES",
		  	      .Idprod = "MTS", 	   
		   	      .Idbank =  Menu_bnk_union.Bnk_id,    
		  	      .Idloc  = null,    	   
		  	      .Idcust = null);
	    Csid_item_key_ws = "CREDIT_ADV_TYPES:";
	    Csid_match_key_ws = "FED" ;
	%End       
	Call "CFG_MATCH_ITEM" USING
	    	By Reference Idname of Csid_union_key_ws
            	By Reference Idprod of Csid_union_key_ws
            	By Reference Idbank of Csid_union_key_ws
            	By Reference Idloc  of Csid_union_key_ws
            	By Reference Idcust of Csid_union_key_ws
		BY Reference Csid_item_key_ws
		BY Reference Csid_match_key_ws
		BY Reference Csid_match_key_ws_length
		BY Reference Csid_seq_ordinal_ws
		BY Reference Csid_error_msg_ws
		BY Reference Csid_error_msg_ws_length
          Returning Csid_ret_stat.

X1100_CHECK_FOR_FED_END.
	EXIT.


X1150_CHECK_IBAN_CNTRY.
%^
%^ Country of party above IBAN does not match IBAN country.
%^ Check table to see if this is allowable.
%^
	If Csid_save_cntry_ws = Spaces Then
		Set success_is in Csid_Bic_cc_exc_wf to True
		Go To X1150_CHECK_IBAN_CNTRY_END
	End-if.

	Set Failure_is in Csid_Bic_cc_exc_wf to True.
	
	%Beg
		Csid_union_key_ws(.idname	= "FIELD_EDIT_TABLES",
			       .idprod	= "MTS",
			       .idbank	= "",
			       .idloc	= "",
			       .idcust	= "");
		Csid_item_key_ws = "IBAN_BIC_CC_EXC:";
		Csid_item_type_ws = "VSTR(5)";
		Csid_seq_ordinal_ws = <1>;
		Cfg_status_wf Success_is;
	%End

	Perform until Failure_is in Cfg_status_wf
	    Call "CFG_GET_ITEM"
	       using
		by reference Idname of Csid_union_key_ws
		by reference Idprod of csid_union_key_ws
		by reference Idbank of Csid_union_key_ws
		by reference Idloc of  Csid_union_key_ws
		by reference Idcust of Csid_union_key_ws
		by Reference Csid_item_key_ws
		by Reference Csid_seq_ordinal_ws
       		by Reference Csid_item_type_ws
		by Reference Csid_item_data_ws
		by Reference Csid_item_data_ws_length
		by Reference Csid_error_msg_ws
		by Reference Csid_error_msg_ws_length
            RETURNING Cfg_status_wf

	    If Success_is in cfg_status_wf
		%Beg 
			Csid_parse ^IN(Csid_item_data_ws) 
				csid_Cfg_bic_ctry_ws, "|" csid_Cfg_iban_ctry_ws, /;
		%End
		If Success_is in Csid_Parse_status and
		       csid_Cfg_bic_ctry_ws = csid_save_cntry_ws and
		       csid_Cfg_iban_ctry_ws = csid_iban_cntry_ws
		    Set Success_is in Csid_Bic_cc_exc_wf to True
		    Set Failure_is in Cfg_status_wf to True
		End-if
	    End-if
	    Add 1 to Csid_seq_ordinal_ws
	End-perform.

X1150_CHECK_IBAN_CNTRY_END.
	EXIT.

X1200_CHECK_SOURCES.
%^
%^ Need to check it itemcame from ENT source, OR,
%^ has been thru RPR/EXC 
%^
	Set Failure_is in csid_already_warned_ws to True.
	%Beg
	    Csid_union_key_ws(.Idname = "SOURCE_CODE_TABLES",
		  	      .Idprod = "MTS", 	   
		   	      .Idbank =  Null,    
		  	      .Idloc  =  Null,    	   
		  	      .Idcust =  Null);
	    Csid_item_key_ws = "ENT_SOURCE_CODES:";
	    Csid_match_key_ws = Ent_ftr_set.src_code;
	    csid_seq_ordinal_ws = <0>;
	%End

	Call "CFG_MATCH_ITEM" USING
	    	By Reference Idname of Csid_union_key_ws
            	By Reference Idprod of Csid_union_key_ws
            	By Reference Idbank of Csid_union_key_ws
            	By Reference Idloc  of Csid_union_key_ws
            	By Reference Idcust of Csid_union_key_ws
		BY Reference Csid_item_key_ws
		BY Reference Csid_match_key_ws
		BY Reference Csid_match_key_ws_length
		BY Reference Csid_seq_ordinal_ws
		BY Reference Csid_error_msg_ws
		BY Reference Csid_error_msg_ws_length
          Returning Csid_already_warned_ws.

	If Success_is in Csid_already_warned_ws
	Then
		Go to X1200_CHECK_SOURCES_END
	End-if.
	%^
	%^ Not an Entry Source, need to scan Mesage History for RPR or EXC logs
	%^
	%beg
		Ent_msg_history EQUATE: Csid_msg_hist(nomod);
		Last: Csid_msg_hist;
	%end

	Perform Until Success_is in csid_already_warned_ws or
		      Failure_is in csid_msg_hist_status

		If Idname of Csid_msg_hist = "EXCEPTN_LOG" or "REPAIR_LOG"
		Then
			Set Success_is in Csid_already_warned_ws to True
		Else
			%beg PREV: Csid_msg_hist; %end
		End-if
	End-perform.

	%beg Break: Csid_msg_hist; %end.
	
	%^
X1200_CHECK_SOURCES_END.
	Exit.

X1300_CHK_UCC_SRC.
%^
%^ See if we should replace the Name/Address with our REL/AUX
%^
	Set Failure_is in csid_non_ucc_src to True
	Move Src_code of Ent_ftr_set to Csid_ucc_save_src
	%Beg
	    Csid_union_key_ws(.Idname = "SOURCE_CODE_TABLES",
		  	      .Idprod = "MTS", 	   
		   	      .Idbank =  Menu_bnk_union.Bnk_id,    
		  	      .Idloc  = null,    	   
		  	      .Idcust = null);
	    Csid_item_key_ws = "NON_UCC_SOURCES:";
	    Csid_match_key_ws = Ent_ftr_set.src_code ;
	%End       
	Call "CFG_MATCH_ITEM" USING
	    	By Reference Idname of Csid_union_key_ws
            	By Reference Idprod of Csid_union_key_ws
            	By Reference Idbank of Csid_union_key_ws
            	By Reference Idloc  of Csid_union_key_ws
            	By Reference Idcust of Csid_union_key_ws
		BY Reference Csid_item_key_ws
		BY Reference Csid_match_key_ws
		BY Reference Csid_match_key_ws_length
		BY Reference Csid_seq_ordinal_ws
		BY Reference Csid_error_msg_ws
		BY Reference Csid_error_msg_ws_length
          Returning Csid_non_ucc_src.

X1300_CHK_UCC_SRC_END.
	EXIT.

X1400_CHK_DUAL_MATCH6.
%^
%^ Check the SWF_DUALID_MATCH6 Table for a  value in the owning bank
%^
	Move "N" to csid_tmp_flg_ws.

	%Beg
	    Csid_union_key_ws(.Idname = "FIELD_EDIT_TABLES",
		  	      .Idprod = "MTS", 	   
		   	      .Idbank =  Menu_bnk_union.Bnk_id,    
		  	      .Idloc  = null,    	   
		  	      .Idcust = null);
	    Csid_item_key_ws = "SWF_DUALID_MATCH6:";
	    Csid_match_key_ws = Ent_ftr_set.loc_info.bank ;
	%End       
	Call "CFG_MATCH_ITEM" USING
	    	By Reference Idname of Csid_union_key_ws
            	By Reference Idprod of Csid_union_key_ws
            	By Reference Idbank of Csid_union_key_ws
            	By Reference Idloc  of Csid_union_key_ws
            	By Reference Idcust of Csid_union_key_ws
		BY Reference Csid_item_key_ws
		BY Reference Csid_match_key_ws
		BY Reference Csid_match_key_ws_length
		BY Reference Csid_seq_ordinal_ws
		BY Reference Csid_error_msg_ws
		BY Reference Csid_error_msg_ws_length
          Returning Csid_ret_stat.

	If Success_is in csid_ret_stat
	Then
		If (Success_is in Csid_ret_stat )
		    %Beg  Csid_item_type_ws = "STR(5)" ;  %End
		    Call "CFG_GET_ITEM" USING
			by Reference Idname of Csid_union_key_ws
			by Reference Idprod of Csid_union_key_ws
			by Reference Idbank of Csid_union_key_ws
			by Reference Idloc of Csid_union_key_ws
			by Reference Idcust of Csid_union_key_ws
			by Reference Csid_item_key_ws
			by Reference Csid_seq_ordinal_ws
        		by Reference Csid_item_type_ws
			by Reference Csid_item_data_ws
			by Reference Csid_item_data_ws_length
			by Reference Csid_error_msg_ws
			by Reference Csid_error_msg_ws_length
	              RETURNING Csid_ret_stat
		    If (Success_Is in Csid_ret_stat)
			%beg
				Csid_Parse ^in(csid_item_data_ws) ^str<4>,csid_tmp_flg_ws,/;
			%end
		    end-if
	End-if.

X1400_CHK_DUAL_MATCH6_END.
	EXIT.
X2000_CHECK_SECOND_IBAN.

	Set Failure_is in csid_bic_in_adr to True.
	%^ Check the Credit Party
	If Cdt_idtype of Cdt_typ of Ent_credit_set = "S" Then
	    If  Cdt_id of Cdt_typ of Ent_credit_set(4:1) = ":"
	    Then    %^ Skip over the bank
		Move Cdt_id of Cdt_typ of Ent_credit_set(9:2) to Csid_res_country_ws 
	    Else
	    	Move Cdt_id of Cdt_typ of Ent_credit_set(5:2) to Csid_res_country_ws 
	    End-if
	Else
	    If (Cdt_adr_ptr_ok of flgs3 of ent_credit_set = "T")
	    Then
		%beg break: csid_tmp_adr_set;
   			     Ent_credit_set.Cdt_adr_set_ptr CONN: csid_tmp_adr_set;
     			     break: csid_tmp_adr_set;
		%end
		If (Swift_id of csid_tmp_adr_set Not = Spaces)
		Then
		    Move Swift_id of  csid_tmp_adr_set(5:2) to Csid_res_country_ws
		    Set Success_is in csid_bic_in_adr to True
		end-if
	    Else
		If Cdt_idtype of cdt_typ of Ent_credit_set = "E"
		Then
			%beg
				Csid_parse ^in(ent_credit_set.cdt_typ.cdt_id)
					Csid_party_extype (^STRING<2>),
					csid_gcheck_id,/;
			%end
			CALL "CUST_XTEND_ID_EDIT" using
				BY REFERENCE Csid_party_extype
   				BY REFERENCE Csid_gcheck_id
   	     			BY REFERENCE Csid_gcheck_id_length
    				BY REFERENCE Csid_temp1_vstr
    				By REFERENCE Csid_temp1_vstr_length
    				By REFERENCE Csid_delay_change
    				BY REFERENCE Csid_got_advice
    				By Reference Csid_extnd_country
    				BY REFERENCE Csid_error_memo
    				BY REFERENCE Csid_error_memo_length
    				By REFERENCE Csid_error_code
    				By REFERENCE Csid_error_code_length
    				BY REFERENCE Csid_check_stat
    				BY REFERENCE Csid_not_garbage
  			RETURNING Csid_ret2_stat
			If Success_is in Csid_ret2_stat And
			   Csid_extnd_country NOT = Spaces
			Then
				%beg csid_res_country_ws = csid_extnd_country; %end
			end-if
			%^ get country for Extended IDs table
		end-if
	    end-if
	end-if

	Move Spaces to Csid_iban_cntry_ws
	If Csid_res_country_WS NOT = Spaces
	Then
     		    %Beg Csid_iban_cntry_ws = Csid_res_country_ws; %End
	Else
		If Bnp_mailing_country of Ent_credit_set NOT = Spaces
		Then
			%Beg Csid_iban_cntry_ws = Ent_credit_set.bnp_mailing_country; %End
		Else
			%^ No country provided, try for On-Us
	   		%Beg
			    Csid_iban_cntry_ws = Menu_bnk_union.Country_code;
	   		%End
		end-if
	end-if.
	%^
	%beg csid_temp_party_id = Csid_checkid_ws; %end
	%^
%^	Move csid_checkid_ws(5:csid_checkid_ws_length) to csid_temp_party_id
%^	subtract 4 from csid_temp_party_id_length
%^
	Set Failure_is in Csid_iban_found to True
	Call "VALIDATE_IBAN" Using
		by Reference csid_temp_party_id
		by Reference csid_temp_party_id_length
		by Reference csid_iban_cntry_ws
		by Reference csid_iban_bnk_ws
		by Reference csid_iban_bnk_ws_length
		by Reference csid_iban_brnch_ws
		by Reference csid_iban_brnch_ws_length
		by Reference csid_iban_curr_ws
		By Reference csid_bnk_code_rec_ws
		By Reference csid_bnk_code_rec_ws_lengths
		By Reference csid_valid_iban_flg_ws
	returning Csid_val_iban_ret.

	If Success_is in Csid_val_iban_ret AND
	   csid_bnk_code_rec_ws NOT = SPACES
	Then
		%^ See if this is our account, if so, 
		%^ return the trimmed account number
		Call "CUST_IS_ID_ON_US" using
			By Reference 	idacc of idkey of csid_bnk_code_rec_ws
			By Reference 	idacc_length of csid_bnk_code_rec_ws_lengths
			By Reference	csid_bnk_code_bnk_ws
		Returning  csid_on_us_bnk_code

		If Success_is in csid_on_us_bnk_code
		Then
		     If ( Csid_party_bank_id_length = 0 )  OR (Csid_party_bank_id = SPACES )
		     THEN
	    		If (Cdt_adr_bnk_id of Ent_credit_set = SPACES )
				%Beg  Csid_gcheck_bank_id = Ent_ftr_set.Loc_info.Bank;  %End
	    		ELSE
				%Beg  Csid_gcheck_bank_id = Ent_credit_set.Cdt_adr_bnk_id;  %End
	    		END-IF		
		     ELSE
	    		%Beg  Csid_gcheck_bank_id = Csid_party_bank_id;  %End
		     END-IF

		     CALL "CHKDGT_EDIT" USING
			        by reference Csid_acc_idtype_ws
      				by reference Csid_temp_party_id
			        by reference Csid_temp_party_id_length
   				by reference Csid_gcheck_bank_id
    				by reference Csid_multibank_ws
    				by reference Csid_temp1_vstr
  		     RETURNING Csid_ret2_stat
		     If Success_is in Csid_ret2_stat
		     Then
				%beg Csid_checkid_ws= csid_temp_party_id; %end
		     end-if		
		end-if
	End-if.


X2000_CHECK_SECOND_IBAN_END.
	EXIT.
%^
%^
%^ CREDITSIDE_SCREEN routine.                        
%^
%^   Calling format:
%^	Call "Creditside_screen" Using
%^		By Reference Credit_currency
%^		By Reference Message_amount
%^              By Reference Message_currency
%^		By Reference Credit_account
%^		By Reference Is_payment
%^		By Reference Xbank_account_ok
%^		By Reference Credit_account_type
%^		By Reference Do_chips_qualif
%^		By Reference Is_repetitive_lookup
%^		By Reference Lock_cdt_party
%^		By Reference Special_fee_key
%^		By Reference Credit_account_changed
%^		By Reference Credit_changed
%^		By Reference IB1_changed
%^		By Reference IBK_changed
%^		By Reference BBK_changed
%^		By Reference BNP_changed
%^		By Reference ADV_changed
%^              By Reference Init_debit_currency
%^		By Reference Debit_currency
%^		By Reference Debit_account_changed
%^		By Reference Debit_changed
%^		By Reference Debit_account
%^		By Reference Debit_account_type
%^		By Reference Nochange_bank
%^		By Reference Lock_dbt_party
%^		By Reference Debit_fee_key
%^		By Reference Debit_internal_state
%^		By Reference Debit_account_okay
%^		By Reference Debit_not_suspect
%^		By Reference Debit_status
%^		By Reference Msg_bank_changed
%^		By Reference Debit_ErrMemo_count
%^		By Reference Debit_currency_found
%^		By Reference Credit_currency_found
%^		By Reference Cdt_account_okay
%^		By Reference Original_cdt_depth
%^		By Reference Advice_parties
%^		By Reference CHK_SI_iswas_found
%^		By Reference IB1_iswas_qualified
%^		By Reference IBK_iswas_qualified
%^		By Reference BBK_iswas_qualified
%^		By Reference BNP_iswas_qualified
%^		By Reference Secwire_dest_state_ls
%^		By Reference Cdt_not_suspect
%^		By Reference No_beneficiary
%^		By Reference Credit_ErrMemo_count
%^	    Returning Return_status_ws.
%^	Possible return status values are:
%^		SUCCESS
%^		FAILURE
%^
%^	  Called to fill out credit side of message, retrieving any address
%^    information for on-file parties and to identify a credit account.  This
%^    is an interactive routine used by ENTRY/VFY/RPR/EXC and it is expected
%^    to be called multiple times as the operator creates and refines a
%^    message interactively.  "Changed" arguments are used to indicate which
%^    creditside parties (or debit party) the operator has changed since the
%^    last time this routine was called for this message; any parties with a 
%^    0 changed flag are assumed to have been fully processed by a previous 
%^    call to this routine.  If the credit party or debit party themselves are
%^    changed, we will not "roll back" any party insertions done when 
%^    processing the previous credit party; that is left to the operator.  
%^    We begin by processing the Credit Party, since the kinds of lookups that
%^    we do differ for the credit party, the first creditside party
%^    AFTER the creditside party, and any creditside parties after that. 
%^    Processing the credit party special instructions can cause "pushdown" 
%^    -- another address is substituted as the new credit party, and the old
%^    credit party moves into the next slot in the creditside party chain.
%^    The creditside parties are FILLED in the order:
%^		Credit Party
%^		Beneficiary Party  	(BNP)
%^		Beneficiary's Bank 	(BBK)
%^		Intermediary Bank  	(IBK)
%^		First Intermediary Bank (IB1)
%^
%^    The order of receipt of the message by the Creditside parties is:
%^		Credit Party                   Credit_changed
%^		First Intermediary Bank (IB1)  IB1_changed
%^		Intermediary Bank  	(IBK)  IBK_changed
%^		Beneficiary's Bank 	(BBK)  BBK_changed
%^		Beneficiary Party  	(BNP)  BNP_changed
%^    If CHIPS qualification is done, the first party present in order of
%^    receipt after the credit party must be CHIPS qualified.
%^    If no CHIPS qualification is being done, we merely do an address
%^    lookup for this party.  Whether CHIPS qualification is being done or
%^    not, address lookups are all that is necessary for any remaining
%^    creditside parties.
%^	CHIPS qualification toggles are maintained for each credit party.
%^    For a CHIPS qualification toggle to be SET by CREDITSIDE_SCREEN,
%^    the Credit_adv_type must be SPACES or CHP, the credit party must 
%^    have an associated P account, and either the credit party or the
%^    subsidiary party being qualified must have changed.  These toggles
%^    will be CLEARED by CREDITSIDE_SCREEN if the credit party changes to
%^    one which does not have an associated P account, if the subsidiary
%^    party changes to one which fails chips qualification, or if the
%^    Cdt_adv_typ at the time of either change is not either SPACES or
%^    CHP.  Toggle SET means that the subsidiary party is CHIPS qualified;
%^    however, toggle OFF does not necessarily mean that it cannot be,
%^    since the change arguments may never have been set to test qualification.
%^      If the caller wants to make sure that a message is properly chips
%^    qualified and the toggle is not set for the highest creditside party,
%^    he should set the CHANGE flag for the credit party, make sure that the
%^    Credit_adv_type is SPACES or CHP, and call DEBITSIDE_SCREEN one more 
%^    time.
%^
%^	If the Credit_changed flag is non-0, we begin by using RELGET to
%^    look up the credit party address in our REL file.  Error messages are
%^    indicated by setting the appropriate field message sub-fields on the 
%^    FTRSCR screen.  
%^        If there was no Cdt_typ and the Is_payment argument is non-0,
%^    an error message will be set and the routine will return FAILURE.  If 
%^    the lookup failed we will return a NOF indicator (and if Is_payment is 
%^    non-0, an error message).
%^      If the credit party address is on-file and not ambiguous and the
%^    Is_rptv argument is 0,  we call the GLOBAL_PREF_CORR routine in 
%^    SIDE_SUBS.COB to check for a global preferred correspondent.  If we do
%^    not find one of those, we call SI_FIRST_CREDIT in SI_SUBS.COB to search
%^    for an SI which might cause party insertion.  If we find an insertable
%^    party, the original Credit Party is pushed down in the creditside 
%^    parties and the new preferred correspondent is substituted as a
%^    candidate Credit Party address.  An information memo is written to the 
%^    message history documenting the SI execution.               
%^	We then enter a cycle of looking up the new candidate credit
%^    party address in our REL file, and, if we find it unambiguously,
%^    using SI_FIRST_CREDIT to check the new Credit Party for AIN SI's, ...
%^	We match to an AIN SI using the current advice method (if it is
%^    non-blank, which means that it is an override specified by the mapper
%^    which called us and not a default), the amount, and the currency.
%^    We will ignore AIN's with a match parameter of EQL RRT.  Once we find
%^    a matching AIN, its Si_method, if non-blank, overrides the cdt_adv_typ.
%^    Its Si_submethod, if it is "SUB", means that we do a substitution and
%^    overwrite the credit party.  If the Si_submethod is either blank or 
%^    "INS", we push the credit party down and insert the new party.
%^
%^	Once there are no more substitutions, if we still have an unambiguous
%^    on-file credit party address, we call the SETC_REDIT_ADDRESS routine in
%^    SIDE_SUBS.COB to set credit party elements from the address set.
%^
%^       We now call REL_ACC_FROM_ADR to get the credit account set.  If the 
%^    Credit_account argument is not SPACES, we will use it as the credit party 
%^    account REGARDLESS of the resolution of the credit party address.  If it
%^    is SPACES, then we will tell REL_ACC_FROM_ADR to get the credit account
%^    from the credit address.
%^      If we are able to determine a credit account,  we call the
%^    SET_CREDIT_ACCOUNT routine in SIDE_SUBS.COB to set credit set elements 
%^    from the account set.
%^
%^      Regardless of whether or not we were able to unambiguously determine
%^    an on-file credit party account and an on-file credit party address,
%^    we now proceed to process any remaining debit party SIs, emerging with
%^    a final debit party address and account, and then other creditside 
%^    parties which resulted from credit party pushdowns or which have non-0 
%^    change flags.  If CHIPS qualification has been requested, we will try to
%^    qualify the first of the IB1, IBK, BBK, or BNP parties which exist if 
%^    it is not already CHIPS qualified.
%^	If there is a creditside party which is properly positioned and CHIPS
%^    qualification has been requested, and it did not result from a credit
%^    party pushdown, the id_overflow field for that creditside party will be
%^    used as additional CHIPS qualification information.
%^      If CHIPS qualification was attempted, REL address lookups will be done
%^    for any remaining credit parties REGARDLESS of the outcome of the CHIPS
%^    qualification.
%^      If no CHIPS qualification was attempted, REL address lookups will be
%^    done for all creditside parties below the Credit Party.
%^
%^ INPUT ARGUMENTS:
%^ explicit:
%^  Credit_currency	      STR(3)  contains the credit currency.
%^	This is a mandatory field.
%^  Message_amount	      DEC(14.2)  contains the credit amount.
%^	This is a mandatory field.
%^  Message_currency    STR(3)  contains the currency of the credit amt.
%^      In a cross-currency system, the new amount currency argument will
%^      indicate the currency of the amount argument.  It must NOT be SPACES.
%^      The amount will be converted to match the currency of an SI for SI
%^      matching.
%^      In a cross-currency system, a Credit_currency argument of SPACES will
%^      be interpreted as a wildcard currency search and it will match the
%^      currency of whatever account is found by following the non-currency
%^      search rules.   The Message_currency argument will be used as a
%^      "suggested currency" for that party.  If there is an account in the
%^      amount currency associated with the party address and if it can be
%^      selected without breaking any other constraints.
%^  Credit_account	      ACC_ID_REC.DDF contains account ID if caller
%^  	has pre-determined it; else spaces.
%^  Is_payment		      Long    If NON-0, message is a payment and 
%^	both an unambiguous credit address and credit account are required.
%^  Xbank_account_ok	      Long    Non-0 if we are permitted to find a
%^	credit account in a different bank from the credit party.
%^  Credit_account_type	      STR(1)  Select an account of this type from
%^ 	the accounts associated with the credit party address.
%^  Do_chips_qualif	      Long    Non-0 if we should attempt to CHIPS
%^      qualify the first existing creditside position downstream from the
%^	credit party (in order, the IB1, IBK, BBK or BNP).
%^  Is_repetitive_lookup      Long   Non-0 if this is a repetitive lookup,
%^	in which case we will not map special instructions nor copy the
%^	debit account's cnf_seq to the message.
%^  Lock_cdt_party            Long   Non-0 if the credit party is locked
%^      (such as by instantiation of a locked repetitive) and should not be
%^ 	changed by AINs, INTRTL tables, or anything else.
%^  Special_fee_key	      Str(1) Passed to Set_credit_account.  
%^				     SPACE for nothing special.
%^				     For now, "W" if the fees are to be waived.
%^  Credit_account_changed    Long   Non-0 if caller has set or changed the
%^  	credit account override or credit account idtype since the last time 
%^ 	we were called.
%^  Credit_changed            Long   Non-0 if operator has changed the credit
%^	party since the last time we were called.
%^  Ib1_changed		      Long   Non-0 if operator has changed the IB1 party
%^	since the last time we were called.
%^  Ibk_changed		      Long   Non-0 if operator has changed the IBK party
%^	since the last time we were called.
%^  Bbk_changed		      Long   Non-0 if operator has changed the BBK party
%^	since the last time we were called.
%^  Bnp_changed		      Long   Non-0 if operator has changed the BNP party
%^	since the last time we were called.
%^  Adv_changed		      Long   Non-0 if operator has changed the Advice
%^	method since the last time we were called.
%^  CHK_SI_relevant           Long    Toggle.  Initially set to 0 by caller.
%^  Ib1_iswas_qualified       Long    Toggle.  Initially set to 0 by caller.
%^  Ibk_iswas_qualified       Long    Toggle.  Initially set to 0 by caller.
%^  Bbk_iswas_qualified       Long    Toggle.  Initially set to 0 by caller.
%^  Bnp_iswas_qualified       Long    Toggle.  Initially set to 0 by caller.
%^
%^ Explicit input arguments passed to DEBIT_SCREEN_ACCOUNT:
%^  Init_debit_currency	      STR(3)  contains the debit currency as originally
%^	passed to DEBITSIDE_SCREEN.  This is a mandatory field.
%^  Debit_currency	      STR(3)  contains the debit currency.
%^	This is a mandatory field.
%^  Debit_account_changed     Long   Non-0 if caller has set or changed the
%^  	debit account override or debit account idtype since the last time 
%^ 	we were called.
%^  Debit_changed	      Long   Non-0 if operator has changed the debit
%^	party since the last time we were called.
%^  Debit_account	      ACC_ID_REC.DDF contains account ID if caller
%^  	has pre-determined it; else spaces.
%^  Debit_account_type	      STR(1) Select an account of this type from
%^ 	the accounts associated with the debit party address.
%^  Nochange_bank	      Long   Non-0 if a debit party bank which 
%^	disagrees with the Menu_bnk_union bank should not cause a bank
%^	context switch.  (The Msg_bank_changed flag will still be hoisted
%^	when appropriate even though no context switch will be done.)
%^  Lock_dbt_party            Long   Non-0 if the debit party is locked
%^      (such as by instantiation of a locked repetitive) and should not be
%^ 	changed by AINs, INTRTL tables, or anything else.
%^  Debit_fee_key	      Str(1) Passed to Set_debit_account.  
%^				     SPACE for nothing special.
%^				     For now, "W" if the fees are to be waived.
%^  Debit_internal_state      Long   Indicator of what state of completion the
%^	pre-creditside part of debitside-lookup achieved. 
%^  
%^ implicit:
%^   Credit party:
%^	Ent_credit_set.Cdt_typ
%^	Ent_credit_set.Cdt_name1		
%^	Ent_credit_set.Cdt_name2		
%^	Ent_credit_set.Cdt_name3		
%^	Ent_credit_set.Cdt_name4		
%^   IB1:
%^	Ent_credit_set.Ib1
%^	Ent_credit_set.Ib1_name1
%^	Ent_credit_set.Ib1_name2
%^	Ent_credit_set.Ib1_name3
%^	Ent_credit_set.Ib1_name4
%^   IBK:
%^	Ent_credit_set.Ibk
%^	Ent_credit_set.Ibk_name1
%^	Ent_credit_set.Ibk_name2
%^	Ent_credit_set.Ibk_name3
%^	Ent_credit_set.Ibk_name4
%^   BBK:
%^	Ent_credit_set.Bbk
%^	Ent_credit_set.Bbk_name1
%^	Ent_credit_set.Bbk_name2
%^	Ent_credit_set.Bbk_name3
%^	Ent_credit_set.Bbk_name4
%^   BNP:
%^	Ent_credit_set.Bnp
%^	Ent_credit_set.Bnp_name1
%^	Ent_credit_set.Bnp_name2
%^	Ent_credit_set.Bnp_name3
%^	Ent_credit_set.Bnp_name4
%^   Menu_bnk_union.Id for current bank id.
%^
%^ OUTPUT ARGUMENTS:
%^ Explicit arguments returned from DEBIT_SCREEN_ACCOUNT:
%^  Debit_account_okay	      long   is returned 0 if we should find an account
%^	and we cannot.  Else non-0.
%^  Debit_not_suspect	      long   is returned 0 if any mapping errors
%^	were detected during debitside setup, otherwise 1.  For payments,
%^	mapping errors are caused by any ambiguous debitside parties, a
%^	NOF debit party, or a non-existent or ambiguous debit
%^	account.  For non-payments, mapping errors are caused by any
%^	ambiguous debitside party or a NOF (but not non-existent) debit
%^	party.  If this flag is returned 0, the message should be routed to
%^	repair instead of being passed through for automated payment
%^	processing.
%^  Debit_status	      long   is returned SUCCESS if no obviously bad 
%^	or inconsistent rel or aux file data was read during debitside setup, 
%^	otherwise FAILURE.
%^  Msg_bank_changed	      long   is returned non-0 if the debit party was
%^      found in a different bank, requiring the message (context) bank to
%^      change.
%^  Debit_ErrMemo_count          Long   is the number of error or warning
%^	memos added to the message history during debitside lookup. 
%^	Informational memos indicating normal SI parsing and execution are
%^	NOT error or warning memos.
%^  Debit_currency_found      Str(3) is the debit currency found -- the
%^	explicit currency of the debit account, if any.  It will only be SPACES
%^	if no debit account was found.
%^  
%^
%^ Explicit arguments returned from CREDITSIDE_SCREEN:
%^  Credit_currency_found      Str(3) is the credit currency found -- the
%^	explicit currency of the credit account, if any.  It will only be SPACES
%^	if no credit account was found.
%^  Account_okay 	      long   is returned 0 if any mapping errors
%^	were detected during credit account lookup/setup, otherwise 1.
%^	Relget_msgcode contains detailed VMSG error message code.
%^  Original_cdt_depth 	      Long    Depth to which original credit party has
%^	been pushed down.  0 = still CDT, 1 = IB1, 2 = IBK, 3 = BBK, 4 = BNP
%^  Advice_parties	      Long    Number of creditside parties to receive
%^	advices.  1, 2, or 3.
%^  CHK_SI_iswas_found        Long    Toggle.  Initially set to 0 by caller.
%^  	Non-0 if CREDITSIDE_SCREEN has detected a relevant CHK SI on
%^	the *DEBIT* Party.
%^  Ib1_iswas_qualified       Long    Toggle.  Initially set to 0 by caller.
%^	Non-0 if CREDITSIDE_SCREEN has CHIPS qualified IB1 party and stays 
%^	set until re-qualification fails due to CDT party change or IB1 change.
%^  Ibk_iswas_qualified       Long    Toggle.  Initially set to 0 by caller.
%^	Non-0 if CREDITSIDE_SCREEN has CHIPS qualified IBK party.
%^  Bbk_iswas_qualified       Long    Toggle.  Initially set to 0 by caller.
%^	Non-0 if CREDITSIDE_SCREEN has CHIPS qualified BBK party.
%^  Bnp_iswas_qualified       Long    Toggle.  Initially set to 0 by caller.
%^	Non-0 if CREDITSIDE_SCREEN has CHIPS qualified BNP party.
%^  Secwire_dest_state_ls     LONG    Secwire destination edit indicator.
%^                  1 = IB1 secwire dest failed
%^                  2 = IBK secwire dest failed
%^                  3 = BBK secwire dest failed
%^                  4 = no secwire dest edit failed.  #20916
%^  Cdt_not_suspect		      long    is returned 0 if any mapping errors
%^	were detected during creditside setup, otherwise 1.  For payments,
%^	mapping errors are caused by any ambiguous debitside parties, a
%^	NOF debit party, or a non-existent or ambiguous debit
%^	account.  For non-payments, mapping errors are caused by any
%^	ambiguous debitside party or a NOF (but not non-existent) debit
%^	party.                                            
%^  No_beneficiary	      Long    is returned 1 if there is NO beneficiary
%^ 	for a payment message  (This does not cause Cdt_not_suspect to be 
%^ 	returned 0).
%^  Error_Memo_count          Long    is the number of error or warning
%^	memos added to the message history during creditside lookup. 
%^	Informational memos indicating normal SI parsing and execution are
%^	NOT error or warning memos.
%^  Return_status_ws is SUCCESS if there were no obviously fatal errors during
%^	creditside setup, otherwise FAILURE.
%^
%^Implicit:
%^   Message history
%^   Credit party:
%^	Ent_credit_set.Cdt_adr_set_ptr
%^	Ent_credit_set.Cdt_rel_id
%^	Ent_credit_set.Cdt_adr_bnk_id
%^	Ent_credit_set.Cdt_typ
%^	Ent_credit_set.Cdt_name1		
%^	Ent_credit_set.Cdt_name2		
%^	Ent_credit_set.Cdt_name3		
%^	Ent_credit_set.Cdt_name4		
%^	Ent_credit_set.Cdt_account
%^	Ent_credit_set.Cdt_acc_class         
%^	Ent_credit_set.Cdt_acc_parent_code
%^	Ent_credit_set.Cdt_acc_prod_codes         
%^	Ent_credit_set.Cdt_adr_class         
%^	Ent_credit_set.Cdt_adv_typ         
%^	Ent_credit_set.Cdt_concen_acc
%^	Ent_credit_set.Cdt_currency         
%^	Ent_credit_set.Cdt_department         
%^	Ent_credit_set.Cdt_recon_ref        
%^	Ent_credit_set.Cdt_shnam         
%^	Ent_credit_set.Cdt_spc_inst1         
%^	Ent_credit_set.Cdt_spc_inst2         
%^	Ent_credit_set.Cdt_spc_inst3
%^	Ent_credit_set.Cdt_sys_of_rec         
%^	Ent_credit_set.Cdt_wir_key         
%^	Ent_credit_set.Flgs.Cdt_hold_flg         
%^	Ent_credit_set.Pymnt.Adv_type         
%^	Ent_credit_set.Pymnt.Location
%^	Ent_credit_set.Pymnt.Phn_time         
%^	Ent_credit_set.Pymnt.Que 
%^   IB1:
%^	Ent_credit_set.Ib1_adr_set_ptr
%^	Ent_credit_set.Ib1_adr_bnk_id
%^	Ent_credit_set.Ib1_rel_id
%^	Ent_credit_set.Ib1
%^	Ent_credit_set.Ib1_id_overflow
%^	Ent_credit_set.Ib1_name1
%^	Ent_credit_set.Ib1_name2
%^	Ent_credit_set.Ib1_name3
%^	Ent_credit_set.Ib1_name4
%^   IBK:
%^	Ent_credit_set.Ibk_adr_set_ptr
%^	Ent_credit_set.Ibk_adr_bnk_id
%^	Ent_credit_set.Ibk_rel_id
%^	Ent_credit_set.Ibk
%^	Ent_credit_set.Ibk_id_overflow
%^	Ent_credit_set.Ibk_name1
%^	Ent_credit_set.Ibk_name2
%^	Ent_credit_set.Ibk_name3
%^	Ent_credit_set.Ibk_name4
%^   BBK:
%^	Ent_credit_set.Bbk_adr_set_ptr
%^	Ent_credit_set.Bbk_adr_bnk_id
%^	Ent_credit_set.Bbk_rel_id
%^	Ent_credit_set.Bbk
%^	Ent_credit_set.Bbk_id_overflow
%^	Ent_credit_set.Bbk_name1
%^	Ent_credit_set.Bbk_name2
%^	Ent_credit_set.Bbk_name3
%^	Ent_credit_set.Bbk_name4
%^   BNP:
%^	Ent_credit_set.Bnp
%^	Ent_credit_set.Bnp_id_overflow
%^	Ent_credit_set.Bnp_name1
%^	Ent_credit_set.Bnp_name2
%^	Ent_credit_set.Bnp_name3
%^	Ent_credit_set.Bnp_name4
%^   FTR:
%^	Ent_ftr_set.cdt_adv_flg
%^      Ent_ftr_set.chrg.cdt_chrg 
%^	Ent_ftr_set.chrg.dbt_chrg 
%^	Ent_ftr_set.currency_code 
%^	Ent_ftr_set.flgs.adv_ovr_flg 
%^	Ent_ftr_set.flgs.cdt_adv_flg 
%^	Ent_ftr_set.instr_adv_type 
%^	Ent_ftr_set.loc_info.bank 
%^	Ent_ftr_set.si_flgs.check_found 
%^	Ent_ftr_set.si_flgs.cor_done 
%^	Ent_ftr_set.si_flgs.fx_found 
%^	Ent_ftr_set.si_flgs.pre_found 
%^	Ent_ftr_set.si_flgs.rte_done 
%^	Ent_ftr_set.type_code
%^
%^
%^ Modification history:
%^
%^	Fred P. Isaacs	30-Jun-1995
%^		Initial version.
%^      Fred P. Isaacs  20-JUL-1995
%^		Now forces Cdt_adr_bnk_id to be Menu_bnk_union ID for NOF or
%^		ambiguous debit party and Cdt_adr_bnk_id to be same as
%^		Dbt_adr_bnk_id (or Menu_bnk_union ID for ENTRY if debit party
%^		bank is still blank).
%^      Fred P. Isaacs  25-JUL-1995
%^     		Now calls SI_FIRST_CREDIT with length of list of SI types
%^		to make subsequent parse cleaner.
%^      Fred P. Isaacs  31-JUL-1995
%^		Added Nochange_bank argument.
%^      Fred P. Isaacs  9-AUG-1995
%^              Made sure that Account_okay_ls argument flag is returned
%^		with proper setting.
%^		Made sure that credit account setup checks for cross-bank
%^		address/account relationship.
%^      Fred P. Isaacs  28-AUG-1995
%^              Tightened definition of full_parse for admins.  
%^		Make account default be account spec if one was given.
%^      Fred P. Isaacs  6-SEP-1995
%^              Added secondary wire check.
%^      Fred P. Isaacs  7-SEP-1995
%^              Made sure that SI_FIRST_CREDIT does not get called with no
%^		adr set and that blank credit parties get flagged NOF.
%^      Fred P. Isaacs  11-SEP-1995
%^              Fixed Csid_try_chips flag init; make sure Csid_acc_seq set;
%^		correct chips qualification.
%^      Fred P. Isaacs  21-SEP-1995
%^		Added overwrite option to AIN insertion using SI_submethod.
%^      Fred P. Isaacs  11-OCT-1995
%^		Fixed AIN processing logic.
%^      Fred P. Isaacs  25-OCT-1995
%^              Changed GET_SECWIRE_DEST to GET_CDTWIRE_DEST.  Added code to
%^		set Cdt_wir_key in Ent_credit_set.  Added code to copy adv SI's
%^		to Ent dummy union and to hook that up to Ent_adv_seq.
%^              Also changed default for Account_okay_ls to 1 when no account
%^		change is attempted.
%^      Fred P. Isaacs  27-OCT-1995
%^              Adjusted Account_okay_ls to ONLY come up false if we should
%^		find an account and we don't.  (Party is on-file or account
%^		was passed in.)
%^              Changed FIND_ADR_ID returned status not to conflict with and
%^		trample RELGET returned status for subsidiary parties.
%^      Fred P. Isaacs  29-OCT-1995
%^		Cleaned up party substitution memos.
%^      Fred P. Isaacs  8-NOV-1995
%^              Added Lock_cdt_party argument.
%^      Fred P. Isaacs  17-NOV-1995
%^              Added advice type changed argument; Restructured advice type 
%^		setup and usage.
%^      Fred P. Isaacs  29-NOV-1995
%^		Made sure that Ent_c_adr_set is not used for blank credit
%^		party.
%^              Removed idtype from Aux database swf_to_aba_index lookup to
%^		match index structure.
%^      Fred P. Isaacs  6-DEC-1995
%^		Removed reset of adv type chain on reset of advice type.
%^      Fred P. Isaacs  11-DEC-1995
%^		Tweaked advice sequence setup.  Fixed credit party bank id.
%^      Fred P. Isaacs  20-DEC-1995
%^              Made sure that Relget_adr_set is connected to Ent_d_adr_set
%^		before scanning for debit SI's.
%^	Fred P. Isaacs  28-FEB-1996
%^		Now clears SI AIN status properly on re-entry, so it doesn't
%^		keep re-applying the last one it found.
%^              Correct IF nesting for no second idtype to make sure that
%^		address still gets set up.  Fix advice type initialization.
%^ 	Fred P. Isaacs   12-APR-1996
%^		Simplified RELGET "$" mode to search AUX swift ONLY for
%^		lower creditside parties.
%^ 	Fred P. Isaacs   18-APR-1996
%^		Make sure Csid_try_chips gets cleared when next party fails.
%^		Turn off overenthusiastic clearing of credit name and address
%^		when lookup fails.
%^ 	Fred P. Isaacs    9-MAY-1996
%^      	Removed code to reset Cdt_wir_key since this is now done in
%^		the CREDIT_ADVICE_LOOKUP routine.
%^              Corrected arguments to SET_BNP_PARTY, SET_BBK_PARTY, 
%^		SET_IBK_PARTY, and SET_IB1_PARTY to be full id with overflow.
%^              Shortened error memos; made error /info memo write more robust.
%^	Fred P. Isaacs	22-MAY-1996
%^              Setup for PREadvise and SPLit now corrected.
%^		Changed args for SI_FIRST_CREDIT and SI_FIRST_DEBIT.
%^		Changed CREDITSIDE_SCREEN args to have separate debitside
%^		    and creditside amounts and currencies passed by caller.
%^              Fixed connection glitch in Ent_c_adr_set when advice changed.
%^	Fred P. Isaacs	28-MAY-1996
%^              Cleaned up handling of account match lookup failure.
%^              Changed wording of PRE SI memos.
%^	Fred P. Isaacs	31-MAY-1996
%^		OOPS.  Corrected handling of account match lookup failure so
%^		we no longer lock up NOF accounts.
%^		If no lookup is attempted for credit party because there is
%^		no ID, we must make sure that RELGET_MSGCODE gets zeroed.
%^	Fred P. Isaacs	4-JUN-1996
%^		Make sure bank is set correctly for NOF credit parties.
%^		Fix FX and CHEQUE logic and move to correct place.
%^	Fred P. Isaacs	13-JUN-1996
%^              Check for BKT Si_method on normal SI's and object to it.
%^	Fred P. Isaacs	17-JUN-1996
%^              Cleaned up COR SI logic.
%^	Fred P. Isaacs	28-JUN-1996
%^		Fixed trap on SUB AIN's
%^	Fred P. Isaacs	3-JUL-1996
%^              Restructured lower creditside party lookups.  Lower creditside
%^		name and address now ONLY get overwritten if ALL party ids
%^		resolved to linked AUX entries or to the same REL entry.
%^	Fred P. Isaacs	 12-JUL-1996
%^		Tweaked restructured lookups so that a blank name and address
%^		  will get filled in if we can find ANY ID, so long as multiple
%^		  IDs are not inconsistent.
%^		Fixed misplaced length adjustment when unpacking condensed
%^		  lower credit party id.
%^		Fixed error in lower creditside status check para.
%^              Fixed return usage to recognize and not use a soft failure
%^		  (I.e, nothing found) for lower creditside lookup.
%^		Modularized and corrected lower credit party unpack/update
%^		  of long ID with overflow.
%^		Corrected ELSE case on chips qualification to know we do not
%^		  have a good address.
%^		Corrected lower credit party lookup to ignore any CHIPS data
%^		  in parentheses.
%^	Fred P. Isaacs	 15-JUL-1996
%^              Now uses "u" RELGET idtype to force chips uid lookup in AUX
%^		*WITHOUT* displaying a selection screen.
%^	Fred P. Isaacs	 16-JUL-1996
%^              Now uses common UID qualification on CHIPS message.
%^	Fred P. Isaacs	 17-JUL-1996
%^              Now eats trailing spaces on single lower creditside ID.
%^      John R. Phelan   19-JUL-1996
%^              Split Value Dating - Use the new Accounting Method parameter
%^              in Si_p1 of Ent_cnf_set to set the Dbt_ps_elig_flg.  Flag
%^              preadvise limit missing as "L" and preadvise limit expired as
%^              "X" in Dbt_ps_elig_flg. #18222
%^              Unit Confirmations - Reconnect Relget_adr_set from
%^		Ent_c_adr_set so the standing instruction sequence can be
%^		scanned for an "IND" instruction. #18219
%^	Fred P. Isaacs  01-AUG-1996
%^	        Now no longer searches for COR SI if message source is COR.
%^              Now reports not fully parsed if we had a pushdown error.
%^              Now behaves better for AIN trying to insert NOF party.
%^              Now sets up address and account when finding COR, since it
%^		will need them.
%^              Fixed typo in IBK secwire dest. Thanks to John Phelan.
%^		Credit party bank now set properly for CHK.
%^              Relaxed credit party edit to only object to missing credit
%^		account if we have a credit party address and require an
%^		account (i.e, when we are inconsistent).
%^		FTRSCR_EDITS will take care of NOF credit party checks when
%^		we lack both an account and an address.
%^      John R. Phelan   21-AUG-1996
%^		Make sure Relget_adr_set is connected so we can look up IND
%^		standing instructions.  Make sure Csid_conn_stat is current.
%^      John R. Phelan   29-AUG-1996
%^              Clear Cdt_recon_ref field.  #19552
%^      John R. Phelan   02-SEP-1996
%^              Set the NOF Cdt_account correctly.  #19175, #19199, #19313.
%^      John R. Phelan   20-SEP-1996
%^              Reset Csid_musthave_acct after calling Set_credit_advice and
%^              Set_credit_address, if the account is no longer required.
%^              #19791
%^      John R. Phelan   20-SEP-1996
%^              Maintain pointer to Ent_c_adr_set.
%^              Reconnect Ent_c_adr_set when a pushdown error occurs.  #20148
%^	John R. Phelan   20-SEP-1996
%^		Fix AIN lookup trap caused by missing section of code.  #19599
%^      John R. Phelan   26-SEP-1996
%^              Change Csid_parse statement to ignore white space so it doesn't
%^              trap on string overflow.  #20415
%^      John R. Phelan   26-SEP-1996
%^              Break Ent_c_acc_set and clear out other account level fields
%^              when Cdt_account is cleared.  #20393
%^      John R. Phelan   26-SEP-1996
%^              Initialize Dbt_ps_elig_flg for NOF accounts.  #20528
%^      John R. Phelan   27-SEP-1996
%^              Add call to Intrtl_spec_pref_corr to determine
%^              site specific preferred correspondents.  #19967
%^      Fred P. Isaacs   09-OCT-1996
%^              Added security arguments to GET_CDTWIRE_DEST.  Added
%^              Csid_lc_secwir flag to force lower creditside lookups into
%^              REL instead of AUX when we are sending a secwir to that lower
%^              party.  #20498, #20523.  Migrated to 4.2 by JRP.
%^
%^      Fred P. Isaacs   09-OCT-1996
%^              1) Allow use of solo X(answerback) or T(dial digit) id's in
%^                 lower creditside parties.
%^              2) If lower creditside party gets a secwire and
%^                 ANYTYPE_LOWER_CREDIT INTRTL flag is T, any solo on-rel
%^                 idtype is allowed.
%^              3) For any ID, a bank specifier may be incorporated.
%^                 If it is present, AUX lookups will be skipped and we
%^                 will go to the REL database.
%^		#19579, #19629.  Migrated to 4.2 by JRP
%^      John R. Phelan   16-OCT-1996
%^              Initialize Dbt_ps_elig_flg for NOF accounts (but only if
%^              Pre_found is not "Y").  #20972
%^      John R. Phelan   16-OCT-1996
%^              Break Relget_adr_set and Ent_c_adr_set for NOF parties.  Allow
%^              Intrtl_spec_pref_corr to be called for all idtypes.  #21072
%^      John R. Phelan   23-OCT-1996
%^              If an ABA number was returned from the AUX database, check to
%^              see if the Fed preferred bank needs to be moved into the
%^              Cdt_adr_bnk_id.  #21163
%^      John R. Phelan   24-OCT-1996
%^              Make sure Set_nof_cdt_account is called prior to calling
%^              Set_credit_unit_cnf to make sure that the Cdt_account field is
%^              set correctly.  Set_credit_unit_cnf passes Cdt_account to the
%^              Nof_domicil_unit Intrtl routine.  #21591
%^      John R. Phelan   28-OCT-1996
%^              Added Preferred advice and preferred submetho return arguments
%^              from Intrtl_spec_pref_corr routine.  #20726
%^      John R. Phelan   30-OCT-1996
%^              Clear out the lower credit party rel_id's and adr_set_ptr's if
%^              they've changed.  Add Secwire_dest_state_ls return argument.
%^              Returned values are...
%^                  1 = IB1 secwire dest failed
%^                  2 = IBK secwire dest failed
%^                  3 = BBK secwire dest failed
%^                  4 = no secwire dest edit failed.  #20916
%^      John R. Phelan  04-NOV-1996
%^              Consolidate the logic that determines Type_code into
%^              Ftrscr_edits.  #21838
%^      Fred P. Isaacs  10-DEC-1996
%^              1. Change CHIPS qualification to check for common UID if we
%^                 have a uid and SWIFT only but do this after initial
%^                 qualification (so credit party P is on common UID).
%^		   Migrated to 4.2 by John Phelan.
%^      Fred P. Isaacs  10-DEC-1996
%^              Fix lower creditside party qualification to not register
%^              a conflict when it just cannot find an ID (as opposed to
%^              finding a conflicting one).  #21957
%^		Migrated to 4.2 by John Phelan.
%^      Fred P. Isaacs  10-DEC-1996
%^              Fixed typo in B400_SET_ADVICE when setting Cdt_id.  22492
%^              Cleaned up use of lookup failed flag.               22591
%^		Migrated to 4.2 by John Phelan.
%^      John R. Phelan  13-DEC-1996
%^              Make sure there's something in the id field before trying
%^              to Chips qualify a party.  Fix a few typos.  #22975
%^      John R. Phelan  13-DEC-1996
%^              Check return code from RELGET before using Relget_adr_set.
%^              #22447
%^      John R. Phelan  20-DEC-1996
%^              In C660_LOWER_CREDIT, if RELGET returns a different key
%^              of the same idtype, then replace the old key with the
%^              new key, without disturbing any other ids in the ID
%^              field.  #23053
%^      John R. Phelan  27-DEC-1996
%^              Fixed bug in setting the Csid_multi_party flag.           
%^              Flag was sometimes getting set to 1 when the id field was
%^		empty.  #23053
%^      John R. Phelan  30-DEC-1996
%^              Clear out credit party name and address when the address
%^              changes from on-file to not-on-file.  #21817
%^      John R. Phelan   7-JAN-1997
%^              If a message is received and the bene is for a common uid but
%^              is identified with a tid and account number, route the message
%^              straight thru.  #23563
%^      John R. Phelan   16-JAN-1997
%^              If the Def_secwir_if_pre_spl flag is "Y", and a BBK party
%^              might need to be preadvised, look up the REL for the BBK party
%^              so Valdate_edit has a country code to work with.  #21876
%^      John R. Phelan    23-JAN-1997
%^              If there's no room to insert a preferred correspondent,
%^		don't overwrite the credit party.  Also, make sure
%^		address sets are always connected NOMOD.  #22302
%^	Fred P. Isaacs	12-FEB-1997
%^		Retain bank when changing to P account for CHP advice  #25404.
%^	Fred P. Isaacs	12-FEB-1997
%^		Retain bank when changing to ABA for FED advice  #25449.
%^      John R. Phelan  13-MAR-1997
%^              Change the search currency if an account is inserted by an
%^              AIN or selected from a Relget or Rel_acc_from_adr screen.
%^              #23745
%^      John R. Phelan  13-MAR-1997
%^              Clear out the Cdt_hold flag from the previous account whenever
%^              the Cdt_account field is cleared.  #24455
%^      John R. Phelan  13-MAR-1997
%^              Cross-currency changes.  #23745
%^      John R. Phelan  13-MAR-1997
%^              If the Cdt_adv_typ field hasn't been overridden or changed,
%^              clear it out when the credit party changes.  #25626
%^      John R. Phelan  25-MAR-1997
%^              Set the CDT_ADR_BNK_ID to the preferred fed bank when we find
%^              the ABA on the AUX XREF.  #25253, #27040
%^      John R. Phelan  27-MAR-1997
%^              Clear out the Cdt_account field if Cdt_typ is an ABA.  #26510
%^      John R. Phelan  06-MAY-1997
%^              Call the Intrtl_Nia_Pref_Corr routine from the screen routine
%^              as well as from the mapper routine.  #26964
%^      John R. Phelan  06-MAY-1997
%^              Add logic to determine if the debit account should be looked up
%^              again because something has changed on the creditside that
%^              might cause a debitside AIN to be executed.  #28073
%^
%^      Fred Kelley     02-Jun-1997   #28375
%^              Added Csid_use_bank argument for GET_ACCOUNT_CURRENCY to
%^              determine when to use bank defaults and when not to.
%^              4.1 to 4.2
%^
%^      John Phelan     20-Jun-1997   #30139, #30395
%^              If the first SI search fails, AND the address has no accounts,
%^		AND the credit_amount_currency_ls is NOT spaces, then use the
%^		credit_amount_currency_ls as the search currency for the
%^		second SI search.
%^
%^	Fred P. Isaacs	1-July-1997    PER 28784
%^		Implement Si_send_secwir_flg for credit party AIN.
%^
%^	Fred P. Isaacs	23-JUL-1997.  Check that account etc. are not spaces
%^		before clearing them.  Instrument and trap on repair loop
%^		condition which fragments message.
%^
%^	Fred P. Isaacs	31-JUL-1997.  Made instrumentation for fragmentation
%^		loop only turn on when APL$FRAGMENTATION_CHECK is "ON"
%^		and added OPER3 logging for loop messages.
%^
%^      John R. Phelan   4-AUG-1997
%^              Don't use the Relget Disp_id from the disambiguation screen to
%^              determine the new search currency.  #29028
%^
%^	Fred P. Isaacs	18-AUG-1997.  Do not try to set account if we are
%^		trying to leave without setting it.  REG 32620.
%^
%^      John R. Phelan  20-Aug-1997    19962
%^              Allow inserted party to be NOF, as long as it's on the AUX file.
%^
%^	Fred P. Isaacs	2-SEP-1997
%^		Changed argument lists -- first step towards new currency
%^		conversion.
%^
%^      John R. Phelan  17-SEP-1997.  Lookup lower creditside
%^              "U" ids on REL.  This is a requirement, since the FASIN mapper 
%^		uses the "U" idtype in the SBK party, and the SAF_ISO mapper 
%^		copies this party to the BNP party.  #32218
%^
%^      John R. Phelan  24-Dec-1997    19962
%^              Allow inserted party to be NOF, as long as it's on the AUX file.
%^		Correct Si_first_credit, Si_first_debit argument lists.  Insert
%^		space in "Pref correspondent" message.
%^
%^      Joseph Carey  06-Jan-1998    19269
%^		Changes made to following paragraphs:
%^		1. B280_Credit_Adr.
%^		   Do not insert the Preferred Fed Bank if the transaction
%^		   type is "BPF" (Bypass Preferred Fed Bank).
%^		2. C600_Credit_Fail
%^		   Do not insert the Preferred Fed Bank if transaction 
%^		   type is "BPF".
%^		3. D720_Cdt_SWF_to_ABA
%^		   Do not insert the Preferred Fed Bank if transaction 
%^		   type is "BPF".
%^
%^	Fred P. Isaacs  8-JAN-1998 
%^      37158	Recognize that lookup needs to be done for IRS account.
%^
%^      Fred Kelley     26-Jan-1998
%^      30746   Aux_extended_id. Relget called with no ID
%^              par. C660_LOWER_CREDIT.  Migrated to V4.3 by Jphelan.
%^
%^      John R. Phelan  03-Feb-1998
%^      35648   Added three new parameters to the Intrtl_spec_pref_corr
%^              routine to pass the 3 characters suffixes of P/ accounts,
%^              and the bank wire service register.  Changed to call the new
%^              Validate_pid_adv_type subroutine to determine the valid "P"
%^              advice type, since this can now vary depending on bank.
%^              Changed to call the new Lookup_pid_rec subroutine to lookup
%^              up "P" ID information, since this can vary depending on bank,
%^              account suffix, currency, etc...  These changes are
%^              necessary for the Amex German Clearing Interface.
%^
%^      John R. Phelan  10-Feb-1998
%^      39285   Implement Aux AIN Standing Instructions for the Amex German
%^		clearing interface.  They need to be able to add a single
%^		AIN to Aux records.  Relget will return the AIN in
%^		Relget si set.  B420_GET_NEWPARTY will check for an
%^		AIN in Relget si set as the last step.
%^
%^      Fred P. Isaacs  18-Feb-1998
%^	36920   Make sure explicit fed bank is inserted.
%^
%^	Fred P. Isaacs  18-MAR-1998
%^	40702   Added E idtype as one to be preserved for lower credit party
%^		lookup.
%^
%^ 	Fred P. Isaacs	8-APR-1998
%^	41633.  Modify fix 36920 above to not do it if tran-type is "BPF".
%^
%^	Don Ryan	24-Aug-1998	#45981
%^	Extended ID's with a sub-type of "ID" and alpha characters after the 
%^	code word were writing an ambiguous message for the beneficiary on 
%^	incoming telex messages.  Paragraph C660_lower_credit is being modified.
%^
%^	Fred Isaacs	10-SEP-1998	#45875
%^ 	Now changes ID in message to match credit account.
%^
%^	Fred Isaacs	22-SEP-1998	#46178
%^ 	Corrected loop control logic in C660_LOWER_CREDIT
%^
%^	Fred Isaacs	20-FEB-1999	#51503
%^	Fixed handling of RELGET status return for credit party in
%^	C600_CREDIT_FAIL paragraph.
%^
%^	Diana Pacelle	26-FEB-1999
%^	Changed the setting of ent_credit_set.cdt_typ.cdt_idtype from
%^	a move to an assign.  Was not being recognized by
%^	Video as a changed field.
%^
%^	Fred P. Isaacs	16-APR-1999	53312
%^	Use a clip_compose to set inserted credit party up for lookup --
%^	this trims off any trailing blanks.
%^
%^	Fred P. Isaacs	20-APR-1999  	#53263
%^	Changed descriptive AIN error memos to go into Csid_info_memo;
%^	Added setup logic to force sensible substitution for blank
%^	message currency before calling SI_FIRST_CREDIT.
%^	
%^ 	Fred P. Isaacs	5-MAY-1999	54146(PORT)
%^	Corrected call to GET_SUFFIX_FROM_PID
%^
%^ 	Fred P. Isaacs	21-JUL-1999	54115(PORT)
%^	Cleaned up error message when AIN cannot get secwire sent to
%^	pushed-down credit party.
%^
%^	Jan Walsh	15-Jan-1999	#37222
%^ 	Moved the ambiguous lookup logic in B200_BNP so that the lookup 
%^      would be completed before the Chips Qualification was performed.  
%^      This corrected the problem of the "No account with that name on 
%^      file" message being displayed after a @name/city lookup had 
%^      returned a valid account.
%^
%^	Jan Walsh	22-Jan-1999	#15126
%^ 	Shift-cancel out of an ambiguous selection screen was returning
%^      a '*' in the cdt_ovr field.  Changed to return a '?'.
%^
%^	Jan Walsh	08-Feb-1999	#16070
%^ 	When BNF party is in R/99999 format, blank out idtype and idtype
%^      leaving only the name / address info.
%^
%^	Fred Isaacs	19-Feb-1999	51503
%^	When RELGET returns failure, in Paragraph C600_CREDIT_FAIL set 
%^	CDT_OVR to "?" only on an error code of 0.
%^
%^      John Phelan     24-FEB-1999     #46381
%^      Set Csid_id_bank_ws_length to 3 when me move the bank prefix into it,
%^      in paragraph D700-NOF_ID_BANK.  Formerly, the search in
%^      D700_NOF_ID_BANK was failing because the length hadn't been set.
%^
%^ 	Fred P. Isaacs	7-APR-1999	#52348
%^	When setting account to match clearinghouse advising method,
%^	need to match on suffix (if in use) as well as "P" idtype.
%^
%^	Fred P. Isaacs	20-APR-1999  	#53263
%^	Changed descriptive AIN error memos to go into Csid_info_memo;
%^	Added setup logic to force sensible substitution for blank
%^	message currency before calling SI_FIRST_CREDIT.
%^
%^      Allen Joress    05-May-1999   spr 48541 -  Migrate 42789
%^      Add code to distinguish if calling routine is from the
%^      PDQ_SERVER.
%^
%^	J. Walsh    06-May-1999        SPR 15526, PROJ 54097
%^	Lookup fails if address is marked for deletion.
%^
%^	K. Hanlon	14-Jun-1999	PER 50434
%^	Call SI_COPY_ADV to copy the advice set into the message (adv_Seq)
%^	(MT103 processing needs this information)
%^
%^      J. Walsh    25-Jun-1999        SPR 55540
%^      Modify SYS_MEMO message when lookup fails if address is marked 
%^      for deletion.
%^
%^	Fred P. Isaacs	21-JUL-1999	55092
%^	Now forces reset of address and re-do of account selection if
%^	advice change can change account.
%^
%^	Kristen Hanlon	29-JUN-1999	#55461
%^	Add logic to look for the CONFIRM codeword in the codeword_seq and
%^	if found and a delivery confirm does not exist then set one up since
%^	it must have been skipped due to CPD errors in the mappers.
%^
%^	Jan Walsh	03-Aug-1999	#55714
%^	Removed changes made for #37222 and moved to relget to correct problem
%^	with bic in bnf not expanding.
%^	
%^	Fred P. Isaacs	5-Oct-1999	58119 for port
%^	PID suffix will be checked on suffixed PID against advice method;
%^	suffix for advice method will be appended onto unsuffixed PID.
%^
%^	Fred P. Isaacs	7-Oct-1999	Migrate 57534 
%^	Move Initialization of Csid_push_error to top of routine.
%^
%^	Fred P. Isaacs	15-Oct-1999	58231 for port
%^	Cleaned up Csid_acc_id_ws usage.
%^
%^	Fred Isaacs	18-JAN-2000     #60094
%^	Made sure we break Csid_bnk_union before exit.
%^
%^	Fred Isaacs	20-JAN-2000	60544
%^	Clean up base id argument to have a zero length when its blank.
%^	COMPOSE will turn a null string into a single trailing space even if
%^	you turn off trailing spaces.
%^
%^	Fred P. Isaacs	11-FEB-2000	60913
%^	Added Swift_adr_nof_warning flag detection and warning logic for lower
%^	creditside parties.
%^
%^	Fred Isaacs	19-MAY-2000     #63716
%^	Modified changes for 60874 above to fix problem when finding default
%^	from a NOF reference and to enforce stickiness of account id when
%^	not appropriate for advice method (actually simplifies lookup logic).
%^
%^	Fred Isaacs	24-JUL-2000	#52354 #54255
%^	If we are about to check a preadvise_limit or its expiration date and
%^	we have a concentration account, then we must look for the preadvise
%^	limit and expiration date in the concentration account, not the debit
%^	account.  54255 is same for group.
%^
%^	Fred Isaacs	26-OCT-2000	68396
%^	Add currency and amount arguments to call to CUST_SPEC_PREF_CORR routine
%^	so that those passed as arguments to CREDITSIDE routines can be passed
%^	through to CUST routines.  They are not set in the message yet.
%^
%^	Fred Isaacs	1-NOV-2000	67416, 67675
%^	Make sure that record structure of preferred correspondent ids is
%^	reflected in code and that record lengths are passed as an argument when
%^	records are passed.
%^
%^ 	Fred P. Isaacs	10-NOV-2000	68957
%^	Minor tweaks to fix to beneficiary is a bank flag.
%^
%^	Fred Isaacs	12-DEC-2000	70356
%^	Make sure to do change to set overall record length after using record
%^	arg to cust sub.
%^
%^	Tom Carroll	04-JAN-2001	70330
%^	Allow E type ID's to be lookuped up when entered as the BNP party.  E
%^	IDTypes worked okay when used in any other party.
%^
%^	Fred P. Isaacs	7-FEB-2001	70982
%^	Move SET_NOF_CDT_ACCOUNT calls to right place.
%^	Make clearing recon field explicit.
%^
%^ 	Fred P. Isaacs  8-Feb-2001
%^	70258 Don't do lower creditside lookup on party that was just pushed 
%^		down.
%^	71649 Correct check for whether to process lower creditside party or 
%^		not.
%^
%^ Fred P. Isaacs	13-MAR-2001  72040
%^ 	Detect and set error for bail out from ambiguous credit party lookup
%^	and set no push down (push down error) for blank credit party idtype.
%^
%^	Fred P. Isaacs	15-MAY-2001	73480
%^	Corrected B400_SET_ADVICE paragraph P account matcher.
%^
%^	Fred P. Isaacs	6-JUN-2001	75024
%^	For clearinghouse advice method and credit party with corresponding
%^	clearinghouse E/ id, check extended id config table and do not change
%^	the E/ id to a P/ id if it is marked as deferred in the table.
%^
%^	J. Walsh	18-Oct-2001	76600
%^	Handle MENU command being returned from REL_GET.
%^
%^	Ken Bjelke	02-Jan-2002 75468
%^	Move setting of ent_credit_set.bnp_bnk_flg up to prior to B400_SET_ADVICE
%^	call to allow for proper evaluation of ADV_SEQ rules.
%^
%^	S. Smith	25-Feb-2002	81673, 81772
%^	Do not null out the cdt_recon_ref field if this message is
%^	a repetitive. 
%^
%^	S. Smith	15-Mar-2002	Spr 82733
%^	Change the parse of the ttl_aba_accounts to look for a pipe instead 
%^	of a slash, it should be "|" not "/"
%^
%^	Ken Bjelke	24-Apr-2002	Spr 82462
%^	Change EQUATE from end_d_adr_set to a connect when setting up for 
%^	B440_SCAN_DEBIT_SIS.
%^
%^	Ken Bjelke	29-Apr-2002	83550
%^	Allow Cdt to be own pref corr when SUB is the AIN action.
%^	Add check to GET_NEWPARTY ensure that we don't loop count when
%^	SUB AIN and current party have the same address. The 1st substitution
%^	takes place OK, an we will detect and exit after that.
%^
%^
%^	Ken Bjelke 6-Nov-2002	91685
%^	Cdt_account not always being filled for clearinghouse/rtgs systems.
%^
%^ Fred P. Isaacs  11-NOV-2002  90950
%^		Changed Prule_party_fsect to make AUX prules work.
%^
%^ Ken Bjelke	27-Nov-2002
%^	Add CUST_IS_ID_ON_US routine to check the BIC returned from Validate IBAN
%^
%^ Ken Bjelke 	04-Nov-2002	93036
%^	Correct setting of cdt_adr_bnk_id. Ensure it is set for AUX items,
%^	with Channel_determination set accounts.
%^
%^ Ken Bjelke	09-Dec-2002 92510,93143
%^	Inhibit the No account with that name message. Was being generated
%^	when no ID.IDtype was present on BNP.
%^
%^ Ken Bjelke 	09-Dec-2002 	Spr 92503, 92507 
%^	Allow forCHANNEL_DETERMINATION call to be made after
%^	CDTAIN  SUB is performed. Correct account info carry over.
%^
%^ Ken Bjelke 	09-Dc-2002	Spr 92927 
%^	Correct currency processing on DFT's.
%^
%^ Jan Walsh	16-Dec-2002	93532
%^	Add mode and credit currency to arguements for SECWIRE_EVAL call.
%^
%^ Ken Bjelke 	23-Dec-2002 Spr 92775,93394	
%^	Correct TRAP when switching from On-file To Aux.
%^
%^ Ken Bjelke  02-Jan-2003	90862
%^	Always try to change to ID type required or channel, regardless of
%^	Channel-Determination Success/Failure. Attempt to limit error messages.
%^
%^ Ken Bjelke 06-Jan-2003	91254
%^	Change c660_lower_credit to use S on rel_get call instead of $ when
%^	the party being lookup up is the result of an IBAN cracking.
%^
%^ Jan Walsh	14-Jan-2003	94392
%^	Correct SWIFT to ABA xref lookup in D720_CDT_SWF_TO_ABA.
%^
%^ Fred P. Isaacs  16-JAN-2003 94807
%^	"Soften" connection via credit and debit set address pointers since
%^	AUX entry can get erased while message is still being processed.
%^
%^ B. Lanza	21-Jan-2003	Spr 89085
%^	Initialize Csid_next_function at beginning. For cases where rel_get 
%^	is not called, this field wasn't initialized. Also check menu_next_function 
%^	after perform B200_BNP (moved from creditside_lookup).
%^
%^ Ken Bjelke	10-Feb-2003	Spr 95266
%^	Clear out cdt_adr_ptr_ok flag in C600_CREDIT_FAIL. If need be it will
%^	be reset.
%^
%^ Ken Bjelke 	18-Feb-2003	Spr 95710
%^	Change account search logic when presented a non-accounting ID  and no
%^	requested Account type. First try for F in currency, then any in Currency,
%^	then Default, If not, ambigious screen.
%^
%^ Ken Bjelke 	21-Feb-2003
%^	96094 - Modify logic for check AIN party against existing party. Need to 
%^	check id type to see whether to strip the / or not. Length checks were
%^	inhibiting some AINs from taking place.
%^
%^ Ken Bjelke 21-Feb-2003	96262
%^	always check for PRE rule.
%^
%^ Ken Bjelke	04-Mar-2003	94675
%^	Leave Accounts on ABA. Was being blanked.
%^
%^
%^ Ken Bjelke	12-Mar-2003	86577
%^	Allow for R/RT/id processing RT to remain intact, secondary ID
%^	will be looked up for lower Credit Parties.
%^
%^ Ken Bjelke 	20-Mar-2003	97547
%^	Ensure that cdt_acctyp_seq is given a BREAK: after each use.
%^
%^ Ken Bjelke  02-Apr-2003	97529
%^	If an account has been provided by CHANNEL_DETERMINATION, clear the
%^	CDT_IDTYPE message "That address has no associated accounts"
%^
%^ Ken Bjelke 	02-Apr-2003	98145
%^	Correct the inhibit logic for Skipping CDTAINs on levels above address.
%^
%^ J. Walsh	03-April-2003	97452
%^	Test relget_msgcode after call to REL_ACC_FROM_ADR to detect when 
%^	a GOLDCANCEL was done from an ambiguous selection screen.
%^
%^ K. Bjelke 	07-Apr-2003	97452
%^	Change logic regarding GOLDCANCEL from rel_acc_from_adr. Leave
%^	cdt_id as is, set creditside_screen_ls to failure to prevent
%^	Hostget call.
%^
%^ Ken Bjelke	21_Apr-2003	97359
%^	When IBAN in Bnp, Do NOT insert BBK if bic matches address set for Cdt party.
%^	Also ensure bnp country is filled in from IBAN.
%^
%^ Ken Bjelke	30-Apr-2003	
%^
%^	97965 - When Adv_changed_ls is set, assume Cdt_changed_ls and
%^		cdt_acc_changed_ls to be set. This will flush the cdt_account
%^		and allow the proper re-lookups to take place.
%^
%^	97405 - Add more logic to populate res_country/mailing country when
%^		processing IBAN's
%^
%^ Ken Bjelke 	13-May-2003	99693,99742
%^	
%^	99693 - Correct account change flag setting to avoid
%^		blanking acocunt when not required.
%^
%^	99742 - Correct trap when switching from ON to NOF,
%^		cdt_adr_ptr_ok flag was not being reset.
%^
%^ Ken Bjelke 	02-Jun-2003	100589,100627
%^	Correct error message delivered for NOF BIC when Swift_adr_nof_warning
%^	is set. Correct processing for bank without structured_account flag set.
%^	If flag is NOT st, skip all IBAN processing.
%^
%^
%^ Ken Bjelke 	09-Jun-2003	100551
%^	Clear out the cdt_acc_2 and cdt_acc_3 subfields when the account is changed.
%^
%^ Ken Bjelke 	11-Jun-2003	100258
%^	Don't insert BBK from IBAN when CDT party contains a BIC
%^	either on Address or in ID
%^
%^ Ken Bjelke 	16-Jun-2003
%^	99759	- Add new error message "Invalid IBAN/BBAN detected"
%^	100502  - Inhibit AIN from taking place when Account in Currency is available
%^		  in credit party.
%^
%^ Ken Bjelke 	23-Jun-2003	101450
%^	Correct trap when chanking for AIN account. Was happening when the
%^	encountering an AIN on AUX after an IBAN insert
%^
%^ Ken Bjelke 	01-July-2003	101647
%^	Clear the Cdt_res_country when the Credit party changes.
%^
%^ Ken Bjelke	17-July-2003	102124
%^	Correct invocation of CDTAIN when non-account id provided and
%^	account is available. AIN should still be invoked if it is not
%^	above the address level.
%^
%^	Ken Bjelke 	28-July-2003	101377
%^	Strip extra ID's when RPT is sent in with UID. Extra Id's causing
%^	problems, and will be lookup up later.
%^
%^ Ken Bjelke 	30-July-2003	101878
%^	101878 - Move setting of credit_set rel_id items to before
%^		 Channel determination call. Setting is tentative.
%^
%^ Ken Bjelke 	4-Aug-2003	103299
%^	Clear the Pref_corr_rec when encountering a SUB of same. 
%^	This should exit loop and allow processing to continue.
%^
%^ John Phelan	6-Aug-2003	103076
%^	Fix problem where validate_iban results were being carried over
%^	from previous call.
%^
%^ T. Carroll	07-Aug-2003	101906
%^	Bypass debit party lookup when the party change flag is set to a 2.
%^	This means we a being called from RPR, EXC or VCH and the party is
%^	already present.
%^
%^ Ken Bjelke 19-AUg-2003	103144
%^	Allow NOF pref corr processing when the Pref_corr was an ON_US 
%^	loaded BBAN.
%^
%^ Ken Bjelke 	21-Aug-2003	103527	
%^	Clear res_country of BNP and CDT if the credit and the change
%^	set are the same. but the party has changed. This should handle 
%^	most cases.
%^
%^ Ken Bjelke 	21-Aug-2003 99758
%^	Provide country value to VALIDATE_IBAN if possible.
%^
%^
%^ Ken Bjelke	27-Aug-2003	101817
%^	Recall GET_IDTYPE_FROM_CHAN after all channel changes.
%^
%^ Ken Bjelke	08-Sep-2003	97564
%^	When performing a lower party lookup on a BIC, for a Repetitive,
%^	append a / to the REL_GET call to prevent the ambiguous screen
%^	from allowing a party change.
%^
%^ Ken Bjelke 	09-Sep-2003 104445, 104446
%^	ensure CDT_RES_COUNTRY is cleared on a pushdown, and
%^	reset csid_musthave_acct priot to each CHANNEL_DETERMINATION call 
%^
%^ Ken Bjelke 	01-Oct-2003	105540
%^	If the Exit Channel_Determination call is not made due to the
%^ 	'already called' flag set, check to see if the initial CD call
%^	failed, and set status accordingly.
%^
%^ Ken Bjelke 	02-Oct-2003	104447
%^	Ensure we have a currency set during the CDTAIN check for Level and
%^	presence of the account.
%^
%^
%^ Ken Bjelke 	14-Oct-2003	100672,105601,105715,105795
%^
%^	100672 - Inhibit the choosing of "L" accounts, as is done with
%^		 P and Y.
%^
%^	105601 - Correct ASI finding proper Credit Party Information.
%^		 Ruels on AUX items not found correctly.
%^
%^	105715 - CDT party CNF's were removed when BNP changed. Corrected.
%^
%^	105795 - AUX clr not found, Leave relget_adr_set connected thru PRULE
%^		 CHANGE_CREDIT call. Was setting as Message rule seq as opposed
%^		 to AUX.
%^
%^ Ken Bjelke	22-Oct-2003	106424
%^	Calculate Pay to country(when not provided) using the next highest party 
%^	over BNP (BBK or CDT).
%^
%^ Ken Bjelke 	30-Oct-2003	106499
%^	Ensure that an AUX inserted party receives the "*" in the OVR field.
%^	Was not always being set.
%^
%^ Ken Bjelke 	12-Nov-2003	106338
%^	Move "DETERM_RES_COUNTRY" call for Credit party to C620_COPY_ADDRESS 
%^
%^ Ken Bjelke 	12-Nov-2003	107171
%^	Correct fix for 106499, was causing stale data in the Cdt party after an
%^	AUX Insertion.
%^
%^ Ken Bjelke 14-Nov-2003	107171
%^	Clear country on PUSH.
%^
%^ Cynthia Crain 18-Dec-2003 PER 97347
%^	Modified B200_BNP to clear address pointer before lookup.
%^
%^ Ken Bjelke 	24-Dec-2003	108387
%^	Correct edits for pref_corr SUB pointing to self.
%^
%^ Brian McLean 30-Dec-2003     97344
%^      Added call to Precalc_cdt_value_date to support effective dates for
%^      Channel Determination.
%^
%^ Ken Bjelke 	06-Jan-2004	108776
%^	Correct RPT processing for BIC's in Lower_credit. Missing / on
%^	compose was causing BIC not to be found.
%^
%^ Ken Bjelke 	09-Jan-2004	108891
%^	Exit from a110_got_credit immediately when Channel_determination calls
%^	have all failed. Attempting to find an account at this point is useless,
%^	and can result in ambiguous screens being presented.
%^
%^ Ken Bjelke 08-Dec-2003	107303
%^	Check if FED is an allowable ADV type, If so, process look for ABA's
%^	as A idtype  on the ABA index.
%^	If NOT look for E/FW info in the Extended ID index.
%^
%^ Ken Bjelke 	30-Jan-2004	98430
%^	Add support for COLLECTIONS_TRAN_TYP config. When tran type matches,
%^	Copy BBK down to BNP if bnp is blank. Skip SECWIRE_EVAL call, and
%^	set the BBK_SECWIR flag.
%^
%^ Ken Bjelke 	2-Feb-2004	101633
%^	Connect the Channel Clearing account set when loading the cdt_account field.
%^	This will allow Callers to handle the charges flags better.
%^
%^ Ken Bjelke 	18-Feb-2004 109837
%^	Only exit routine on Channel_determination failure IF a channel was requested
%^	by user. Otherwise allow the lookups to process the rest of the lower parties.
%^
%^ C. Crain	20-Feb-2004	PER 97347
%^	For Lower credit parties, replace "E" Idtype BCC with BIC based on
%^	LKUP_BIC_BY_BCC flag.
%^
%^ C. Crain	10-Mar-2004	110955
%^	Allow for S/<BIC>/<BCC> ID in C660_LOWER_CREDIT to be a hard hit
%^	whether record is in AUX or REL.  Created D750_MATCH_EXTENDED_IDS which
%^	is executed from D740_MATCH_IDS_TO_REL for REL as well as from
%^	C660-LOWER_CREDIT for AUX.
%^
%^ Ken Bjelke  24-Mar-2004  Sync in the 1.2 changes
%^
%^	 Ken Bjelke 	19-Jan-2004	107166
%^		Clear the Credit account upon a channel change. This will ensure that
%^		a stale Clearing Account will not be used in the Credit Party.
%^
%^ 	 Ken Bjelke 	21-Jan-2004	109250
%^		Clear out csid_prm_method_ws and csid_prm_secwir and csid_acctg_method_ws
%^		each pass thru GET_EXEC_PARAMS. Leftover values causing trouble.
%^
%^	 Ken Bjelke 	2-Feb-2004	101633
%^		Connect the Channel Clearing account set when loading the cdt_account field.
%^		This will allow Callers to handle the charges flags better.
%^
%^	 Ken Bjelke 	3-Mar-2004 	109297
%^		Skip PRULE_CHANGE_CREDIT call in B280 when Change Flag is not 1
%^		value of 2 indicates First time pass. 
%^
%^	 J. Curley	04-Mar-2004	110592
%^		Set BNP_MAILING_COUNTRY to Country code returned by DETERM_RES_COUNTRY form
%^		BBK if entered, or CDT if no BBK.
%^
%^	 Ken Bjelke 	12-Mar-2004 	111045
%^		111045 - Never set xxx_res_country from csid_iban_country.
%^
%^	 Ken Bjelke	12-Mar-2004	107268
%^		Fill in CHG_BBK and CHG_BBK and CHG_CDT
%^
%^ Ken Bjelke 	03-May-2004	Updates from 1.2
%^
%^ 	Ken Bjelke 	30-Mar-2004
%^		Add the inv_swf_id message to the CREDIT_FAIL paragraph.
%^
%^ 	Ken Bjelke 	14-Apr-2004	112362
%^		Correct CHKSI debit SI processing.
%^
%^	 Ken Bjelke	19-Apr-2004	110911
%^		Skip account lookups when No channel has been determined, but proceed with
%^		Lower Party lookups.
%^
%^	 Ken Bjelke 	29-Apr-2004	112708
%^		Correct "PRE"  rule detection. 
%^
%^ Ken Bjelke 	12-May-2004	95185,97006
%^	Add call to "CUST_BILAT_ACCT" to populate Bilateral account fields
%^	when required.
%^
%^ Ken Bjelke  10-May-2004 	113363
%^	In X1000_CHECK_IBAN_BNP skip REP_BBK_AFORMAT if the bic is to be replaced
%^	with same. (previously was checking cdt_iban flag, removed this qualification).
%^
%^ Ken Bjelke 	27-May-2004 	111980
%^	Ensure Invalid Iban/BBan message is attechs to correct field and 
%^	Displayed on screen. Was missing for Credit Party.
%^
%^ J. Walsh	27-May-2004	113468
%^	Change test Relget_msgcode = 0 to Relget_msgcode = Spaces.
%^
%^ Ken Bjelke 	01-Jun-2004	114029
%^	Call acctsub_cdt_nof in B280_credit_party prior to evaluating and
%^	IBAN/BBAN. Leftover data was being pushed down.
%^
%^ Ken Bjelke 08-Jun-2004	113435
%^	Set cdt_iban flag Only when full IBAN, was being set on valid bbans.
%^
%^
%^ Ken Bjelke	18-Jun-2004 114091
%^	Correct the parsing of the CDTNATIVE original IBAN parameter data.
%^
%^ Ken Bjelke 	23-Jun-2004	114518
%^	Don't attempt to get acount if Channel_Determination has failed
%^	AND the proposed  Channel is RTGS or CLEARING house. This
%^ 	will allow the correct error message to be displayed, instead
%^	of no such account.
%^
%^ Ken Bjelke 	24-Jun-2004	114037
%^	Skip resetting the RTGS/CLEARING account if it is already set.
%^	Was resulting in the overwritting of Autotreive items.
%^
%^ Ken Bjelke 	24-Jun-2004	114599
%^	Use the returned bank from the Channel_record account for
%^	Checks as the cdt_adr_bnk_id.
%^
%^ Ken Bjelke 	01-Jul-2004	114895
%^	Clear the country of res for BNP the same way as CDT when
%^	party has changed. 
%^
%^ Ken Bjelke 3-Aug-2004	112704
%^	Add the csid_irr_acc_type field to enforce Channel_Determination set
%^	account id's.  When Channel_Determination sets an account type it will
%^	be enforced.
%^	
%^ Jan Walsh	03-Sep-2004	116259
%^	Test for user entering a MENU command in REL_GET (called from REL_ACC_FROM_ADR).
%^
%^ Ken Bjelke 	04-Sep-2004 116486
%^	Leave relget_adr_set connected for On AUX pref corrs..
%^
%^ J. Curley	07-Sep-2004	115131 (migrate)
%^	Keep country of residency of bnf when command MOVE NEXT PARTY TO CDT
%^	inserts IBAN bank.  Moved clearing of CDT_RES_COUNTRY to after any
%^ 	insertions are done into para C620_COPY_ADDRESS.
%^	Clear BBK_RES_COUNTRY, IBK_RES_COUNTRY, and IB1_RES_COUNTRY if ids
%^	are changed.
%^	Corrections to BNP_MAILING_COUNTRY.  If BNP_Mailing_country is same
%^	as Change_credit_set value (i.e. was not manually changed), then
%^	Set to BNP_RES_COUNTRY if BNP_BNK_FLG is Y, or to BBK if there is one
%^	or to CDT if neither of the above.  If BBK changes, then change the
%^	BNP_MAILING_COUNTRY.
%^
%^ J. Curley	17-Sep-2004	116032 (migrate)
%^	More PAY_TO Country (aka BNP_MAILING_COUNTRY) changes.  
%^	Only update the BNP_MAILING_COUNTRY if it is spaces, or if the bnp (if a bank)
%^	or Bbk (if present) or cdt if (bnp and bbk didn't apply) changed.  If 
%^	bbk changed, be sure to re-set the bbk res country because the old value
%^	might still be hanging around.  SPR raised because CDT's country was being
%^	used to set BNP_MAILING_COUNTRY in error - found when testing CDTAINS.
%^
%^ J. Curley	20-Sep-2004	116304 (migrate)
%^	Push change flags down when pushing a cdt party down (unless push is for IBAN)
%^
%^ Ken Bjelke 	21-Sep-2004	117102	
%^	leave ter_amt alone when mt103_charge generated.
%^
%^
%^ Ken Bjelke  22-Sep-2004	1.2 WTX and FOR Migrations
%^
%^ 	Ken Bjelke 	11-Aug-2004	114539
%^		Added the new return status for VALIDATE_IBAN. Also use
%^		the Extended ID table to get a country for a call to VALIDATE_IBAN.
%^
%^	 Ken Bjelke 	25-Aug-2004 114539	
%^		More enhancements for 114539. Add a * in front of Incorrect Format in BNP
%^		to allow better error screen error message handling. 
%^
%^ 	Ken Bjelke 	30-Aug-2004	
%^		Split the IVAL$_IBAN_REQ message into Warning and Blocking versions,
%^		IVAL$_IBAN_REQ_W and IVAL$_IBAN_REQ_B.
%^
%^	 Ken Bjelke  31-Aug-2004	116580
%^		Add check of BIC against the IBAN country. Calls table IBAN_BIC_CC_EXC
%^ 		for any allowable mismatched pairs.
%^
%^ 	Ken Bjelke 2-Sep-2004 116708	
%^		Correct overwritting bnp-mailing_country (PAY TO).
%^
%^	 Ken Bjelke 	7-Sep-2004 116564, 116719	
%^		Add *Info messages for the Failure_ignore_is return from Validate_iban.
%^
%^ 	J. Walsh	05-Oct-2004
%^		Remove obsolete references to standing instruction data structures.
%^
%^ J. Curley	22-Dec-2004	118843 (migrate from z_wtx)
%^	Correct Segmentation fault when BNP contained E/RTxxxxx (vs E/RT/xxxxx).
%^	Changed to strip out RT/ by looking for "RT/" at start of ID, and added
%^	defensive code when pulling Csid_party_extype2 out of Csid_id_ws, to
%^	make sure Csid_id_ws_length is > than 2 before subtracting 2.
%^
%^ S. Smith	17-Feb-2005	Spr 120865
%^	Do not clear out the cdt_recon_ref the first time through, only if the
%^	account changes later.
%^
%^ D. Ryan	04-Apr-2005	120992
%^	In the C660_lower_credit paragraph include an additional check for the
%^	status of the csid_iban_party_ws for BBK lookups on REL or AUX.
%^
%^ Ken Bjelke 	22-Apr-2005	122072
%^	Implement FTRSCR$_MULTI_DISAGREE message when multi id's in lower credit
%^	parties do not match REL.
%^
%^ Ken Bjelke  27-Apr-2005	Several Updates
%^
%^		117312
%^		Correct triggers for the REP_BBK_xFORMAT prms on the BBK.
%^
%^ 		117743
%^		Check for Locked_credit prior to checking IBAN in BNP. Do NOT
%^		perform pushup if credit party is locked.
%^
%^ 		117819
%^		Don't null the BNP res_country unless the IDtype has changed.
%^
%^		119839
%^		Inhibit insertion when Cdt party BIC is not valid.
%^
%^ 		118916
%^		Correct case where an On-file is taken to Off-file with NO ID.
%^		PRULE_CHANGE_CREDIT was not getting called.
%^
%^ Ken Bjelke 	28=Apr-2005	More Updates.
%^	 	118267
%^		Correct the handling of Account checking when channel_determination 
%^		has an error. An account not in currency error was being generated when
%^		the Channel Account would have been used.
%^
%^		120543
%^		Remove the setting of Csid_lkup_pend_del for the Credit Party.
%^		This is no longer valid. Change allow REL_GET to check AUX if the
%^		party is pending Del on REL.
%^
%^		121147
%^		Skip the REP_BBKA_FORMAT if Bic was already in address. In case of
%^		Autrv_retry, a second try at insertion was made, resulting in the bnp_bnk_flg
%^		incorrectly being set to Y.
%^
%^		121347
%^		Check that REP_BBK_A is not inserting party already there.
%^
%^ Ken Bjelke 17-Jun-2005	124059
%^	Correct condition where IBAN in RPR, and REP_BBK_AFORMAT trigger could result 
%^	in blanking out the BNP.
%^
%^ C. Crain	14-Jul-2005	124573
%^	Correct X1100_CHECK_IBAN_BNP so the csid_set_chg_flg_ws is set to 
%^	failure when the BIC is on AUX and thus avoid setting the CDT, BBK and
%^	BIC change fields.
%^
%^ J. Walsh	21-Jul-2005	123442
%^	Back out 120992: (lookups on lower credit partys are only done on AUX)
%^	change misleading message.
%^
%^ Ken Bjelke	28-Jul-2005	124657
%^	During an AIN transition from AUX to AUX, some of the flags
%^	were not being set correctly. This has been corrected.
%^
%^ J. Curley	02-Sep-2005	118486 (migrate)
%^	Do not clear out BBK RES COUNTRY when BBK was just entered for the first time
%^	along with the BBK RES COUNTRY.  If the Change_credit_set.bbk is spaces then
%^	they are entering the BBK for the first time.  Also make sure to use the 
%^	correct RELGET_ADR_SET when getting the BBK's Risk Country and Country Code.
%^
%^K. Morrow	17-Oct-2005
%^	Replace old error messaging logic with new logic for 3.0 UI
%^	(ie. calls to "ftrscr_write_error"). Remove FTRSCR fsect.
%^
%^ J. Curley	20-Dec-2005	125769 (migrate)
%^	Clear out credit_set info when last lookup succeeded and current lookup failed
%^	when Ent_credit_set.Flgs3.Cdt_adr_ptr_ok = "T" - i.e. last lookup found 
%^	party on AUX.  Was causing Ent_c_adr_set data to hang around.
%^
%^ Ken Bjelke 	8-Feb-2006	
%^	Converted Creditside Screen to State processing for RELGET re-entry
%^
%^ C. Crain	01-Mar-2006	126253
%^	Modified C520_UPDATE_BNP to set bnp_bnk_flg for E/ids (to cover those 
%^      not on REL/AUX).  Migrated from 2.0.   
%^
%^ C. Crain	14-Mar-2006	126253
%^	Moved code fix for 126253 to B200_BNP_MAP.  In 3.0, C520_UPDATE_BNP is
%^      no longer executed when the BNP party is not on REL/AUX. 
%^
%^ Ken Bjelke	28-Mar-2006	128654
%^	Correct exit from A120_DO_ACCOUNT when NOF and no changes have been made.
%^
%^ Ken Bjelke 	17-Apr-2006
%^	Correct return status variables from RELGET_CONNECT.
%^
%^ Ken Bjelke 	10-May-2006
%^	check for IBAN expansion to correctly set next state in cdt_party processing. 
%^
%^ Ken Bjelke 26-May-2006
%^	
%^	131051 - Correct cross bank AIN processing, detect when a cross bank	
%^		 AIN has been performed and avoid self insertion loop.
%^
%^	131003 - Clear csid_save_cntry_ws each pass to correct any carry over
%^		 in IBAN processing.
%^
%^ D. Ryan	26-Jul-2006	icr_000636
%^	Remove an invalid error message after the ambiguous screen is displayed.
%^	When entering an "@" for the BNF idtype and the credit advice is "FED",
%^	an invalid error message was being displayed once the REL account was
%^	selected.  Pressing the Enter Key removed the error messages and the
%^	Shift/Release message was displayed.  Paragraphs B200_bnp_aux_compl,
%^	B220_bbk_name_compl, B240_ibk_name_compl, B260_ib1_name_compl.
%^
%^ Ken Bjelke	27-JUL-2006	128654
%^	Check for AIN's even when the CDT party is blank. Bank level AIN's
%^	may still be triggered.
%^
%^ Ken Bjelke 		09-Jun-2006	131418
%^	Correct circular AIN detection logic.
%^
%^
%^ Ken Bjelke 	21-Aug-2006	132692
%^	If cdt_acc_2.sec_flg is Information, leave all cdt_acc_2 field intact.
%^
%^ D. Ryan	09-Oct-2006	132840,132451 	icr_000851
%^ 	Lookup data in Lower parties when found on REL and SECwir is set. 
%^	Copied changes from version 2.0 for BNP,BBK,IBK,IB1.  The changes from
%^	#132451 are needed for #132840 and setting the Csid_found_it flag.
%^
%^ Ken Bjelke 	23-Oct-2006	133939 Migrated by S. Smith 1-nov-2006 icr_000899
%^	Add code to ensure that lower parties found on AUX/REL set the xxx_adr_ptr_ok	
%^	flag and pointer. Was not being set when party changed with the Name/Address
%^	still being present.
%^
%^ Ken Bjelke 	13-Sep-2006	132783
%^	If the Credit party contains no data and an CDTAIN is being exceuted,
%^	do not call PUSH_CREDIT_PARTY. Treat as success and just sub in the data.
%^
%^ Ken Bjelke	Migrations updates.
%^
%^	134685
%^	Add code to ensure that lower parties found on AUX/REL set the xxx_adr_ptr_ok	
%^	flag and pointer. Was not being set when party changed with the Name/Address
%^	still being present.
%^
%^	133393
%^	Set currency field to NULL instead of spaces.
%^
%^	133942
%^	Clear the name/address fields on a REP_BBKD to allow for a re-lookup.
%^
%^	133939
%^	Add code to ensure that lower parties found on AUX/REL set the xxx_adr_ptr_ok	
%^	flag and pointer. Was not being set when party changed with the Name/Address
%^	still being present.
%^
%^	132476
%^	Connect rtgs/clearing accounts at same point as CHK/CHQ to allow
%^	for currency location from the Clearing account. Also propagate forward
%^	Cust_creditside Fsect. 
%^	133476
%^	Add additional account connect/Currency setting when Channel changes in
%^	B400_SET_ADVICE. If initial channel was not the final, currency was not 
%^	being returned.
%^
%^ Fred P. Isaacs  28-NOV-2006    134758
%^	Cleaned up post-CDTAIN filtering code to not reject an AIN inserting a
%^	BIC-11 to supersede a BIC-8.
%^
%^ Ken Bjelke 	4-Jan-2007	icr_1137
%^	On DDR's use the party's account, not the clearing.
%^
%^ Ken Bjelke	14-Mar-2007	136996
%^	Set non_ucc_src to True when ent_ftr_set.src_code is spaces.
%^	If this is so, we must be in RPT maint.
%^
%^ Ken Bjelke	21-Mar-2007	132507
%^	Add support for the SWF_DUALID_MATCH6 table. If set to Y in the
%^	owning bank. allow match for dual ID's on the 1st 6 characters
%^	of the BIC.
%^
%^ Fred P. Isaacs  29-Mar-2007	135695
%^	SEND_SECWIRE=N execution parameter on a CDTAIN now turns off ALL
%^	secondary wires.  SEND_SECWIRE=Y turns on secondary wire for 
%^	party being pushed down regardless of SECWIRE_EVAL routine 
%^	results.  If there are multiple CDTAINs with the SEND_SECWIRE
%^	execution parameter set to different results the last one wins.
%^
%^ Fred P. Isaacs  17-Apr-2007    137413
%^	Due to certain complex prule environments, detect 
%^ 	MTS$SUBPARTICIPANT_CDTAIN parameter in message and override 
%^	Lock_cdt_party_ls argument for CDTAIN execution since we are in a
%^	Target subparticipant and need to find our participant regardless of
%^	any overrides.
%^
%^ Ken Bjelke 	26-Apr-2007	137904
%^	Correct the duplicate AIN detection logic, Was declaring more 
%^	as duplicates then it should.
%^
%^
%^ Ken Bjelke 	4-May-2007	137630
%^	Refine duplicate AIN detection when cross bank is involved. Was
%^	causing EXC with pref_corr_loop when preventable.
%^
%^ Cynthia Crain   08-May-2007    133448
%^	Qualifed REP_BBK_DFORMAT so replacement occurs when name1 is present
%^      and id is not present and REP_BBK_AFORMAT so replacement does not
%^	occur if the S idtype's id contains two ids.
%^
%^
%^ Ken Bjelke	23-May-2007	136705
%^	In LOWER_CREDIT set csid_ovr to ? instead of * on Soft Failures. Trap
%^	was resulting on unusual cases of Mismatched BIC/UID both on AUX.
%^
%^ Fred P. Isaacs  30-May-2007    138638
%^	Move logic to detect MTS$SUBPARTICIPANT_CDTAIN parameter in message 
%^	and override Lock_cdt_party_ls argument for CDTAIN execution to after
%^	CHANNEL_DETERMINATION call.
%^
%^ J. Walsh	29-Aug-2007	135695
%^	Add call to CUST_SECWIRE_SAVE prior to SECWIRE_EVAL call.
%^
%^ J. Walsh	04-Oct-2007	135695
%^	A call to CUST_SECWIRE_SAVE must also be made after creditside has
%^	updated secwire flags.
%^
%^ Fred P. Isaacs 25-Oct-2007
%^	135695  Corrected logic to handle MTS$SEND_SECWIRE parameter value 
%^		of N on a CDTAIN.
%^	141269  Missed a code branch -- inserted another check on lock_cdt_party
%^		to unlock it if we are doing TGT.
%^	141702 	Restore calls to CUST_SECWIRE_SAVE after secwire flags are 
%^		updated.
%^
%^ Fred P. Isaacs   20-December-2007	141620 CR 385
%^	Added call to CUST_PAYTO_NETWORK() routine to handle TGT2 insertions.
%^
%^ Ken Bjelke		21-Aug-2008	CR4157
%^	Completely remove 136705 changes. Will allow lower credit to
%^	process names properly.
%^
%^
%^ Ken Bjelke - Migrate CR5125
%^ 	Tom Carroll 	22-Sep-2008	CR2559
%^		Do not set the BBK_RES_COUNTRY when ID and IDTYPE are missing.
%^
%^ Fred P. Isaacs  22-JAN-2009    CR6039
%^ 	Added calls to CUST_EXTENDED_ID_QUAL to CHIPS qualification code for 
%^	each lower credit party.
%^
%^
%^ Joseph Carey		10-Feb-2009	CR6612 Migrate from 2.0 --> Joseph Carey 03-Dec-2008 CR5935 
%^	Update code that populates the Bnp_bei_flag.
%^	This code was not cognizant of all the Swf subtypes that
%^	indicate a BEI.  The SWIFT handbook for 2008 lists
%^	six Swift subtypes that indicate that a BIC is really a BEI:
%^	    BEID, CORP, MCCO, SMDP, TESP, TRCO
%^
%^ B. Lanza		11-Mar-2009	CR7181
%^	Do not clear the cdt_acc_2 "sec" and cdt_acc_3 "ter" fields
%^	when preadvise has already been done.	
%^
%^ Ken Bjelke 		22-Apr-2009	CR9255
%^	Break csid_adr_set prior to EQUATE'ing to avoid trap.
%^
%^ J. Walsh		02-Jun-2009	MR-09-02
%^	Add call to SET_PSD_CODES just before leaving so that
%^	PSD codes are assigned for all messages.
%^
%^ Ken Bjelke		30-Jun-2009	CR10395
%^	When Credit party goes from On-Rel to Off rel/On-AUX
%^	Set the Credit bank to the Owning bank. 
%^
%^ B. Lanza		10-Jul-2009	CR10438
%^	In ENT, entered cdt id and bnf and used "Move cdt to bnf" command
%^	without pressing <enter>, party moves down, then enter cdt id and
%^	press <enter>. It was not setting the Secondary wire flag.
%^	SECWIRE_EVAL was not being called. 
%^	Change in B220_BBK_INIT_LKUP to set bbk_init_secwir as next state
%^	when exiting early, rather than bnp_init_lkup. 
%^
%^ Fred P. Isaacs  27-Jul-2009	CR12399
%^	Clear our field containing COR/CDTAIN selector between uses, preventing
%^	check against "CORAIN".
%^
%^ Ken Bjelke	28-Jul-2009	CR12472 / 12720
%^	Check for Bank presence when parsing BIC for IBAN/BIC consistency check.
%^	Could result in mismatch and incorrect error.
%^
%^ B. Lanza	12-Aug-2009	CR12949
%^	Re-lookup a pushed down UID to allow it to qualify.
%^	
%^ Ken Bjelke	25-Aug-2009	CR12090
%^	Correct checking for Secwir Eval call. 
%^
%^ Tom Carroll	03-Nov-2009	14957
%^	Corrected an IF statement that was causing call to SET_NOF_CDT_ACCOUNT 
%^	to occur when the account was actually on file.
%^
%^ Ken Bjelke	17-Dec-2009	tc15622
%^	Back out changes from 14957
%^
%^ Ken Bjelke	22-Dec-2009	tc15646
%^	add setting of csid_know_acc_id when locating clearing account.
%^	Also, add failure_is in csid_chan_imposed_acct to the IF modified in 14597/15622
%^
%^ Ken Bjelke 	6-Jan-2010	tc15812
%^	Back out 15646 and apply 15225.  This Corrects trap and
%^	also corrected Charge Flag issue. 
%^
%^ End Revision History
%^******************************************************************************

%Module CREDITSIDE_SCREEN;

%^******************************************************************************
%^*****************************************************************************
%^                                                                            *
%^ Paragraphs in this procedure are labeled as follows:                       *
%^                                                                            *
%^	A100_MAIN	     Subroutine entry point, dispatch, and return
%^      B200_BNP	     Looks up Beneficiary Party.
%^      B220_BBK	     Looks up Beneficiary Party's Bank.
%^      B240_IBK	     Looks up Intermediary BanK.
%^      B260_IB1	     Looks up First Intermediary BanK.
%^      B280_CDT_PARTY    Looks up Credit Party and sets up message.
%^	B320_SET_ADDRESS     Sets up message credit party from address info.
%^	B340_GET_ACCOUNT_SET Selects and connects account from party address.
%^	B360_SET_ACCOUNT     Sets up message credit party from account info.
%^	B400_SET_ADVICE	     Sets advice method for this credit party.
%^	B420_GET_NEWPARTY    Tries to get a pushdown/substitute party.
%^	B440_SCAN_DEBIT_SIS  Scans for debit SIs.	
%^      B450_SCAN_DEBIT_AINS Scans for debit AINs.
%^      C520_UPDATE_BNP      Updates BNP from Csid_party_id
%^	C540_UPDATE_BBK      Updates BBK from Csid_party_id
%^	C560_UPDATE_IBK      Updates IBK from Csid_party_id
%^	C580_UPDATE_IB1      Updates IB1 from Csid_party_id
%^	C600_CREDIT_FAIL     Cleans up after credit party lookup failure.
%^	C620_COPY_ADDRESS    Copies address info into credit party.
%^	C640_PUSH_CREDIT     Pushes current credit party down.
%^      C650_LOOKUP_BBK_ADDRESS Looks up BBK REL address
%^	C660_LOWER_CREDIT    Looks up a lower creditside party
%^      C670_CHECK_COMMON_UID Check for case of a COMMON UID and SWIFT TID.
%^	C730_GET_PID_SUFFIXES  Get P ID Suffixes for the Spec_pref_corr Rtn
%^	D100_BCC_LKUP_BIC    Replaces BCC with BIC based on config	
%^	D700_NOF_CDT_BANK    Corrects bank info for NOF credit party.
%^	D720_CDT_SWF_TO_ABA  Converts NOF SWIFT ID into an ABA number.
%^	D740_MATCH_IDS_TO_REL  Matches lower credit party id's to REL address
%^	D750_MATCH_EXTENDED_IDS Matches any Extended IDs to Supplement IDs
%^	D760_LC_SWF_TO_ABA    Uses lower credit party SWIFT ID as index to XREF
%^	X920_INFO_MEMO	     Writes an informational memo.
%^                                                                            *
%^*****************************************************************************

%linkage
01  Credit_currency_ls	  	%Str(3);
01  Message_amount_ls	  	%Amount;
01  Message_currency_ls  	%Str(3);
01  Credit_account_ls	  	%Str(34);
01  Is_payment_ls	  	%Long;
01  Xbank_account_ok_ls	  	%Long;
01  Cdt_acc_type_ls  	  	%Str(1);
01  Do_chips_qualif_ls	  	%Long;
01  Is_rptv_lookup_ls	  	%Long;
01  Lock_cdt_party_ls	  	%Long;
01  Special_fee_key_ls	  	%Str(1);
01  Cdt_acc_changed_ls	  	%Long;
01  Credit_changed_ls	  	%Long;
01  IB1_changed_ls	  	%Long;
01  IBK_changed_ls	  	%Long;
01  BBK_changed_ls	  	%Long;
01  BNP_changed_ls	  	%Long;
01  Adv_changed_ls	  	%Long;
01  Init_debit_currency_ls 	%Str(3);
01  Debit_currency_ls	  	%Str(3);
01  Dbt_acc_changed_ls	  	%Long;
01  Debit_changed_ls	  	%Long;
01  Debit_account_ls	  	%Str(34);
01  Dbt_acc_type_ls  	  	%Str(1);
01  Nochange_bank_ls	  	%Long;
01  Lock_dbt_party_ls	  	%Long;
01  Debit_fee_key_ls	  	%Str(1);
01  Dbt_internal_ls	  	%Long;
01  Dbt_account_okay_ls	  	%Long;
01  Dbt_not_suspect_ls	  	%Long;
01  Debit_status_ls	  	%Boolean;
01  Msg_bank_changed_ls	  	%Long;
01  Dbt_errmemo_count_ls  	%Long;
01  Dbt_currency_found_ls 	%Str(3);
01  Cdt_currency_found_ls 	%Str(3);
01  Cdt_account_okay_ls	  	%Long;
01  Credit_depth_ls 	  	%Long;
01  Advice_parties_ls	  	%Long;
01  CHK_SI_relevant_ls	  	%Long;
01  Ib1_qualified_ls	  	%Long;
01  Ibk_qualified_ls	  	%Long;
01  Bbk_qualified_ls	  	%Long;
01  Bnp_qualified_ls	  	%Long;
01  Secwire_dest_state_ls 	%Long;
01  Cdt_not_suspect_ls	  	%Long;
01  No_beneficiary_ls	  	%Long;
01  Cdt_Errmemo_count_ls  	%Long;
01  Creditside_screen_ls	%Boolean;

%Procedure using Credit_currency_ls, Message_amount_ls, Message_currency_ls, 
	Credit_account_ls, Is_payment_ls, Xbank_account_ok_ls, Cdt_acc_type_ls,
 	Do_chips_qualif_ls, Is_rptv_lookup_ls, Lock_cdt_party_ls,
	Special_fee_key_ls, Cdt_acc_changed_ls, 
	Credit_changed_ls, IB1_changed_ls, IBK_changed_ls, BBK_changed_ls, 
	BNP_changed_ls, Adv_changed_ls, Init_debit_currency_ls, 
	Debit_currency_ls, Dbt_acc_changed_ls, Debit_changed_ls, 
	Debit_account_ls, Dbt_acc_type_ls, Nochange_bank_ls,
	Lock_dbt_party_ls, Debit_fee_key_ls, Dbt_internal_ls, 
	Dbt_account_okay_ls, Dbt_not_suspect_ls, Debit_status_ls, 
	Msg_bank_changed_ls, Dbt_errmemo_count_ls, Dbt_currency_found_ls, 
	Cdt_currency_found_ls, Cdt_account_okay_ls, 
	Credit_depth_ls, Advice_parties_ls, CHK_SI_relevant_ls, 
	Ib1_qualified_ls, Ibk_qualified_ls, Bbk_qualified_ls, Bnp_qualified_ls,
	Secwire_dest_state_ls, Cdt_not_suspect_ls, No_beneficiary_ls, 
	Cdt_errmemo_count_ls
    RETURNING  Creditside_screen_ls.
%^*****************************************************************************

%^*****************************************************************************
A100_MAIN.
	Set Success_is in Creditside_screen_ls to true.
%^ Universal Reset
	Set Failure_is in Resolve_ambiguous to True.

%^ In case CREDITSIDE_SCREEN_EQUATE was used to protect a Relget_index selection
%^ from getting clobbered by debitside, call CREDITSIDE_SCREEN_RESTORE to
%^ to look for a Relget_index connection that might need to be restored.

	Call "CREDITSIDE_SCREEN_RESTORE".


	Perform Until Success_is in resolve_ambiguous  Or
		      Complete_is in Cdt_screen_state Or
		      Error_is    in Cdt_screen_state Or
		      Menu_is 	  in Cdt_screen_state

	    EVALUATE True

		When	Init_is in Cdt_screen_State
			 Perform B100_CDT_SCREEN_INIT Thru
				 B100_CDT_SCREEN_INIT_END
			%^ Display "Cdt screen init"

		When Cdt_lkup in Cdt_screen_state
			Perform B280_Cdt_lkup Thru
				B280_Cdt_lkup_end
			%^ Display "Cdt lkup"

		When Cdt_index_conn1 in Cdt_screen_state
		     	Perform B280_CDT_INDEX_CONN1 Thru
				B280_CDT_INDEX_CONN1_END
			%^ Display "Cdt index Conn"

		When Cdt_index_conn2 in Cdt_screen_state
		     	Perform B280_CDT_INDEX_CONN2 Thru
				B280_CDT_INDEX_CONN2_END
			%^ Display "Cdt Index Conn 2"

		When Cdt_map in Cdt_screen_state
			Perform B280_cdt_map Thru
				B280_Cdt_map_end

			%^ Display "Cdt Map"

%^ Use these states to simulate a Perform Loop

		When Ain_processing in Cdt_screen_state		%^ If pref_corr is blank, Set ain_complete and Exit
			Perform Ain_processing_Init thru
				Ain_processing_Init_end

			%^ Display "Ain Processing 1"

		When Ain_Index_Conn1 in Cdt_screen_state
			Perform Ain_index_Conn_init 	Thru
				Ain_index_Conn_init_end
			%^ Display "Ain Conn 1"

		When Ain_processing2 in Cdt_screen_state
			Perform AIN_PROCESSING_CONT Thru
				Ain_processing_cont_end
			%^ Display "Ain Processing 2"


		When Ain_Index_conn2 in Cdt_screen_state	
			Perform Ain_Index_Conn_Compl 	Thru
				Ain_Index_Conn_Compl_end

			%^ Display "Ain Index Conn 2"

%^ AIN PROCESSING LOOK END

		When Ain_Proc_Compl in Cdt_screen_state		%^ Sets flag AIN_PROCESSING complete
			Perform Ain_Processing_Compl 	Thru
				Ain_Processing_Compl_end

			%^ Display "Ain Processing Compl"

		When   	Bnp_init_Lkup
			Perform B200_Bnp_init_lkup Thru
				B200_Bnp_init_lkup_end
			%^ Display "Bnp Init"


		When	Bnp_Aux_lkup
			Perform B200_Bnp_Aux_lkup Thru
				B200_Bnp_Aux_lkup_end
			%^ Display "Bnp Aux Lkup"


		When	Bnp_Aux_conn
			Perform B200_Bnp_Aux_conn Thru
				B200_Bnp_Aux_conn_End
			%^ Display "Bnp Aux Conn"


		When	Bnp_Aux_compl
			Perform B200_bnp_Aux_compl Thru
				B200_bnp_Aux_compl_end
			%^ Display "Bnp Aux Compl"

		When	Bnp_lookup
			Perform B200_bnp_Lookup Thru
				B200_bnp_Lookup_End
			%^ Display "Bnp Lookup"

		When	Bnp_index_conn
			Perform B200_bnp_Index_Conn Thru
				B200_bnp_Index_Conn_end
			%^ Display "Bnp Index Conn"


		When	Bnp_map
			Perform B200_Bnp_Map Thru
				B200_Bnp_Map_end
			%^ Display "Bnp Map"


		When   	Bbk_init_Lkup
			Perform B220_Bbk_init_lkup Thru
				B220_Bbk_init_lkup_end
		When	Bbk_name_lkup
			Perform B220_Bbk_name_lkup Thru
				B220_Bbk_name_lkup_end
		When	Bbk_name_conn
			Perform B220_Bbk_name_conn Thru
				B220_Bbk_name_conn_end
		When	Bbk_name_compl
			Perform B220_Bbk_Name_compl Thru
				B220_Bbk_Name_compl_end
		When	Bbk_lookup
			Perform B220_Bbk_Lkup Thru
				B220_Bbk_Lkup_End
		When	Bbk_index_conn
			Perform B220_Bbk_Index_Conn Thru
				B220_Bbk_Index_Conn_end
		When	Bbk_map
			Perform B220_Bbk_Map Thru
				B220_Bbk_Map_end

		When 	Bbk_init_secwir
			Perform A120_BBK_INIT_SECWIR thru
				A120_BBK_INIT_SECWIR_END

		When	Bbk_secwir_conn
			Perform  BBK_Secwir_conn1 Thru
				 BBK_Secwir_conn1_end

		When 	Secwir_proc
			Perform Secwir_processing  Thru
				Secwir_processing_end



		When   	Ibk_init_Lkup
			Perform B240_Ibk_init_lkup Thru
				B240_Ibk_init_lkup_end
		When	Ibk_name_lkup
			Perform B240_Ibk_name_lkup Thru
				B240_Ibk_name_lkup_end
		When	Ibk_name_conn
			Perform B240_Ibk_name_conn Thru
				B240_Ibk_name_conn_end
		When	Ibk_name_compl
			Perform B240_Ibk_Name_compl Thru
				B240_Ibk_Name_compl_end
		When	Ibk_lookup
			Perform B240_Ibk_Lkup Thru
				B240_Ibk_Lkup_End
		When	Ibk_index_conn
			Perform B240_Ibk_Index_Conn Thru
				B240_Ibk_Index_Conn_end
		When	Ibk_map
			Perform B240_Ibk_Map Thru
				B240_Ibk_Map_End

		When   	Ib1_init_Lkup
			Perform B260_Ib1_init_lkup Thru
				B260_Ib1_init_lkup_end
		When	Ib1_name_lkup
			Perform B260_Ib1_name_lkup Thru
				B260_Ib1_name_lkup_end
		When	Ib1_name_conn
			Perform B260_Ib1_name_conn Thru
				B260_Ib1_name_conn_end
		When	Ib1_name_compl
			Perform B260_Ib1_Name_compl Thru
				B260_Ib1_Name_compl_end
		When	Ib1_lookup
			Perform B260_Ib1_Lkup Thru
				B260_Ib1_Lkup_End
		When	Ib1_index_conn
			Perform B260_Ib1_Index_Conn Thru
				B260_Ib1_Index_Conn_end
		When	Ib1_map
			Perform B260_Ib1_Map Thru
				B260_Ib1_Map_end

		When Got_Credit in Cdt_screen_state		%^ Cdt party complete, lower credit and account logic
			Perform A110_GOT_CREDIT_1 	Thru
				A110_GOT_CREDIT_1_END
			%^ Display "Got Credit 1"


		When Do_account in Cdt_screen_state
			Perform A120_DO_ACCOUNT 	Thru
				A120_DO_ACCOUNT_END
			%^ Display "Do Account"

		When Do_account_compl in Cdt_screen_state
			Perform A120_DO_ACCOUNT_COMPL 	Thru
				A120_DO_ACCOUNT_COMPL_END
			%^ Display "Do Account Compl"


		When  Account_index_conn In Cdt_screen_state
			Perform	A120_ACCOUNT_CONN 	Thru
				A120_ACCOUNT_CONN_END

		When Got_credit_2 in Cdt_screen_state
			Perform A110_GOT_CREDIT_2 	Thru
				A110_GOT_CREDIT_2_END
			%^ Display "Got Credit 2"

		When Got_credit_conn in Cdt_screen_state
			Perform A110_GOT_CREDIT_CONN	Thru
				A110_GOT_CREDIT_CONN_END

		When Got_credit_Compl in Cdt_screen_state
			Perform A110_GOT_CREDIT_COMPL	Thru
				A110_GOT_CREDIT_COMPL_END
			%^ Display "Got Credit Compl"

		When Completion_proc in Cdt_screen_state
			Perform A110_COMPLETTION_PROCESSING thru
				A110_COMPLETION_PROCESSING_END
			%^ Display "Completion Processing"


	    END-EVALUATE
	END-PERFORM.

%^ Always set PSD codes before leaving
        Call "SET_PSD_CODES" using
	    by content "ENT"
            returning Sts_ws.

	%^ Display "Exiting Program"
	
	If Success_is in Resolve_Ambiguous
	Then
		%^ Exit Program
		%^Move Cdt_screen_state to Debit_completed_ls
		Go to A100_MAIN_END
	End-if.

A100_MAIN_EXIT.

        Set Init_is in Cdt_screen_state to True.
	%^	Move dbt_screen_state to Debit_completed_ls.	

A100_MAIN_END.
 	%EXIT PROGRAM.



%^
%^ PUSHDOWN PROCESSING LOOP
%^
%^
AIN_PROCESSING_INIT.

	If (Csid_credit_changed  = 0 ) 
	Then
		Set Got_Credit in cdt_screen_state to True
		Go to AIN_PROCESSING_INIT_END
	END-IF

	If  (Idtype of Csid_pref_corr_rec = SPACE )
		          OR (Success_is in Csid_push_error)
			  OR (Lock_cdt_party_ls NOT = 0 )
	Then	%^ Take us Out of the loop
		Set Got_Credit in cdt_screen_state to True
		Go to AIN_PROCESSING_INIT_END
	End-if

	If Success_is in Initial_Ain
	Then
		Move 5 to Csid_push_count
		%Beg  Relget_msgcode = NULL;  %End
		Set Failure_is in Initial_Ain to True
	End-if


%^	    Perform UNTIL (Idtype of Csid_pref_corr_rec = SPACE )
%^		          OR (Success_is in Csid_push_error)
%^			  OR (Lock_cdt_party_ls NOT = 0 )

	If (Csid_push_count <= 0 )
	Then	%^ too many pushed
		    %Beg
		    screen_field_ws = "credit.cdt_typ.cdt_id";
		    error_mnemonic_ws = "FTRSCR$_INV_AIN_SI";
		    %End
	            call "FTRSCR_WRITE_ERROR" using
	              by reference screen_field_ws
		      by reference error_mnemonic_ws
	    	    %Beg
		    Csid_compose ^OUT(Csid_info_memo),
		            "Preferred correspondent loop?? for "
			     Csid_pref_corr_rec, / ;
		    %End	
		    Perform X920_INFO_MEMO through X920_INFO_MEMO_END
		    Add 1 to Cdt_errmemo_count_ls
		    Set Failure_is in Creditside_screen_ls to true
		    Move ZERO to Cdt_not_suspect_ls
		    Set Success_is in Csid_push_error to TRUE
		    Set Error_is in Cdt_screen_state to True
		    Go To AIN_processing_init_end				%^ Why stay, shouldn't this just exit
	End-if.

	Subtract 1 from Csid_push_count
	Move SPACES to Csid_acc_id_ws
	%ACE_IS Ent_c_adr_set connected giving Csid_conn_stat;
        %Beg  Csid_acc_id_ws = Csid_pref_corr_rec.idkey ;  %End
        Set CDT in Relget_title_flag to TRUE
        Move Spaces to Csid_lkup_pend_del
        %Beg  Csid_next_function = Menu_next_function;  %End

        Call "REL_GET" USING
                    By reference Idtype of Csid_pref_corr_rec
                    By reference Csid_acc_id_ws
                    By reference Csid_acc_id_ws_length
		    by reference Csid_lkup_pend_del
                  RETURNING Csid_ret_stat

%^
%^ CACHE all results/flags/pointers, use to restore at point of repeating the lookup
%^


	If Success_is in Relget_ambiguous_wf
	Then
		Set Success_is  	in Resolve_Ambiguous to True
		Set Ain_Index_conn1 	in Cdt_screen_state  to True
		Go to AIN_PROCESSING_INIT_END
	End-if.


	If Relget_reject_flag = "M" Or
	  (Csid_next_function not = Menu_next_function)
	Then
		Set Menu_is in cdt_screen_state to True
		Go to Ain_Processing_INIT_end
	End-if.


	Set Ain_processing2 in Cdt_screen_state to True.

AIN_PROCESSING_INIT_END.
	EXIT.

AIN_INDEX_CONN_INIT.
%^
	Call "RELGET_CONNECT" USING 
	    by reference Csid_lkup_pend_del
	  RETURNING Csid_ret_stat.

	Set AIN_PROCESSING2 in Cdt_screen_state to True.

AIN_INDEX_CONN_INIT_END.
	EXIT.
%^
%^ NEED A SPLIT FOR PROCESSING
%^
AIN_PROCESSING_CONT.
	If Csid_lkup_pend_del = "T"
	Then
		    %Beg
		    screen_field_ws = "credit.cdt_typ.cdt_id";
		    error_mnemonic_ws = "VMSG$_ADR_PEND_DEL";
		    %End
	            call "FTRSCR_WRITE_ERROR" using
	              by reference screen_field_ws
		      by reference error_mnemonic_ws
                    Add 1 to Cdt_errmemo_count_ls
		    Set Success_is in Csid_credit_pend_del to TRUE
		    Set Failure_is in Creditside_screen_ls to TRUE
	End-if.


        If (PD_enqueue_to_server of Menu_cfg = "T")
		   AND (Relget_msgcode = Vmsg_lookup_fail_wc)
		   AND (Cdt_ovr of Cdt_typ of Ent_credit_set NOT = "*")
	THEN
%^ We have an ambiguous address - write memo and let calling routine
%^  route message.
        	%Beg
                    Csid_compose ^OUT(Csid_info_memo)
                        "Ambiguous Address for Account: ",
			 Ent_Credit_Set.Cdt_Typ.Cdt_Idtype, "/",
                         Ent_Credit_Set.Cdt_Typ.Cdt_Id, / ;
                %End
                Move ZERO to Cdt_not_suspect_ls
                Perform X920_INFO_MEMO through X920_INFO_MEMO_END
         End-if.


        If (Success_is in Csid_ret_stat  )
       		AND (Cdt_ovr of Cdt_typ of Ent_credit_set = SPACE )
		And (Cdt_idtype of Ent_credit_set = Idtype of csid_pref_corr_rec)
		And (Cdt_id of Ent_credit_set = Idkey of Csid_pref_corr_rec)
		AND (Csid_corr_derivation = "REL")
		%^ same address may be both cdt and next parties If ID is different
        THEN
		%^ With a Bank level AIN, this case is OK, jut leave the push_error set
		%^ to skip performing the PUSHDOWN
                Set Success_is in Csid_push_error to TRUE
        END-IF

	If (Failure_is in Csid_push_error )
	Then
	    If (PUSHDOWN in Csid_do_pushdown   )
	    Then
		%ACE_IS Relget_adr_set connected giving Csid_conn2_stat;
	        If (Success_is in Csid_conn2_stat)
		    %Beg
		    BREAK: Csid_adr_set ;
        	    Relget_adr_set EQUATE: Csid_adr_set(NOMOD) ;
		    BREAK: Relget_adr_set ;
		    %End
		END-IF

		%ACE_IS Ent_c_adr_set connected giving Csid_conn_stat;
		If (Success_is in Csid_conn_stat)
		    %Beg
			    Ent_c_adr_set EQUATE: Relget_adr_set(NOMOD) ;
			    BREAK: Ent_c_adr_set;
	           %End
		ELSE
		    Move 0 to Rel_id of Relget_adr_set
		END-IF

	        Perform C640_PUSH_CREDIT through C640_PUSH_CREDIT_END
		If Success_is in Csid_push_error then
		    %^   Perform A110_GOT_CREDIT through A110_GOT_CREDIT_END
		    Set Got_Credit in Cdt_screen_state to True
		    GO TO Ain_processing_cont_end		%^A100_MAIN_END
		END-IF

	        If (Success_is in Csid_didansi_ws)
                    If ( csid_prm_secwir_ws = "Y" )
		        If ((Bbk_secwir of BBK of Ent_credit_set NOT = "Y" )
			    AND (Ibk_secwir of IBK of Ent_credit_set NOT = "Y")
			    AND (Ib1_secwir of IB1 of Ent_credit_set NOT = 
									"Y" ))
			THEN
%^ Si on pushed party requests a secondary wire.
		   	    Evaluate Csid_pushed_credit
		      	      WHEN 1
				%Beg
		          	Ent_credit_set.Ib1.Ib1_secwir = "Y" ;
		          	Csid_compose ^OUT(Csid_info_memo)
				         "Secondary wire to IB1 set by AIN", / ;
		          	%End
    		          	Perform X920_INFO_MEMO through 
							 X920_INFO_MEMO_END
			  	Move 1 to Ib1_changed_ls
				Call "CUST_SECWIRE_SAVE"

		      	      WHEN 2
		          	%Beg
		          	Ent_credit_set.Ibk.Ibk_secwir = "Y" ;
    		          	Csid_compose ^OUT(Csid_info_memo)
				         "Secondary wire to IBK set by AIN", / ;
		          	%End
  		          	Perform X920_INFO_MEMO through 
							     X920_INFO_MEMO_END
			  	Move 1 to Ibk_changed_ls
				Call "CUST_SECWIRE_SAVE"

			      WHEN 3
		          	%Beg
		          	Ent_credit_set.Bbk.Bbk_secwir = "Y" ;
    		          	Csid_compose ^OUT(Csid_info_memo)
				         "Secondary wire to BBK set by AIN", / ;
		          	%End
    		          	Perform X920_INFO_MEMO through 
							  X920_INFO_MEMO_END
			  	Move 1 to Bbk_changed_ls
				Call "CUST_SECWIRE_SAVE"

		      	      WHEN Other
                               	%Beg
		    		screen_field_ws = "credit.bnp.bnp_idtype";
		    		error_mnemonic_ws = "FTRSCR$_NOTSECWIR";
	    		        %End
               		        call "FTRSCR_WRITE_ERROR" using
              		          by reference screen_field_ws
	      		          by reference error_mnemonic_ws
			        %Beg
    		                Csid_compose ^OUT(Csid_info_memo)
       				    "AIN cannot send secondary wire ",
				    "to pushed-down credit party", / ;
		                %End
	          		Perform X920_INFO_MEMO through 
							X920_INFO_MEMO_END
			  	Add 1 to Cdt_errmemo_count_ls
    		          	Move ZERO to Cdt_not_suspect_ls
                               	Set Failure_is in Creditside_screen_ls to true
	            	    END-EVALUATE
			END-IF
			Move SPACE to Csid_prm_secwir_ws
		    ELSE
		        If (Csid_prm_secwir_ws = "N")
%^ Si on pushed party requests a secondary wire.
		           Evaluate Csid_pushed_credit
		             WHEN 1
			       %Beg
		               Ent_credit_set.Ib1.Ib1_secwir = "N" ;
    		               Csid_compose ^OUT(Csid_info_memo)
				  "Secondary wire to IB1 suppressed by AIN", / ;
		               %End
    		               Perform X920_INFO_MEMO through 
							   X920_INFO_MEMO_END
				Call "CUST_SECWIRE_SAVE"

		              WHEN 2
		                %Beg
		                Ent_credit_set.Ibk.Ibk_secwir = "N" ;
    		                Csid_compose ^OUT(Csid_info_memo)
				  "Secondary wire to IBK suppressed by AIN", / ;
		                %End
    		                Perform X920_INFO_MEMO through 
							     X920_INFO_MEMO_END
				Call "CUST_SECWIRE_SAVE"

		              WHEN 3
		                %Beg
		                Ent_credit_set.Bbk.Bbk_secwir = "N" ;
    		                Csid_compose ^OUT(Csid_info_memo)
				  "Secondary wire to BBK suppressed by AIN", / ;
		                %End
    		                Perform X920_INFO_MEMO through 
							     X920_INFO_MEMO_END
				Call "CUST_SECWIRE_SAVE"

		              WHEN Other
                               	%Beg
		    		screen_field_ws = "credit.bnp.bnp_idtype";
		    		error_mnemonic_ws = "FTRSCR$_NOTSECWIR";
	    		        %End
               		        call "FTRSCR_WRITE_ERROR" using
              		          by reference screen_field_ws
	      		          by reference error_mnemonic_ws
				%Beg
  		                Csid_compose ^OUT(Csid_err_memo)
       				  "AIN cannot suppress secondary wire ",
				    "to pushed-down credit party", / ;
		                %End
		          	Perform X920_INFO_MEMO through 
							X920_INFO_MEMO_END
			  	Add 1 to Cdt_errmemo_count_ls
		          	Move ZERO to Cdt_not_suspect_ls
                               	Set Failure_is in Creditside_screen_ls to true
	                   END-EVALUATE
			   Move SPACE to Csid_prm_secwir_ws
		        END-IF
		    END-IF
		END-IF

		%Beg  BREAK: Relget_adr_set ;  %End
                If (Success_is in Csid_conn2_stat)
		    %Beg
		  	  Csid_adr_set EQUATE: Relget_adr_set(NOMOD) ;
		         	  Ent_credit_set.flgs3.cdt_adr_ptr_ok = "T"  ;
		    	  BREAK: Csid_adr_set ;
		    %End
		    If Rel_id of relget_adr_set = 0
		    Then	%^ AUX hit
			 Move Vmsg_dat_notonfile_wc  to  Relget_msgcode
		    End-if
		ELSE
%^ We must repeat the lookup.
%^
%^ As a repeat lookup, need we check for ambiguous results, Probably should cache the address and
%^ just re-connect
%^
%^ I can not see a case where this would suceed under 1.2 and up, To get here without an address set,
%^ we require a totally NOF pref corr. So, let's just load up the ID fields, and set failure to csid_ret_stat
%^
	        	    %Beg
				    Csid_clip_compose ^OUT(Csid_acc_id_ws)
					Csid_pref_corr_rec.idkey, / ;
			    %end
			    Set Failure_is in Csid_ret_stat to True
		            Set CDT in Relget_title_flag to TRUE
		            Move Spaces to Csid_lkup_pend_del
		       	    %Beg  Csid_next_function = Menu_next_function;  %End
	      		    Call "REL_GET" USING 
			        By reference Idtype of Csid_pref_corr_rec
			        By reference Csid_acc_id_ws
		       	        By reference Csid_acc_id_ws_length
		    		by reference Csid_lkup_pend_del
		              RETURNING Csid_ret_stat

			    If Success_is in Relget_ambiguous_wf
			    Then
				Set Success_is  	in Resolve_Ambiguous to True
				Set Ain_Index_Conn2 	in Cdt_screen_state  to True
				Go to AIN_PROCESSING_CONT_END
			    End-if

	    		    If ( Relget_reject_flag = "M" )  Or
			       ( Csid_next_function not = Menu_next_function )
			    Then
				Set Menu_is in Cdt_screen_state to True
				Go to AIN_PROCESSING_CONT_END
			    End-if
		%^ NOTE: This is a repeat lookup so memos should already be posted and
		%^       error messages should have already been set.
		END-IF
	ELSE
		%Beg  BREAK: Ent_c_adr_set ;  %End
	END-IF.

	Set Ain_proc_Compl in Cdt_screen_state to True.

AIN_PROCESSING_CONT_END.
	EXIT.

AIN_INDEX_CONN_COMPL.
%^
	Call "RELGET_CONNECT" USING 
	    by reference Csid_lkup_pend_del
	  RETURNING Csid_ret_stat.

	Set Ain_proc_compl in Cdt_screen_state to True.

AIN_INDEX_CONN_COMPL_END.
	EXIT.


AIN_PROCESSING_COMPL.
%^
%^
%^
	If (Failure_is in Csid_push_error )
	Then
		%^ Moved address copy down
		If (Relget_return_key NOT = SPACES )
		Then
		        %Beg
		        Csid_parse ^IN(Relget_return_key), Csid_return_key, 
				^SPACE, / ;
		        %End
		 ELSE
		        %Beg  Csid_return_key = Csid_acc_id_ws ;  %End
		 END-IF	

		 If (Csid_id_bank_ws = SPACES )
		        %Beg
			Csid_id_bank_ws = Ent_ftr_set.Loc_info.Bank ;
			%End
		 END-IF

 	         If (Failure_is in Csid_ret_stat ) Or (Relget_msgcode = Vmsg_dat_notonfile_wc )
 		 Then %^ FAILURE state is a leftover  106499
                       If (Relget_msgcode = Vmsg_dat_notonfile_wc ) %^ AUX hit 
                            If (Success_is in Csid_didansi_ws)
				If PUSHDOWN in Csid_do_pushdown
				    %Beg
                                    Csid_compose ^OUT(Csid_info_memo),
                                    	"Credit party ", Ent_credit_set.cdt_typ,
                                        " Rule inserted ", Csid_pref_corr_rec, / ;
                                    %End
				ELSE
				    %^ strange place, but... we need another call to take place
				    Set Failure_is in Csid_chdet_called to True
				    %Beg
                                    Csid_compose ^OUT(Csid_info_memo),
                                    	"Credit party ", Ent_credit_set.cdt_typ,
                                       " Rule substituted ", Csid_pref_corr_rec, / ;
                                    %End
				END-IF
                                Perform X920_INFO_MEMO through
							    X920_INFO_MEMO_END

			     END-IF
	               Else
			   %^ 103144 OK NOF but it was a valid BBAN D, allow to pass
			   If NOT (Success_is in csid_on_us_bnk_code)
			   Then	%^ COMPLETELY NOF - And not BBAN
		    		%Beg
			    		screen_field_ws = "credit.cdt_typ.cdt_idtype";
			    		error_mnemonic_ws = "VMSG$_MR_CORRNOTONFILE";
		    		%End
	            		call "FTRSCR_WRITE_ERROR" using
	              		  by reference screen_field_ws
		      		  by reference error_mnemonic_ws
				%Beg
	                    	    Csid_compose ^OUT(Csid_info_memo)
		    	       	       "ERROR: NOF credit party preferred corr ",
					Csid_pref_corr_rec, " in SI for ",
					Ent_credit_set.cdt_typ, / ; 
	                   	%End
	                        Perform X920_INFO_MEMO through X920_INFO_MEMO_END
	                        Set Failure_is in Creditside_screen_ls to true
	                        Set Success_is in Csid_push_error to TRUE
		                Add 1 to Cdt_errmemo_count_ls
			    end-if
	                    %Beg
	                        Ent_credit_set (.Cdt_name1 = NULL,
				    	        .Cdt_name2 = NULL,
					        .Cdt_name3 = NULL,
					        .Cdt_name4 = NULL,
                                                .flgs3.cdt_adr_ptr_ok = Null) ;
		            %End
			END-IF
	                %Beg
	                Ent_credit_set (.Cdt_typ
                                           (.Cdt_ovr = "*",
					    .Cdt_idtype = Relget_return_idtype,
					    .Cdt_id = Csid_return_key ),	
					 .Cdt_adr_bnk_id = Ent_ftr_set.Loc_info.bank);	%^ switch to AUX/NOF now
				          Csid_id_bank_ws = Ent_ftr_set.Loc_info.Bank;  %^ Csid should be owning bank
                        BREAK: Ent_c_adr_set ;
		        %End
* clear all the other stuff left over from previous on-file address
			Add 1 to Csid_this_deletes
			If (Csid_this_deletes > Csid_loop_limit )
%^ Do nothing for now
			    Add 1 to Csid_this_more
                        END-IF

			If (Relget_msgcode = Vmsg_dat_notonfile_wc)
			Then
				%^ AUX record, leave connected to Prule setup
	      		  	%Beg	BREAK: Csid_adr_set;
					Relget_adr_set EQUATE: Csid_adr_set(NOMOD) ;
				%end
			end-if

			Call "ACCTSUB_CDT_NOF"

			If (Relget_msgcode = Vmsg_dat_notonfile_wc)
			Then
	      		      %^ Reset now, after cleared by ACCTSUB_CDT_NOF
	      		      %beg ent_credit_set.flgs3.cdt_adr_ptr_ok = "T";
		   		   Ent_credit_set.Cdt_adr_set_ptr POINT: Relget_adr_set;
     	      		      %end
			Else
				%beg BREAK: Relget_adr_set; %END
			End-if
 	            ELSE
		        If (Success_is in Csid_didansi_ws)
			    If PUSHDOWN in Csid_do_pushdown
				%Beg
                                Csid_compose ^OUT(Csid_info_memo),
                                    	"Credit party ", Ent_credit_set.cdt_typ,
                                        " Rule inserted ", Csid_pref_corr_rec, / ;
                                %End
			    ELSE
			        %^ strange place, but... we need another call to take place
			        Set Failure_is in Csid_chdet_called to True
				%Beg
                                Csid_compose ^OUT(Csid_info_memo),
                                    	"Credit party ", Ent_credit_set.cdt_typ,
                                       " Rule substituted ", Csid_pref_corr_rec, / ;
                                %End
			    END-IF
		            Perform X920_INFO_MEMO through X920_INFO_MEMO_END
                        END-IF
 		        If (Cdt_ovr of Cdt_typ of Ent_credit_set NOT = SPACE )
	                    %Beg  Ent_credit_set.Cdt_typ.Cdt_ovr = " " ;  %End
		        END-IF
	                %Beg
	                Ent_credit_set(.Cdt_typ
					   (.Cdt_idtype = Relget_return_idtype,
					    .Cdt_id = Csid_return_key ),
				       .Cdt_adr_bnk_id = Csid_id_bank_ws ) ;
		        Relget_adr_set EQUATE: Ent_c_adr_set(NOMOD) ;
                        Ent_credit_set( .Cdt_rel_id = Ent_c_adr_set.Rel_id,
                                        .Cdt_adr_set_ptr POINT: Ent_c_adr_set,
					.flgs3.cdt_adr_ptr_ok = "T");
		        %End
		    	If (Relget_msgcode = Vmsg_dat_notonfile_wc) Then
				%beg ent_credit_set.cdt_typ.cdt_ovr = "*"; %end
		    	end-if
		    END-IF
	            If (Success_is in Csid_ret_stat   )
		       OR (Relget_msgcode = Vmsg_dat_notonfile_wc )
	            THEN
			%^  We actually did get a REL or AUX db hit, so let's copy the address.
		        %Beg  Csid_id_bank_ws = Relget_adr_set.bnk_id ;  %End
	                Perform C620_COPY_ADDRESS through C620_COPY_ADDRESS_END
	            END-IF
		    Perform B400_SET_ADVICE through B400_SET_ADVICE_END
		    Perform B420_GET_NEWPARTY through B420_GET_NEWPARTY_END
		    If (Failure_is in Creditside_screen_ls  )
			OR (Success_is in Csid_cor_found   )
		    THEN
			%^ bust out of loop
			%^ Perform A110_GOT_CREDIT through A110_GOT_CREDIT_END
			Set Got_credit in Cdt_screen_state to True
			GO TO AIN_PROCESSING_COMPL_EXIT	%^A100_MAIN_EXIT
		    END-IF
	END-IF.		    
	   %^ Was a loop END-PERFORM
       %^ END-IF.

%^
%^ End CDTAIN Processing Loop
%^
%^
AIN_PROCESSING_COMPL_EXIT.

	Set Ain_processing in cdt_screen_state to True.


AIN_PROCESSING_COMPL_END.
	EXIT.


A110_GOT_CREDIT_1.
* We have either pushed down through all preferred correspondents or had
* an error doing so.

	If Credit_changed_ls = 1 Then
		%^ 0 is no change, 2 is VCH called, and credit not set
		%beg csid_upd_level cdt_party_is; %end
		Call "PRULE_UPDATE_PARTY" Using
			By Reference csid_upd_level
			By Reference csid_pr_memo
			by reference csid_pr_memo_length
		returning csid_ret_stat
	end-if.

* Now finish any debit SI lookups.
	Move ZERO to Csid_change_debit.
	If (Debit_changed_ls = 1 )
	   OR (Credit_changed_ls = 1 )
	   OR (Adv_changed_ls NOT = 0 )
	   OR (Bnp_changed_ls NOT = 0 )
	THEN
	    Move 1 to Csid_change_debit
	END-IF.
        %^ Check to see if there are any debit AIN's which would
        %^ require a debit lookup to take place
        Perform B450_SCAN_DEBIT_AINS thru B450_SCAN_DEBIT_AINS_end
        If (Debit_changed_ls NOT = 0 )
           OR (Success_is in Csid_debit_ain) Or
	      (Tran_type of Ent_ftr_set = "DDR")	%^ Need to possibly change debit Account
	THEN
	    If tran_type of Ent_ftr_set = "DDR"
	    Then
		%^ flip the SOURCE and ADV_TYP for the duration of the call
		%beg
			Temp_adv_hold_ws = Ent_credit_set.cdt_adv_typ;
			Ent_credit_set.cdt_adv_typ = Ent_ftr_set.src_code;
			Ent_ftr_set.src_code = temp_adv_hold_ws;
		%end
		Move dbt_internal_ls to dbt_int_save_ws	
		Move 1 to dbt_internal_ls %^ Initial call
	    End-if

	    Call "DEBIT_SCREEN_ACCOUNT" USING
                By Reference Init_debit_currency_ls
	        By Reference Debit_currency_ls
	        By Reference Message_amount_ls
                By Reference Message_currency_ls
	        By Reference Debit_account_ls
	        By Reference Is_payment_ls
	        By Reference Xbank_account_ok_ls
	        By Reference Dbt_acc_type_ls
	        By Reference Is_rptv_lookup_ls
		By Reference Nochange_bank_ls
		By Reference Lock_dbt_party_ls
		By Reference Debit_fee_key_ls
		By Reference Dbt_acc_changed_ls
		By Reference Csid_change_debit
		By Reference Dbt_internal_ls
		By Reference Dbt_currency_found_ls
		By Reference Dbt_account_okay_ls
		By Reference Dbt_not_suspect_ls
		By Reference Msg_bank_changed_ls
		By Reference Dbt_errmemo_count_ls
	      RETURNING Debit_status_ls

   	   If tran_type of Ent_ftr_set = "DDR"
	   Then
		%^ flip the SOURCE and ADV_TYP Back
		%beg
			Ent_ftr_set.src_code = Ent_credit_set.cdt_adv_typ;
			Ent_credit_set.cdt_adv_typ = Temp_adv_hold_ws;
		%end
		Move dbt_int_save_ws to dbt_internal_ls
	   End-if
	ELSE
	    Move 1 to Dbt_account_okay_ls
	    Move 1 to Dbt_not_suspect_ls
	    Move ZERO to Msg_bank_changed_ls
	    Move ZERO to Dbt_errmemo_count_ls
	    Set Success_is in Debit_status_ls to true
	END-IF.

* Now let's see if we have any codewords we care about

	Set Failure_is in Csid_pre_codeword to TRUE.
	Set Failure_is in Csid_chk_codeword to TRUE.
%^  Scan for PREVICE codeword
	If (Debit_changed_ls NOT = 0 )
	    Move ZERO to Chk_SI_relevant_ls
	END-IF.
	If (Csid_change_debit NOT = 0 )
	   AND (Failure_is in Csid_cor_found  )
        THEN
	    Add 1 to Csid_this_psflags
	    If (Csid_this_psflags > Csid_loop_limit )
%^ Do nothing for now
		Add 1 to Csid_this_more
	    END-IF
            If (Pre_found of Si_flgs of Ent_ftr_set not = "Y" )
		AND (Dbt_ps_elig_flg of Flgs of Ent_debit_set NOT = "N" )
	    THEN
                %Beg Ent_debit_set.Flgs.Dbt_ps_elig_flg = "N"; %End
            END-IF
	    If (Dbt_rel_id of Ent_debit_set NOT = 0 )    
		%ACE_IS Ent_codeword_seq connected giving Csid_conn_stat;
	        If (Failure_is in Csid_conn_stat)
* Try hooking up just in case.
	            %Beg  
	            Ent_msg_union (NOTRAP,
		       .codeword_seq CONN: Ent_codeword_seq(NOMOD) ) ;
		    Ent_msg_union(ETRAP) ;
	            %End
		    %ACE_IS Ent_codeword_seq connected giving Csid_conn_stat;
	        END-IF

%^ #73057 Fix status check to avoid Subject Trap,
%^	change Failure_is to Success_is - EGO

	        If (Success_is in Csid_conn_stat)  then
	            %Beg  FIRST: Ent_codeword_seq ;  %End
	            Perform until (SEQ_END_IS in Ent_codeword_seq_cursor)
		        Evaluate True
			    When Ent_codeword_seq = "CHEQUE"
			        Set Success_is in Csid_chk_codeword to true

			    When Ent_codeword_seq = "PREVICE"
			        Set Success_is in Csid_pre_codeword to true

		        End-evaluate
		        %Beg  NEXT: Ent_codeword_seq ;  %End
	            END-PERFORM
	        END-IF
		%Beg
		        BREAK: Relget_adr_set ;
	        	Ent_debit_set.Dbt_adr_set_ptr CONN: Relget_adr_set(NOMOD) ;
		%End
                Perform B440_SCAN_DEBIT_SIS through B440_SCAN_DEBIT_SIS_END
                %Beg
                BREAK: Relget_adr_set;
	        %End
	    End-if
        End-if.

	%^
	%^ Channel_determination to be called each to thru.
	%^
	Move cdt_adv_typ of Ent_credit_set to Csid_save_adv_type.
	%^
	If Not(Success_is in Csid_chdet_called) Then
		Set Success_is in csid_musthave_acct to True
		Set Failure_is in csid_chan_imposed_acct to True
		Set Success_is in Csid_chdet_called to True
	        Perform X930_PRECALC_CVD thru X930_PRECALC_CVD_END
		Call "CHANNEL_DETERMINATION" Using By reference Csid_false_ws
						   By Reference Csid_true_ws
						   By Content "   "
						   By Reference csid_chan_acc_ws
						   By Reference csid_chan_acc_ws_lengths
						   By Reference csid_disable_ain_ws
		returning  Csid_chdet_stat_ws
		If (Failure_is in Csid_chdet_stat_ws) Then
			 Set failure_is in Csid_ret_stat to True
       		         Set Failure_is in Creditside_screen_ls to true
		Else
			If (Csid_know_acc_id = Spaces AND
		            idkey of Csid_Chan_acc_ws NOT = Spaces) And
			   NOT(tran_type of ent_ftr_set = "DDR")
			Then
				%^ Insert the Account returned from Channel_Determination
		 	        Set Failure_is in Csid_musthave_acct to true
				Set Success_is in csid_chan_imposed_acct to True
			Else
				%^ ID type only returned, enforce that as account type to enforce
				If idtype of Csid_chan_acc_ws NOT = Spaces %^ Better not be spaces...
				Then
					%beg Csid_irr_acc_type_ws = Csid_chan_acc_ws.idtype; %end
				End-if
				%^ Channel change with no Account added, need to reevaluate
				%^ existing account
				If cdt_adv_typ of Ent_credit_set NOT =
				   Csid_save_adv_type
				then
					 Move 1 to Cdt_acc_changed_ls
				end-if
			end-if
		end-if
	Else
		%^ Check  old status and fail if required
		If Failure_is in csid_chdet_stat_ws Then
			 Set failure_is in Csid_ret_stat to True
       		         Set Failure_is in Creditside_screen_ls to true
		end-if
	end-if.

%^
%^ Get current account in buffer.
%^
	If Endpoint_id of Rchan_channel_set NOT = cdt_adv_typ of Ent_credit_set AND
	   Cdt_adv_typ of Ent_credit_set NOT = Spaces
	Then
		%^ get to channel to check
		Set ID_IS in csid_prchan_mode to True
		If Cdt_adr_bnk_id of Ent_credit_set not = spaces then
		    %Beg csid_chan_ident_ws.Idbank = Ent_credit_set.Cdt_adr_bnk_id; %End
		Else
		    %Beg csid_chan_ident_ws.Idbank = Ent_ftr_set.Loc_info.Bank; %End
		End-if
			%Beg csid_chan_ident_ws.idkey = Ent_credit_set.Cdt_adv_typ; %End

		Call "GET_CHANNEL" using
			By Reference 	Csid_prchan_mode
			By Reference	Csid_chan_ident_ws
			By Reference 	Csid_chan_ident_ws_lengths
		returning Csid_got_channel_ws
	End-if.

	If failure_is in Csid_chdet_stat_ws
	Then
		%^ Failure now is now going to get any better... exit gracefully
		If (Cdt_adv_typ of Ent_credit_set = Spaces) Or %^ 109837 allow for BNP lookups
		   (Cdt_adv_flg of Ent_ftr_set = "Y") 
		Then
			%^ 108891
			Set Do_account_compl in Cdt_screen_state to True	%^ out we go Failed state, but finish lower party.\
			%^ off to a120_post accoun checking 
			Go To A110_GOT_CREDIT_1_END	%^ 110911
		End-if

		If Endpoint_id of Rchan_channel_set NOT = cdt_adv_typ of Ent_credit_set AND
		   Cdt_adv_typ of Ent_credit_set NOT = Spaces
		Then
			%^ get to channel to check
			Set ID_IS in csid_prchan_mode to True
			If Cdt_adr_bnk_id of Ent_credit_set not = spaces then
			    %Beg csid_chan_ident_ws.Idbank = Ent_credit_set.Cdt_adr_bnk_id; %End
			Else
			    %Beg csid_chan_ident_ws.Idbank = Ent_ftr_set.Loc_info.Bank; %End
			End-if

			%Beg csid_chan_ident_ws.idkey = Ent_credit_set.Cdt_adv_typ; %End
	
			Call "GET_CHANNEL" using
				By Reference 	Csid_prchan_mode
				By Reference	Csid_chan_ident_ws
				By Reference 	Csid_chan_ident_ws_lengths
			returning Csid_got_channel_ws
		End-if
		 
		If ((RTGS_IS in Endpoint_type of Rchan_channel_set) or
		    (clrhouse_is in Endpoint_type of Rchan_channel_set)) 
		Then
			%^ We cannot get a valid Account at this point,
			%^ Take an Exit
		        Set Failure_is in Csid_musthave_acct to true
			Set Do_account_compl in Cdt_screen_state to True	
			Go To  A110_GOT_CREDIT_1_END
		End-if
	End-if


	If Not(cdt_adv_typ of Ent_credit_set = csid_save_adv_type)
	Then
		%beg break: relget_adr_set; %end 
		%^ Ensure Correct IDTYPE
		Call "GET_IDTYPE_FROM_CHAN" Using
			By Reference Csid_temp_idtype,
			By Reference csid_lookup_temp,
			By Reference Csid_lookup_temp_length
		Returning csid_ret_stat

		If Success_is in csid_ret_stat Then
			%^ have have a good ID use it
			%beg ent_credit_set.cdt_typ.cdt_idtype = Csid_temp_idtype;
  			     Csid_compose ^OUT(Ent_credit_set.Cdt_typ.Cdt_id)
					    Csid_lookup_temp,/;
			%end
		end-if
	end-if.

	Move SPACES to Cdt_currency_found_ls.
	%ACE_IS Relget_adr_set connected giving Csid_conn2_stat;
	If (Failure_is in Csid_conn2_stat)   then
	    %ACE_IS Ent_c_adr_set connected giving Csid_conn_stat;
            If (Success_is in Csid_conn_stat)   then
                %Beg
                Ent_c_adr_set EQUATE: Relget_adr_set(NOMOD);
                %End
            end-if
        end-if.
	

%^ Force for FED.... Keep for now to be replaced with something mopre generic.
	IF (Cdt_idtype of Cdt_typ of Ent_credit_set = "A" )
	   AND (Cdt_adv_typ of Ent_credit_set = "FED" )
	THEN
* Don't need accounting info
            Set Failure_is in Csid_musthave_acct to true
	    Move "USD" to Cdt_currency_found_ls	
	END-IF.

	If (Cdt_adv_typ of Ent_credit_set = "CHK" OR "CHQ") Or
           (((RTGS_IS in Endpoint_type of Rchan_channel_set) or	%^ 133476
 	    (clrhouse_is in Endpoint_type of Rchan_channel_set))  AND
	   NOT(Cdt_adv_typ of Ent_credit_set = "FED"  and Tran_type of Ent_ftr_set = "SEC")) And
	  NOT(tran_type of ent_ftr_set = "DDR")%^ Allow DDR's to use own account
	Then
* Don't need accounting info
	    Set Failure_is in Csid_musthave_acct to true
%^ SET CHECK account and Currency
   	   If (idkey of csid_chan_acc_ws Not = Spaces)	Then
		%^ Channel Determination provided an account number use, it
		%beg
		   Ent_credit_set.cdt_adr_bnk_id = Csid_chan_acc_ws.idbank;
		   Ent_credit_set.cdt_account(.idbank = Csid_chan_acc_ws.idbank,
					      .idtype = Csid_chan_acc_ws.idtype,
					      .idkey  = Csid_chan_acc_ws.idkey ) ;
		    Csid_know_acc_id(.idbank = Csid_chan_acc_ws.idbank,
				      .idtype = Csid_chan_acc_ws.idtype,
				      .idkey  = Csid_chan_acc_ws.idkey ) ; 
		
		%end
		%^ Need to get a better currency, in Europe,
		%^ multiple currency checks can be
		%^ cut from 1 bank derived GL from channel determination should be used.
		%^
   	 	%ace_conn_root_q Rel_acc_index ;
    		%Beg
	    		BREAK: Ent_acc_set ;
	    		BREAK: Ent_acc_rel_reg ;
    			Rel_acc_index ^SEARCH (FORWARD, EQL,
			     .Rel_name_key(.Idbank = ent_credit_set.cdt_account.Idbank, 
			 	    .Idtype = ent_credit_set.cdt_account.Idtype,
			 	    .Idkey (.Idacc = ent_credit_set.cdt_account.Idkey,
				 	    .Idadr = NULL,
				 	    .Idpad = NULL ) ),
			 CONN: Ent_acc_set(NOMOD)) ;
		%end
		If (Success_is in Ent_acc_set_status) Then
		    Move Currency_id of Ent_acc_set to Cdt_currency_found_ls
		    %^ If blank, set to Base
   	            If (Cdt_currency_found_ls = SPACES ) Then
			    If Cdt_adr_bnk_id of Ent_credit_set =
						Bnk_id of Menu_bnk_union
			        Move Base_currency_id of Menu_bnk_union to 
						  Cdt_currency_found_ls
		            ELSE
	       			%Beg
	        		     BREAK: Csid_bnk_union ;
	   			     SEARCH: Bnk_index 
		 				(Key = Ent_credit_set.Cdt_adr_bnk_id ) ;
				%end
	        		    If Failure_is in Bnk_index_status  
	            			Move SPACES to Cdt_currency_found_ls
	        		    ELSE
	            			%Beg  Bnk_index CONN: Csid_bnk_union (NOMOD) ;
					%End
	            			Move Base_currency_id of Csid_bnk_union to 
						    Cdt_currency_found_ls
	        		    END-IF
            		     END-IF
        	    END-IF
		
		   %beg BREAK: Ent_acc_set; %end
		End-if
	    Else
 		If (FX_ENA in Menu_cfg = Low_values) Then
	 	    If Cdt_adr_bnk_id of Ent_credit_set = Bnk_id of Menu_bnk_union
			Move Base_currency_id of Menu_bnk_union to Cdt_currency_found_ls
	    	    ELSE
			%Beg
			BREAK: Csid_bnk_union ;
			SEARCH: Bnk_index 
				(Key = Ent_credit_set.Cdt_adr_bnk_id ) ;
			%End
			If Failure_is in Bnk_index_status  
			    Move SPACES to Cdt_currency_found_ls
			ELSE
			    %Beg  Bnk_index CONN: Csid_bnk_union (NOMOD) ;  %End
			    Move Base_currency_id of Csid_bnk_union to 
				Cdt_currency_found_ls
			END-IF
	    	    END-IF
	 	end-if
	     end-if
		%^ When processing a CHK in this environment, the currency must be
		%^ Specified, Don't default. THe Cur mut be present to determine the
		%^ Account
	END-IF.
%^
%^ Here is the SPLIT to do Account processing, Make this a STATE
%^
	Set Do_account in Cdt_screen_state to True.

A110_GOT_CREDIT_1_END.
	EXIT.

A120_DO_ACCOUNT.
%^
%^ Time for the account lookups.
%^
      If (Csid_credit_changed NOT = 0 )
	Then
	    If (Failure_is in csid_chan_imposed_acct) Then
		 %^ leave intact, test possibly just add the Channel GL below
	        %Beg
                    Ent_credit_set (
                        .cdt_account            = NULL,
                        .cdt_acc_prod_codes     = NULL,
                        .cdt_acc_class          = NULL);
		%end
		If NOT(Informational in Sec_flg of Cdt_acc_2 of Ent_credit_set)
	 	 and Not(Pre_done in Dda_balance of Ent_debit_set)  %^ CR7181 don't clear if preadvise is done
		Then   %^ Not account related, pass along the fee info 132692
		    %Beg
               		Ent_credit_set.cdt_acc_2
		  		(.Sec_amt = <0>,
		   		 .Sec_cur = NULL,
		   		 .Sec_acc = Null);
		    %End
		    Set Null_flg in Sec_flg of Cdt_acc_2 of Ent_credit_set to true
		End-if
		If Not(MT103_Charges in ter_flg of cdt_acc_3 of Ent_credit_set)
	 	 and Not(Pre_done in Dda_balance of Ent_debit_set)  %^ CR7181 don't clear if preadvise is done
		Then
			Set Null_flg in Ter_flg of Cdt_acc_3 of Ent_credit_set to true
			%beg
				ent_credit_set.cdt_acc_3
					    	(.Ter_amt = <0>,
						 .Ter_cur= NULL,
						 .Ter_acc = Null);
			%end
		End-if
	    end-if

	    If  (Cdt_ovr of Cdt_typ of Ent_credit_set = SPACE ) 
	    Then
	   	%^ full address on file.
		Perform B320_SET_ADDRESS through B320_SET_ADDRESS_END

		IF (Cdt_idtype of Cdt_typ of Ent_credit_set = "A" )
                     AND (Cdt_adv_typ of Ent_credit_set = "FED" )
		THEN
		    Set Failure_is in Csid_musthave_acct to true
		    Move "USD" to Cdt_currency_found_ls
		END-IF
	    END-IF

	    If NOT ((Success_is in Csid_musthave_acct) And
	            ((Cdt_ovr of Cdt_typ of Ent_credit_set = Space) Or 
		     (Credit_account_ls NOT = SPACES )))
	%^ Causes traps leaving on file
	%^ when not FED. And Failure_is in csid_chan_imposed_acct %^ 15646 Not Off file when Clearing account 
	%^	Failure_is in Csid_musthave_acct  And
	%^	((cdt_ovr of Ent_credit_set Not = Space or
	%^	  Credit_account_ls = Spaces))
	    Then
		%^
		%^	We went off file, clear out.
		%^		
		If (Cdt_recon_ref of Ent_credit_set NOT = SPACES ) OR
        	   (Cdt_recon_ref_length of Ent_credit_set_lengths NOT = 0)
	       	Then
			If rptv_id of ent_ftr_set = spaces and
			     credit_changed_ls = 1
			THEN
			    %Beg  Ent_credit_set.Cdt_recon_ref = NULL;  %End
			END_IF
		End-if
		%^ Undo things done by SET_CREDIT_ACCOUNT
		If (Cdt_concen_acc of Ent_credit_set NOT = SPACES )
		Then
		    %Beg  Ent_credit_set.Cdt_concen_acc = NULL;  %End
		END-IF
		If (Cdt_sys_of_rec of Ent_credit_set NOT = SPACES )
		    %Beg  Ent_credit_set.Cdt_sys_of_rec = "   ";  %End
		END-IF	   
	        If (Cdt_parent_code of Ent_credit_set NOT = SPACES )
	          OR (Cdt_parent_code_length of Ent_credit_set_lengths
							      NOT = 0)
		THEN
		    %Beg  Ent_credit_set.Cdt_parent_code = NULL;  %End
		END-IF	   
		If Cdt_hold_flg of Ent_credit_set NOT = SPACE
		    %Beg  Ent_credit_set.flgs.cdt_hold_flg = " ";  %end
		END-IF
		CALL "SET_NOF_CDT_ACCOUNT"
		Set Do_Account_Compl in Cdt_screen_state to True
		Go To A120_DO_ACCOUNT_END
	    END-IF
%^
%^	 ELSE of the Cdt_credit_changed Not = 0 Case
%^
	ELSE
	    If (Cdt_acc_changed_ls NOT = 0 )
		Add 1 to Csid_this_deletes
		If (Csid_this_deletes > Csid_loop_limit ) 
%^ Do nothing for now
		    Add 1 to Csid_this_more
		END-IF
 		If (Cdt_account of Ent_credit_set NOT = SPACES )
	            %Beg
                    Ent_credit_set (
                        .cdt_account            = NULL,
                        .cdt_acc_prod_codes     = NULL,
                        .cdt_acc_class          = NULL ) ;
		    %End
		END-IF
		If (Cdt_hold_flg of Flgs of Ent_credit_set NOT = SPACE )
		    %Beg  Ent_credit_set.flgs.cdt_hold_flg = NULL ;  %End
		END-IF
 		%Beg  BREAK: Ent_c_acc_set; 
		      BREAK: Ent_c_acc_rel_reg;
		%End
		If Not (Success_is in Csid_musthave_acct)
		Then
			Set Do_account_compl in cdt_screen_state to True
			Go to A120_DO_ACCOUNT_END
		End-if
	   Else
			Set Do_account_compl in cdt_screen_state to True
			Go to A120_DO_ACCOUNT_END
	   End-if
	End-if.


	Move ZERO to Cdt_account_okay_ls
	Perform B340_GET_ACCOUNT_SET through B340_GET_ACCOUNT_SET_END

	If Relget_reject_flag = "M" Or
	  (Csid_next_function not = Menu_next_function)
	Then
		Set Menu_is in cdt_screen_state to True
		Go to A120_DO_ACCOUNT_END
	End-if.

	If Relget_msgcode = "VMSG$_MISSINGDAT" Then %^ 97452
		%^ GOLDCANCEL was set in rel_acc_from_adr, get out
               	Set Failure_is  in csid_ret_stat to True
		Set Failure_is  in Creditside_screen_ls to True
		Set Complete_is in Cdt_screen_state to True
 		Go to A120_DO_ACCOUNT_END
	End-if

	If Success_is in Relget_ambiguous_wf
	Then
		Set Success_is   in Resolve_Ambiguous to True
		Set Account_index_conn in Cdt_screen_state  to True
	Else
		Perform B340_GET_ACCT_SET_CLNUP Thru
			B340_GET_ACCT_SET_CLNUP_END
	   	If (Idtype of Cdt_account of Ent_credit_set NOT = SPACE )
    		Then
	       	 	Perform B360_SET_ACCOUNT through B360_SET_ACCOUNT_END
		END-IF
		Set Do_account_compl in Cdt_screen_state to True
	End-if.

A120_DO_ACCOUNT_END.
	EXIT.

A120_ACCOUNT_CONN.
%^
%^
	Call "RELGET_ACCOUNT_CONNECT" 
	    returning Csid_ret_stat.

	Perform B340_GET_ACCT_SET_CLNUP Thru
		B340_GET_ACCT_SET_CLNUP_END.

	Set Do_account_Compl in Cdt_screen_state to True.

A120_ACCOUNT_CONN_END.
	EXIT.


A120_DO_ACCOUNT_COMPL.

%^	Perform B340_GET_ACCT_SET_CLNUP Thru
%^		B340_GET_ACCT_SET_CLNUP_END.
%^
%^    	If (Idtype of Cdt_account of Ent_credit_set NOT = SPACE )
%^  	Then
%^        	Perform B360_SET_ACCOUNT through B360_SET_ACCOUNT_END
%^	END-IF


	If (Cdt_acc_changed_ls = 0 ) And
	   (Csid_credit_changed = 0 )
	Then
	    If (FX_ENA in Menu_cfg = Low_values) Then
		%ACE_IS Ent_c_acc_set connected giving Csid_conn_stat;
		If (Success_is in Csid_conn_stat)
	       	        Move Currency_Id of Ent_c_acc_set to Cdt_currency_found_ls
		END-IF
		If (Cdt_currency_found_ls = SPACES ) THEN
		   If (Cdt_adr_bnk_id of Ent_credit_set = Bnk_id of Menu_bnk_union)
			    Move Base_currency_id of Menu_bnk_union to
						Cdt_currency_found_ls
	            ELSE
	            	%Beg
	            		BREAK: Csid_bnk_union ;
	          		SEARCH: Bnk_index (Key = Ent_credit_set.Cdt_adr_bnk_id ) ;
	                %End
	                If Success_is in Bnk_index_status  
		            %Beg  Bnk_index CONN: Csid_bnk_union(NOMOD); %End
			     Move Base_currency_id of Csid_bnk_union to
							Cdt_currency_found_ls
	            	END-IF
	            END-IF
		END-IF
	    Else
	   	%^ Leave it blank for FX enabled. We may have had input
	   	%ACE_IS Ent_c_acc_set connected giving Csid_conn_stat;
	    	If (Success_is in Csid_conn_stat)
               		Move Currency_Id of Ent_c_acc_set to Cdt_currency_found_ls
	    	END-IF
	    End-if
	END-IF.

%^	Ensure that we fill in res_country if possible

	If Cdt_res_country of ent_credit_set = spaces and Cdt_id of Ent_credit_set not = spaces
	    Initialize Csid_risk_country_ws, Csid_country_code_ws
	    If rel_id of ent_c_adr_set not = 0
		  %Ace_is ent_c_adr_set connected;
		  If success_is in ace_status_wf
	            Move risk_country of ent_c_adr_set to Csid_risk_country_ws
	            Move country_code of ent_c_adr_set to Csid_country_code_ws
		  end-if
	    end-if
	    Call "DETERM_RES_COUNTRY" using
	       by content "CDT"
	       by reference Cdt_idtype of Ent_credit_set
	       by reference Cdt_id of Ent_credit_set
	       by reference Cdt_id_length of Ent_credit_set_lengths
	       by reference Csid_risk_country_ws
	       by reference Csid_country_code_ws
	       by reference Cdt_res_country of Ent_credit_set
	       by reference Csid_res_country_ws
	    If Csid_res_country_ws not = spaces
	        %Beg Ent_credit_set.cdt_res_country = Csid_res_country_ws; %end
	    end-if
	end-if.

	%^ 115131 if BNP_MAILING_COUNTRY wasn't entered set 
	%^ 116032 JC Don't change BNP_MAILING_COUNTRY unless party changed or BNP_MAILING_COUNTRY blank
	%^ and don't change it to spaces.

	If (Bnp_mailing_country of Ent_credit_set = Bnp_mailing_country of Change_credit_set) or
	   (Bnp_mailing_country of Ent_credit_set = SPACES)  then

	    If Bnp_bnk_flg of Ent_credit_set = "Y" then
		If (Bnp_mailing_country of Ent_credit_set = SPACES OR
		    Bnp of Ent_credit_set NOT = Bnp of Change_credit_set) and 
		   (Bnp_res_country of Ent_credit_set not = SPACES) then

* If the BNP changed then need to call determ_res_country for the bnp.

		    If Bnp of Ent_credit_set NOT = Bnp of Change_credit_set then


			    Initialize Csid_risk_country_ws, Csid_country_code_ws
			    %^ 109688 comented out code removed. 
			    Call "DETERM_RES_COUNTRY" using
			       by content "BNP"
			       by reference bnp_idtype of Ent_credit_set
			       by reference bnp_id of Ent_credit_set
			       by reference bnp_id_length of Ent_credit_set_lengths
			       by reference Csid_risk_country_ws
			       by reference Csid_country_code_ws
			       by reference Csid_blank_country_ws
			       by reference Csid_res_country_ws
			    If Csid_res_country_ws not = spaces
			        %Beg Ent_credit_set.bnp_res_country = Csid_res_country_ws; %end
			    end-if
		    End-if


	            %beg ent_credit_set.bnp_mailing_country = ent_credit_set.Bnp_res_country; %end

		End-if
	    Else
		If (Bbk of Ent_credit_set not = SPACES OR
		    Bbk_name1_length of Ent_credit_set_lengths NOT = ZERO) then
		    If (Bnp_mailing_country of Ent_credit_set = SPACES OR 
		        Bbk of Ent_credit_set NOT = Bbk of Change_credit_set) and
		       (Bbk_res_country of Ent_credit_set not = SPACES) then

* If the BBK changed then need to call determ_res_country for the bbk 
* (except if the Change Credit Set is empty and
* the BBK_RES_COUNTRY is not empty - which means they just entered it.

			If Bbk of Ent_credit_set NOT = Bbk of Change_credit_set and
			   Bbk of Change_credit_set not = SPACES then

			    Initialize Csid_risk_country_ws, Csid_country_code_ws
		            %Beg  BREAK: Relget_adr_set ;  %End
			    Initialize Relget_adr_set
		            If (Bbk_rel_id of Ent_credit_set NOT = 0 ) Or
			       (Bbk_adr_ptr_ok of flgs3 of Ent_credit_set = "T") Then
		                %Beg
				Relget_adr_set(NOTRAP);
				Ent_credit_set(NOTRAP);
		                Ent_credit_set.bbk_adr_set_ptr CONN: Relget_adr_set(NOMOD) ;
				Relget_adr_set(ETRAP);
				Ent_credit_set(ETRAP);
		                %End
		            END-IF
			    If rel_id of relget_adr_set not = 0
				  %Ace_is relget_adr_set connected;
				  If success_is in ace_status_wf
			            Move risk_country of relget_adr_set to Csid_risk_country_ws
			            Move country_code of relget_adr_set to Csid_country_code_ws
				  end-if
			    end-if
			    Call "DETERM_RES_COUNTRY" using
			       by content "BBK"
			       by reference bbk_idtype of Ent_credit_set
			       by reference bbk_id of Ent_credit_set
			       by reference bbk_id_length of Ent_credit_set_lengths
			       by reference Csid_risk_country_ws
			       by reference Csid_country_code_ws
			       by reference Csid_blank_country_ws
			       by reference Csid_res_country_ws
			    If Csid_res_country_ws not = spaces
			        %Beg Ent_credit_set.bbk_res_country = Csid_res_country_ws; %end
			    end-if
			End-if

			%beg ent_credit_set.bnp_mailing_country = ent_credit_set.Bbk_res_country; %end
		    End-if
		Else
		    If (Address_type of Cdt_adr_type of Ent_credit_set = "B") then
			If (Bnp_mailing_country of Ent_credit_set = SPACES or 
			    Cdt_typ of Ent_credit_set NOT = Cdt_typ of Change_credit_set) and
			   (Cdt_res_country of Ent_credit_set not = SPACES) then
			    %beg ent_credit_set.bnp_mailing_country = ent_credit_set.Cdt_res_country; %end
			End-if
		    End-if
		End-if
	    End-if

	End-if.

%^
%^ At this point, we have a Channel and a good Account, check for the Bilat
%^
	Call "CUST_BILAT_ACCT".

	Set Got_credit_2 in Cdt_screen_state to True.

A120_DO_ACCOUNT_COMPL_END.
	EXIT.


%^ Make this EXIT a state,  A110_GOT_CREDIT_COMPL
%^
%^
A110_GOT_CREDIT_2.	%^ Label is now used tobypass Account logic while doing lower parti

%^ Now that any pushdowns have occurred, we go through the lower creditside 
*    parties.
	If (( (Adv_changed_ls NOT = 0 )
	   OR (Bnp_changed_ls NOT = 0 ) )
	   AND (Credit_changed_ls NOT = 1 )) Or
	   NOT( (Failure_is in csid_chdet_stat_ws) and	%^ Don't look for account we can't find
	        ((RTGS_IS in Endpoint_type of Rchan_channel_set) or
	        (clrhouse_is in Endpoint_type of Rchan_channel_set)))  
	THEN
	    %ACE_IS Ent_c_adr_set connected giving Csid_conn_stat;
	    If (Failure_is in Csid_conn_stat)
	       AND (Cdt_rel_id of Ent_credit_set NOT = 0)
	    THEN
		%Beg
	        Ent_credit_set.Cdt_adr_set_ptr CONN: Ent_c_adr_set(NOMOD) ;
		%End
	    END-IF
	    Set Failure_is in Csid_changed_it to TRUE
	    Perform B400_SET_ADVICE through B400_SET_ADVICE_END
	    If (Cdt_rel_id of Ent_credit_set NOT = 0 )
		AND (Cdt_account of Ent_credit_set = SPACES )
                AND ( (Cdt_adv_typ of Ent_credit_set NOT = "FED" )
		      AND (ABA_id of Ent_c_adr_set NOT = SPACES ) )
		AND (Cdt_adv_typ of Ent_credit_set NOT = "CHK" AND "CHQ")
	    THEN
                Set Success_is in Csid_musthave_acct to true
	        Perform B320_SET_ADDRESS through B320_SET_ADDRESS_END

	        IF ( (Cdt_idtype of Cdt_typ of Ent_credit_set = "A" )
		      AND (Cdt_adv_typ of Ent_credit_set = "FED" ) )
	           OR (Cdt_adv_typ of Ent_credit_set = "CHK" OR "CHQ") Or
		  (Failure_is in csid_chdet_stat_ws) and
	      		((RTGS_IS in Endpoint_type of Rchan_channel_set) or
	       		(clrhouse_is in Endpoint_type of Rchan_channel_set))
	    	THEN
* Don't need accounting info
	            Set Failure_is in Csid_musthave_acct to true
	        END-IF
		Add 1 to Csid_this_deletes
		If (Csid_this_deletes > Csid_loop_limit ) 
%^ Do nothing for now
		    Add 1 to Csid_this_more
		END-IF
		If (Cdt_account of Ent_credit_set NOT = SPACES )
	            %Beg
                    Ent_credit_set (
                        .cdt_account            = NULL,
                        .cdt_acc_prod_codes     = NULL,
                        .cdt_acc_class          = NULL ) ;
		    %End
		END-IF
		If (Cdt_hold_flg of Flgs of Ent_credit_set NOT = SPACE )
		    %Beg  Ent_credit_set.flgs.cdt_hold_flg = NULL ;  %End
		END-IF
		%Beg  BREAK: Ent_c_acc_set;
		      BREAK: Ent_c_acc_rel_reg;
		%End
		If (Success_is in Csid_musthave_acct   )
		    Move ZERO to Cdt_account_okay_ls
	            Perform B340_GET_ACCOUNT_SET through 
			    B340_GET_ACCOUNT_SET_END
	  	   If Relget_msgcode = "VMSG$_MISSINGDAT" Then %^ 97452
			%^ GOLDCANCEL was set in rel_acc_from_adr, get out
                	Set Failure_is  in csid_ret_stat to True
			Set Failure_is  in Creditside_screen_ls to True
			Set Complete_is in Cdt_screen_state to True
 			Go to A110_GOT_CREDIT_2_END
		    End-if
	    	    If (Relget_reject_flag = "M") Or
		       (Csid_next_function not = Menu_next_function)
		    Then
			Set Menu_is in Cdt_screen_state to True
			Go to A110_GOT_CREDIT_2_END
	    	    End-if
		    If Success_is in Relget_ambiguous_wf
		    Then
			Set Success_is       in Resolve_Ambiguous to True
			Set Got_credit_conn in Cdt_screen_state  to True
			Go to A110_GOT_CREDIT_2_END
		    END-IF
		    Perform B340_GET_ACCT_SET_CLNUP Thru
			    B340_GET_ACCT_SET_CLNUP_END
		    If (Idtype of Cdt_account of Ent_credit_set NOT = SPACE )
		    	Perform B360_SET_ACCOUNT through B360_SET_ACCOUNT_END
		    END-IF  
	    END-IF
	End-if
	END-IF        


	Set Got_credit_compl in Cdt_screen_state to True.

A110_GOT_CREDIT_2_END.
	EXIT.

A110_GOT_CREDIT_CONN.
%^
%^
%^
	Call "RELGET_ACCOUNT_CONNECT" 
	    returning Csid_ret_stat.

	Perform B340_GET_ACCT_SET_CLNUP Thru
		B340_GET_ACCT_SET_CLNUP_END.

	If (Idtype of Cdt_account of Ent_credit_set NOT = SPACE )
	    Perform B360_SET_ACCOUNT through B360_SET_ACCOUNT_END
	END-IF

	Set Got_credit_Compl in Cdt_screen_state to True.

A110_GOT_CREDIT_CONN_END.
	EXIT.


A110_GOT_CREDIT_COMPL.

	Call "SET_CREDIT_ADVICE" USING
	    By reference Credit_account_ls
	    By reference Is_rptv_lookup_ls
	RETURNING Csid_ret_stat  

        %^ If this is a not on file account, check to see if any unit
        %^ confirmations need to be generated.
        If Cdt_rel_id of Ent_credit_set = 0 then
		Add 1 to Csid_this_deletes
		If (Csid_this_deletes > Csid_loop_limit ) 
%^ Do nothing for now
		    Add 1 to Csid_this_more
		END-IF
                Call "SET_CREDIT_UNIT_CNF"
        end-if.

        IF ( (Cdt_idtype of Cdt_typ of Ent_credit_set = "A" )
             AND (Cdt_adv_typ of Ent_credit_set = "FED" ) )
           OR (Cdt_adv_typ of Ent_credit_set = "CHK" OR "CHQ")
        THEN
* Don't need accounting info
            Set Failure_is in Csid_musthave_acct to true
            Move 1 to Cdt_account_okay_ls
        END-IF.

%^ If CHIPS qualification is requested, which is a U.S.-specific phenomenon, 
%^  check for specific "CHP" credit advice method
	If (Do_chips_qualif_ls NOT = 0 )
	   AND (Cdt_ovr of Cdt_typ of Ent_credit_set = SPACE )
	   AND (Cdt_idtype OF Cdt_typ OF Ent_credit_set = "P")
	   AND (Cdt_adv_typ of Ent_credit_set = "CHP" )
	THEN
	    Set Success_is in Csid_try_chips to TRUE
	ELSE
	    Set Failure_is in Csid_try_chips to TRUE
	END-IF.


	Set Ib1_init_lkup in Cdt_screen_state to True.

A110_GOT_CREDIT_COMPL_END.
	EXIT.



%^ STATE DRIVEN IB1 Processing Check 
%^ STATE DRIVEN IBK Processing Check 

%^ STATE DRIVEN BBK Processing Check



A120_BBK_INIT_SECWIR.
%^ if the secondary wire flag has a chance of being defaulted
%^   to "Y", then look up the BBK address.
	If date_time of Cdt_value_date of Ent_credit_set NOT = 0 Then
		%beg tmp_value_date_ws =
		   	Ent_credit_set.cdt_value_date.date_time;
		%end
	else
		%beg tmp_value_date_ws = Null; %end
	end-if


	If ((Def_secwir_if_pre_spl of Menu_cfg = "Y")
               and (Bbk_rel_id of Ent_credit_set = 0)
               and (Dbt_ps_elig_flg of Ent_debit_set = "P" or "S")
              %^ and (Value_date of Ent_ftr_set > Menu_date_ws)
               and (tmp_value_date_ws > Menu_date_ws)
               and (Bbk_idtype of Ent_credit_set not = "S")
               and ((Bbk_id of ent_credit_set not = spaces) or
                    (Bbk_name1 of ent_credit_set not = spaces))
               and (Bbk_secwir of ent_credit_set = SPACE)
               and (Ib1_secwir of ent_credit_set not = "Y")
               and (Ibk_secwir of ent_credit_set not = "Y"))
	Then
                   Perform C650_LOOKUP_BBK_ADDRESS thru
                           C650_LOOKUP_BBK_ADDRESS_end

	Else
		If (bbk_id of Ent_credit_set Not = Spaces and	%^ Y will be forced
		    Tran_type of Ent_ftr_set = csid_col_tran_type_ws And
		    csid_col_tran_type_ws NOT = spaces)
		Then
		    %^ This is a Collection, skip SECWIRE_EVAL, Force Y to BBK
		    %beg
			 Ent_credit_set.bbk.bbk_secwir = "Y";
			 Ent_credit_set.bnp_bnk_flg = "Y";
		    %end
        	    Perform C650_LOOKUP_BBK_ADDRESS thru
	                    C650_LOOKUP_BBK_ADDRESS_end
		Else
			%^ No special BBK secwir handling, back to the flow
			Set Secwir_proc in Cdt_screen_state to True
			Go to A120_Bbk_init_secwir_end
		End-if

		If (Relget_reject_flag = "M")	Or
   		   (Csid_next_function not = Menu_next_function)
		Then
			Set Menu_is in cdt_screen_state to True
			Go to A120_BBK_INIT_SECWIR_END
		End-if

		If Success_is in Relget_ambiguous_wf
		Then
			Set Success_is  	in Resolve_Ambiguous to True
			Set Bbk_secwir_Conn 	in CDT_screen_state  to True
			Go to A120_BBK_INIT_SECWIR_END
		End-if 
        End-if.

	If (Success_is in Csid_iban_bbk_proc)
	Then
		%^ This was a re-lookup on the BBk 
		Set Completion_proc in Cdt_screen_state to True
	Else
		Set Secwir_proc in Cdt_screen_state to True
	End-if.

A120_BBK_INIT_SECWIR_END.
	EXIT.

BBK_SECWIR_CONN1.

	Call "RELGET_CONNECT" USING 
	    by reference Csid_lkup_pend_del
	  RETURNING Csid_ret_stat.

	Set Secwir_proc in Cdt_screen_state to True.

BBK_SECWIR_CONN1_END.
	EXIT.
%^
%^ Call SECWIR EVAL and see if we need to lookup the
%^ destinations
%^
SECWIR_PROCESSING.

	If (bbk_id of Ent_credit_set Not = Spaces and	%^ Y will be forced
	    Tran_type of Ent_ftr_set = csid_col_tran_type_ws And
	    csid_col_tran_type_ws NOT = spaces)
	    %^ This is a Collection, skip SECWIRE_EVAL, Force Y to BBK
	    	%^ DONE ABOVE
		%^  %beg
		%^	 Ent_credit_set.bbk.bbk_secwir = "Y";
		%^	 Ent_credit_set.bnp_bnk_flg = "Y";
	    	%^end
  		%^ ALREADY DONE          Perform C650_LOOKUP_BBK_ADDRESS thru
        	%^            C650_LOOKUP_BBK_ADDRESS_end

	    If  (Bnp_id of Bnp of Ent_credit_set = SPACES ) AND
	        ( (Bnp_name1_length of Ent_credit_set_lengths = 0 ) And
	         (Bnp_name1 of Ent_credit_set = SPACES ) )
	    Then
		%^ If the BNP is blank at this point, copy in the current BBK
		Perform C750_BBK_TO_BNP thru
			C750_BBK_TO_BNP_END
	    End-if
	Else
	    Call "CUST_SECWIRE_SAVE"

	    %^ ALL other items need to be evaulated
	    Call "SECWIRE_EVAL" using
	    	by content "ENT"
	    	by reference Cdt_currency_found_ls
	End-if.

        If (Ib1_changed_ls NOT = 0 )
	   AND (Ib1_secwir of Ent_credit_set = "Y" )
	   AND (Routexcp_edit of Menu_cfg = "T" )
	THEN
* Must check for place to send secondary wire.
	    Move SPACES to Csid_id_ws	
            %Beg  Csid_temp2_vstr = NULL ;  %End
            If (Ib1_rel_id of Ent_credit_set = 0 )
                AND (Ib1_idtype of Ib1 of Ent_credit_set NOT = "S" )
            THEN
                %Beg
                Csid_compose ^OUT(Csid_temp1_vstr)
                                Ent_credit_set.Ib1.Ib1_id, / ;
                Csid_parse ^IN(Csid_temp1_vstr)
                                ^STRING, "/BC", Csid_temp2_vstr,
                                ^ONEOF ( ("/", ^STRING, / ),
                                         (/) ) ;
                %End
                If (Failure_is in Csid_parse_status   )
                    %Beg
                    Csid_parse ^IN(Csid_temp1_vstr),
                                ^STRING, "/(BC", Csid_temp2_vstr,
                                ^ONEOF ( ("/", ^STRING, / ),
                                         (")", ^STRING, / ),
                                         (/) ) ;
                    %End
                    If (Failure_is in Csid_parse_status   )
                        %Beg  Csid_temp2_vstr = NULL ;  %End
                    END-IF
                END-IF
            END-IF
            If (Csid_temp2_vstr_length NOT = 0 )
                %Beg
                Csid_id_ws = Csid_temp2_vstr ;
                Csid_idtype_ws = "S" ;
                %End
            ELSE
                %Beg
                Csid_parse ^IN(Ent_credit_set.Ib1.Ib1_id)
                        Csid_id_ws, ^ONEOF ( ("/", ^STRING, / ),
                                             (/) ) ;
                Csid_idtype_ws = Ent_credit_set.Ib1.Ib1_idtype ;
                %End
            END-IF
            %Beg  BREAK: Relget_adr_set ;  %End
	    Initialize Relget_adr_set
            If (Ib1_rel_id of Ent_credit_set NOT = 0) Or
	       (Ib1_adr_ptr_ok of flgs3 of Ent_credit_set = "T") Then
                %Beg
		Relget_adr_set(NOTRAP);
		Ent_credit_set(NOTRAP);
                Ent_credit_set.ib1_adr_set_ptr CONN: Relget_adr_set(NOMOD) ;
		Relget_adr_set(ETRAP);
		Ent_credit_set(ETRAP);
                %End
            END-IF
            Move 1 to Csid_want_secure
            Call "GET_CDTWIRE_DEST" Using
                By content "WIR"
                By reference Csid_idtype_ws
                By reference Csid_id_ws
                By reference Csid_id_ws_length
                By content "    "
                By reference Csid_want_secure
                By reference Csid_got_secure
                By reference Csid_info_memo
                By reference Csid_info_memo_length
                By reference Csid_vmsg_ws
              RETURNING Csid_ret_stat
            If (Failure_is in Csid_ret_stat   )
                OR (Csid_got_secure = 0 )
            THEN
		%Beg
		screen_field_ws = "credit.ib1.ib1_secwir";
		error_mnemonic_ws = Csid_vmsg_ws;
		%End
	        call "FTRSCR_WRITE_ERROR" using
	          by reference screen_field_ws
		  by reference error_mnemonic_ws
                Move 1 to Secwire_dest_state_ls         %^ Ib1 secwire dest fai 
		Move 1 to Csid_bogus_parties
	    END-IF
	END-IF.

        If (Ibk_changed_ls NOT = 0 )
	   AND (Ibk_secwir of Ent_credit_set = "Y" )
	   AND (Routexcp_edit of Menu_cfg = "T" )
	THEN
* Must check for place to send secondary wire.
	    Move SPACES to Csid_id_ws	
            %Beg  Csid_temp2_vstr = NULL ;  %End
            If (Ibk_rel_id of Ent_credit_set = 0 )
                AND (Ibk_idtype of Ibk of Ent_credit_set NOT = "S" )
            THEN

                %Beg
                Csid_compose ^OUT(Csid_temp1_vstr)
                                Ent_credit_set.Ibk.Ibk_id, / ;
                Csid_parse ^IN(Csid_temp1_vstr)
                                ^STRING, "/BC", Csid_temp2_vstr,
                                ^ONEOF ( ("/", ^STRING, / ),
                                         (/) ) ;
                %End
                If (Failure_is in Csid_parse_status   )
                    %Beg
                    Csid_parse ^IN(Csid_temp1_vstr),
                                ^STRING, "/(BC", Csid_temp2_vstr,
                                ^ONEOF ( ("/", ^STRING, / ),
                                         (")", ^STRING, / ),
                                         (/) ) ;
                    %End
                    If (Failure_is in Csid_parse_status   )
                        %Beg  Csid_temp2_vstr = NULL ;  %End
                    END-IF
                END-IF
            END-IF
            If (Csid_temp2_vstr_length NOT = 0 )
                %Beg
                Csid_id_ws = Csid_temp2_vstr ;
                Csid_idtype_ws = "S" ;
                %End
            ELSE
                %Beg
                Csid_parse ^IN(Ent_credit_set.Ibk.Ibk_id)
                        Csid_id_ws, ^ONEOF ( ("/", ^STRING, / ),
                                             (/) ) ;
                Csid_idtype_ws = Ent_credit_set.Ibk.Ibk_idtype ;
                %End
            END-IF
            %Beg  BREAK: Relget_adr_set ;  %End
	    Initialize Relget_adr_set
            If (Ibk_rel_id of Ent_credit_set NOT = 0) Or
	       (Ibk_adr_ptr_ok of flgs3 of Ent_credit_set = "T") Then
                %Beg
		Relget_adr_set(NOTRAP);
		Ent_credit_set(NOTRAP);
                Ent_credit_set.ibk_adr_set_ptr CONN: Relget_adr_set(NOMOD) ;
		Relget_adr_set(ETRAP);
		Ent_credit_set(ETRAP);
                %End
            END-IF
            Move 1 to Csid_want_secure
            Call "GET_CDTWIRE_DEST" Using
                By content "WIR"
                By reference Csid_idtype_ws
                By reference Csid_id_ws
                By reference Csid_id_ws_length
                By content  "    "
                By reference Csid_want_secure
                By reference Csid_got_secure
                By reference Csid_info_memo
                By reference Csid_info_memo_length
                By reference Csid_vmsg_ws
              RETURNING Csid_ret_stat
            If (Failure_is in Csid_ret_stat   )
                OR (Csid_got_secure = 0 )
            THEN
		%Beg
			screen_field_ws = "credit.ibk.ibk_secwir";
			error_mnemonic_ws = Csid_vmsg_ws;
		%End
	        call "FTRSCR_WRITE_ERROR" using
	          by reference screen_field_ws
		  by reference error_mnemonic_ws
                Move 2 to Secwire_dest_state_ls         %^ Ibk secwire dest fai 
		Move 1 to Csid_bogus_parties
	    END-IF
	END-IF.


        If (Bbk_changed_ls NOT = 0 )
	   AND (Bbk_secwir of Ent_credit_set = "Y" )
	   AND (Routexcp_edit of Menu_cfg = "T" )
	THEN
* Must check for place to send secondary wire.
* This edit is mainly intended for banks which don't purchase the WRP function.
* Without the WRP function, messages which go to ROUTEXCPQ for lack of
* good wire advice routing information cannot be repaired. Thus, we try
* to prevent routing exceptions with an up-front edit.      
	    Move SPACES to Csid_id_ws	
            %Beg  Csid_temp2_vstr = NULL ;  %End
            If (Bbk_rel_id of Ent_credit_set = 0 )
                AND (Bbk_idtype of Bbk of Ent_credit_set NOT = "S" )
            THEN

                %Beg
                Csid_compose ^OUT(Csid_temp1_vstr)
                                Ent_credit_set.Bbk.Bbk_id, / ;
                Csid_parse ^IN(Csid_temp1_vstr)
                                ^STRING, "/BC", Csid_temp2_vstr,
                                ^ONEOF ( ("/", ^STRING, / ),
                                         (/) ) ;
                %End
                If (Failure_is in Csid_parse_status   )
                    %Beg
                    Csid_parse ^IN(Csid_temp1_vstr),
                                ^STRING, "/(BC", Csid_temp2_vstr,
                                ^ONEOF ( ("/", ^STRING, / ),
                                         (")", ^STRING, / ),
                                         (/) ) ;
                    %End
                    If (Failure_is in Csid_parse_status   )
                        %Beg  Csid_temp2_vstr = NULL ;  %End
                    END-IF
                END-IF
            END-IF
            If (Csid_temp2_vstr_length NOT = 0 )
                %Beg
                Csid_id_ws = Csid_temp2_vstr ;
                Csid_idtype_ws = "S" ;
                %End
            ELSE
                %Beg
                Csid_parse ^IN(Ent_credit_set.Bbk.Bbk_id)
                        Csid_id_ws, ^ONEOF ( ("/", ^STRING, / ),
                                             (/) ) ;
                Csid_idtype_ws = Ent_credit_set.Bbk.Bbk_idtype ;
                %End
            END-IF
            %Beg  BREAK: Relget_adr_set ;  %End
	    Initialize Relget_adr_set
            If (Bbk_rel_id of Ent_credit_set NOT = 0 ) Or
	       (Bbk_adr_ptr_ok of flgs3 of Ent_credit_set = "T") Then
                %Beg
		Relget_adr_set(NOTRAP);
		Ent_credit_set(NOTRAP);
                Ent_credit_set.bbk_adr_set_ptr CONN: Relget_adr_set(NOMOD) ;
		Relget_adr_set(ETRAP);
		Ent_credit_set(ETRAP);
                %End
            END-IF
            Move 1 to Csid_want_secure
            Call "GET_CDTWIRE_DEST" Using
		By content "WIR"
                By reference Csid_idtype_ws
		By reference Csid_id_ws 
		By reference Csid_id_ws_length
		By content  "    "
                By reference Csid_want_secure
                By reference Csid_got_secure
                By reference Csid_info_memo
                By reference Csid_info_memo_length
                By reference Csid_vmsg_ws
              RETURNING Csid_ret_stat 
	    If (Failure_is in Csid_ret_stat   )
                OR (Csid_got_secure = 0 )
            THEN
%^		%Beg Ftrscr.credit.bbk.bbk_secwir.msg = Csid_vmsg_ws ; %End
		%Beg
		screen_field_ws = "credit.bbk.bbk_secwir";
		error_mnemonic_ws = Csid_vmsg_ws;
		%End
	        call "FTRSCR_WRITE_ERROR" using
	          by reference screen_field_ws
		  by reference error_mnemonic_ws
                Move 3 to Secwire_dest_state_ls         %^ Bbk secwire dest fai 
		Move 1 to Csid_bogus_parties
	    END-IF
	END-IF.


	Set BNP_init_lkup in Cdt_screen_state to True.


SECWIR_PROCESSING_END.
	EXIT.





A110_COMPLETTION_PROCESSING.
%^ Was end portion of got_credit, runs after all lower parties are done
%^
%^ final processing
%^
%^
	If (Success_is in Csid_try_chips)
%^ It could be a two-party CHIPS
	    If ( (Dbt_bnk_inf1_length of Ent_debit_set_lengths NOT = 0)
		 AND (Dbt_bnk_inf1 of Ent_debit_set NOT = SPACES ) )
	      OR (Orp_ref_num_length of Ent_debit_set_lengths NOT = 0 )
	    THEN
		Set Failure_is in Csid_try_chips to TRUE
            END-IF
	END-IF.

* Let's check to see whether our party mapping was okay.
	If (Is_payment_ls = 0 )
* Admins have fewer requirements.
	    If (Csid_bogus_parties NOT = 0 )
* Admin credit party was not completely processed.
	        Move ZERO to Cdt_not_suspect_ls
		Set Failure_is in Creditside_screen_ls to true
	    END-IF
	ELSE
	    If ( (Credit_changed_ls Not = 0 )	%^ Was = 1
	         OR (Cdt_acc_changed_ls NOT = 0 ) )
	    THEN
		If ( (Failure_is in Csid_set_account)
		    AND (Success_is in Csid_musthave_acct   ) )
	    	 THEN
		    If ( (Success_is in Csid_set_address )
		         OR (Cdt_rel_id of Ent_credit_set NOT = 0 ) )
		    THEN
%^  Flag account-less on-file credit party
			If (Cdt_ovr of Cdt_typ of Ent_credit_set NOT = "?" )
			    %Beg  
			    Ent_credit_set.cdt_typ.cdt_ovr = "?" ;
			    %End
                	END-IF
	        	Move ZERO to Cdt_not_suspect_ls
			Set Failure_is in Creditside_screen_ls to true
		    END-IF
		END-IF
	    END-IF
	    IF (Csid_bogus_parties NOT = 0 )
* Credit party was not completely processed.
	        Move ZERO to Cdt_not_suspect_ls
		Set Failure_is in Creditside_screen_ls to true
	    END-IF
	END-IF.

	If Bnp_idtype of Bnp of Ent_credit_set = "R"
	    %Beg
	    Ent_credit_set.Bnp.Bnp_idtype = " ";
	    Ent_credit_set.Bnp.Bnp_id = " ";
	    %End
	END-IF.

	If (Bnp_id of Bnp of Ent_credit_set = SPACES )
	   AND ( (Bnp_name1_length of Ent_credit_set_lengths = 0 )
		OR (Bnp_name1 of Ent_credit_set = SPACES ) )
	THEN
	    Move 1 to No_beneficiary_ls
	ELSE
	    Move 0 to No_beneficiary_ls
	END-IF.

	If (Advice_parties_ls > 3 )
* Maximum of three advice parties.
	   Move 3 to Advice_parties_ls
	END-IF.

	%Beg
	BREAK: Csid_acc_seq ;
 	%End.

%^ ABA's shouldn't have accounts anymore...
        If Cdt_idtype of Ent_credit_set = "A" then
	    %^ And they should use the preferred fed bank if there is one
	    Move SPACES to Csid_preferred_bank
	    If (Bank of Loc_info of Ent_ftr_set = Bnk_id of Menu_bnk_union )
		Move Preferred_fed_bnk_id of Menu_bnk_union to
							    Csid_preferred_bank
	    ELSE
		%Beg
		BREAK: Csid_bnk_union ;
		SEARCH: Bnk_index 
			(Key = Ent_ftr_set.Loc_info.Bank ) ;
		%End
		If Success_is in Bnk_index_status  
		    %Beg  Bnk_index CONN: Csid_bnk_union (NOMOD) ;  %End
		    Move Preferred_fed_bnk_id of Csid_bnk_union to 
							Csid_preferred_bank
		END-IF
            END-IF
	    If ( Csid_preferred_bank NOT = SPACES AND 
					Cdt_adr_bnk_id of Ent_credit_set)
	       AND (Tran_type of Ent_ftr_set NOT = "BPF" )
	    THEN
		If (Cdt_id of Cdt_typ of Ent_credit_set(4:1) = ":" )
		    %Beg
		    Csid_parse ^IN(Ent_credit_set.Cdt_typ.Cdt_id)
			^STRING<3>, ":", Csid_temp1_vstr, ^SPACE, / ;
		    %End
		ELSE
		    %Beg
		    Csid_temp1_vstr = Ent_credit_set.cdt_typ.cdt_id ;
		    %End
		END-IF
		%Beg
		Csid_compose ^OUT(Ent_credit_set.Cdt_typ.Cdt_id)
			Csid_preferred_bank, ":", Csid_temp1_vstr, / ;
		Ent_credit_set.Cdt_adr_bnk_id = Csid_preferred_bank ;
		%End
	    END-IF
        END-IF.

%^ If this is an RTGS or CLEARING_HOUSE payment, ensure that we have a clearing
%^ account ID present 91695
	If ((RTGS_IS in Endpoint_type of Rchan_channel_set) or
	    (clrhouse_is in Endpoint_type of Rchan_channel_set)) And
	    (csid_chan_acc_ws Not = Spaces) And Not(tran_type of Ent_ftr_set = "DDR")
%^ 15225
%^ check is no good, was causing set_credit_account to always be skipped. 
%^AND ( cdt_account of Ent_credit_set NOT = csid_chan_acc_ws)
%^ Autotreive will not have seen the CDT ACCOUNT yet, already been here, skip Autrieve may have added info
%^ 15225
	Then
		%^ Connect the Clearing account and call set_credit_account
   	 	%ace_conn_root_q Rel_acc_index ;
    		%Beg
	    		BREAK: Ent_c_acc_set;
			BREAK: Ent_c_acc_rel_reg;
    			Rel_acc_index ^SEARCH (FORWARD, EQL,
			     .Rel_name_key(.Idbank = Csid_chan_acc_ws.idbank, 
			 	    .Idtype = Csid_chan_acc_ws.Idtype,
			 	    .Idkey (.Idacc = Csid_chan_acc_ws.Idkey,
				 	    .Idadr = NULL,
				 	    .Idpad = NULL ) ),
			 CONN: Ent_c_acc_set(NOMOD,
				REG: Ent_c_acc_rel_reg (NOMOD))) ;
		%end
		If (Success_is in Ent_c_acc_set_status) Then
			%^ Call Set_credit_account to connect us up
			Call "SET_CREDIT_ACCOUNT" Using
			    By reference idkey of Csid_chan_acc_ws
	    		    By reference Is_rptv_lookup_ls
	    		    By reference Special_fee_key_ls
          		RETURNING Csid_ret_stat
		end-if

* For the IF statement below, first get the .MSG field of ftrscr.credit.cdt_typ.cdt_idtyp.
		%Beg
			Screen_field_ws = "credit.cdt_typ.cdt_idtype";
		%End
		Call "FTRSCR_GET_FLDMSG" Using
                  By Reference screen_field_ws    	%^ In
	          By Reference tmp_scr_stat_ws 		%^ Out
	          By Reference tmp_scr_stat_ws_length	%^ Out

		If tmp_scr_stat_ws =  "VMSG$_DAT_NOACC" Then
			%^ Back out this error
			%Beg
				screen_field_ws = "credit.cdt_typ.cdt_idtype";
				error_mnemonic_ws = "";
			%End
			Call "FTRSCR_WRITE_ERROR" using
			  by reference screen_field_ws
			  by reference error_mnemonic_ws
			Subtract 1 from Cdt_errmemo_count_ls
			If Cdt_errmemo_count_ls = 0 then
				Set Success_is in  Creditside_screen_ls to True
			end-if
		end-if
		Set Success_is in csid_chan_imposed_acct to True
		Move 1 to Cdt_account_okay_ls
		Set Failure_is in Csid_itsa_clearhouse to True
	end-if.
	%^ Lets add any IBAN as NATIVEACCOUNT PRM that we may have encountered
	%^ along the way.
	
	If csid_orig_iban_ws_length > 0 and
	   csid_orig_iban_ws (1:csid_orig_iban_ws_length) not = spaces Then
		  %Beg
	 	  Compose ^OUT(csid_prm_name_ws) "MTS$CDTNATIVE_ACCOUNT", /; 
		  Compose ^OUT(csid_prm_value_ws) csid_orig_iban_ws, /;
		  csid_Prm_level_wo msg_is;
		  csid_Prm_source_wo msg_is;
		  csid_Prm_edit_wo Text_is;
		  %End
		  Initialize csid_prm_time_on_ws, csid_prm_time_off_ws
		  Initialize csid_prm_remaining_ws
		  Set Success_is in csid_prm_mode_wf to True
		  Call "PRULE_MSG_UPDATE_PARAM" using
			   by reference csid_prm_name_ws,	  %^ vstr(40)
			   by reference csid_prm_name_ws_length,  %^ length
			   by reference csid_prm_level_wo, 	  %^ PRULE_LEVEL_ONEOF.DDF
			   by reference csid_prm_source_wo, 	  %^ PRULE_SOURCE_ONEOF.DDF
			   by reference csid_prm_time_on_ws,	  %^ time
			   by reference csid_prm_time_off_ws,	  %^ time
			   by reference csid_prm_edit_wo, 	  %^ PR_PARAM_EDIT_ONEOF.DDF
			   by reference csid_prm_mode_wf,	  %^ boolean
			   by reference csid_prm_remaining_ws	  %^ long
			   by reference csid_prm_value_ws,	  %^ vstr(80)
			   by reference csid_prm_value_ws_length, %^ length
			   by reference csid_prm_present_wf, 	  %^ boolean
			   by reference csid_prm_memo_ws,	  %^ vstr(ACE$_MSG_STR_SIZE)
			   by reference csid_prm_memo_ws_length	  %^ length
			   returning csid_prm_status_wf		  %^ boolean
	end-if.


	Add Csid_this_deletes to Csid_total_deletes
	Add Csid_this_psflags to Csid_total_psflags
	If (Csid_total_psflags > Csid_loop_limit )
	   OR (Csid_total_deletes > Csid_loop_limit )
	THEN
%^ Do nothing for now
	    Add 1 to Csid_this_more
	END-IF.
        %Beg  BREAK: Csid_bnk_union;  %End.


%^ Begin the clear out of an Address that id not in the same bank as the Clearing 
%^ Account being paid. 
%^
	If Success_is in Fed_xbank_nopref_flg
	Then
		If (Idbank of Cdt_account of Ent_credit_set is not = Cdt_adr_bnk_id of Ent_credit_set And
		    Idbank of Cdt_account of Ent_credit_set is not = spaces )
		And ((RTGS_IS in Endpoint_type of Rchan_channel_set) or
		     (clrhouse_is in Endpoint_type of Rchan_channel_set))
		And
		    ((Cdt_rel_id of Ent_credit_set NOT = 0 ) or
		     (Cdt_adr_ptr_ok of Flgs3 of Ent_credit_set = "T"))
		Then
			%^ Take the Credit off file and set the cdtr_adr_bnk_id to match the
			%^ Clearing account. THis is the bank where the payment should take place
		    %Beg
			    Ent_credit_set(
				 .cdt_adr_bnk_id = ent_credit_set.cdt_account.idbank,
			         .cdt_rel_id = <0>, 
				 .Cdt_spc_inst1 = null,
				 .Cdt_spc_inst2 = null,
				 .Cdt_spc_inst3 = null,
				 .Cdt_department = null,
				 .Cdt_adr_class = null,
				 .Cdt_adr_type = null,
				 .cdt_wir_key = null,
 			 	 .cdt_adr_set_ptr   delete ,
				 .flgs3.cdt_adr_ptr_ok = Null,
				 .cdt_typ.cdt_ovr = "*") ;
			    Break: Relget_adr_set;
       		     %End
		     %^ Update the Prule info
		     Perform X930_CHANGE_CREDIT thru
			     X930_CHANGE_CREDIT_END		

	   	     %beg csid_upd_level cdt_party_is; %end
		     Call "PRULE_UPDATE_PARTY" Using
				By Reference csid_upd_level
				By Reference csid_pr_memo
				by reference csid_pr_memo_length
		     returning csid_ret_stat
		End-if
	END-IF.

	Set Complete_is in Cdt_screen_state to True.


A110_COMPLETION_PROCESSING_END.
   EXIT.

B100_CDT_SCREEN_INIT.
%^
%^ Initialization of lookup start
%^
	%Beg  Csid_next_function = Menu_next_function;  %End %^ Assume we're staying a while
	Move 1 to Cdt_not_suspect_ls.
        Move 4 to Secwire_dest_state_ls.        %^ No secwire dest edit failed  
	Move ZERO to Credit_depth_ls.
	Move ZERO to Csid_credit_changed.
	Move ZERO to Advice_parties_ls
	Move ZERO to Cdt_errmemo_count_ls.
	Move ZERO to Csid_bogus_parties.
	Set Failure_is in Csid_IRS_tran to TRUE.
	Move 1 to Cdt_account_okay_ls.
	Set Failure_is in Csid_set_address to TRUE.
	Set Failure_is in Csid_set_account to TRUE.
	Move ZERO to Csid_second_id_length.
	Set Success_is in Csid_musthave_acct to true.
	Set Failure_is in Csid_iban_expanded to True.
	Set Failure_is in Csid_Chdet_called to True.
	Set Failure_is in csid_chan_imposed_acct to True.
	Set None_is in csid_iban_party_ws to True.
	Set Failure_is in Csid_disable_ain_ws to True.
	Move SPACES to Csid_orig_iban_ws, Csid_irr_acc_type_ws,
	               csid_prm_method_ws, csid_prm_secwir_ws, csid_acctg_method_ws,
		       csid_ucc_save_src.
	Initialize csid_iban_cntry_ws, csid_bnk_code_rec_ws, csid_save_cntry_ws.
	Move SPACE to Csid_id_bank_ws.
	Set Failure_is in  Csid_iban_bbk_proc To True.
	Set Failure_is in TGT2_subpartic to True.
	Set Failure_is in csid_non_ucc_src to True.

	%^ with and ADvice change, we will most likely need to force a
	%^ redo of the credit party/account
	If (adv_changed_ls NOT = 0) Then
		%^ move 1 to cdt_acc_changed_ls
		move 1 to credit_changed_ls
	end-if.
	If ( Cdt_adv_flg of Ent_ftr_set = "Y")
	   AND (Cdt_adv_typ of Ent_credit_set NOT = SPACES )
	THEN
	    Move Cdt_adv_typ of Ent_credit_set to Csid_opr_advice
	ELSE
	    Move SPACES to Csid_opr_advice
	END-IF.
	Move SPACES to Csid_ain_advice.
	%Beg
	Csid_pref_corr_rec = NULL ;
	Csid_pref_next_id_rec = NULL ;
	Csid_chan_acc_ws = NULL;
	Csid_next_function = Menu_next_function; 
	Csid_tgt_account_bic = NULL;
	%End

	Move SPACES To Csid_corr_derivation.
	Set Failure_is in Csid_cor_found to true.
        Move Credit_currency_ls to Csid_currency_ws.
	Set Failure_is in Csid_push_error to TRUE.
	Move ZERO to Csid_pushed_credit.

	Set Success_is in Initial_Ain to True.


	If (Not_loaded_is in Lkup_cfg_values_ws)
	Then
		Set Loaded_is in lkup_cfg_values_ws to True
		Call "GCV_STRCTRD_ACCT_IN_USE" using
			by reference csid_struct_acct_ws
		If (csid_struct_acct_ws = "Y") Then
			Call "GCV_BBAN_CNTRY_REQ" using
			      by reference csid_tmp_flg_ws
			If csid_tmp_flg_ws = "Y" or "T" THen
				Set Success_is in csid_bban_cntry_req_ws to True
			else
				Set Failure_is in csid_bban_cntry_req_ws to True
			end-if
		end-if
		Call "GCV_COLLECTIONS_TRAN_TYP" using
			by Reference Csid_col_tran_type_ws
		Perform X1000_check_for_fed thru
			X1000_check_for_fed_end
%^		Get config flag for replacing lower debit party BCC Id with BIC
%^		Call "GCV_LKUP_BIC_BY_BCC" using
%^			by reference Lkup_bic_by_bcc_ws
%^ Get config flag for 6 character BIC match on dual ids
%^		Call "GCV_SWF_DUALID_MATCH6" using
%^			by reference csid_tmp_flg_ws
		Perform X1400_CHK_DUAL_MATCH6 Thru
			X1400_CHK_DUAL_MATCH6_END
		If csid_tmp_flg_ws = "Y" or "T" Then
			Set Success_is in Csid_swf_dualid_match6 to True
		else
			Set Failure_is in Csid_swf_dualid_match6 to True
		end-if

		Call "GCV_FED_XBANK_NOPREF" using
		      by reference csid_tmp_flg_ws
		If csid_tmp_flg_ws = "Y" or "T"
		Then
			Set Success_is in Fed_xbank_nopref_flg to True
		Else
			Set Failure_is in Fed_xbank_nopref_flg to True
		End-if
	End-if.

* Set up loop detector
	Move ZERO to Csid_this_deletes, Csid_this_psflags, Csid_this_more.
	If (Trn_date of Trn_ref of Ent_ftr_set NOT = Ctrn_date of Csid_trn )
	   OR (Trn_num of Trn_ref of Ent_ftr_set NOT = Ctrn_num of Csid_trn )
	   OR (Trn_ref of Ent_ftr_set = SPACES )
	THEN
	    Move Trn_date of Trn_ref of Ent_ftr_set to Ctrn_date of Csid_trn
	    Move Trn_num of Trn_ref of Ent_ftr_set to Ctrn_num of Csid_trn
	    Move ZERO to Csid_total_deletes
	    Move ZERO to Csid_total_psflags
	    Move 1 to Csid_entries
	ELSE
	    Add 1 to Csid_entries
	END-IF.

%^	 Record initial shallowest party. %^ obselete
%^ Check for lower party UCC handling
	If NOT(csid_ucc_save_src = src_code of Ent_ftr_set) or
	      (csid_ucc_save_src = spaces)
	Then
		Perform X1300_CHK_UCC_SRC thru
			X1300_CHK_UCC_SRC_END
	End-if.

	%Beg  Csid_know_acc_id = NULL;  %End.
	If (Credit_account_ls NOT = SPACES )
            Move Credit_account_ls to Csid_instring
	    %Beg
	    Csid_clip_compose ^OUT(Csid_temp1_vstr)
		Csid_instring, / ;
	    Csid_parse ^IN(Csid_temp1_vstr)
		^OPTION( Csid_know_acc_id.idbank(^STR<3>)),
		Csid_intype_oneof( ^ONEOF(" ",
					"D",
					"G",

					"V",
					"F",
					"P" )),
		Csid_know_acc_id.idkey(^STR<-1>), / ;
	   Csid_compose ^OUT(Csid_know_acc_id.idtype)
		Csid_intype_oneof(^ONEOF(" ",
					"D",
					"G",
					"V",
					"F",
					"P" )), / ;
	   %End
	END-IF.


	If (Cor_done in Si_flgs of Ent_ftr_set = SPACE)
	   AND (Src_code of Ent_ftr_set NOT = "COR" )
	THEN
	    Move 2 to Csid_num_AINSIs
	%^    %Beg  Csid_AINSI_Types = "CDTAIN,COR" ;  %End
	ELSE
	    If (Cor_done in Si_flgs of Ent_ftr_set = "P" )
		Set Success_is in Csid_cor_found to true
	    END-IF
* Don't interrupt AIN search for CORs.  Been there, done that.
	    Move 1 to Csid_num_AINSIs
	 %^   %Beg  Csid_AINSI_Types = "CDTAIN" ;  %End
	END-IF.

	Set Failure_is in Csid_found_it to true.
	If (Tran_type of Ent_ftr_set = "IRS")
	   AND (Cdt_idtype of Cdt_typ of Ent_credit_set = SPACE)
	THEN
	    %Beg
	    Csid_union_key_ws(.Idname = "FED_CHIP_TABLES",
		  	      .Idprod = "MTS", 	   
		   	      .Idbank =  Menu_bnk_union.Bnk_id,    
		  	      .Idloc  = null,    	   
		  	      .Idcust = null);
	    Csid_compose ^OUT(Csid_item_key_ws),
			"TTL_ABA_ACCOUNTS:", /; 
	    Csid_compose ^OUT(Csid_match_key_ws),
			Menu_bnk_union.Bnk_ID, / ;
	    Csid_seq_ordinal_ws = <1>;
	    Csid_item_type_ws = "VSTR(80)";
	    %End
	    Call "CFG_GET_ITEM" USING
	        BY Reference Idname of Csid_union_key_ws
	        BY Reference Idprod of Csid_union_key_ws
	        BY Reference Idbank of Csid_union_key_ws
	        BY Reference Idloc of Csid_union_key_ws
	        BY Reference Idcust of Csid_union_key_ws
	        BY Reference Csid_item_key_ws
                By Reference Csid_seq_ordinal_ws
       	        By Reference Csid_item_type_ws
                By Reference Csid_item_data_ws
       	        By Reference Csid_item_data_ws_length
                By Reference Csid_error_msg_ws
       	        By Reference Csid_error_msg_ws_length
              RETURNING Csid_ret_stat
	    If (Success_is in Csid_ret_stat )
		AND (Csid_item_data_ws_length > 0 )
	    THEN
		%Beg
		Csid_parse ^IN(Csid_item_data_ws)
		    Csid_ttl_account, "|", ^STRING, / ;
		%End
                If Success_is in Csid_Parse_Status
		    %Beg
		    Ent_credit_set.Cdt_typ (.Cdt_ovr = null,
					    .Cdt_idtype = "A",
					    .Cdt_id = Csid_Ttl_account);
		    %End
		    Set Success_is in Csid_IRS_tran to TRUE
		END-IF
	    END-IF
	END-IF.
	%Beg  Relget_msgcode = NULL;  %End.


	Set Cdt_lkup in Cdt_screen_state to True.

B100_CDT_SCREEN_INIT_END.
	EXIT.



B200_BNP_INIT_LKUP.
%^ MOVE INTO BNP LOOKUP flag SETTING

	If (Bnp_id of Bnp of Ent_credit_set NOT = SPACES )
	   OR ( (Bnp_name1_length of Ent_credit_set_lengths NOT = 0 ) 
	        AND (Bnp_name1 of Ent_credit_set NOT = SPACES ) )
	THEN
	    If (Success_is in Csid_try_chips)
		AND ( (Bnp_changed_ls = 0 )
		      AND (Adv_changed_ls = 0 )
	              AND (Credit_changed_ls NOT = 1 ) )
		AND (Bnp_qualified_ls NOT = 0 )
	    THEN
		Set Failure_is in Csid_try_chips to TRUE
		Set Completion_proc in Cdt_screen_state to True
		Go To B200_BNP_INIT_LKUP_END
	    ELSE
	        If NOT( (Csid_pushed_credit NOT = 4 )
		       AND ( (Success_is in Csid_try_chips)
		       OR (Bnp_changed_ls NOT = 0 ) ))
		THEN
			Set Completion_proc in Cdt_screen_state to True
			Go To B200_BNP_INIT_LKUP_END
		END-IF
	    END-IF
	Else
		%^ Blank Field, exit
		Set Completion_proc in Cdt_screen_state to True
		Go To B200_BNP_INIT_LKUP_END
	END-IF.

*  Paragraph to do account lookup on the BNP.  
*  If Success_is in Csid_try_chips we will try to chips qualify it.
*  If it is not set, then we do a REL lookup using C660_LOWER_CREDIT.  
*     If the REL lookup succeeds, we use FIND_ADR_ID to perfect our external
*    	   id and copy in the name and address info.  We set the
*          Bnp_adr_set_ptr and copy in the Bnp_adv_inst.

	If (bnp_adr_ptr_ok of flgs3 of ent_credit_set NOT = Spaces)
	then	%^ hose out prior lookup
		%beg Ent_credit_set(.bnp_rel_id = <0>,
				    .bnp_adr_set_ptr DELETE,
				    .flgs3.bnp_adr_ptr_ok = Null);
		%end
	end-if.

	%^ If BNP has changed, change the country too if not differently entered.
	If (bnp_res_country of Ent_credit_set = bnp_res_country of Change_credit_set)
	AND  ( bnp_id of bnp of ent_credit_set NOT = bnp_id of bnp of Change_credit_set) %^ 107747
 	And  ( bnp_idtype of bnp of Ent_credit_set NOT = Spaces)       %^ 117819
	Then
		%beg Ent_credit_set.bnp_res_country = NULL; %end
	end-if.


* If not "global" IDTYPE, no lookup. Bank-specific IDTYPES
* are assumed to refer to accounts at the "other" bank.
	%Beg  Relget_msgcode = NULL;  %End.
	If (Bnp_idtype of Bnp of Ent_credit_set NOT = "N")
	   AND (Bnp_idtype of Bnp of Ent_credit_set NOT = "A")
	   AND (Bnp_idtype of Bnp of Ent_credit_set NOT = "S")
	   AND (Bnp_idtype of Bnp of Ent_credit_set NOT = "C")
           AND (Bnp_idtype of Bnp of Ent_credit_set NOT = "X")
           AND (Bnp_idtype of Bnp of Ent_credit_set NOT = "T")
           AND (Bnp_idtype of Bnp of Ent_credit_set NOT = "U")
	   AND (Bnp_idtype of Bnp of Ent_credit_set NOT = "@")
	   AND (Bnp_idtype of Bnp of Ent_credit_set NOT = "E")
	   AND (Bnp_idtype of Bnp of Ent_credit_set NOT = SPACE)
	THEN
		Perform B200_BNP_CLEANUP thru B200_BNP_CLEANUP_END
		GO TO B200_BNP_INIT_LKUP_END
	END-IF.

	IF ( Bnp_idtype of bnp of Ent_credit_set = SPACE and
	     Bnp_id     of bnp of Ent_credit_set = SPACE) Then
		Perform B200_BNP_CLEANUP thru B200_BNP_CLEANUP_END
		GO TO B200_BNP_INIT_LKUP_END
	end-if.

        %^ If a Repetitive with multiples,  then clear any info
        %^ after the 1st and remap , it will be re-mapped.
        If (Is_rptv_lookup_ls NOT = 0 )
        THEN
                %Beg
                Csid_parse ^IN(Ent_credit_set.Bnp.Bnp_id)
                        Csid_temp1_vstr, "/(", ^STRING, ^SPACE, / ;
                %End

                If Success_is in Csid_parse_status
                        %Beg
                        Csid_compose ^OUT(Ent_credit_set.Bnp.Bnp_id)
                                Csid_temp1_vstr, / ;
                        %End
                End-if
        End-if.

        Set Failure_is in Csid_multi_party to true.
        Move SPACES to Csid_party_id.

        %Beg Csid_party_idtype = Ent_credit_set.bnp.bnp_idtype;
            Csid_parse ^IN(Ent_credit_set.Bnp.Bnp_id)
                        Csid_party_id, ^SPACE, / ;
        %End

	If Success_is in Csid_parse_status   then
	        %Beg
		Csid_parse ^IN(Csid_party_id),
		    ^ONEOF(
   (^string<2>(<CHAR$M_ALPHA>), "/",Csid_party_extype(^STRING<2>(<CHAR$M_ALPHA>)), 
				Csid_temp1_vstr, ^SPACE, /),
	(Csid_temp1_vstr, "/",Csid_party_extype(^STRING<2>(<CHAR$M_ALPHA>)), 
				^STRING, ^SPACE, /),
			(Csid_temp1_vstr, "/??", ^STRING, ^SPACE, /));
	        %End
	        If (Success_is in Csid_parse_status   )
		    AND (Csid_temp1_vstr_length NOT = 0 )
		THEN
		    Set Success_is in Csid_multi_party to true
	        END-IF
	END-IF.

* put in N or @ id if left blank by operator
	IF (Bnp_idtype of Bnp of Ent_credit_set = "N" OR "@")
	   AND (Bnp_id of Bnp of Ent_credit_set = SPACES)
	THEN
	    If Bnp_name1 of Ent_credit_set NOT = SPACES
		MOVE SPACES TO Csid_20charid_ws
		If Bnp_idtype OF Bnp OF Ent_credit_set = "N"
		    Call "AUTONAM" USING
			By reference Bnp_name1 OF Ent_credit_set
			By reference Bnp_name1_length of Ent_credit_set_lengths
			By reference Csid_20charid_ws
			By reference Csid_length
		ELSE
		    Call "CREATE_AUX_MNAM" USING 
			By reference Csid_20charid_ws
			By reference Bnp_name1_length of Ent_credit_set_lengths
			By reference Bnp_name1 OF Ent_credit_set
			By reference Bnp_name2_length OF Ent_credit_set_lengths
			By reference Bnp_name2 OF Ent_credit_set
			By reference Bnp_name3_length OF Ent_credit_set_lengths
			By reference Bnp_name3 OF Ent_credit_set
			By reference Bnp_name4_length OF Ent_credit_set_lengths
			By reference Bnp_name4 OF Ent_credit_set
		END-IF
		MOVE %SIZ(Csid_20charid_ws) TO Csid_20charid_ws_length
		%Beg
		Csid_compose ^OUT(Ent_credit_set.Bnp.Bnp_id), 
				Csid_20charid_ws, /;
		%End
	    ELSE
*		error, name missing
		%Beg
		screen_field_ws = "credit.bnp_name1";
		error_mnemonic_ws = "FTRSCR$_NAMEMISSING";
		%End
	        call "FTRSCR_WRITE_ERROR" using
	          by reference screen_field_ws
		  by reference error_mnemonic_ws
		Add 1 to Csid_bogus_parties
		Add 1 to Cdt_errmemo_count_ls
		Perform B200_BNP_CLEANUP thru B200_BNP_CLEANUP_END
		GO TO B200_BNP_INIT_LKUP_END
	    END-IF
	END-IF.

	Set Failure_is in Csid_found_it to true.
	Set Failure_is in Csid_chips_candidate to true.
	Set Failure_is in Csid_chips_party to true.
	Set Failure_is in Csid_chips_override to true.


	If (Bnp_idtype of Bnp of Ent_credit_set = "@" )
	Then
		Set Bnp_Aux_lkup in Cdt_screen_state to True
	Else
		Set Bnp_lookup in Cdt_screen_state to True
	End-if.

B200_BNP_INIT_LKUP_END.
	EXIT.

B200_BNP_AUX_LKUP.

* We're being asked to search the AUX database, so let's do it before
*  we try the CHIPS qualification.
	%Beg
	    Csid_parse ^IN(Ent_credit_set.Bnp.Bnp_id ) ^SPACE, Csid_id_ws, 
		    ^SPACE, / ;
	%End

	Set BNP in Relget_title_flag to TRUE
	Move SPACES to Csid_lkup_pend_del	
	%Beg  Csid_next_function = Menu_next_function;  %End
	Call "REL_GET" USING 
		By content "&"
		By reference Csid_id_ws
		By reference Csid_id_ws_length
		by reference Csid_lkup_pend_del
	RETURNING Csid_ret_stat

	If (Relget_reject_flag = "M")	Or
   	   (Csid_next_function not = Menu_next_function)
	Then
		Set Menu_is in cdt_screen_state to True
		Go to B200_BNP_AUX_LKUP_END
	End-if

	If Success_is in Relget_ambiguous_wf
	Then
		Set Success_is  	in Resolve_Ambiguous to True
		Set Bnp_Aux_Conn 	in CDT_screen_state  to True
		Go to B200_BNP_AUX_LKUP_END
	Else
		Set Bnp_Aux_Compl in Cdt_screen_state to True
	End-if.

	

B200_BNP_AUX_LKUP_END.
	EXIT.

B200_BNP_AUX_CONN.
%^
%^
	Call "RELGET_CONNECT" USING 
	    by reference csid_lkup_pend_del
	  RETURNING csid_ret_stat.

	Set Bnp_Aux_Compl in cdt_screen_state to True. 

B200_BNP_AUX_CONN_END.
	EXIT.

B200_BNP_AUX_COMPL.

	If (Relget_msgcode = Vmsg_dat_notonfile_wc ) OR
	   (Success_is in Csid_ret_stat   )
	THEN
		Set Success_is in Csid_found_it to true
		Move "BNP" to Bcc_lkup_party
	    	Perform D100_BCC_LKUP_BIC thru D100_BCC_LKUP_BIC_END
	    	If Failure_is in Bcc_lkup_status
		    Set Error_is in cdt_screen_state to True
		    GO TO B200_BNP_AUX_COMPL_END
		end-if
		If (Relget_return_key NOT = SPACES )
		    %Beg
	            Csid_parse ^IN(Relget_return_key), 
		            Ent_credit_set.bnp.bnp_id, ^SPACE, / ;
		    Ent_credit_set.bnp.bnp_idtype = Relget_return_idtype ;
		    %End
		END-IF

%^ icr_000636 Remove any invalid error messages that may have been found
%^	      before the beneficiary selection was made from an ambiguous 
%^	      screen.

		If Screen_field_ws Not = Spaces And
%^		   (Csid_party_idtype Not = "A" or "C" or "D" or "E" or "P" or "S" or " ")
		   Idtype of Rel_name_key of Relget_index Not =
			Idtype of Disp_id of Relget_index
		Then
		    %Beg
			error_mnemonic_ws = "";
		    %End
	            call "FTRSCR_WRITE_ERROR" using
	          	by reference screen_field_ws
		  	by reference error_mnemonic_ws
		End-if
	ELSE
* We did a generic lookup which failed.
		%Beg
			screen_field_ws = "credit.bnp.bnp_id";
			error_mnemonic_ws = "VMSG$_LOOKUPFAIL";
		%End
	        call "FTRSCR_WRITE_ERROR" using
	          by reference screen_field_ws
		  by reference error_mnemonic_ws
		Add 1 to Csid_bogus_parties
		Add 1 to Cdt_errmemo_count_ls
	END-IF.


	Set Bnp_lookup in Cdt_screen_state to True.

B200_BNP_AUX_COMPL_END.
	EXIT.


B200_BNP_LOOKUP.
	If (Success_is in Csid_try_chips)
* If Ent_debit_set.Dbt_wir_key.idtype is a *, it automatically qualifies.
	    If Idtype of Dbt_wir_key of Ent_debit_set = "*" 
	        Move 1 to Bnp_qualified_ls
		Set Failure_is in Csid_try_chips to TRUE
		Perform B200_BNP_CLEANUP thru B200_BNP_CLEANUP_END
	        GO TO B200_BNP_LOOKUP_END
	    END-IF
	    Move 0 to Bnp_qualified_ls

            If (Bnp_id of Ent_credit_set = spaces)
            or (Bnp_length of Ent_credit_set_lengths NOT > 2 )
            THEN
* No ID to qualify
                Set Failure_is in Csid_try_chips to TRUE
            END-IF

%^ Try for CHIPS qualification lookup.
            If Success_is in Csid_try_chips
	        Call "CUST_EXTENDED_ID_QUAL"  USING
		    by Reference Bnp_idtype of Ent_credit_set
		    by Reference Bnp_id of Ent_credit_set
		    by Reference Bnp_id_length of Ent_credit_set_lengths
		    by Reference Bnp_idtype of Ent_credit_set
		    by Reference Bnp_id of Ent_credit_set
		    by Reference Bnp_id_length of Ent_credit_set_lengths
		    by Reference Csid_tmp_flg_ws
		    by Reference Csid_temp1_vstr
		    by Reference Csid_temp1_vstr_length
	          returning Csid_temp_stat

	        Call "CHIPS_QUALIFICATION"  USING
		    By reference Bnp_idtype of Bnp of Ent_credit_set
		    By reference Bnp_id of Bnp of Ent_credit_set
	          RETURNING Csid_ret_stat
	        If   (Success_is in Csid_ret_stat   )
		 And (Success_is in  Csid_chp_qual_cand)
		Then
		    Set Success_is in Csid_found_it to true
		    Set Success_is in Csid_chips_candidate to true
	        ELSE
%^ Override pseudo-qualification is not needed for the interactive case.
                    Set Failure_is in Csid_found_it to true
                    Move ZERO to Bnp_qualified_ls
	        END-IF
	    END-IF
	END-IF.
	If (Success_is in Csid_try_chips )
	    Set Failure_is in Csid_try_chips to TRUE
	    If (Success_is in Csid_chips_candidate   )
%^ Relget_adr_set is copy of address rel for chips candidate
*   BNP party has an account at the Ent_credit_set bank, so we can create 
*   an ID string from the full qualification data (UID, Swift ID, and
*   account ID).
	        Call "CUST_EXTENDED_ID_QUAL"  USING
		    by Reference Bnp_idtype of Ent_credit_set
		    by Reference Bnp_id of Ent_credit_set
		    by Reference Bnp_id_length of Ent_credit_set_lengths
		    by Reference Bnp_idtype of Ent_credit_set
		    by Reference Bnp_id of Ent_credit_set
		    by Reference Bnp_id_length of Ent_credit_set_lengths
		    by Reference Csid_tmp_flg_ws
		    by Reference Csid_temp1_vstr
		    by Reference Csid_temp1_vstr_length
	          returning Csid_temp_stat

 		Call "CHIPS_QUALIFICATION_IDSTR"  USING
		    By reference Bnp_idtype of Bnp of Ent_credit_set
		    By reference Bnp_id of Bnp of Ent_credit_set
                    By reference Bnp_id_length of Ent_credit_set_lengths
		    By reference Csid_id_ws
		    By reference Csid_id_ws_length
		  RETURNING Csid_chips_party
                If (Failure_is in Csid_chips_party   )
* Could have case of a COMMON UID and SWIFT TID.
                    Perform C670_CHECK_COMMON_UID thru
                            C670_CHECK_COMMON_UID_end
                    If Success_is in Csid_chips_party  

                        %Beg
                        Ent_credit_set (.bnp.bnp_idtype = Csid_party_idtype,
                                        .bnp.bnp_id = Csid_id_ws ) ;
                        %End
                    END-IF
                END-IF
	    END-IF
            If (Failure_is in Csid_chips_party   )
                Set Failure_is in Csid_found_it to true
                Move ZERO to Bnp_qualified_ls
            ELSE
* Removed overflow - obsolete
                %Beg
                Ent_credit_set (.bnp.bnp_id = Csid_id_ws, CHANGE ) ;
                %End
                Move 1 to BNP_qualified_ls
	    END-IF
	END-IF.

	If (Success_is in Csid_chips_party   )
	    OR (Success_is in Csid_chips_override   )
	THEN
	    If Success_is in Csid_found_it
		Perform B205_BNP_ADDRESS through B205_BNP_ADDRESS_END
		Perform B200_BNP_CLEANUP thru B200_BNP_CLEANUP_END
	    Else
		Set Completion_PROC in Cdt_screen_state to True
	    END-IF
	    Go to B200_BNP_LOOKUP_END
	END-IF.

	If (Bnp_changed_ls = 0 )
	    AND (Adv_changed_ls = 0 )
	THEN
%^ Nothing to do
	    Perform B200_BNP_CLEANUP thru B200_BNP_CLEANUP_END
	    Go To B200_BNP_LOOKUP_END
	END-IF.

        If (Bnp_changed_ls NOT = 0 )
%^ Look at whether or not BNP is a bank.
	    If (bnp_bnk_flg of ent_credit_set = spaces) Or
	       (bnp_bnk_flg of ent_credit_set = "N") Then
		%^ preserve if entered already KB reset if ID provided 
		    If (Csid_party_idtype = "B" OR "A" OR "S" )
	       	     	%Beg  Ent_credit_set.Bnp_bnk_flg = "Y";  %End
		    ELSE
		    	%Beg  Ent_credit_set.Bnp_bnk_flg = "N";  %End
		    END-IF
	     end-if
	END-IF.

	If ( (Bnp_name1_length of Ent_credit_set_lengths NOT = 0 ) 
             AND (Bnp_name1 of Ent_credit_set NOT = SPACES ) )
	   OR ( (Bnp_name2_length of Ent_credit_set_lengths NOT = 0 ) 
             AND (Bnp_name2 of Ent_credit_set NOT = SPACES ) )
	   OR ( (Bnp_name3_length of Ent_credit_set_lengths NOT = 0 ) 
             AND (Bnp_name3 of Ent_credit_set NOT = SPACES ) )
	   OR ( (Bnp_name4_length of Ent_credit_set_lengths NOT = 0 ) 
             AND (Bnp_name4 of Ent_credit_set NOT = SPACES ) )
	THEN
	    Set Failure_is in Csid_lc_noaddress to true
	ELSE
	    Set Success_is in Csid_lc_noaddress to true
	END-IF.

%^
%^ This section will most likely need to be changed once the bank approves the
%^ Country chioce logic spec
%^

	If (Bnp_idtype of Bnp of Ent_credit_set = SPACE And
	    bnp_id of bnp of ent_credit_set NOT = spaces) And
	    csid_struct_acct_ws = "Y" or "T"
	THEN
		Set Failure_is in csid_lookup_bban to True	%^ assume invalid
		%beg
			Csid_party_id = Ent_credit_set.bnp.bnp_id ; 
			Csid_party_idtype = Ent_credit_set.Bnp.Bnp_idtype ;
		%End
		Initialize csid_iban_bnk_ws, csid_iban_bnk_ws_length 
		Initialize csid_iban_brnch_ws, csid_iban_brnch_ws_length
		Initialize csid_iban_curr_ws
		Initialize Csid_bnk_code_rec_ws, csid_bnk_code_rec_ws_lengths
		Initialize csid_valid_iban_flg_ws

%^xxxx		Initialize csid_val_iban_ret			%^ Was really setting this to Success
		Set Success_is IN csid_val_iban_ret to true	%^ SPR 136107

		If Bnp_mailing_country of ent_credit_set Not = SPACES then
		    %beg csid_iban_cntry_ws = ent_credit_set.bnp_mailing_country; %end
		Else
		    If (Bbk_id of Bbk of Ent_credit_set not = SPACES or
			Bbk_name1 of Ent_credit_set not = SPACES) then
			 If Bbk_res_country of ent_credit_set not = SPACES then
			     %beg csid_iban_cntry_ws = ent_credit_set.bbk_res_country; %end
			     %beg Ent_credit_set.Bnp_mailing_country = ent_credit_set.bbk_res_country; %end
			 End-if
		    Else
			 %beg csid_iban_cntry_ws = ent_credit_set.cdt_res_country; %end
			     %beg Ent_credit_set.Bnp_mailing_country = ent_credit_set.Cdt_res_country; %end
		    End-if

		End-if
		%^
		%^ Check the Next party up, for a BIC to up
		%^
		If (Bbk of Ent_credit_set not = SPACES or 
		    Bbk_name1 of Ent_credit_set not = SPACES) then
			Initialize Csid_res_country_ws
			If Bbk_idtype of bbk of Ent_credit_set = "S" Then
			    If  Bbk_id of Bbk of Ent_credit_set(4:1) = ":"
			    Then
				    Move Bbk_id of Bbk of Ent_credit_set(9:2) to Csid_res_country_ws
			    Else
				    Move Bbk_id of Bbk of Ent_credit_set(5:2) to Csid_res_country_ws
			    End-if
			Else
			    If (bbk_adr_ptr_ok of flgs3 of ent_credit_set = "T")
			    Then
				%beg break: csid_tmp_adr_set;
		    			     Ent_credit_set.bbk_adr_set_ptr CONN: csid_tmp_adr_set;
		    			     break: csid_tmp_adr_set;
				%end
	    			If (Swift_id of csid_tmp_adr_set Not = Spaces)
				Then
				    Move Swift_id of  csid_tmp_adr_set(5:2) to Csid_res_country_ws
				end-if
			    Else
				If Bbk_idtype of bbk of Ent_credit_set = "E"
				Then
					%^ get country for Extended IDs table
					%beg
						Csid_parse ^in(ent_credit_set.bbk.bbk_id)
							Csid_party_extype (^STRING<2>),
							csid_gcheck_id,/;
					%end
					CALL "CUST_XTEND_ID_EDIT" using
						BY REFERENCE Csid_party_extype
		   				BY REFERENCE Csid_gcheck_id
		   	     			BY REFERENCE Csid_gcheck_id_length
		    				BY REFERENCE Csid_temp1_vstr
		    				By REFERENCE Csid_temp1_vstr_length
		    				By REFERENCE Csid_delay_change
		    				BY REFERENCE Csid_got_advice
		    				By Reference Csid_extnd_country
		    				BY REFERENCE Csid_error_memo
		    				BY REFERENCE Csid_error_memo_length
		    				By REFERENCE Csid_error_code
		    				By REFERENCE Csid_error_code_length
		    				BY REFERENCE Csid_check_stat
		    				BY REFERENCE Csid_not_garbage
		  			RETURNING Csid_ret2_stat
					If Success_is in Csid_ret2_stat And
					   Csid_extnd_country NOT = Spaces
					Then
						%beg csid_res_country_ws = csid_extnd_country; %end
					end-if
					%^ get country for Extended IDs table
				end-if
			    end-if
			end-if
	    		If Csid_res_country_ws not = spaces
	        	    %Beg Csid_iban_cntry_ws = Csid_res_country_ws; %End
			    If bnp_mailing_country of Ent_credIt_set = Spaces
			    Then
				    %Beg Ent_credit_set.bnp_mailing_country = Csid_res_country_ws; %End
			    End_if
			end-if
		Else
			Initialize Csid_res_country_ws
			%^ Check the Credit Party
			If Cdt_idtype of Cdt_typ of Ent_credit_set = "S"
			Then
			    If  Cdt_id of Cdt_typ of Ent_credit_set(4:1) = ":"
			    Then    %^ Skip over the bank
				Move Cdt_id of Cdt_typ of Ent_credit_set(9:2) to Csid_res_country_ws 
	    		    Else
	    			Move Cdt_id of Cdt_typ of Ent_credit_set(5:2) to Csid_res_country_ws 
	    		    End-if
			Else
			    If (Cdt_adr_ptr_ok of flgs3 of ent_credit_set = "T")
			    Then
				%beg break: csid_tmp_adr_set;
		    			     Ent_credit_set.Cdt_adr_set_ptr CONN: csid_tmp_adr_set;
		    			     break: csid_tmp_adr_set;
				%end
	    			If (Swift_id of csid_tmp_adr_set Not = Spaces)
				Then
				    Move Swift_id of  csid_tmp_adr_set(5:2) to Csid_res_country_ws
				end-if
			    Else
				If Cdt_idtype of cdt_typ of Ent_credit_set = "E"
				Then
					%beg
						Csid_parse ^in(ent_credit_set.cdt_typ.cdt_id)
							Csid_party_extype (^STRING<2>),
							csid_gcheck_id,/;
					%end
					CALL "CUST_XTEND_ID_EDIT" using
						BY REFERENCE Csid_party_extype
		   				BY REFERENCE Csid_gcheck_id
		   	     			BY REFERENCE Csid_gcheck_id_length
		    				BY REFERENCE Csid_temp1_vstr
		    				By REFERENCE Csid_temp1_vstr_length
		    				By REFERENCE Csid_delay_change
		    				BY REFERENCE Csid_got_advice
		    				By Reference Csid_extnd_country
		    				BY REFERENCE Csid_error_memo
		    				BY REFERENCE Csid_error_memo_length
		    				By REFERENCE Csid_error_code
		    				By REFERENCE Csid_error_code_length
		    				BY REFERENCE Csid_check_stat
		    				BY REFERENCE Csid_not_garbage
		  			RETURNING Csid_ret2_stat
					If Success_is in Csid_ret2_stat And
					   Csid_extnd_country NOT = Spaces
					Then
						%beg csid_res_country_ws = csid_extnd_country; %end
					end-if
					%^ get country for Extended IDs table
				end-if
			    end-if
			end-if
	    		If Csid_res_country_ws not = spaces
	        	    %Beg Csid_iban_cntry_ws = Csid_res_country_ws; %End
			    If Address_type of Cdt_adr_type of Ent_credit_set = "B" And
			       bnp_mailing_country of Ent_credIt_set = Spaces
			    Then
			      %Beg Ent_credit_set.bnp_mailing_country = Csid_res_country_ws; %End
			    End-if
	    		end-if
		End-if
		
		If csid_res_country_ws = Spaces
		Then
			%^ No decision from above, try bnp_mailing and BNK
			If NOT(bnp_MAILING_country of ent_credit_set = Spaces) Then
				%beg csid_iban_cntry_ws = ent_credit_set.bnp_MAILING_country;
				     Csid_save_cntry_ws = csid_iban_cntry_ws;
				%end
			Else
				%beg csid_iban_cntry_ws = menu_bnk_union.country_code; %end
			end-if
		Else
			%beg Csid_save_cntry_ws = csid_iban_cntry_ws; %end
		End-if


		Call "VALIDATE_IBAN" Using
			by Reference csid_party_id
			by Reference csid_party_id_length
			by Reference csid_iban_cntry_ws
			by Reference csid_iban_bnk_ws
			by Reference csid_iban_bnk_ws_length
			by Reference csid_iban_brnch_ws
			by Reference csid_iban_brnch_ws_length
			by Reference csid_iban_curr_ws
			By Reference csid_bnk_code_rec_ws
			By Reference csid_bnk_code_rec_ws_lengths
			By Reference csid_valid_iban_flg_ws
		returning Csid_val_iban_ret

		If (Success_is in csid_val_iban_ret) AND
		   (csid_save_cntry_ws NOT = csid_iban_cntry_ws AND
		    csid_save_cntry_ws NOT = Spaces) AND
		   (csid_valid_iban_flg_ws = "I")
		Then
			%^ BBK/CDT country differs from IBAN country in
			%^ Check table for allowable difference, else,
			%^ flag as a Blocking type error
			Perform X1150_CHECK_IBAN_CNTRY Thru
				X1150_CHECK_IBAN_CNTRY_END
			If Not(Success_is in Csid_Bic_cc_exc_wf)
			Then
				%^ No match, flag as error and exit
				%Beg
				screen_field_ws = "credit.bnp.bnp_id";
				error_mnemonic_ws = "LKUP$_IBAN_BIC_CC";
				%End
	        		call "FTRSCR_WRITE_ERROR" using
	        		  by reference screen_field_ws
				  by reference error_mnemonic_ws
				Add 1 to Csid_bogus_parties
				Add 1 to Cdt_errmemo_count_ls
	                        Set Failure_is in Creditside_screen_ls to TRUE
				Move spaces to csid_iban_cntry_ws
				Set Completion_PROC in Cdt_screen_state to True
				Go to B200_BNP_LOOKUP_END				
			End-if
		End-if

		%^ 3 possible results Fail Pass and Fail passthru
		Evaluate True
			When Failure_blocking_is in Csid_val_iban_ret
				%^ Fail       - possible Invalid Account
				Evaluate Csid_valid_iban_flg_ws
					When "I"	%^ Bad IBAN
						%Beg
						screen_field_ws = "credit.bnp.bnp_id";
						error_mnemonic_ws = "LKUP$_IBAN_FAILURE_B";
						%End
	        				call "FTRSCR_WRITE_ERROR" using
	        				  by reference screen_field_ws
						  by reference error_mnemonic_ws
					When "N"	%^ Bad BBAN
						%Beg
						screen_field_ws = "credit.bnp.bnp_id";
						error_mnemonic_ws = "LKUP$_BBAN_FAILURE_B";
						%End
	        				call "FTRSCR_WRITE_ERROR" using
	        				  by reference screen_field_ws
						  by reference error_mnemonic_ws
					When "R"	%^ Iban Required
						%Beg
						screen_field_ws = "credit.bnp.bnp_id";
						error_mnemonic_ws = "IVAL$_IBAN_REQ_B";
						%End
	        				call "FTRSCR_WRITE_ERROR" using
	        				  by reference screen_field_ws
						  by reference error_mnemonic_ws
				end-evaluate

				If Success_is in csid_bban_cntry_req_ws And
				   Csid_valid_iban_flg_ws = "N" And
				   bnp_mailing_country of Ent_credit_set = Spaces
				Then
				   %Beg
				   screen_field_ws = "credit.bnp_mailing_country";
				   error_mnemonic_ws = "LKUP$_COUNTRY_REQ";
				   %End
	        		   call "FTRSCR_WRITE_ERROR" using
	        		     by reference screen_field_ws
				     by reference error_mnemonic_ws
				End-if
				Add 1 to Csid_bogus_parties
				Add 1 to Cdt_errmemo_count_ls
	                        Set Failure_is in Creditside_screen_ls to TRUE
				Move spaces to csid_iban_cntry_ws
			
			When  Success_is in csid_val_iban_ret
				%^ Pass       - Valid IBAN/BBAN
				%^ save for parameter addition later
				%beg	Csid_parse ^in(ent_credit_set.bnp.bnp_id) csid_orig_iban_ws,"/",^str,/; %end
				If Failure_is in Csid_parse_status
				Then
					%beg csid_orig_iban_ws = ent_credit_set.bnp.bnp_id; %end
				end-if
				%^ Now we must perform IBAN specific Insertion/pushup data
				Perform  D780_BNP_IBAN thru
					 D780_BNP_IBAN_END
				%^	Set BNP_IS in csid_Iban_party_ws to True
				%^	Perform C680_IBAN_DETECTED Thru
				%^		C680_IBAN_DETECTED_END

			When  Failure_warning_is in csid_val_iban_ret
				%^ Fail/Pass  - Not on us lower party data
				%^ Can't figure out number, let it pass
				Evaluate Csid_valid_iban_flg_ws
					When "I"	%^ Bad IBAN
						%Beg
						screen_field_ws = "credit.bnp.bnp_id";
						error_mnemonic_ws = "LKUP$_IBAN_FAILURE_W";
						%End
	        				call "FTRSCR_WRITE_ERROR" using
	        				  by reference screen_field_ws
						  by reference error_mnemonic_ws
					When "N"	%^ Bad BBAN
						%Beg
						screen_field_ws = "credit.bnp.bnp_id";
						error_mnemonic_ws = "LKUP$_BBAN_FAILURE_W";
						%End
	        				call "FTRSCR_WRITE_ERROR" using
	        				  by reference screen_field_ws
						  by reference error_mnemonic_ws
					When "R"	%^ Iban Required
						%Beg
						screen_field_ws = "credit.bnp.bnp_id";
						error_mnemonic_ws = "IVAL$_IBAN_REQ_W";
						%End
	        				call "FTRSCR_WRITE_ERROR" using
	        				  by reference screen_field_ws
						  by reference error_mnemonic_ws
				end-evaluate

				If Success_is in csid_bban_cntry_req_ws And
				   Csid_valid_iban_flg_ws = "N" And   %^ ensure not an IBAN
				   bnp_mailing_country of Ent_credit_set = Spaces
				Then
   				   %Beg
					screen_field_ws = "credit.bnp_mailing_country";
					error_mnemonic_ws = "LKUP$_COUNTRY_REQ";
					%End
	        			call "FTRSCR_WRITE_ERROR" using
	        			  by reference screen_field_ws
					  by reference error_mnemonic_ws
				End-if
	                        Set Failure_is in Creditside_screen_ls to TRUE
				move spaces to csid_iban_cntry_ws 


			When Failure_ignore_is in csid_val_iban_ret
				Evaluate Csid_valid_iban_flg_ws
					When "I"	%^ Bad IBAN
						%Beg
						screen_field_ws = "credit.bnp.bnp_id";
						error_mnemonic_ws = "LKUP$_IBAN_FAILURE_I";
						%End
	        				call "FTRSCR_WRITE_ERROR" using
	        				  by reference screen_field_ws
						  by reference error_mnemonic_ws
					When "N"	%^ Bad BBAN
						%Beg
						screen_field_ws = "credit.bnp.bnp_id";
						error_mnemonic_ws = "LKUP$_BBAN_FAILURE_I";
						%End
	        				call "FTRSCR_WRITE_ERROR" using
	        				  by reference screen_field_ws
						  by reference error_mnemonic_ws
					When "R"	%^ Iban Required
						%Beg
						screen_field_ws = "credit.bnp.bnp_id";
						error_mnemonic_ws = "IVAL$_IBAN_REQ_I";
						%End
	        				call "FTRSCR_WRITE_ERROR" using
	        				  by reference screen_field_ws
						  by reference error_mnemonic_ws
				end-evaluate
				move spaces to csid_iban_cntry_ws 

			When Other %^ temp new numbers, just treat as Pass/Fail
				move spaces to csid_iban_cntry_ws 
		End-evaluate
		Set Completion_PROC in Cdt_screen_state to True
		Go to B200_BNP_LOOKUP_END	%^ no more to do
	END-IF.	    

%^ We still need to try the lookup
	%Beg
		Csid_party_id = Ent_credit_set.bnp.bnp_id ; 
		Csid_party_idtype = Ent_credit_set.Bnp.Bnp_idtype ;
	%End.
	Set BNP in Relget_title_flag to TRUE
        Move SPACE to Csid_lc_secwir.
        PERFORM C660_LOWER_CREDIT through C660_LOWER_CREDIT_END.

	If Success_is in Relget_ambiguous_wf
	Then
		Set Success_is  	in Resolve_Ambiguous to True
		Set Bnp_Index_Conn 	in CDT_screen_state  to True
		Go to B200_BNP_LOOKUP_END
	End-if.

	Perform C660_LOWER_CREDIT_MAP thru
		C660_LOWER_CREDIT_MAP_END.


	Set BNP_MAP in Cdt_screen_state to True.

B200_BNP_LOOKUP_END.
	EXIT.


B200_BNP_INDEX_CONN.
%^
%^ Re-enter here after return from ambiguous screen and 
%^ Connect the indices required.  
%^

	Perform C660_LOWER_CREDIT_CONN thru
		C660_LOWER_CREDIT_CONN_END.

	Perform C660_LOWER_CREDIT_MAP thru
		C660_LOWER_CREDIT_MAP_END.

	Set Bnp_map in Cdt_screen_state to True.

B200_BNP_INDEX_CONN_END.
	EXIT.


B200_BNP_MAP.
        If (Csid_ovr = "?" )
 	    %Beg
	    screen_field_ws = "credit.bnp.bnp_idtype";
            error_mnemonic_ws = Csid_lc_error;
	    %End
	    call "FTRSCR_WRITE_ERROR" using
	      by reference screen_field_ws
	      by reference error_mnemonic_ws
	    Add 1 to Csid_bogus_parties
	    Add 1 to Cdt_errmemo_count_ls
 	    Set Completion_PROC in Cdt_screen_state to True
	    GO TO B200_BNP_MAP_END
	END-IF.

        IF (Failure_is in Csid_ret_stat)
	    If (Csid_party_idtype = "S")
	      AND (Swift_adr_nof_warning of Menu_cfg = "T")
	    THEN
%^18-May-89 For SWIFT ID's, set fatal error if INTRTL flag is set
 	        %Beg
	        screen_field_ws = "credit.bnp.bnp_id";
           	error_mnemonic_ws = "FTRSCR$_INV_SWF_ID_AUX";
	    	%End
	    	call "FTRSCR_WRITE_ERROR" using
	    	  by reference screen_field_ws
	    	  by reference error_mnemonic_ws
		Add 1 to Csid_bogus_parties
		Add 1 to Cdt_errmemo_count_ls
		Set Failure_is in Creditside_screen_ls to TRUE
	    END-IF
	    Perform B200_BNP_CHK_E_ID_BNK thru B200_BNP_CHK_E_ID_BNK_END
	    Set Completion_PROC in Cdt_screen_state to True
	    GO TO B200_BNP_MAP_END
	END-IF.


%^ #132840
	If ( ( (Csid_ovr = SPACE ) OR (Csid_ovr = "*" ) )
	      AND (Success_is in Csid_ret_stat )
	      AND ( Success_is in Csid_lc_noaddress or
		    Success_is in csid_non_ucc_src ))
	THEN
	    Set Success_is in Csid_found_it to true
	END-IF.
	Perform C520_UPDATE_BNP through C520_UPDATE_BNP_END.

	If ((Csid_ovr = SPACE ) OR (Csid_ovr = "*" )) AND
	    (Success_is in Csid_ret_stat ) And
	     Failure_is in Csid_found_it	%^ need to keep Name.address instact, remark as onREL/AUX
	Then
		%beg 	    Ent_credit_set(.bnp_rel_id = Relget_adr_set.rel_id,
	    		   		   .bnp_adr_set_ptr POINT: Relget_adr_set,
			   		   .flgs3.bnp_adr_ptr_ok = "T");
		%end
	End-if.

	If (Failure_is in Csid_found_it   )
	    GO TO B200_BNP_MAP_CLEANUP
	END-IF.

%^B200_BNP_ADDRESS.
	Perform B205_BNP_ADDRESS through B205_BNP_ADDRESS_END.

B200_BNP_MAP_CLEANUP.
* If the beneficiary name is now non-blank, look for "missing data"
* error and clear it.
* For the IF statement below, first get the .MSG field of ftrscr.credit.bnp_name1.

	Perform B200_BNP_CLEANUP thru B200_BNP_CLEANUP_END.


B200_BNP_MAP_END.
  EXIT.

B200_BNP_CHK_E_ID_BNK.
*	Set the bnp_bnk_flg for E/Ids 

	IF Csid_party_idtype NOT = "E"
	    GO TO B200_BNP_CHK_E_ID_BNK_END
	END_IF.
	
	Call "CHK_E_ID_BANK" using
		by reference bnp_idtype of Ent_credit_set
	   	by reference bnp_id     of Ent_credit_set
	    returning Csid_temp_stat.
	IF Success_is in Csid_temp_stat
        THEN
	    %Beg  Ent_credit_set.Bnp_bnk_flg = "Y";  %End
	ELSE
	    %Beg  Ent_credit_set.Bnp_bnk_flg = "N";  %End
	END-IF.

B200_BNP_CHK_E_ID_BNK_END.
  EXIT.

B200_BNP_CLEANUP.
%^
%^ small bit of code required to exit from several paragrapghs, factored out here.
%^
	%Beg
	Screen_field_ws = "credit.bnp_name1";
	%End.
	Call "FTRSCR_GET_FLDMSG" Using
          By Reference screen_field_ws    	%^ In
          By Reference csid_temp1_vstr 		%^ Out
          By Reference csid_temp1_vstr_length.	%^ Out

	If (Csid_temp1_vstr = Vmsg_missingdat_wc)
	   AND ( (Bnp_name1_length of Ent_credit_set_lengths NOT = 0 )
		 AND (Bnp_name1 of Ent_credit_set NOT = SPACES ) )
	THEN
	    %Beg
	    screen_field_ws = "credit.bnp_name1";
	    error_mnemonic_ws = "";
            %End
	    Call "FTRSCR_WRITE_ERROR" using
	      by reference screen_field_ws
              by reference error_mnemonic_ws
	END-IF.


	Set Completion_PROC in Cdt_screen_state to True.
B200_BNP_CLEANUP_END.
	EXIT.


B205_BNP_ADDRESS.
	If (Success_is in Csid_found_it   )
* Removed overflow from compose - obsolete
	    %Beg
	    Csid_compose ^OUT(Csid_id_ws) 
		Ent_credit_set.bnp.bnp_id, / ;
	    Csid_idtype_ws = Ent_credit_set.bnp.bnp_idtype ;
	    %End  

	    Call "SET_BNP_PARTY" USING
	        By reference Csid_idtype_ws
	        By reference Csid_id_ws
	        By reference Csid_id_ws_length
	        By reference Bank of Loc_info of Ent_ftr_set
	      RETURNING Csid_ret_stat
	    Add 1 to Advice_parties_ls
	END-IF.
B205_BNP_ADDRESS_END.
    Exit.

B220_BBK_INIT_LKUP.
%^
%^ First, check if we need to be here.
%^
	If (BBK_id of BBK of Ent_credit_set NOT = SPACES )
	   OR ( (Bbk_name1_length of Ent_credit_set_lengths NOT = 0 ) 
	        AND (Bbk_name1 of Ent_credit_set NOT = SPACES ) )
	THEN
	    If (Success_is in Csid_try_chips)
		AND ( (Bbk_changed_ls = 0 )
	              AND (Credit_changed_ls NOT = 1 )
		      AND (Adv_changed_ls = 0 ) )
		AND (Bbk_qualified_ls NOT = 0 )
	    THEN
		%^ Exit, no party change, stay if possible CHIPS lookup
		Set Failure_is in Csid_try_chips to TRUE
		Set Bbk_init_secwir in Cdt_screen_state to True		%^ CR10438/CR12639
		Go to B220_Bbk_init_lkup_end
	    ELSE
	        If NOT( (Csid_pushed_credit NOT = 3 ) AND
		      ( (Success_is in Csid_try_chips) OR
		        (Bbk_changed_ls NOT = 0 ) ))
		THEN
			%^ Nothing to do Just Exit, say to lookup.
			Set Bbk_init_secwir in Cdt_screen_state to True		%^ CR10438/CR12639
			Go to B220_Bbk_init_lkup_end
		END-IF
	    END-IF
	Else
		Set Bnp_Init_lkup in Cdt_screen_state to True
		Go to B220_Bbk_init_lkup_end
	END-IF.

*  Paragraph to do account lookup on the BBK.  
*  If Success_is in Csid_try_chips we will try to chips qualify it.
*  If it is not set, then we do a REL lookup.  
*     If the REL lookup succeeds, we use FIND_ADR_ID to perfect our external
*    	   id and copy in the name and address info.  We set the Bbk_rel_id
*          and the Bbk_adr_set_ptr and copy in the Bbk_adv_inst.

        %^ Clear out the previous address if necessary
        If Bbk_changed_ls not = 0 then
            %Beg
            Ent_credit_set (.Bbk_rel_id         =  <0>,
                            .Bbk_adr_set_ptr    DELETE,
			    .flgs3.Bbk_adr_ptr_ok = Null);
            %End
	    If Bbk of Ent_credit_set NOT = Bbk of Change_credit_set and  %^ dont clear it out if they just entered it
	       Bbk of Change_credit_set not = SPACES then
		%Beg Ent_credit_set.bbk_res_country = NULL; %End	%^ 115131 
	    End-if
        END-IF.

       %^ If a Repetitive with multiples,  then clear any info
        %^ after the 1st and remap , it will be re-mapped.
        If (Is_rptv_lookup_ls NOT = 0 )
        THEN
                %Beg
                Csid_parse ^IN(Ent_credit_set.Bbk.Bbk_id)
                        Csid_temp1_vstr, "/(", ^STRING, ^SPACE, / ;
                %End
                If Success_is in Csid_parse_status
                        %Beg
                        Csid_compose ^OUT(Ent_credit_set.Bbk.Bbk_id)
                                Csid_temp1_vstr, / ;
                        %End
                End-if
        End-if.

        Set Failure_is in Csid_multi_party to true.
        Move SPACES to Csid_party_id.
        %Beg Csid_party_idtype = Ent_credit_set.Bbk.Bbk_idtype; %End.
* Removed overflow test - obsolete
            %Beg
            Csid_party_id = Ent_credit_set.Bbk.Bbk_id ;
	    Csid_parse ^IN(Csid_party_id),
		^ONEOF(
			(Csid_temp1_vstr, "/", 
				Csid_party_extype (^STRING<2>(<CHAR$M_ALPHA>)), 
				^STRING, ^SPACE, /),
			(Csid_temp1_vstr, "/??", ^STRING, ^SPACE, /));
	    %End
	    If (Success_is in Csid_parse_status   )
		AND (Csid_temp1_vstr_length NOT = 0 )
	    THEN
                Set Success_is in Csid_multi_party to true
            END-IF.

* put in N or @ id if left blank by operator
	%Beg  Relget_msgcode = NULL;  %End.
        Move Bbk_secwir of Bbk of Ent_credit_set to Csid_lc_secwir.
	IF (Bbk_idtype of Bbk of Ent_credit_set = "N" OR "@")
	   AND (Bbk_id of Bbk of Ent_credit_set = SPACES)
	THEN
	    If Bbk_name1 of Ent_credit_set NOT = SPACES
		MOVE SPACES TO Csid_20charid_ws
		If Bbk_idtype OF Bbk OF Ent_credit_set = "N"
		    Call "AUTONAM" USING
			By reference Bbk_name1 OF Ent_credit_set
			By reference Bbk_name1_length of Ent_credit_set_lengths
			By reference Csid_20charid_ws
			By reference Csid_length
		ELSE
		    Call "CREATE_AUX_MNAM" USING 
			By reference Csid_20charid_ws
			By reference Bbk_name1_length of Ent_credit_set_lengths
			By reference Bbk_name1 OF Ent_credit_set
			By reference Bbk_name2_length OF Ent_credit_set_lengths
			By reference Bbk_name2 OF Ent_credit_set
			By reference Bbk_name3_length OF Ent_credit_set_lengths
			By reference Bbk_name3 OF Ent_credit_set
			By reference Bbk_name4_length OF Ent_credit_set_lengths
			By reference Bbk_name4 OF Ent_credit_set
		END-IF
		MOVE %SIZ(Csid_20charid_ws) TO Csid_20charid_ws_length
		%Beg
		Csid_compose ^OUT(Ent_credit_set.Bbk.Bbk_id), 
				Csid_20charid_ws, /;
		%End
	    ELSE
*		error, name missing
%^		%Beg Ftrscr.credit.Bbk_name1.msg = "FTRSCR$_NAMEMISSING"; %End
 	    	%Beg
	    	screen_field_ws = "credit.Bbk_name1";
           	error_mnemonic_ws = "FTRSCR$_NAMEMISSING";
	    	%End
	    	call "FTRSCR_WRITE_ERROR" using
	    	  by reference screen_field_ws
	    	  by reference error_mnemonic_ws
		Add 1 to Csid_bogus_parties
		Add 1 to Cdt_errmemo_count_ls
	        Set Failure_is in Csid_try_chips to TRUE
		Set Bnp_init_lkup in Cdt_screen_state to True
		GO TO B220_BBK_INIT_LKUP_END
	    END-IF
	END-IF.

	Set Failure_is in Csid_found_it to true.
	Set Failure_is in Csid_chips_candidate to true.
	Set Failure_is in Csid_chips_party to true.
	Set Failure_is in Csid_chips_override to true.

	If (Bbk_idtype of Bbk of Ent_credit_set = "@" )
	Then
		Set Bbk_name_lkup in Cdt_screen_state to True
	Else
		Set Bbk_lookup in Cdt_screen_state to True
	End-if.

B220_BBK_INIT_LKUP_END.
	EXIT.

B220_BBK_NAME_LKUP.

* We're being asked to search the AUX database, so let's do it before
*  we try the CHIPS qualification.
	%Beg
	    Csid_parse ^IN(Ent_credit_set.Bbk.Bbk_id ) ^SPACE, Csid_id_ws, 
		    ^SPACE, / ;
	%End

	Set BBK in Relget_title_flag to TRUE
	Move SPACES to Csid_lkup_pend_del	
	%Beg  Csid_next_function = Menu_next_function;  %End
	Call "REL_GET" USING 
		by content "&"
		By reference Csid_id_ws
		By reference Csid_id_ws_length
		by reference Csid_lkup_pend_del
	      RETURNING Csid_ret_stat

	If (Relget_reject_flag = "M")	Or
   	   (Csid_next_function not = Menu_next_function)
	Then
		Set Menu_is in cdt_screen_state to True
		Go to B220_BBK_NAME_LKUP_END
	End-if

	If Success_is in Relget_ambiguous_wf
	Then
		Set Success_is  	in Resolve_Ambiguous to True
		Set Bbk_Name_Conn 	in CDT_screen_state  to True
		Go to B220_BBK_NAME_LKUP_END
	End-if.

	Set Bbk_Name_Compl in cdt_screen_state to True.

B220_BBK_NAME_LKUP_END.
	EXIT.

B220_BBK_NAME_CONN.
%^
%^
	Call "RELGET_CONNECT" USING 
	    by reference csid_lkup_pend_del
	  RETURNING csid_ret_stat.

	Set Bbk_Name_Compl in cdt_screen_state to True. 

B220_BBK_NAME_CONN_END.
	EXIT.

B220_BBK_NAME_COMPL.
	    If (Relget_msgcode = Vmsg_dat_notonfile_wc )
		OR (Success_is in Csid_ret_stat   )
	    THEN
                If (Csid_lc_secwir NOT = "Y" )
* If we are sending a secwir, lookup MUST be done in REL database instead.
                    Set Success_is in Csid_found_it to true
                END-IF
		Move "BBK" to Bcc_lkup_party
	    	Perform D100_BCC_LKUP_BIC thru D100_BCC_LKUP_BIC_END
	    	If Failure_is in Bcc_lkup_status
		    Set Bbk_init_lkup in Cdt_screen_state to True
		    GO TO B220_BBK_NAME_COMPL_END
		end-if
		If (Relget_return_key NOT = SPACES )
		    %Beg
	            Csid_clip_compose ^OUT(Ent_credit_set.Bbk.Bbk_id), 
			Relget_return_key, / ;
		    Ent_credit_set.Bbk.Bbk_idtype = Relget_return_idtype ;
		    %End
		End-if

%^ icr_000636 Remove any invalid error messages that may have been found
%^	      before the bbk selection was made from an ambiguous 
%^	      screen.

		If Screen_field_ws Not = Spaces And
		   Idtype of Rel_name_key of Relget_index Not =
			Idtype of Disp_id of Relget_index
		Then
		    %Beg
			error_mnemonic_ws = "";
		    %End
	            call "FTRSCR_WRITE_ERROR" using
	          	by reference screen_field_ws
		  	by reference error_mnemonic_ws
		END-IF
	    ELSE
* We did a generic lookup which failed.
%^		%Beg  Ftrscr.credit.Bbk.Bbk_id.msg = "VMSG$_LOOKUPFAIL";  %End
 	    	%Beg
	    	screen_field_ws = "credit.Bbk.Bbk_id";
           	error_mnemonic_ws = "VMSG$_LOOKUPFAIL";
	    	%End
	    	call "FTRSCR_WRITE_ERROR" using
	    	  by reference screen_field_ws
	    	  by reference error_mnemonic_ws
		Add 1 to Csid_bogus_parties
		Add 1 to Cdt_errmemo_count_ls
	END-IF.


	Set Bbk_Lookup in Cdt_screen_state to True.

B220_BBK_NAME_COMPL_END.
	EXIT.

B220_BBK_LKUP.

	If (Success_is in Csid_try_chips)
* If Ent_debit_set.Dbt_wir_key.idtype is a *, it automatically qualifies.
	    If Idtype of Dbt_wir_key of Ent_debit_set = "*" 
	        Move 1 to Bbk_qualified_ls
		Set Failure_is in Csid_try_chips to TRUE
		Set Bnp_init_lkup in Cdt_screen_state to True
	        GO TO B220_BBK_LKUP_END
	    END-IF
	    Move 0 to Bbk_qualified_ls

            If (Bbk_id of Ent_credit_set = spaces)
            or (Bbk_length of Ent_credit_set_lengths NOT > 2 )
            THEN
* No ID to qualify
                Set Failure_is in Csid_try_chips to TRUE
	    END-IF

%^ Try for CHIPS qualification lookup.
            If Success_is in Csid_try_chips
	        Call "CUST_EXTENDED_ID_QUAL"  USING
		    by Reference Bbk_idtype of Ent_credit_set
		    by Reference Bbk_id of Ent_credit_set
		    by Reference Bbk_id_length of Ent_credit_set_lengths
		    by Reference Bbk_idtype of Ent_credit_set
		    by Reference Bbk_id of Ent_credit_set
		    by Reference Bbk_id_length of Ent_credit_set_lengths
		    by Reference Csid_tmp_flg_ws
		    by Reference Csid_temp1_vstr
		    by Reference Csid_temp1_vstr_length
	          returning Csid_temp_stat

		Call "CHIPS_QUALIFICATION"  USING
		    By reference Bbk_idtype of Bbk of Ent_credit_set
		    By reference Bbk_id of Bbk of Ent_credit_set
	          RETURNING Csid_ret_stat
	        If (Success_is in Csid_ret_stat   )
		    AND  (Success_is in Csid_chp_qual_cand)	%^(Chips_uid_id of Relget_adr_set NOT = SPACES )
	        THEN
		    Set Success_is in Csid_found_it to true
		    Set Success_is in Csid_chips_candidate to true
	        ELSE
%^ Override pseudo-qualification is not needed for the interactive case.
                    Set Failure_is in Csid_found_it to true
                    Move ZERO to Bbk_qualified_ls
	        END-IF
	    END-IF
	END-IF.
	If (Success_is in Csid_try_chips)
	    Set Failure_is in Csid_try_chips to TRUE
	    If (Success_is in Csid_chips_candidate   )
%^ Relget_adr_set is copy of address rel for chips candidate
* BBK party has an account at the Ent_credit_set bank, so we can create 
*   an ID string from the full qualification data (UID, Swift ID, and
*   account ID).
	        Call "CUST_EXTENDED_ID_QUAL"  USING
		    by Reference Bbk_idtype of Ent_credit_set
		    by Reference Bbk_id of Ent_credit_set
		    by Reference Bbk_id_length of Ent_credit_set_lengths
		    by Reference Bbk_idtype of Ent_credit_set
		    by Reference Bbk_id of Ent_credit_set
		    by Reference Bbk_id_length of Ent_credit_set_lengths
		    by Reference Csid_tmp_flg_ws
		    by Reference Csid_temp1_vstr
		    by Reference Csid_temp1_vstr_length
	          returning Csid_temp_stat

		Call "CHIPS_QUALIFICATION_IDSTR"  USING
		    By reference Bbk_idtype of Bbk of Ent_credit_set
		    By reference Bbk_id of Bbk of Ent_credit_set
                    By reference Bbk_id_length of Ent_credit_set_lengths
		    By reference Csid_id_ws
		    By reference Csid_id_ws_length
		  RETURNING Csid_chips_party
                If (Failure_is in Csid_chips_party   )
* Could have case of a COMMON UID and SWIFT TID.
                    Perform C670_CHECK_COMMON_UID thru
                            C670_CHECK_COMMON_UID_end
                    If Success_is in Csid_chips_party  
* Removed overflow setting - obsolete
                        %Beg
                        Ent_credit_set (.Bbk.Bbk_idtype = Csid_party_idtype,
                                        .Bbk.Bbk_id = Csid_id_ws ) ;
                        %End
		    END-IF
                END-IF
            END-IF
            If (Failure_is in Csid_chips_party   )
                Set Failure_is in Csid_found_it to true
                Move ZERO to Bbk_qualified_ls
            ELSE
* Removed overflow  - obsolete
                %Beg
                Ent_credit_set (.Bbk.Bbk_id = Csid_id_ws, CHANGE ) ;
                %End
                Move 1 to BBK_qualified_ls
	    END-IF
	END-IF.

	If (Success_is in Csid_chips_party   )
	    OR (Success_is in Csid_chips_override   )
	THEN
	    If Success_is in Csid_found_it
		Perform B220_BBK_MAP_CLEANUP Thru
			B220_BBK_MAP_CLEANUP_END
	        GO TO B220_BBK_LKUP_END
	    ELSE
	        GO TO B220_BBK_LKUP_END
	    END-IF
	END-IF.

	If (Bbk_changed_ls = 0 )
	    AND (Adv_changed_ls = 0 )
	THEN
%^ Nothing to do
	    Set Bnp_init_lkup in cdt_screen_state to True
	    GO TO B220_BBK_LKUP_END
	END-IF.

	If ( (Bbk_name1_length of Ent_credit_set_lengths NOT = 0 ) 
             AND (Bbk_name1 of Ent_credit_set NOT = SPACES ) )
	   OR ( (Bbk_name2_length of Ent_credit_set_lengths NOT = 0 ) 
             AND (Bbk_name2 of Ent_credit_set NOT = SPACES ) )
	   OR ( (Bbk_name3_length of Ent_credit_set_lengths NOT = 0 ) 
             AND (Bbk_name3 of Ent_credit_set NOT = SPACES ) )
	   OR ( (Bbk_name4_length of Ent_credit_set_lengths NOT = 0 ) 
             AND (Bbk_name4 of Ent_credit_set NOT = SPACES ) )
	THEN
	    Set Failure_is in Csid_lc_noaddress to true
	ELSE
	    Set Success_is in Csid_lc_noaddress to true
	END-IF.

	If (Bbk_idtype of Bbk of Ent_credit_set = SPACE)
	   AND (Failure_is in Csid_lc_noaddress   )
	THEN
%^ If one of the id's is a foreign account number, we cannot
%^  confirm the id so we cannot use any address information that we have.
%^  Skip the lookup.
            Set Bnp_init_lkup in Cdt_screen_state to True
	    GO TO B220_BBK_LKUP_END
	END-IF.	    

%^ We still need to try the lookup
* Removed overflow test - obsolete
	%Beg
		Csid_party_id = Ent_credit_set.Bbk.Bbk_id ;  
		Csid_party_idtype = Ent_credit_set.Bbk.Bbk_idtype ;
	%End.
	Set BBK in Relget_title_flag to TRUE
        PERFORM C660_LOWER_CREDIT through C660_LOWER_CREDIT_END.

	If Success_is in Relget_ambiguous_wf
	Then
		Set Success_is  	in Resolve_Ambiguous to True
		Set Bbk_Index_Conn 	in CDT_screen_state  to True
		Go to B220_BBK_LKUP_END
	End-if.

	Perform C660_LOWER_CREDIT_MAP thru
		C660_LOWER_CREDIT_MAP_END.

	Set BBK_MAP in Cdt_screen_state to True.

B220_BBK_LKUP_END.
	EXIT.


B220_BBK_INDEX_CONN.
%^
%^ Re-enter here after return from ambiguous screen and 
%^ Connect the indices required.  
%^

	Perform C660_LOWER_CREDIT_CONN thru
		C660_LOWER_CREDIT_CONN_END.

	Perform C660_LOWER_CREDIT_MAP thru
		C660_LOWER_CREDIT_MAP_END.

	Set Bbk_map in Cdt_screen_state to True.

B220_BBK_INDEX_CONN_END.
	EXIT.


B220_BBK_MAP.

        If (Csid_ovr = "?" )
	Then
 	    %Beg
	    screen_field_ws = "credit.Bbk.Bbk_idtype";
            error_mnemonic_ws = Csid_lc_error ;
	    %End
	    call "FTRSCR_WRITE_ERROR" using
	      by reference screen_field_ws
	      by reference error_mnemonic_ws
	    Add 1 to Csid_bogus_parties
	    Add 1 to Cdt_errmemo_count_ls
	    Set Bnp_init_lkup in Cdt_screen_state to True
	    GO TO B220_BBK_MAP_END
	END-IF.

        IF (Failure_is in Csid_ret_stat)
	    If (Csid_party_idtype = "S")
	      AND (Swift_adr_nof_warning of Menu_cfg = "T")
	    THEN
	    %^18-May-89 For SWIFT ID's, set fatal error if INTRTL flag is set
 	    	%Beg
	    		screen_field_ws = "credit.Bbk.Bbk_id";
           		error_mnemonic_ws = "FTRSCR$_INV_SWF_ID_AUX";
	    	%End
	    	call "FTRSCR_WRITE_ERROR" using
	    	  	by reference screen_field_ws
	    	  	by reference error_mnemonic_ws
		Add 1 to Csid_bogus_parties
		Add 1 to Cdt_errmemo_count_ls
		Set Failure_is in Creditside_screen_ls to TRUE
	    Else	%^ clear messages
		%Beg
			screen_field_ws = "credit.bbk.bbk_id";
	        	error_mnemonic_ws = "";
	        %End
	        Call "FTRSCR_WRITE_ERROR" using
	          	by reference screen_field_ws
	          	by reference error_mnemonic_ws		
	    END-IF
	    Set Bnp_init_lkup in Cdt_screen_state to True
	    GO TO B220_BBK_MAP_END
	END-IF.

%^ #132840

	If ( ( (Csid_ovr = SPACE ) OR (Csid_ovr = "*" ) )
	      AND (Success_is in Csid_ret_stat )
	      AND ( Success_is in Csid_lc_noaddress or
		    Success_is in csid_non_ucc_src )) OR
	(Csid_ovr = SPACE and Csid_lc_secwir  = "Y") %^ MUST use looked info for SECWIR
	THEN
	    Set Success_is in Csid_found_it to true
	END-IF.
	Perform C540_UPDATE_BBK through C540_UPDATE_BBK_END.

	If ((Csid_ovr = SPACE ) OR (Csid_ovr = "*" )) AND
	    (Success_is in Csid_ret_stat ) And
	     Failure_is in Csid_found_it	%^ need to keep Name.address instact, remark as onREL/AUX
	Then
		%beg 	    Ent_credit_set(.bbk_rel_id = Relget_adr_set.rel_id,
	    		   		   .bbk_adr_set_ptr POINT: Relget_adr_set,
			   		   .flgs3.bbk_adr_ptr_ok = "T");
		%end

	End-if.

	If (Failure_is in Csid_found_it)
	    Set Bnp_init_lkup in Cdt_screen_state to True
	    GO TO B220_BBK_MAP_END
	END-IF.

%^B220_BBK_ADDRESS.
	Perform B220_BBK_MAP_CLEANUP Thru
		B220_BBK_MAP_CLEANUP_END.

B220_BBK_MAP_END.
   EXIT.

B220_BBK_MAP_CLEANUP.
	If (Success_is in Csid_found_it   )
* Removed overflow from compose - obsolete
	    %Beg
	    Csid_compose ^OUT(Csid_id_ws) 
		Ent_credit_set.Bbk.Bbk_id, / ;
	    Csid_idtype_ws = Ent_credit_set.Bbk.Bbk_idtype ;
	    %End  

	    Call "SET_BBK_PARTY" USING
	        By reference Csid_idtype_ws
	        By reference Csid_id_ws
	        By reference Csid_id_ws_length
	        By reference Bank of Loc_info of Ent_ftr_set
	      RETURNING Csid_ret_stat
	    Add 1 to Advice_parties_ls
	END-IF.

	Set Bbk_init_secwir in Cdt_screen_state to True.

B220_BBK_MAP_CLEANUP_END.
   EXIT.
B240_IBK_INIT_LKUP.
%^
%^ First, check if we need to be here.
%^
	If (IBK_id of IBK of Ent_credit_set NOT = SPACES )
	   OR ( (Ibk_name1_length of Ent_credit_set_lengths NOT = 0 ) 
	        AND (Ibk_name1 of Ent_credit_set NOT = SPACES ) )
	THEN
	    If (Success_is in Csid_try_chips)
		AND ( (Ibk_changed_ls = 0 )
	              AND (Credit_changed_ls NOT = 1 )
		      AND (Adv_changed_ls = 0 ) )
		AND (Ibk_qualified_ls NOT = 0 )
	    THEN
		%^ Exit, no party change, stay if possible CHIPS lookup
		Set Failure_is in Csid_try_chips to TRUE
		Set BBK_Init_lkup in Cdt_screen_state to True
		Go to B240_Ibk_init_lkup_end
	    ELSE
	        If NOT( (Csid_pushed_credit NOT = 2 ) AND
		      ( (Success_is in Csid_try_chips) OR
		        (Ibk_changed_ls NOT = 0 ) ))
		THEN
			%^ Nothing to do Just Exit, say to lookup.
			Set BBK_Init_lkup in Cdt_screen_state to True
			Go to B240_Ibk_init_lkup_end
		END-IF
	    END-IF
	Else
		Set BBK_Init_lkup in Cdt_screen_state to True
		Go to B240_Ibk_init_lkup_end
	END-IF.

*  Paragraph to do account lookup on the IBK.  
*  If Success_is in Csid_try_chips we will try to chips qualify it.
*  If it is not set, then we do a REL lookup.  
*     If the REL lookup succeeds, we use FIND_ADR_ID to perfect our external
*    	   id and copy in the name and address info.  We set the Ibk_rel_id
*          and the Ibk_adr_set_ptr and copy in the Ibk_adv_inst.

        %^ Clear out the previous address if necessary
        If Ibk_changed_ls not = 0 then
            %Beg
            Ent_credit_set (.ibk_rel_id         =  <0>,
                            .ibk_adr_set_ptr    DELETE,
			    .flgs3.ibk_adr_ptr_ok = Null);
            %End
	    %Beg Ent_credit_set.ibk_res_country = NULL; %End	%^ 115131 
        END-IF.

       %^ If a Repetitive with multiples,  then clear any info
        %^ after the 1st and remap , it will be re-mapped.
        If (Is_rptv_lookup_ls NOT = 0 )
        THEN
                %Beg
                Csid_parse ^IN(Ent_credit_set.Ibk.Ibk_id)
                        Csid_temp1_vstr, "/(", ^STRING, ^SPACE, / ;
                %End
                If Success_is in Csid_parse_status
                        %Beg
                        Csid_compose ^OUT(Ent_credit_set.Ibk.Ibk_id)
                                Csid_temp1_vstr, / ;
                        %End
                End-if
        End-if.

        Set Failure_is in Csid_multi_party to true.
        Move SPACES to Csid_party_id.
        %Beg Csid_party_idtype = Ent_credit_set.ibk.ibk_idtype; %End.
* Removed overflow test - obsolete
            %Beg
            Csid_party_id = Ent_credit_set.Ibk.Ibk_id ;
	    Csid_parse ^IN(Csid_party_id),
		^ONEOF(
			(Csid_temp1_vstr, "/", 
				Csid_party_extype (^STRING<2>(<CHAR$M_ALPHA>)), 
				^STRING, ^SPACE, /),
			(Csid_temp1_vstr, "/??", ^STRING, ^SPACE, /));
	    %End
	    If (Success_is in Csid_parse_status   )
		AND (Csid_temp1_vstr_length NOT = 0 )
	    THEN
                Set Success_is in Csid_multi_party to true
            END-IF.

* put in N or @ id if left blank by operator
	%Beg  Relget_msgcode = NULL;  %End.
        Move Ibk_secwir of Ibk of Ent_credit_set to Csid_lc_secwir.
	IF (Ibk_idtype of Ibk of Ent_credit_set = "N" OR "@")
	   AND (Ibk_id of Ibk of Ent_credit_set = SPACES)
	THEN
	    If Ibk_name1 of Ent_credit_set NOT = SPACES
		MOVE SPACES TO Csid_20charid_ws
		If Ibk_idtype OF Ibk OF Ent_credit_set = "N"
		    Call "AUTONAM" USING
			By reference Ibk_name1 OF Ent_credit_set
			By reference Ibk_name1_length of Ent_credit_set_lengths
			By reference Csid_20charid_ws
			By reference Csid_length
		ELSE
		    Call "CREATE_AUX_MNAM" USING 
			By reference Csid_20charid_ws
			By reference Ibk_name1_length of Ent_credit_set_lengths
			By reference Ibk_name1 OF Ent_credit_set
			By reference Ibk_name2_length OF Ent_credit_set_lengths
			By reference Ibk_name2 OF Ent_credit_set
			By reference Ibk_name3_length OF Ent_credit_set_lengths
			By reference Ibk_name3 OF Ent_credit_set
			By reference Ibk_name4_length OF Ent_credit_set_lengths
			By reference Ibk_name4 OF Ent_credit_set
		END-IF
		MOVE %SIZ(Csid_20charid_ws) TO Csid_20charid_ws_length
		%Beg
		Csid_compose ^OUT(Ent_credit_set.Ibk.Ibk_id), 
				Csid_20charid_ws, /;
		%End
	    ELSE
*		error, name missing
%^		%Beg Ftrscr.credit.ibk_name1.msg = "FTRSCR$_NAMEMISSING"; %End
 	    	%Beg
	    	screen_field_ws = "credit.ibk_name1";
           	error_mnemonic_ws = "FTRSCR$_NAMEMISSING";
	    	%End
	    	call "FTRSCR_WRITE_ERROR" using
	    	  by reference screen_field_ws
	    	  by reference error_mnemonic_ws
		Add 1 to Csid_bogus_parties
		Add 1 to Cdt_errmemo_count_ls
	        Set Failure_is in Csid_try_chips to TRUE
		Set Bbk_init_lkup in Cdt_screen_state to True
		GO TO B240_IBK_INIT_LKUP_END
	    END-IF
	END-IF.

	Set Failure_is in Csid_found_it to true.
	Set Failure_is in Csid_chips_candidate to true.
	Set Failure_is in Csid_chips_party to true.
	Set Failure_is in Csid_chips_override to true.

	If (Ibk_idtype of Ibk of Ent_credit_set = "@" )
	Then
		Set Ibk_name_lkup in Cdt_screen_state to True
	Else
		Set Ibk_lookup in Cdt_screen_state to True
	End-if.

B240_IBK_INIT_LKUP_END.
	EXIT.

B240_IBK_NAME_LKUP.

* We're being asked to search the AUX database, so let's do it before
*  we try the CHIPS qualification.
	%Beg
	    Csid_parse ^IN(Ent_credit_set.Ibk.Ibk_id ) ^SPACE, Csid_id_ws, 
		    ^SPACE, / ;
	%End

	Set IBK in Relget_title_flag to TRUE
	Move SPACES to Csid_lkup_pend_del	
	%Beg  Csid_next_function = Menu_next_function;  %End
	Call "REL_GET" USING 
		by content "&"
		By reference Csid_id_ws
		By reference Csid_id_ws_length
		by reference Csid_lkup_pend_del
	      RETURNING Csid_ret_stat

	If (Relget_reject_flag = "M")	Or
   	   (Csid_next_function not = Menu_next_function)
	Then
		Set Menu_is in cdt_screen_state to True
		Go to B240_IBK_NAME_LKUP_END
	End-if

	If Success_is in Relget_ambiguous_wf
	Then
		Set Success_is  	in Resolve_Ambiguous to True
		Set Ibk_Name_Conn 	in CDT_screen_state  to True
		Go to B240_IBK_NAME_LKUP_END
	End-if.

	Set Ibk_Name_Compl in cdt_screen_state to True.

B240_IBK_NAME_LKUP_END.
	EXIT.

B240_IBK_NAME_CONN.
%^
%^
	Call "RELGET_CONNECT" USING 
	    by reference csid_lkup_pend_del
	  RETURNING csid_ret_stat.

	Set Ibk_Name_Compl in cdt_screen_state to True. 

B240_IBK_NAME_CONN_END.
	EXIT.

B240_IBK_NAME_COMPL.
	    If (Relget_msgcode = Vmsg_dat_notonfile_wc )
		OR (Success_is in Csid_ret_stat   )
	    THEN
                If (Csid_lc_secwir NOT = "Y" )
* If we are sending a secwir, lookup MUST be done in REL database instead.
                    Set Success_is in Csid_found_it to true
                END-IF
		Move "IBK" to Bcc_lkup_party
	    	Perform D100_BCC_LKUP_BIC thru D100_BCC_LKUP_BIC_END
	    	If Failure_is in Bcc_lkup_status
		    Set Bbk_init_lkup in Cdt_screen_state to True
		    GO TO B240_IBK_NAME_COMPL_END
		end-if
		If (Relget_return_key NOT = SPACES )
		    %Beg
	            Csid_clip_compose ^OUT(Ent_credit_set.ibk.ibk_id), 
			Relget_return_key, / ;
		    Ent_credit_set.ibk.ibk_idtype = Relget_return_idtype ;
		    %End
		END-IF

%^ icr_000636 Remove any invalid error messages that may have been found
%^	      before the ibk selection was made from an ambiguous 
%^	      screen.

		If Screen_field_ws Not = Spaces And
		   Idtype of Rel_name_key of Relget_index Not =
			Idtype of Disp_id of Relget_index
		Then
		    %Beg
			error_mnemonic_ws = "";
		    %End
	            call "FTRSCR_WRITE_ERROR" using
	          	by reference screen_field_ws
		  	by reference error_mnemonic_ws
		END-IF
	    ELSE
* We did a generic lookup which failed.
%^		%Beg  Ftrscr.credit.ibk.ibk_id.msg = "VMSG$_LOOKUPFAIL";  %End
 	    	%Beg
	    	screen_field_ws = "credit.ibk.ibk_id";
           	error_mnemonic_ws = "VMSG$_LOOKUPFAIL";
	    	%End
	    	call "FTRSCR_WRITE_ERROR" using
	    	  by reference screen_field_ws
	    	  by reference error_mnemonic_ws
		Add 1 to Csid_bogus_parties
		Add 1 to Cdt_errmemo_count_ls
	END-IF.


	Set Ibk_Lookup in Cdt_screen_state to True.

B240_IBK_NAME_COMPL_END.
	EXIT.

B240_IBK_LKUP.

	If (Success_is in Csid_try_chips)
* If Ent_debit_set.Dbt_wir_key.idtype is a *, it automatically qualifies.
	    If Idtype of Dbt_wir_key of Ent_debit_set = "*" 
	        Move 1 to Ibk_qualified_ls
		Set Failure_is in Csid_try_chips to TRUE
		Set Bbk_init_lkup in Cdt_screen_state to True
	        GO TO B240_IBK_LKUP_END
	    END-IF
	    Move 0 to Ibk_qualified_ls

            If (Ibk_id of Ent_credit_set = spaces)
            or (Ibk_length of Ent_credit_set_lengths NOT > 2 )
            THEN
* No ID to qualify
                Set Failure_is in Csid_try_chips to TRUE
	    END-IF

%^ Try for CHIPS qualification lookup.
            If Success_is in Csid_try_chips
	        Call "CUST_EXTENDED_ID_QUAL"  USING
		    by Reference Ibk_idtype of Ent_credit_set
		    by Reference Ibk_id of Ent_credit_set
		    by Reference Ibk_id_length of Ent_credit_set_lengths
		    by Reference Ibk_idtype of Ent_credit_set
		    by Reference Ibk_id of Ent_credit_set
		    by Reference Ibk_id_length of Ent_credit_set_lengths
		    by Reference Csid_tmp_flg_ws
		    by Reference Csid_temp1_vstr
		    by Reference Csid_temp1_vstr_length
	          returning Csid_temp_stat

		Call "CHIPS_QUALIFICATION"  USING
		    By reference Ibk_idtype of Ibk of Ent_credit_set
		    By reference Ibk_id of Ibk of Ent_credit_set
	          RETURNING Csid_ret_stat
	        If (Success_is in Csid_ret_stat   )
		    AND (Success_is in Csid_chp_qual_cand)	%^(Chips_uid_id of Relget_adr_set NOT = SPACES )
	        THEN
		    Set Success_is in Csid_found_it to true
		    Set Success_is in Csid_chips_candidate to true
	        ELSE
%^ Override pseudo-qualification is not needed for the interactive case.
                    Set Failure_is in Csid_found_it to true
                    Move ZERO to Ibk_qualified_ls
	        END-IF
	    END-IF
	END-IF.
	If (Success_is in Csid_try_chips)
	    Set Failure_is in Csid_try_chips to TRUE
	    If (Success_is in Csid_chips_candidate   )
%^ Relget_adr_set is copy of address rel for chips candidate
* IBK party has an account at the Ent_credit_set bank, so we can create 
*   an ID string from the full qualification data (UID, Swift ID, and
*   account ID).
	        Call "CUST_EXTENDED_ID_QUAL"  USING
		    by Reference Ibk_idtype of Ent_credit_set
		    by Reference Ibk_id of Ent_credit_set
		    by Reference Ibk_id_length of Ent_credit_set_lengths
		    by Reference Ibk_idtype of Ent_credit_set
		    by Reference Ibk_id of Ent_credit_set
		    by Reference Ibk_id_length of Ent_credit_set_lengths
		    by Reference Csid_tmp_flg_ws
		    by Reference Csid_temp1_vstr
		    by Reference Csid_temp1_vstr_length
	          returning Csid_temp_stat

		Call "CHIPS_QUALIFICATION_IDSTR"  USING
		    By reference Ibk_idtype of Ibk of Ent_credit_set
		    By reference Ibk_id of Ibk of Ent_credit_set
                    By reference Ibk_id_length of Ent_credit_set_lengths
		    By reference Csid_id_ws
		    By reference Csid_id_ws_length
		  RETURNING Csid_chips_party
                If (Failure_is in Csid_chips_party   )
* Could have case of a COMMON UID and SWIFT TID.
                    Perform C670_CHECK_COMMON_UID thru
                            C670_CHECK_COMMON_UID_end
                    If Success_is in Csid_chips_party  
* Removed overflow setting - obsolete
                        %Beg
                        Ent_credit_set (.ibk.ibk_idtype = Csid_party_idtype,
                                        .ibk.ibk_id = Csid_id_ws ) ;
                        %End
		    END-IF
                END-IF
            END-IF
            If (Failure_is in Csid_chips_party   )
                Set Failure_is in Csid_found_it to true
                Move ZERO to Ibk_qualified_ls
            ELSE
* Removed overflow  - obsolete
                %Beg
                Ent_credit_set (.ibk.ibk_id = Csid_id_ws, CHANGE ) ;
                %End
                Move 1 to IBK_qualified_ls
	    END-IF
	END-IF.

	If (Success_is in Csid_chips_party   )
	    OR (Success_is in Csid_chips_override   )
	THEN
	    If Success_is in Csid_found_it
		Perform B240_IBK_MAP_CLEANUP Thru
			B240_IBK_MAP_CLEANUP_END
	        GO TO B240_IBK_LKUP_END
	    ELSE
	        Set Bbk_init_lkup in Cdt_screen_state to True
	        GO TO B240_IBK_LKUP_END
	    END-IF
	END-IF.

	If (Ibk_changed_ls = 0 )
	    AND (Adv_changed_ls = 0 )
	THEN
%^ Nothing to do
	    Set Bbk_init_lkup in cdt_screen_state to True
	    GO TO B240_IBK_LKUP_END
	END-IF.

	If ( (Ibk_name1_length of Ent_credit_set_lengths NOT = 0 ) 
             AND (Ibk_name1 of Ent_credit_set NOT = SPACES ) )
	   OR ( (Ibk_name2_length of Ent_credit_set_lengths NOT = 0 ) 
             AND (Ibk_name2 of Ent_credit_set NOT = SPACES ) )
	   OR ( (Ibk_name3_length of Ent_credit_set_lengths NOT = 0 ) 
             AND (Ibk_name3 of Ent_credit_set NOT = SPACES ) )
	   OR ( (Ibk_name4_length of Ent_credit_set_lengths NOT = 0 ) 
             AND (Ibk_name4 of Ent_credit_set NOT = SPACES ) )
	THEN
	    Set Failure_is in Csid_lc_noaddress to true
	ELSE
	    Set Success_is in Csid_lc_noaddress to true
	END-IF.

	If (Ibk_idtype of Ibk of Ent_credit_set = SPACE)
	   AND (Failure_is in Csid_lc_noaddress   )
	THEN
%^ If one of the id's is a foreign account number, we cannot
%^  confirm the id so we cannot use any address information that we have.
%^  Skip the lookup.
	    Set Bbk_init_lkup in Cdt_screen_state to True
	    GO TO B240_IBK_LKUP_END
	END-IF.	    

%^ We still need to try the lookup
* Removed overflow test - obsolete
	%Beg
		Csid_party_id = Ent_credit_set.ibk.ibk_id ;  
		Csid_party_idtype = Ent_credit_set.Ibk.Ibk_idtype ;
	%End.
	Set IBK in Relget_title_flag to TRUE
        PERFORM C660_LOWER_CREDIT through C660_LOWER_CREDIT_END.

	If Success_is in Relget_ambiguous_wf
	Then
		Set Success_is  	in Resolve_Ambiguous to True
		Set Ibk_Index_Conn 	in CDT_screen_state  to True
		Go to B240_IBK_LKUP_END
	End-if.

	Perform C660_LOWER_CREDIT_MAP thru
		C660_LOWER_CREDIT_MAP_END.

	Set IBK_MAP in Cdt_screen_state to True.

B240_IBK_LKUP_END.
	EXIT.


B240_IBK_INDEX_CONN.
%^
%^ Re-enter here after return from ambiguous screen and 
%^ Connect the indices required.  
%^

	Perform C660_LOWER_CREDIT_CONN thru
		C660_LOWER_CREDIT_CONN_END.

	Perform C660_LOWER_CREDIT_MAP thru
		C660_LOWER_CREDIT_MAP_END.

	Set Ibk_map in Cdt_screen_state to True.

B240_IBK_INDEX_CONN_END.
	EXIT.


B240_IBK_MAP.

        If (Csid_ovr = "?" )
	Then
 	    %Beg
	    screen_field_ws = "credit.ibk.ibk_idtype";
            error_mnemonic_ws = Csid_lc_error ;
	    %End
	    call "FTRSCR_WRITE_ERROR" using
	      by reference screen_field_ws
	      by reference error_mnemonic_ws
	    Add 1 to Csid_bogus_parties
	    Add 1 to Cdt_errmemo_count_ls
	    Set Bbk_init_lkup in Cdt_screen_state to True
	    GO TO B240_IBK_MAP_END
	END-IF.

        IF (Failure_is in Csid_ret_stat)
	    If (Csid_party_idtype = "S")
	      AND (Swift_adr_nof_warning of Menu_cfg = "T")
	    THEN
%^18-May-89 For SWIFT ID's, set fatal error if INTRTL flag is set
%^		%Beg  Ftrscr.credit.ibk.ibk_id.msg =  "ftrscr$_inv_swf_id_aux";  %End
 	    	%Beg
	    	screen_field_ws = "credit.ibk.ibk_id";
           	error_mnemonic_ws = "FTRSCR$_INV_SWF_ID_AUX";
	    	%End
	    	call "FTRSCR_WRITE_ERROR" using
	    	  by reference screen_field_ws
	    	  by reference error_mnemonic_ws

		Add 1 to Csid_bogus_parties
		Add 1 to Cdt_errmemo_count_ls
		Set Failure_is in Creditside_screen_ls to TRUE
	    END-IF
	    Set Bbk_init_lkup in Cdt_screen_state to True
	    GO TO B240_IBK_MAP_END
	END-IF.

%^ #132840

	If ( ( (Csid_ovr = SPACE ) OR (Csid_ovr = "*" ) )
	      AND (Success_is in Csid_ret_stat )
	      AND ( Success_is in Csid_lc_noaddress or
		    Success_is in csid_non_ucc_src )) OR
	(Csid_ovr = SPACE and Csid_lc_secwir  = "Y") %^ MUST use looked info for SECWIR
	THEN
	    Set Success_is in Csid_found_it to true
	END-IF.
	Perform C560_UPDATE_IBK through C560_UPDATE_IBK_END.

	If ((Csid_ovr = SPACE ) OR (Csid_ovr = "*" )) AND
	    (Success_is in Csid_ret_stat ) And
	     Failure_is in Csid_found_it	%^ need to keep Name.address instact, remark as onREL/AUX
	Then
		%^ Ensure the adr ptr flag is set
		%beg 	    Ent_credit_set(.ibk_rel_id = Relget_adr_set.rel_id,
	    		   .ibk_adr_set_ptr POINT: Relget_adr_set,
			   .flgs3.ibk_adr_ptr_ok = "T");
		%end
	End-if.

	If (Failure_is in Csid_found_it)
	    Set Bbk_init_lkup in Cdt_screen_state to True
	    GO TO B240_IBK_MAP_END
	END-IF.

%^B240_IBK_ADDRESS.

	Perform B240_IBK_MAP_CLEANUP Thru
		B240_IBK_MAP_CLEANUP_END.

B240_IBK_MAP_END.
   EXIT.

B240_IBK_MAP_CLEANUP.
	If (Success_is in Csid_found_it   )
* Removed overflow from compose - obsolete
	    %Beg
	    Csid_compose ^OUT(Csid_id_ws) 
		Ent_credit_set.ibk.ibk_id, / ;
	    Csid_idtype_ws = Ent_credit_set.ibk.ibk_idtype ;
	    %End  

	    Call "SET_IBK_PARTY" USING
	        By reference Csid_idtype_ws
	        By reference Csid_id_ws
	        By reference Csid_id_ws_length
	        By reference Bank of Loc_info of Ent_ftr_set
	      RETURNING Csid_ret_stat
	    Add 1 to Advice_parties_ls
	END-IF.

	Set Bbk_init_lkup in Cdt_screen_state to True.

B240_IBK_MAP_CLEANUP_END.
	EXIT.


B260_IB1_init_lkup.
%^
%^ First, check if we need to be here.
%^
	If (Ib1_id of Ib1 of Ent_credit_set NOT = SPACES )
	   OR ( (Ib1_name1_length of Ent_credit_set_lengths NOT = 0 ) 
	        AND (Ib1_name1 of Ent_credit_set NOT = SPACES ) )
	THEN
	    If (Success_is in Csid_try_chips)
		AND ( (Ib1_changed_ls = 0 )
	              AND (Credit_changed_ls NOT = 1 )
		      AND (Adv_changed_ls = 0 ) )
		AND (Ib1_qualified_ls NOT = 0 )
	    THEN
		%^ Exit, no party change, stay if possible CHIPS lookup
		Set Failure_is in Csid_try_chips to TRUE
		Set IBK_Init_lkup in Cdt_screen_state to True
		Go to B260_Ib1_init_lkup_end
	    ELSE
	        If NOT( (Csid_pushed_credit NOT = 1 ) AND
		      ( (Success_is in Csid_try_chips) OR
		        (Ib1_changed_ls NOT = 0 ) ))
		THEN
			%^ Nothing to do Just Exit, say to lookup.
			Set IBK_Init_lkup in Cdt_screen_state to True
			Go to B260_Ib1_init_lkup_end
		END-IF
	    END-IF
	Else
		Set IBK_Init_lkup in Cdt_screen_state to True
		Go to B260_Ib1_init_lkup_end
	END-IF.

*  Paragraph to do account lookup on the IB1.  
*  If Success_is in Csid_try_chips we will try to chips qualify it.
*  If it is not set, then we do a REL lookup.  
*     If the REL lookup succeeds, we use FIND_ADR_ID to perfect our external
*    	   id and copy in the name and address info.  We set the Ib1_rel_id
*          and the Ib1_adr_set_ptr and copy in the Ib1_adv_inst.

        %^ Clear out the previous address if necessary
        If Ib1_changed_ls not = 0 then
            %Beg
            Ent_credit_set (.ib1_rel_id         =  <0>,
                            .ib1_adr_set_ptr    DELETE,
			    .flgs3.ib1_adr_ptr_ok = Null);
            %End
	    %Beg Ent_credit_set.ib1_res_country = NULL; %End	%^ 115131 
        END-IF.

       %^ If a Repetitive with multiples,  then clear any info
        %^ after the 1st and remap , it will be re-mapped.
        If (Is_rptv_lookup_ls NOT = 0 )
        THEN
                %Beg
                Csid_parse ^IN(Ent_credit_set.Ib1.Ib1_id)
                        Csid_temp1_vstr, "/(", ^STRING, ^SPACE, / ;
                %End
                If Success_is in Csid_parse_status
                        %Beg
                        Csid_compose ^OUT(Ent_credit_set.Ib1.Ib1_id)
                                Csid_temp1_vstr, / ;
                        %End
                End-if
        End-if.

        Set Failure_is in Csid_multi_party to true.
        Move SPACES to Csid_party_id.
        %Beg Csid_party_idtype = Ent_credit_set.ib1.ib1_idtype; %End.
* Removed overflow test - obsolete
            %Beg
            Csid_party_id = Ent_credit_set.Ib1.Ib1_id ;
	    Csid_parse ^IN(Csid_party_id),
		^ONEOF(
			(Csid_temp1_vstr, "/", 
				Csid_party_extype (^STRING<2>(<CHAR$M_ALPHA>)), 
				^STRING, ^SPACE, /),
			(Csid_temp1_vstr, "/??", ^STRING, ^SPACE, /));
	    %End
	    If (Success_is in Csid_parse_status   )
		AND (Csid_temp1_vstr_length NOT = 0 )
	    THEN
                Set Success_is in Csid_multi_party to true
            END-IF.

* put in N or @ id if left blank by operator
	%Beg  Relget_msgcode = NULL;  %End.
        Move Ib1_secwir of Ib1 of Ent_credit_set to Csid_lc_secwir.
	IF (Ib1_idtype of Ib1 of Ent_credit_set = "N" OR "@")
	   AND (Ib1_id of Ib1 of Ent_credit_set = SPACES)
	THEN
	    If Ib1_name1 of Ent_credit_set NOT = SPACES
		MOVE SPACES TO Csid_20charid_ws
		If Ib1_idtype OF Ib1 OF Ent_credit_set = "N"
		    Call "AUTONAM" USING
			By reference Ib1_name1 OF Ent_credit_set
			By reference Ib1_name1_length of Ent_credit_set_lengths
			By reference Csid_20charid_ws
			By reference Csid_length
		ELSE
		    Call "CREATE_AUX_MNAM" USING 
			By reference Csid_20charid_ws
			By reference Ib1_name1_length of Ent_credit_set_lengths
			By reference Ib1_name1 OF Ent_credit_set
			By reference Ib1_name2_length OF Ent_credit_set_lengths
			By reference Ib1_name2 OF Ent_credit_set
			By reference Ib1_name3_length OF Ent_credit_set_lengths
			By reference Ib1_name3 OF Ent_credit_set
			By reference Ib1_name4_length OF Ent_credit_set_lengths
			By reference Ib1_name4 OF Ent_credit_set
		END-IF
		MOVE %SIZ(Csid_20charid_ws) TO Csid_20charid_ws_length
		%Beg
		Csid_compose ^OUT(Ent_credit_set.Ib1.Ib1_id), 
				Csid_20charid_ws, /;
		%End
	    ELSE
*		error, name missing
%^		%Beg Ftrscr.credit.ib1_name1.msg = "FTRSCR$_NAMEMISSING"; %End
 	    	%Beg
	    	screen_field_ws = "credit.ib1_name1";
           	error_mnemonic_ws = "FTRSCR$_NAMEMISSING";
	    	%End
	    	call "FTRSCR_WRITE_ERROR" using
	    	  by reference screen_field_ws
	    	  by reference error_mnemonic_ws
		Add 1 to Csid_bogus_parties
		Add 1 to Cdt_errmemo_count_ls
	        Set Failure_is in Csid_try_chips to TRUE
		Set Bbk_init_lkup in Cdt_screen_state to True
		GO TO B260_IB1_INIT_LKUP_END
	    END-IF
	END-IF.

	Set Failure_is in Csid_found_it to true.
	Set Failure_is in Csid_chips_candidate to true.
	Set Failure_is in Csid_chips_party to true.
	Set Failure_is in Csid_chips_override to true.

	If (Ib1_idtype of Ib1 of Ent_credit_set = "@" )
	Then
		Set Ib1_name_lkup in Cdt_screen_state to True
	Else
		Set Ib1_lookup in Cdt_screen_state to True
	End-if.

B260_IB1_INIT_LKUP_END.
	EXIT.

B260_IB1_NAME_LKUP.

* We're being asked to search the AUX database, so let's do it before
*  we try the CHIPS qualification.
	%Beg
	    Csid_parse ^IN(Ent_credit_set.Ib1.Ib1_id ) ^SPACE, Csid_id_ws, 
		    ^SPACE, / ;
	%End

	Set IBK in Relget_title_flag to TRUE
	Move SPACES to Csid_lkup_pend_del	
	%Beg  Csid_next_function = Menu_next_function;  %End
	Call "REL_GET" USING 
		by content "&"
		By reference Csid_id_ws
		By reference Csid_id_ws_length
		by reference Csid_lkup_pend_del
	      RETURNING Csid_ret_stat

	If (Relget_reject_flag = "M")	Or
   	   (Csid_next_function not = Menu_next_function)
	Then
		Set Menu_is in cdt_screen_state to True
		Go to B260_IB1_NAME_LKUP_END
	End-if

	If Success_is in Relget_ambiguous_wf
	Then
		Set Success_is  	in Resolve_Ambiguous to True
		Set Ib1_Name_Conn 	in CDT_screen_state  to True
		Go to B260_IB1_NAME_LKUP_END
	End-if.

	Set Ib1_Name_Compl in cdt_screen_state to True.

B260_IB1_NAME_LKUP_END.
	EXIT.

B260_IB1_NAME_CONN.
%^
%^
	Call "RELGET_CONNECT" USING 
	    by reference csid_lkup_pend_del
	  RETURNING csid_ret_stat.

	Set Ib1_Name_Compl in cdt_screen_state to True. 

B260_IB1_NAME_CONN_END.
	EXIT.

B260_IB1_NAME_COMPL.
	    If (Relget_msgcode = Vmsg_dat_notonfile_wc )
		OR (Success_is in Csid_ret_stat   )
	    THEN
                If (Csid_lc_secwir NOT = "Y" )
* If we are sending a secwir, lookup MUST be done in REL database instead.
                    Set Success_is in Csid_found_it to true
                END-IF
		Move "IB1" to Bcc_lkup_party
	    	Perform D100_BCC_LKUP_BIC thru D100_BCC_LKUP_BIC_END
	    	If Failure_is in Bcc_lkup_status
		    Set Ibk_init_lkup in Cdt_screen_state to True
		    GO TO B260_IB1_NAME_COMPL_END
		end-if
		If (Relget_return_key NOT = SPACES )
		    %Beg
	            Csid_clip_compose ^OUT(Ent_credit_set.ib1.ib1_id), 
			Relget_return_key, / ;
		    Ent_credit_set.ib1.ib1_idtype = Relget_return_idtype ;
		    %End
		END-IF

%^ icr_000636 Remove any invalid error messages that may have been found
%^	      before the ib1 selection was made from an ambiguous 
%^	      screen.

		If Screen_field_ws Not = Spaces And
		   Idtype of Rel_name_key of Relget_index Not =
			Idtype of Disp_id of Relget_index
		Then
		    %Beg
			error_mnemonic_ws = "";
		    %End
	            call "FTRSCR_WRITE_ERROR" using
	          	by reference screen_field_ws
		  	by reference error_mnemonic_ws
		END-IF
	    ELSE
* We did a generic lookup which failed.
%^		%Beg  Ftrscr.credit.ib1.ib1_id.msg = "VMSG$_LOOKUPFAIL";  %End
 	    	%Beg
	    	screen_field_ws = "credit.ib1.ib1_id";
           	error_mnemonic_ws = "VMSG$_LOOKUPFAIL";
	    	%End
	    	call "FTRSCR_WRITE_ERROR" using
	    	  by reference screen_field_ws
	    	  by reference error_mnemonic_ws
		Add 1 to Csid_bogus_parties
		Add 1 to Cdt_errmemo_count_ls
	END-IF.


	Set Ib1_Lookup in Cdt_screen_state to True.

B260_IB1_NAME_COMPL_END.
	EXIT.

B260_IB1_LKUP.

	If (Success_is in Csid_try_chips)
* If Ent_debit_set.Dbt_wir_key.idtype is a *, it automatically qualifies.
	    If Idtype of Dbt_wir_key of Ent_debit_set = "*" 
	        Move 1 to Ib1_qualified_ls
		Set Failure_is in Csid_try_chips to TRUE
		Set Ibk_init_lkup in Cdt_screen_state to True
	        GO TO B260_IB1_LKUP_END
	    END-IF
	    Move 0 to Ib1_qualified_ls

            If (Ib1_id of Ent_credit_set = spaces)
            or (Ib1_length of Ent_credit_set_lengths NOT > 2 )
            THEN
* No ID to qualify
                Set Failure_is in Csid_try_chips to TRUE
	    END-IF

%^ Try for CHIPS qualification lookup.
            If Success_is in Csid_try_chips
	        Call "CUST_EXTENDED_ID_QUAL"  USING
		    by Reference Ib1_idtype of Ent_credit_set
		    by Reference Ib1_id of Ent_credit_set
		    by Reference Ib1_id_length of Ent_credit_set_lengths
		    by Reference Ib1_idtype of Ent_credit_set
		    by Reference Ib1_id of Ent_credit_set
		    by Reference Ib1_id_length of Ent_credit_set_lengths
		    by Reference Csid_tmp_flg_ws
		    by Reference Csid_temp1_vstr
		    by Reference Csid_temp1_vstr_length
	          returning Csid_temp_stat

		Call "CHIPS_QUALIFICATION"  USING
		    By reference Ib1_idtype of Ib1 of Ent_credit_set
		    By reference Ib1_id of Ib1 of Ent_credit_set
	          RETURNING Csid_ret_stat
	        If (Success_is in Csid_ret_stat   )
		    AND (Success_is in Csid_chp_qual_cand)	%^(Chips_uid_id of Relget_adr_set NOT = SPACES )
	        THEN
		    Set Success_is in Csid_found_it to true
		    Set Success_is in Csid_chips_candidate to true
	        ELSE
%^ Override pseudo-qualification is not needed for the interactive case.
                    Set Failure_is in Csid_found_it to true
                    Move ZERO to Ib1_qualified_ls
	        END-IF
	    END-IF
	END-IF.
	If (Success_is in Csid_try_chips)
	    Set Failure_is in Csid_try_chips to TRUE
	    If (Success_is in Csid_chips_candidate   )
%^ Relget_adr_set is copy of address rel for chips candidate
* IB1 party has an account at the Ent_credit_set bank, so we can create 
*   an ID string from the full qualification data (UID, Swift ID, and
*   account ID).
	        Call "CUST_EXTENDED_ID_QUAL"  USING
		    by Reference Ib1_idtype of Ent_credit_set
		    by Reference Ib1_id of Ent_credit_set
		    by Reference Ib1_id_length of Ent_credit_set_lengths
		    by Reference Ib1_idtype of Ent_credit_set
		    by Reference Ib1_id of Ent_credit_set
		    by Reference Ib1_id_length of Ent_credit_set_lengths
		    by Reference Csid_tmp_flg_ws
		    by Reference Csid_temp1_vstr
		    by Reference Csid_temp1_vstr_length
	          returning Csid_temp_stat

		Call "CHIPS_QUALIFICATION_IDSTR"  USING
		    By reference Ib1_idtype of Ib1 of Ent_credit_set
		    By reference Ib1_id of Ib1 of Ent_credit_set
                    By reference Ib1_id_length of Ent_credit_set_lengths
		    By reference Csid_id_ws
		    By reference Csid_id_ws_length
		  RETURNING Csid_chips_party
                If (Failure_is in Csid_chips_party   )
* Could have case of a COMMON UID and SWIFT TID.
                    Perform C670_CHECK_COMMON_UID thru
                            C670_CHECK_COMMON_UID_end
                    If Success_is in Csid_chips_party  
* Removed overflow setting - obsolete
                        %Beg
                        Ent_credit_set (.ib1.ib1_idtype = Csid_party_idtype,
                                        .ib1.ib1_id = Csid_id_ws ) ;
                        %End
		    END-IF
                END-IF
            END-IF
            If (Failure_is in Csid_chips_party   )
                Set Failure_is in Csid_found_it to true
                Move ZERO to Ib1_qualified_ls
            ELSE
* Removed overflow  - obsolete
                %Beg
                Ent_credit_set (.ib1.ib1_id = Csid_id_ws, CHANGE ) ;
                %End
                Move 1 to IB1_qualified_ls
	    END-IF
	END-IF.

	If (Success_is in Csid_chips_party   )
	    OR (Success_is in Csid_chips_override   )
	THEN
	    If Success_is in Csid_found_it
		Perform B260_IB1_MAP_CLEANUP Thru
			B260_IB1_MAP_CLEANUP_END
	        GO TO B260_IB1_LKUP_END
	    ELSE
	        GO TO B260_IB1_LKUP_END
	    END-IF
	END-IF.

	If (Ib1_changed_ls = 0 )
	    AND (Adv_changed_ls = 0 )
	THEN
%^ Nothing to do
	    Set Ibk_init_lkup in cdt_screen_state to True
	    GO TO B260_IB1_LKUP_END
	END-IF.

	If ( (Ib1_name1_length of Ent_credit_set_lengths NOT = 0 ) 
             AND (Ib1_name1 of Ent_credit_set NOT = SPACES ) )
	   OR ( (Ib1_name2_length of Ent_credit_set_lengths NOT = 0 ) 
             AND (Ib1_name2 of Ent_credit_set NOT = SPACES ) )
	   OR ( (Ib1_name3_length of Ent_credit_set_lengths NOT = 0 ) 
             AND (Ib1_name3 of Ent_credit_set NOT = SPACES ) )
	   OR ( (Ib1_name4_length of Ent_credit_set_lengths NOT = 0 ) 
             AND (Ib1_name4 of Ent_credit_set NOT = SPACES ) )
	THEN
	    Set Failure_is in Csid_lc_noaddress to true
	ELSE
	    Set Success_is in Csid_lc_noaddress to true
	END-IF.

	If (Ib1_idtype of Ib1 of Ent_credit_set = SPACE)
	   AND (Failure_is in Csid_lc_noaddress   )
	THEN
%^ If one of the id's is a foreign account number, we cannot
%^  confirm the id so we cannot use any address information that we have.
%^  Skip the lookup.
	    Set Ibk_init_lkup in Cdt_screen_state to True
	    GO TO B260_IB1_LKUP_END
	END-IF.	    

%^ We still need to try the lookup
* Removed overflow test - obsolete
	%Beg
		Csid_party_id = Ent_credit_set.ib1.ib1_id ;  
		Csid_party_idtype = Ent_credit_set.Ib1.Ib1_idtype ;
	%End.
	Set IBK in Relget_title_flag to TRUE
        PERFORM C660_LOWER_CREDIT through C660_LOWER_CREDIT_END.

	If Success_is in Relget_ambiguous_wf
	Then
		Set Success_is  	in Resolve_Ambiguous to True
		Set Ib1_Index_Conn 	in CDT_screen_state  to True
		Go to B260_IB1_LKUP_END
	End-if.

	Perform C660_LOWER_CREDIT_MAP thru
		C660_LOWER_CREDIT_MAP_END.

	Set IB1_MAP in Cdt_screen_state to True.

B260_IB1_LKUP_END.
	EXIT.


B260_IB1_INDEX_CONN.
%^
%^ Re-enter here after return from ambiguous screen and 
%^ Connect the indices required.  
%^

	Perform C660_LOWER_CREDIT_CONN thru
		C660_LOWER_CREDIT_CONN_END.

	Perform C660_LOWER_CREDIT_MAP thru
		C660_LOWER_CREDIT_MAP_END.

	Set Ib1_map in Cdt_screen_state to True.

B260_IB1_INDEX_CONN_END.
	EXIT.


B260_IB1_MAP.

        If (Csid_ovr = "?" )
	Then
 	    %Beg
	    screen_field_ws = "credit.ib1.ib1_idtype";
            error_mnemonic_ws = Csid_lc_error ;
	    %End
	    call "FTRSCR_WRITE_ERROR" using
	      by reference screen_field_ws
	      by reference error_mnemonic_ws
	    Add 1 to Csid_bogus_parties
	    Add 1 to Cdt_errmemo_count_ls
	    Set Ibk_init_lkup in Cdt_screen_state to True
	    GO TO B260_IB1_MAP_END
	END-IF.

        IF (Failure_is in Csid_ret_stat)
	    If (Csid_party_idtype = "S")
	      AND (Swift_adr_nof_warning of Menu_cfg = "T")
	    THEN
%^18-May-89 For SWIFT ID's, set fatal error if INTRTL flag is set
%^		%Beg  Ftrscr.credit.ib1.ib1_id.msg =  "ftrscr$_inv_swf_id_aux";  %End
 	    	%Beg
	    	screen_field_ws = "credit.ib1.ib1_id";
           	error_mnemonic_ws = "FTRSCR$_INV_SWF_ID_AUX";
	    	%End
	    	call "FTRSCR_WRITE_ERROR" using
	    	  by reference screen_field_ws
	    	  by reference error_mnemonic_ws

		Add 1 to Csid_bogus_parties
		Add 1 to Cdt_errmemo_count_ls
		Set Failure_is in Creditside_screen_ls to TRUE
	    END-IF
	    Set Ibk_init_lkup in Cdt_screen_state to True
	    GO TO B260_IB1_MAP_END
	END-IF.

%^ #132840

	If ( ( (Csid_ovr = SPACE ) OR (Csid_ovr = "*" ) )
	      AND (Success_is in Csid_ret_stat )
	      AND ( Success_is in Csid_lc_noaddress or
		    Success_is in csid_non_ucc_src )) OR
	(Csid_ovr = SPACE and Csid_lc_secwir  = "Y") %^ MUST use looked info for SECWIR
	THEN
	    Set Success_is in Csid_found_it to true
	END-IF.
	Perform C580_UPDATE_IB1 through C580_UPDATE_IB1_END.

	If ((Csid_ovr = SPACE ) OR (Csid_ovr = "*" )) AND
	    (Success_is in Csid_ret_stat ) And
	     Failure_is in Csid_found_it	%^ need to keep Name.address instact, remark as onREL/AUX
	Then
		%^ Ensure the adr ptr flag is set
		%beg 	    Ent_credit_set(.ib1_rel_id = Relget_adr_set.rel_id,
	    		   		   .ib1_adr_set_ptr POINT: Relget_adr_set,
			   		   .flgs3.ib1_adr_ptr_ok = "T");
		%end
	End-if.

	If (Failure_is in Csid_found_it)
	    Set ibk_init_lkup in Cdt_screen_state to True
	    GO TO B260_IB1_MAP_END
	END-IF.

	Perform B260_IB1_MAP_CLEANUP Thru
		B260_IB1_MAP_CLEANUP_END.


%^B260_IB1_ADDRESS.


B260_IB1_MAP_END.
   EXIT.

B260_IB1_MAP_CLEANUP.
	If (Success_is in Csid_found_it   )
* Removed overflow from compose - obsolete
	    %Beg
	    Csid_compose ^OUT(Csid_id_ws) 
		Ent_credit_set.ib1.ib1_id, / ;
	    Csid_idtype_ws = Ent_credit_set.ib1.ib1_idtype ;
	    %End  

	    Call "SET_IB1_PARTY" USING
	        By reference Csid_idtype_ws
	        By reference Csid_id_ws
	        By reference Csid_id_ws_length
	        By reference Bank of Loc_info of Ent_ftr_set
	      RETURNING Csid_ret_stat
	    Add 1 to Advice_parties_ls
	END-IF.

	Set Ibk_init_lkup in Cdt_screen_state to True.

B260_IB1_MAP_CLEANUP_END.
	EXIT.

B280_CDT_LKUP.
	If (Credit_changed_ls NOT = 0 )	%^ Was = 1
	   OR (Success_is in Csid_IRS_tran )
	THEN
	    Move 1 to Csid_credit_changed
	    %Beg
		    Csid_pref_corr_rec = NULL ;
		    Ent_ftr_set.Si_flgs (.Fx_found  = NULL,
					 .Check_found = NULL ) ;
	    %End
	    If (Cor_done of Si_flgs of Ent_ftr_set = "P" )
		%Beg  Ent_ftr_set.Si_flgs.Cor_done = NULL ;  %End
	    END-IF
	    %^
	    %^ If required, add the BNP lookahead for IBAN and replace
	    %^ if REP_BBK_A/D format PRMs are found.
	    %^
	    If csid_struct_acct_ws = "Y" And
	      (bnp_id of bnp of Ent_credit_set NOT = Spaces AND
	       bnp_idtype of bnp of Ent_credit_set = " ")
	    Then
	    	%^ Check PUSH UP IBAN A and D format replacement logic
	    	Perform X1100_CHECK_IBAN_BNP Thru
	    		X1100_CHECK_IBAN_BNP_END
	    End-if
	    %^
	    %^   Set B280_cdt_pty_init in Cdt_screen_state to True
	    %^  Go To B280_Cdt_lkup_end
            Perform B280_CDT_PARTY through B280_CDT_PARTY_END

	    If Success_is in Relget_ambiguous_wf
	    Then
			Set Success_is  	in Resolve_Ambiguous to True
			Set CDT_Index_Conn1 in CDT_screen_state  to True
			Go to B280_CDT_LKUP_END
	    End-if

	    If (Relget_reject_flag = "M") Or
	       (Csid_next_function not = Menu_next_function)
	    Then
			Set Menu_is in CDT_screen_state  to True
    			Go to B280_CDT_LKUP_END
	    End-if

	    If Success_is in csid_iban_expanded And
	       Csid_pref_corr_rec NOT = spaces
	    Then
			Set Ain_processing in Cdt_screen_state to True
			Go To B280_CDT_LKUP_END
	    End-if



  	   If ((Cdt_idtype of Cdt_typ of Ent_credit_set = SPACE ) OR
	      ( (Cdt_idtype of Cdt_typ of Ent_credit_set = "N" OR "@") AND
	      (Cdt_id of Cdt_typ of Ent_credit_set = SPACES) )) AND
		Failure_is in csid_iban_expanded
	   THEN
		%^ No credit party at all,  just do the lower parties.
    		Perform B420_GET_NEWPARTY through B420_GET_NEWPARTY_END
		Set Ain_processing in Cdt_screen_state to True
		%^Set Ib1_lookup in Cdt_screen_state to True
	   Else
		    Perform B280_CDT_PTY_MAP thru
			    B280_CDT_PTY_MAP_END
		    Set Cdt_map in Cdt_screen_state to True
	   End-if

	Else
	    %^ Add this call for a RPR case where Credit is not changed,
	    %^ but BNP was and could be a corrected IBAN.
	    If csid_struct_acct_ws = "Y" And
	      (bnp_id of bnp of Ent_credit_set NOT = Spaces AND
	       bnp_idtype of bnp of Ent_credit_set = " ") And 
	       bnp_changed_ls NOT = 0 And Credit_changed_ls = 0
 	    Then
	    	%^ Check PUSH UP IBAN A and D format replacement logic
	    	%^ THis can result in a new Credit party right off the bat
	    	Perform X1100_CHECK_IBAN_BNP Thru
	       		X1100_CHECK_IBAN_BNP_END
		If csid_credit_changed  = 1  And
		   Csid_bnk_code_rec_ws NOT = Spaces
		Then
			%^ use the Bank code rec to push back down the BNP
			%beg
				csid_pref_corr_rec
					( .idkey  = csid_bnk_code_rec_ws.idkey,
					  .idtype = csid_bnk_code_rec_ws.idtype);
				Break: ent_c_adr_set;  %^ will be replaced here too...
				BREAK: Relget_adr_set; %^ Can't have this around at this point.
			%End
	    		Initialize Relget_adr_set
		End-if
		Set AIN_processing in Cdt_screen_state to True
	    Else
		Set Got_credit in Cdt_screen_state to True
	    End-if
	End-if.

B280_CDT_LKUP_END.
	EXIT.

B280_CDT_INDEX_CONN1.
%^
%^ Re-enter here after return from ambiguous screen and 
%^ Connect the indices required.  
%^
	Call "RELGET_CONNECT" USING 
	    by reference Csid_lkup_pend_del
	  RETURNING Csid_ret_stat.

	Perform B280_CDT_PTY_MAP thru
		B280_CDT_PTY_MAP_END.

	Set CDT_map in Cdt_screen_state to True.

B280_CDT_INDEX_CONN1_END.
	EXIT.


B280_CDT_MAP.
	If Failure_is in csid_iban_expanded Then
		%^ Success_in in Csid_expanded  indicates the We have, in effect,
		%^ already found an insertion, fall through and do it

		    If (Cdt_ovr of Cdt_typ of Ent_credit_set = SPACE )
			OR ( ( Cdt_ovr of Cdt_typ of Ent_credit_set = "*" )
			     AND (Relget_msgcode = Vmsg_dat_notonfile_wc ) )
		    THEN
			%^ We actually did get a REL or AUX db hit, so let's copy the address.
		        Perform C620_COPY_ADDRESS through C620_COPY_ADDRESS_END
		    END-IF

		    If (Cdt_ovr of Cdt_typ of Ent_credit_set NOT = SPACE) And
			Not(Relget_msgcode = Vmsg_dat_notonfile_wc ) Then
			%^ Break the Relget_adr_set to avoid bogus AIN's left over from Debitside
                	%Beg BREAK: Relget_adr_set; %End
	   	    END-IF

		    Perform B400_SET_ADVICE through B400_SET_ADVICE_END %^ Moved from Above
       		    Perform B420_GET_NEWPARTY through B420_GET_NEWPARTY_END

		    If (Failure_is in Creditside_screen_ls  )
				OR (Success_is in Csid_cor_found   )
	 	    THEN
			Set Got_credit in Cdt_screen_state to True
			GO TO B280_CDT_MAP_END
		    END-IF
	END-IF.

	%^ Add this call for a RPR case where Credit is not changed,
	%^ but BNP was and could be a corrected IBAN.
	If csid_struct_acct_ws = "Y" And
	  (bnp_id of bnp of Ent_credit_set NOT = Spaces AND
	   bnp_idtype of bnp of Ent_credit_set = " ") And 
	   bnp_changed_ls NOT = 0 And Credit_changed_ls = 0
	Then
	    	%^ Check PUSH UP IBAN A and D format replacement logic
	    	%^ THis can result in a new Credit party right off the bat
	    	Perform X1100_CHECK_IBAN_BNP Thru
	       		X1100_CHECK_IBAN_BNP_END
		If csid_credit_changed  = 1  And
		   Csid_bnk_code_rec_ws NOT = Spaces
		Then
			%^ use the Bank code rec to push back down the BNP
			%beg
				csid_pref_corr_rec
					( .idkey  = csid_bnk_code_rec_ws.idkey,
					  .idtype = csid_bnk_code_rec_ws.idtype);
				Break: ent_c_adr_set;  %^ will be replaced here too...
				BREAK: Relget_adr_set; %^ Can't have this around at this point.
			%End
	    		Initialize Relget_adr_set
		End-if
	End-if.

	Set AIN_processing in Cdt_screen_state to True.

B280_CDT_MAP_END.
	EXIT.


B280_CDT_PARTY.
* Paragraph to do actual lookup of credit party.
	Add 1 to Csid_this_deletes
	If (Csid_this_deletes > Csid_loop_limit ) 
%^ Do nothing for now
	    Add 1 to Csid_this_more
	END-IF
%^
%^ This caused problem with Command MOVE NEXT PARTY TO CREDIT
%^
%^	%^ If Credit party changed, change the country too if not differently entered.
%^	If (cdt_res_country of Ent_credit_set = cdt_res_country of Change_credit_set)
%^	AND  ( cdt_typ of ent_credit_set NOT = cdt_typ of Change_credit_set) %^ 107747
%^	Then
%^		%beg Ent_credit_set.cdt_res_country = NULL; %end
%^	end-if.

	If (Cdt_account of Ent_credit_set NOT = SPACES )
            %Beg
            Ent_credit_set (
                        .cdt_account            = NULL,
                        .cdt_acc_prod_codes     = NULL,
                        .cdt_acc_class          = NULL ) ;
	    %End
	END-IF
	If (Cdt_hold_flg of Flgs of Ent_credit_set NOT = SPACE )
	    %Beg  Ent_credit_set.flgs.cdt_hold_flg = NULL ;  %End
	END-IF
	%Beg
		BREAK: relget_adr_set;
		BREAK: Ent_c_adr_set ;
		BREAK: Ent_c_acc_set ;
		BREAK: Ent_c_acc_rel_reg;
	%End.

* put in N or @ id if left blank by operator
	IF (Cdt_idtype of Cdt_typ of Ent_credit_set = "N" OR "@")
	   AND (Cdt_id of Cdt_typ of Ent_credit_set = SPACES)
	THEN
	    If Cdt_name1 of Ent_credit_set NOT = SPACES
		MOVE SPACES TO Csid_20charid_ws
		If Cdt_idtype OF Cdt_typ OF Ent_credit_set = "N"
		    Call "AUTONAM" USING
			By reference Cdt_name1 OF Ent_credit_set
			By reference Cdt_name1_length of Ent_credit_set_lengths
			By reference Csid_20charid_ws
			By reference Csid_length
		ELSE
		    Call "CREATE_AUX_MNAM" USING 
			By reference Csid_20charid_ws
			By reference Cdt_name1_length of Ent_credit_set_lengths
			By reference Cdt_name1 OF Ent_credit_set
			By reference Cdt_name2_length OF Ent_credit_set_lengths
			By reference Cdt_name2 OF Ent_credit_set
			By reference Cdt_name3_length OF Ent_credit_set_lengths
			By reference Cdt_name3 OF Ent_credit_set
			By reference Cdt_name4_length OF Ent_credit_set_lengths
			By reference Cdt_name4 OF Ent_credit_set
		END-IF
		MOVE %SIZ(Csid_20charid_ws) TO Csid_20charid_ws_length
		%Beg
		Csid_compose ^OUT(Ent_credit_set.Cdt_typ.Cdt_id), 
				Csid_20charid_ws, /;
		%End
	    ELSE
%^ error, name missing
 	    	%Beg
	    	screen_field_ws = "credit.cdt_name1";
           	error_mnemonic_ws = "FTRSCR$_NAMEMISSING";
	    	%End
	    	call "FTRSCR_WRITE_ERROR" using
	    	  by reference screen_field_ws
	    	  by reference error_mnemonic_ws
		Add 1 to Cdt_errmemo_count_ls
		Set Failure_is in Creditside_screen_ls to true
	    END-IF
	END-IF.



	If (csid_struct_acct_ws = "Y") And
	   (Cdt_idtype of Cdt_typ of Ent_credit_set = Space) And
	   (Cdt_id of cdt_typ of Ent_credit_set NOT = Space) Then
		%^
		%^ We can be sure that this is an NOF, at least at this point,
		%^ Hose all the leftovers
		%^
		Call "ACCTSUB_CDT_NOF"
		%^ TIme to check for an IBAN
		Set Failure_is in csid_lookup_bban to True	%^ assume invalid
		%beg csid_iban_cntry_ws = NULL; %End
		Move SPACES to csid_iban_cntry_ws
		%beg
			Csid_party_id = Ent_credit_set.Cdt_typ.Cdt_id ; 
			Csid_party_idtype = Ent_credit_set.Cdt_typ.Cdt_idtype ;
		%End
		%^ WaS CDT_RES_COUNTRY
		If Not(bnp_mailing_country of Ent_credit_set = Spaces) Then
			%beg csid_iban_cntry_ws = Ent_credit_set.bnp_mailing_country; %end
		Else
			%^ Attempt to divine a country code to use
			Initialize Csid_risk_country_ws, Csid_country_code_ws
	    		Call "DETERM_RES_COUNTRY" using
	       			by content "CDT"
				by reference cdt_idtype of Ent_credit_set
	       			by reference cdt_id of Ent_credit_set
	       			by reference cdt_id_length of Ent_credit_set_lengths
	       			by reference Csid_risk_country_ws
	       			by reference Csid_country_code_ws
	       			by reference cdt_res_country of Ent_credit_set
	       			by reference Csid_res_country_ws
		end-if
		Call "VALIDATE_IBAN" Using
			by Reference csid_party_id
			by Reference csid_party_id_length
			by Reference csid_iban_cntry_ws
			by Reference csid_iban_bnk_ws
			by Reference csid_iban_bnk_ws_length
			by Reference csid_iban_brnch_ws
			by Reference csid_iban_brnch_ws_length
			by Reference csid_iban_curr_ws
			By Reference csid_bnk_code_rec_ws
			By Reference csid_bnk_code_rec_ws_lengths
			By Reference csid_valid_iban_flg_ws
		returning Csid_val_iban_ret			

		Evaluate true
			When Failure_blocking_is in csid_val_iban_ret
				%^ Fail       - possible Invalid Account

				If Success_is in csid_bban_cntry_req_ws And
				   Csid_valid_iban_flg_ws = "N" And   %^ ensure not an IBAN
				   bnp_mailing_country of Ent_credit_set = Spaces
				Then
 	    			   %Beg
	    			   screen_field_ws = "credit.bnp_mailing_country";
           			   error_mnemonic_ws = "LKUP$_COUNTRY_REQ";
	    			   %End
	    			   call "FTRSCR_WRITE_ERROR" using
	    			     by reference screen_field_ws
	    			     by reference error_mnemonic_ws
				Else
				    Evaluate Csid_valid_iban_flg_ws
					When "I"	%^ Bad IBAN
	    					%Beg
	    					screen_field_ws = "credit.cdt_typ.cdt_id";
           					error_mnemonic_ws = "LKUP$_IBAN_FAILURE_B";
	    					%End
	    					call "FTRSCR_WRITE_ERROR" using
	    					  by reference screen_field_ws
	    					  by reference error_mnemonic_ws
					When "N"	%^ Bad BBAN
	    					%Beg
	    					screen_field_ws = "credit.cdt_typ.cdt_id";
           					error_mnemonic_ws = "LKUP$_BBAN_FAILURE_B";
	    					%End
	    					call "FTRSCR_WRITE_ERROR" using
	    					  by reference screen_field_ws
	    					  by reference error_mnemonic_ws
					When "R"	%^ Iban Required
	    					%Beg
	    					screen_field_ws = "credit.cdt_typ.cdt_id";
           					error_mnemonic_ws = "IVAL$_IBAN_REQ_B";
	    					%End
	    					call "FTRSCR_WRITE_ERROR" using
	    					  by reference screen_field_ws
	    					  by reference error_mnemonic_ws
				    end-evaluate
				End-if
				Add 1 to Csid_bogus_parties
				Add 1 to Cdt_errmemo_count_ls
				Set Failure_is in Creditside_screen_ls to TRUE
			When Success_is in csid_val_iban_ret
				%^ Pass       - Valid IBAN/BBAN
				%^ save for parameter addtion later
				%beg	Csid_parse ^in(ent_credit_set.cdt_typ.cdt_id)
									csid_orig_iban_ws,"/",^str,/;
				%end
				If Failure_is in Csid_parse_status
				Then
					%beg csid_orig_iban_ws = ent_credit_set.cdt_typ.cdt_id; %end
				end-if
				%^ Now we must perform IBAN specific Pushdown
				Perform D790_CDT_IBAN thru
					D790_CDT_IBAN_END
				%^	Set CDT_IS in csid_Iban_party_ws to True
				%^	Perform C680_IBAN_DETECTED Thru
				%^	C680_IBAN_DETECTED_END
			When Failure_warning_is in csid_val_iban_ret
				%^ Fail/Pass
				%^ Since this is the Credit Party, ask for a country if not present
				Evaluate Csid_valid_iban_flg_ws
				   When "I"	%^ Bad IBAN
	    					%Beg
	    					screen_field_ws = "credit.cdt_typ.cdt_id";
           					error_mnemonic_ws = "LKUP$_IBAN_FAILURE_W";
	    					%End
	    					call "FTRSCR_WRITE_ERROR" using
	    					  by reference screen_field_ws
	    					  by reference error_mnemonic_ws
				   When "N"	%^ Bad BBAN
	    					%Beg
	    					screen_field_ws = "credit.cdt_typ.cdt_id";
           					error_mnemonic_ws = "LKUP$_BBAN_FAILURE_W";
	    					%End
	    					call "FTRSCR_WRITE_ERROR" using
	    					  by reference screen_field_ws
	    					  by reference error_mnemonic_ws
				   When "R"	%^ Iban Required
	    					%Beg
	    					screen_field_ws = "credit.cdt_typ.cdt_id";
           					error_mnemonic_ws = "IVAL$_IBAN_REQ_W";
	    					%End
	    					call "FTRSCR_WRITE_ERROR" using
	    					  by reference screen_field_ws
	    					  by reference error_mnemonic_ws
				end-evaluate
				If Success_is in csid_bban_cntry_req_ws And
				   Csid_valid_iban_flg_ws = "N" And   %^ ensure not an IBAN
				   bnp_mailing_country of Ent_credit_set = Spaces
				Then
 	    			   %Beg
	 			   screen_field_ws = "credit.bnp_mailing_country";
         			   error_mnemonic_ws = "LKUP$_COUNTRY_REQ";
	    			   %End
	    			   call "FTRSCR_WRITE_ERROR" using
	    			     by reference screen_field_ws
	    			     by reference error_mnemonic_ws
				   Add 1 to Csid_bogus_parties
				   Add 1 to Cdt_errmemo_count_ls
				   Set Failure_is in Creditside_screen_ls to TRUE
				End-if
				move spaces to csid_iban_cntry_ws
				%^ Continue %^ next if will take us out Not valid for
				%^ Credit party
			When Failure_ignore_is in csid_val_iban_ret
				%^ TEMP treat as Pass/Fail
				If Success_is in csid_bban_cntry_req_ws And
				   Csid_valid_iban_flg_ws = "N" And   %^ ensure not an IBAN
				   bnp_mailing_country of Ent_credit_set = Spaces
				Then
	    			   %Beg
	 			   screen_field_ws = "credit.bnp_mailing_country";
         			   error_mnemonic_ws = "LKUP$_COUNTRY_REQ";
	    			   %End
	    			   call "FTRSCR_WRITE_ERROR" using
	    			     by reference screen_field_ws
	    			     by reference error_mnemonic_ws
				   Add 1 to Csid_bogus_parties
				   Add 1 to Cdt_errmemo_count_ls
				   Set Failure_is in Creditside_screen_ls to TRUE
				End-if
				    Evaluate Csid_valid_iban_flg_ws
					When "I"	%^ Bad IBAN
 	    			   		%Beg
	 			   		screen_field_ws = "credit.cdt_typ.cdt_id";
         			   		error_mnemonic_ws = "LKUP$_IBAN_FAILURE_I";
	    			   		%End
	    			   		call "FTRSCR_WRITE_ERROR" using
	    			   	 	  by reference screen_field_ws
	    			   		  by reference error_mnemonic_ws
					When "N"	%^ Bad BBAN
 	    			   		%Beg
	 			   		screen_field_ws = "credit.cdt_typ.cdt_id";
         			   		error_mnemonic_ws = "LKUP$_BBAN_FAILURE_I";
	    			   		%End
	    			   		call "FTRSCR_WRITE_ERROR" using
	    			   		  by reference screen_field_ws
	    			   		  by reference error_mnemonic_ws
					When "R"	%^ Iban Required
	    			   		%Beg
	 			   		screen_field_ws = "credit.cdt_typ.cdt_id";
         			   		error_mnemonic_ws = "IVAL$_IBAN_REQ_I";
	    			   		%End
	    			   		call "FTRSCR_WRITE_ERROR" using
	    			   		  by reference screen_field_ws
	    			   		  by reference error_mnemonic_ws
				    end-evaluate
				move spaces to csid_iban_cntry_ws
			When Other
				%^ TEMP treat as Pass/Fail
				If Success_is in csid_bban_cntry_req_ws And
				   Csid_valid_iban_flg_ws = "N" And   %^ ensure not an IBAN
				   bnp_mailing_country of Ent_credit_set = Spaces
				Then
 	    			   %Beg
	 			   screen_field_ws = "credit.bnp_mailing_country";
         			   error_mnemonic_ws = "LKUP$_COUNTRY_REQ";
	    			   %End
	    			   call "FTRSCR_WRITE_ERROR" using
	    			     by reference screen_field_ws
	    			     by reference error_mnemonic_ws
				   Add 1 to Csid_bogus_parties
				   Add 1 to Cdt_errmemo_count_ls
				   Set Failure_is in Creditside_screen_ls to TRUE
				End-if
				move spaces to csid_iban_cntry_ws
		End-evaluate
		If Success_is in Csid_iban_expanded THen
			Set Cdt_map in Cdt_screen_state to True
			Go to B280_CDT_PARTY_END
		end-if
		%^ Drop thru for complete processing.
		
	END-IF.

* no lookup if no id type
	If (Cdt_idtype of Cdt_typ of Ent_credit_set = SPACE )
	   OR ( (Cdt_idtype of Cdt_typ of Ent_credit_set = "N" OR "@")
	   AND (Cdt_id of Cdt_typ of Ent_credit_set = SPACES) )
	THEN
%^ Nothing to look up.
	    If (Cdt_ovr of cdt_typ of Ent_credit_set NOT = "*") 
	    THEN
		%Beg
		Ent_credit_set.cdt_typ.cdt_ovr = "*";
		%End
	    END-IF
	    If (Cdt_adr_bnk_id of Ent_credit_set NOT = 
					      Bank of Loc_info of Ent_ftr_set )	
	        %Beg
	        Ent_credit_set.Cdt_adr_bnk_id = Ent_ftr_set.loc_info.bank ;
	        %End
	    END-IF
	    If (Cdt_rel_id of Ent_credit_set NOT = ZERO )
                %Beg
                    Ent_credit_set( .Cdt_shnam  = NULL,
				    .flgs3.cdt_adr_ptr_ok = NULL);
	                BREAK: Relget_adr_set;
       		        BREAK: Ent_c_adr_set;
		%end
		If cdt_name1 of Ent_credit_set = Cdt_name1 of Change_credit_set Then
		    %^ Only clear Name/address when same as change, this could be a 107305
		    %^ change from Onfile to CHK/NOF, need to leave the entered info
		    %Beg
       	                Ent_credit_set(.Cdt_name1  = NULL ,
       	                               .Cdt_name2  = NULL ,
       	                               .Cdt_name3  = NULL ,
       	                               .Cdt_name4  = NULL ) ;
       		    %End
		end-if
                %^ Clear all the other stuff left over from previous
                %^   on-file address
	        Add 1 to Csid_this_deletes
		If (Csid_this_deletes > Csid_loop_limit ) 
%^ Do nothing for now
		    Add 1 to Csid_this_more
		END-IF
                Call "ACCTSUB_CDT_NOF"
                MOVE "N" to Cdt_comm_charge_ws
                MOVE "N" to Cdt_cbl_charge_ws
	    END-IF
	    PERFORM D700_NOF_CDT_BANK thru D700_NOF_CDT_BANK_END
 	    Perform X930_CHANGE_CREDIT thru		%^ clear the leftovers
			X930_CHANGE_CREDIT_END
 	    Go to B280_CDT_PARTY_END
	END-IF.

* Set bank preference if there is one.
* Note that for FED payments, (that is, for Cdt_idtype = "A"),
* tran type "BPF" will bypass the preferred FED pay bank.
	MOVE SPACES to Csid_preferred_bank.
	Evaluate True
		When    (Cdt_idtype of Cdt_typ of Ent_credit_set = "A" ) AND
			(Tran_type of Typ of Ent_ftr_set not = "BPF")    AND
			(Preferred_fed_bnk_id of Menu_bnk_union not = SPACES )
			   If Failure_is in Fed_xbank_nopref_flg
			   Then
				    MOVE Preferred_fed_bnk_id of Menu_bnk_union to Csid_preferred_bank
			   End-if
		When   ((Cdt_idtype of Cdt_typ of Ent_credit_set = "P" ) OR
			 (Cdt_idtype of Cdt_typ of Ent_credit_set = "C")) AND %^ Also use for UID's
			(Preferred_chp_bnk_id of Menu_bnk_union not = SPACES )
			    MOVE Preferred_chp_bnk_id of Menu_bnk_union to Csid_preferred_bank
	end-evaluate.

	If (Csid_preferred_bank NOT = SPACES )
	   AND ( (Cdt_id of Cdt_typ of Ent_credit_set(1:3) NOT = 
							Csid_preferred_bank )
	   OR (Cdt_id of Cdt_typ of Ent_credit_set(4:1) NOT = ":" ) )
	THEN
	    %Beg
	    Csid_parse ^IN(Ent_credit_set.Cdt_typ.Cdt_id),
		 ^OPTION(^STRING<3>,":"), Csid_temp1_vstr, ^SPACE, /;
	    Csid_Compose ^OUT(Ent_credit_set.Cdt_typ.Cdt_id),
		 Csid_preferred_bank, ":", Csid_temp1_vstr, /;
	    %End
	END-IF.
	MOVE SPACES to Csid_id_ws.
	%Beg
	Csid_parse ^IN(Ent_credit_set.Cdt_typ.Cdt_id ) ^SPACE, 
			Csid_id_ws, ^SPACE, / ;
	%End.

	If (Cdt_idtype of Cdt_typ of Ent_credit_set = "P" )
	   AND (Cdt_adv_typ of Ent_credit_set NOT = SPACES )
	   AND (Cdt_adv_flg of Flgs of Ent_ftr_set = "Y" )
	THEN
	    %^ Check to see if this a "P" equivalent advice type
%^
%^
%^OBSELETE hold off and see what need to be here
%^
%^	Call "GET_PID_ADV_DATA" using

	    IF Success_is in Csid_itsa_clearhouse
	       AND (Csid_clrhs_suffix_length NOT = 0 )
	    THEN
		%Beg
		Csid_temp1_vstr = NULL ;
		Csid_temp2_vstr = NULL ;
		Csid_temp3_vstr = NULL ;
		Csid_parse ^IN(Ent_credit_set.Cdt_typ.Cdt_id)
			^OPTION(Csid_temp1_vstr(^STRING<3>), ":" ),
			Csid_temp2_vstr, ^OPTION("/", Csid_temp3_vstr),
			^SPACE, / ;
		%End
		Subtract Csid_clrhs_suffix_length from Csid_temp2_vstr_length
			giving Csid_suffix_index
		Subtract 1 from Csid_suffix_index
%^ Check to see if suffix is already on P id; if not, and P id is numeric,
%^	assume we have a naked P_id and append the suffix.
		If (Csid_temp2_vstr(Csid_suffix_index:Csid_clrhs_suffix_length)
			   NOT = Csid_clrhs_suffix(1:Csid_clrhs_suffix_length ))
		   AND (Csid_temp2_vstr(1:Csid_temp2_vstr_length) is NUMERIC )
		THEN
		    If (Csid_temp1_vstr_length NOT = 0 )
		        %Beg
		        Csid_clip_compose ^OUT(Csid_id_ws)
				Csid_temp1_vstr, ":", Csid_temp2_vstr,
				Csid_clrhs_suffix ;  %End
		    ELSE	
		        %Beg
		        Csid_clip_compose ^OUT(Csid_id_ws)
				Csid_temp2_vstr, Csid_clrhs_suffix ;  %End
		    END-IF
		    IF (Csid_temp3_vstr_length NOT = 0 )
			%Beg
			Csid_clip_compose  "/", Csid_temp3_vstr, / ;  %End
		    ELSE
			%Beg
			Csid_clip_compose  / ;  %End
		    END-IF
		    %Beg
		    Ent_credit_set.Cdt_typ.Cdt_id = Csid_id_ws; %End
		END-IF
	    END-IF
	END-IF.

%^ Perform the credit party lookup.
	Set CDT in Relget_title_flag to TRUE.
        Move Spaces to Csid_lkup_pend_del
	%Beg  Csid_next_function = Menu_next_function;  %End.
	Call "REL_GET" USING 
	    By reference Cdt_idtype of Cdt_typ of Ent_credit_set
	    By reference Csid_id_ws
	    By reference Csid_id_ws_length
	    by reference Csid_lkup_pend_del
	  RETURNING Csid_ret_stat.

	%^ Results checked back in caller

B280_CDT_PARTY_END.
	EXIT.

B280_CDT_INDEX_CONN2.
%^
%^ Re-enter here after return from ambiguous screen and 
%^ Connect the indices required.  
%^
	Call "RELGET_CONNECT" USING 
	    by reference Csid_lkup_pend_del
	  RETURNING Csid_ret_stat.

	Set CDT_Pty_map in Cdt_screen_state to True.

B280_CDT_INDEX_CONN2_END.
	EXIT.

B280_CDT_PTY_MAP.

	If Csid_lkup_pend_del = "T"
	Then
 	    %Beg
	    screen_field_ws = "credit.cdt_typ.cdt_id";
            error_mnemonic_ws = "VMSG$_ADR_PEND_DEL";
	    %End
	    call "FTRSCR_WRITE_ERROR" using
	      by reference screen_field_ws
	      by reference error_mnemonic_ws
            Add 1 to Cdt_errmemo_count_ls
	    Set Success_is in Csid_credit_pend_del to TRUE
	    Set Failure_is in Creditside_screen_ls to TRUE
        End-if

        If (PD_enqueue_to_server of Menu_cfg = "T")
	   AND (Relget_msgcode = Vmsg_lookup_fail_wc)
	   AND (Cdt_ovr of Cdt_typ of Ent_credit_set NOT = "*")
	THEN
%^ We have an ambiguous address - write memo and let calling routine
%^  route message.
            %Beg
            Csid_compose ^OUT(Csid_info_memo)
                "Ambiguous Address for Account: ",
		 Ent_Credit_Set.Cdt_Typ.Cdt_Idtype, "/",
                 Ent_Credit_Set.Cdt_Typ.Cdt_Id, / ;
            %End
            Move ZERO to Cdt_not_suspect_ls
            Perform X920_INFO_MEMO through X920_INFO_MEMO_END
        End-if

%^ Assume that there is no preferred correspondent (implied or otherwise).
	Move SPACES to Csid_pref_corr_rec.

* Move RELGET's returned id into a vstr for checking.
	If (Relget_return_key NOT = SPACES )
	    %Beg
	    Csid_clip_compose ^OUT(Csid_return_key),
		Relget_return_key, / ;
	    %End
	ELSE
	    %Beg  Csid_return_key = Csid_id_ws ;  %End
	END-IF.

        If (Success_is in Csid_ret_stat   )
            OR (Relget_msgcode = Vmsg_dat_notonfile_wc )
            %Beg  Csid_id_bank_ws = Relget_adr_set.bnk_id ;  %End
            If (Csid_id_bank_ws = SPACES )
                %Beg  Csid_id_bank_ws = Ent_ftr_set.Loc_info.Bank ;  %End
            END-IF
            If (Cdt_adr_bnk_id of Ent_credit_set NOT = Csid_id_bank_ws )
                %Beg  Ent_credit_set.Cdt_adr_bnk_id = Csid_id_bank_ws ;  %End
            END-IF
            If (Relget_return_idtype NOT =
				       Cdt_idtype of Cdt_typ of Ent_credit_set )
               OR ( (Csid_return_key_length NOT = 0 )
                     AND ( (Csid_return_key_length NOT = Csid_id_ws_length)
                            OR (Csid_return_key(1:Csid_id_ws_length) NOT =
                                           Csid_id_ws(1:Csid_id_ws_length) ) ) )
            THEN
* Pick up any changes that Relget made to the idtype or id.
                %Beg
		Ent_credit_set.cdt_typ.Cdt_id = Csid_return_key ;
		Ent_credit_set.cdt_typ.Cdt_idtype = Relget_return_idtype ;
		%End
            END-IF
        ELSE
            If (Cdt_adr_bnk_id of Ent_credit_set not =
						Bank of Loc_info of Ent_ftr_set)
                %Beg
                Ent_credit_set.Cdt_adr_bnk_id = Ent_ftr_set.Loc_info.Bank ;
                %End
            END-IF

%^ Operator bailed out.
	    If (Relget_msgcode = Spaces )
		Set Failure_is in Creditside_screen_ls to TRUE
	    END-IF
        END-IF.

	If (Failure_is in Csid_ret_stat   )
	    Perform C600_CREDIT_FAIL through C600_CREDIT_FAIL_end
	ELSE
	    If (Cdt_ovr of Cdt_typ of Ent_credit_set NOT = SPACE )
		%Beg  Ent_credit_set.cdt_typ.cdt_ovr = " " ;  %End
	    END-IF
        END-IF.
	%Beg  
	BREAK: Csid_adr_set ;
	BREAK: Ent_c_adr_set;
	%End.
	IF (Cdt_ovr of Cdt_typ of Ent_credit_set = SPACE ) Or
	   (Relget_msgcode = Vmsg_dat_notonfile_wc ) Then %^AUX CONNECTION REL_id
							 %^ Should be 0
	    %Beg
	    BREAK: Csid_adr_set;
	    Relget_adr_set EQUATE: Csid_adr_set(NOMOD) ;  
	    Relget_adr_set EQUATE: Ent_c_adr_set(NOMOD) ;
            Ent_credit_set( .Cdt_rel_id = Ent_c_adr_set.Rel_id,
                            .Cdt_adr_set_ptr POINT: Ent_c_adr_set,
			    .flgs3.cdt_adr_ptr_ok = "T");
	    %End
	    If swf_subtype of relget_adr_set  = "BEID" or "CORP" or "MCCO" or "SMDP" or "TESP" or "TRCO"
	    Then
		%beg  ent_credit_set.cdt_bei_flag = "Y"; %end
	    else
		%beg  ent_credit_set.cdt_bei_flag = Null; %end
	    end-if
	END-IF.

	If Credit_changed_ls = 1  Then
		%^ Only hit when actual change has taken place.
		%^ Skip for First_time an Autotreive values. 109297
		Perform X930_CHANGE_CREDIT thru
			X930_CHANGE_CREDIT_END
	end-if.

B280_CDT_PTY_MAP_END.
   EXIT.


B320_SET_ADDRESS.
* Sets actual rel address linkages in Message's credit party.

        Move Priority_flg of Ent_ftr_set to Csid_hold_priority_ws
	Call "SET_CREDIT_ADDRESS" USING
	    By Reference Is_rptv_lookup_ls
	  RETURNING Csid_ret_stat.

        If Priority_flg of Ent_ftr_set not = Csid_hold_priority_ws
            %Beg
            Csid_compose ^OUT(Csid_info_memo)
                 "Priority set to ", Ent_ftr_set.flgs.priority_flg,
                 " by credit party ",
		 Ent_credit_set.cdt_typ(.cdt_idtype,"/",.cdt_id) , / ;
            %End
            Perform X920_INFO_MEMO thru X920_INFO_MEMO_END
        End-if.

*  Hook up account sequence - we will need it.
	%Beg
        BREAK: Csid_acc_seq ;
	Ent_c_adr_set.account_seq CONN: Csid_acc_seq (NOMOD) ;
	%End

* Completed address setup.
	Set Success_is in Csid_set_address to TRUE.

	Call "GET_PID_ADV_SUFFIX" Using
	   by reference Cdt_adr_bnk_id of Ent_credit_set
           by reference Cdt_adv_typ of Ent_credit_set
	   by reference Csid_clrhs_suffix
	   by reference Csid_clrhs_suffix_length
         Returning Csid_itsa_clearhouse.
	If (Success_is in Csid_itsa_clearhouse)
	   AND (Cdt_adv_typ of Ent_credit_set = "CHP")
	   AND (Do_chips_qualif_ls NOT = 0 )
	   AND (Cdt_idtype of Cdt_typ of Ent_credit_set NOT = "P" )
	THEN
%^ Must change credit party to Chips participant so we can do qualification.
	    Set Failure_is in Csid_found_it to TRUE
	    %Beg  FIRST: Csid_acc_seq;  %End
	    PERFORM UNTIL (Success_is in Csid_found_it)
			  OR (Failure_is in Csid_acc_seq_status)
		If (Idtype of Rel_name_key of Csid_acc_seq = "P" )
		   AND (Idbank of Rel_name_key of Csid_acc_seq =
					       Cdt_adr_bnk_id of Ent_credit_set)
		THEN
		    If (Csid_clrhs_suffix_length NOT = 0 )
			%Beg
			Csid_clip_compose ^OUT(Csid_clrhs_pid_id)
				Csid_acc_seq.Rel_name_key.Idkey.Idacc, / ;
			%End
			Subtract Csid_clrhs_suffix_length from
				Csid_clrhs_pid_id_length giving
							   Csid_suffix_index
			Add 1 to Csid_suffix_index
			If
		   Csid_clrhs_pid_id(Csid_suffix_index:Csid_clrhs_suffix_length)
			         = Csid_clrhs_suffix(1:Csid_clrhs_suffix_length)
			THEN
			    Set Success_is in Csid_found_it to TRUE
			END-IF
		    END-IF
		ELSE
		    Set Success_is in Csid_found_it to TRUE
		END-IF
		If (Failure_is in Csid_found_it )
		    %Beg  NEXT: Csid_acc_seq;  %End
		END-IF
	    END-PERFORM
	    If (Success_is in Csid_acc_seq_status   )
	        %Beg
		Ent_credit_set.Cdt_typ.Cdt_idtype = "P" ;
		Ent_credit_set.Cdt_typ.Cdt_id =
					  Csid_acctyp_seq.Rel_name_key.Idkey ;
		%End	   	    	    
	    END-IF
	END-IF.


	%beg csid_upd_level cdt_party_is; %end
	Call "PRULE_UPDATE_PARTY" Using
		By Reference csid_upd_level
		By Reference csid_pr_memo
		by reference csid_pr_memo_length
	returning csid_ret_stat.

B320_SET_ADDRESS_END.


   EXIT.
B340_GET_ACCOUNT_SET.
%^  Calls REL_ACCOUNT_FROM_ADR to get an account from the current address.
%^  Ent_c_adr_set must be connected.  
        %^ Check to see if this a "P" advice type
%^	Move Cdt_acc_type_ls to Csid_idtype_ws
%^	Call "GET_PID_ADV_SUFFIX" Using
%^	   by reference Cdt_adr_bnk_id of Ent_credit_set
%^         by reference Cdt_adv_typ of Ent_credit_set
%^	   by reference Csid_clrhs_suffix
%^	   by reference Csid_clrhs_suffix_length
%^        Returning
	Set Failure_is in Csid_itsa_clearhouse to True.	%^ TEMPTEMPTEMP

	%Beg
	BREAK: Ent_c_acc_set ;
	BREAK: Ent_c_acc_rel_reg;
	%End.
	IF (Csid_know_acc_id NOT = SPACES )
	    If (Idbank of Csid_know_acc_id NOT = SPACES )
		AND (Idbank of Csid_know_acc_id NOT = 
					Cdt_adr_bnk_id of Ent_credit_set )
	        AND (Xbank_account_ok_ls = 0 )
	    THEN
%^ Credit party address and account cannot be in different banks.
		Add 1 to Csid_this_deletes
		If (Csid_this_deletes > Csid_loop_limit ) 
%^ Do nothing for now
		    Add 1 to Csid_this_more
		END-IF
		If (Cdt_account of Ent_credit_set NOT = SPACES )
		        %Beg
       		             Ent_credit_set (
       		                 .cdt_account            = NULL,
       		                 .cdt_acc_prod_codes     = NULL,
       		                 .cdt_acc_class          = NULL);
			%end
			If NOT(Informational in Sec_flg of Cdt_acc_2 of Ent_credit_set)
	 	 	 and Not(Pre_done in Dda_balance of Ent_debit_set)  %^ CR7181 don't clear if preadvise
			Then   %^ Not account related, pass along the fee info 132692
			    %Beg
               			Ent_credit_set.cdt_acc_2
			  		(.Sec_amt = <0>,
			   		 .Sec_cur = NULL,
			   		 .Sec_acc = Null);
			    %End
			    Set Null_flg in Sec_flg of Cdt_acc_2 of Ent_credit_set to true
			End-if
			If Not(MT103_Charges in ter_flg of cdt_acc_3 of Ent_credit_set)
	 	 	 and Not(Pre_done in Dda_balance of Ent_debit_set)  %^ CR7181 don't clear if preadvise
			Then
				Set Null_flg in Ter_flg of Cdt_acc_3 of Ent_credit_set to true
				%beg
					ent_credit_set.cdt_acc_3
						    	(.Ter_amt = <0>,
							 .Ter_cur= NULL,
							 .Ter_acc = Null);
				%end
			End-if
		END-IF
		If (Cdt_hold_flg of Flgs of Ent_credit_set NOT = SPACE )
		    %Beg  Ent_credit_set.flgs.cdt_hold_flg = NULL ;  %End
		END-IF
 	    	%Beg
		    	screen_field_ws = "credit.cdt_typ.cdt_idtype";
       		     	error_mnemonic_ws = "VMSG$_NOSUCHACC";
			BREAK: Ent_c_acc_set;
			BREAK: Ent_c_acc_rel_reg;
	    	%End
	    	call "FTRSCR_WRITE_ERROR" using
	    	  by reference screen_field_ws
	    	  by reference error_mnemonic_ws
		Set Failure_is in Creditside_screen_ls to true
		Add 1 to Cdt_errmemo_count_ls
                GO TO B340_GET_ACCOUNT_SET_END
	    END-IF
	    Move 4 to Csid_account_mode
            %Beg
	    Csid_parse ^IN(Csid_know_acc_id.idkey)
		^SPACE, Csid_acc_id_arg, ^SPACE, / ;
	    %End				    
	ELSE
	    %ACE_IS Ent_c_adr_set connected giving Csid_conn_stat;
	    %Beg  BREAK: Relget_adr_set ;  %End
	    If (Failure_is in Csid_conn_stat)
	       OR (Rel_id of Ent_c_adr_set = 0 )
	    THEN
%^ We have a NOF credit party.
		Add 1 to Csid_this_deletes
		If (Csid_this_deletes > Csid_loop_limit ) 
%^ Do nothing for now
		    Add 1 to Csid_this_more
		END-IF
		If (Cdt_account of Ent_credit_set NOT = SPACES )
		        %Beg
       		             Ent_credit_set (
       		                 .cdt_account            = NULL,
       		                 .cdt_acc_prod_codes     = NULL,
       		                 .cdt_acc_class          = NULL);
			%end
			If NOT(Informational in Sec_flg of Cdt_acc_2 of Ent_credit_set)
	 	 	 and Not(Pre_done in Dda_balance of Ent_debit_set)  %^ CR7181 don't clear if preadvise
			Then   %^ Not account related, pass along the fee info 132692
			    %Beg
               			Ent_credit_set.cdt_acc_2
			  		(.Sec_amt = <0>,
			   		 .Sec_cur = NULL,
			   		 .Sec_acc = Null);
			    %End
			    Set Null_flg in Sec_flg of Cdt_acc_2 of Ent_credit_set to true
			End-if
			If Not(MT103_Charges in ter_flg of cdt_acc_3 of Ent_credit_set)
	 	 	 and Not(Pre_done in Dda_balance of Ent_debit_set)  %^ CR7181 don't clear if preadvise
			Then
				Set Null_flg in Ter_flg of Cdt_acc_3 of Ent_credit_set to true
				%beg
					ent_credit_set.cdt_acc_3
						    	(.Ter_amt = <0>,
							 .Ter_cur= NULL,
							 .Ter_acc = Null);
				%end
			End-if
		END-IF
		If (Cdt_hold_flg of Flgs of Ent_credit_set NOT = SPACE )
		    %Beg  Ent_credit_set.flgs.cdt_hold_flg = NULL ;  %End
		END-IF
		%Beg
			BREAK: Ent_c_acc_set; 
			BREAK: Ent_c_acc_rel_reg;
		%End
		Set Failure_is in Csid_ret_stat to True
	        GO TO B340_GET_ACCOUNT_SET_END
	    END-IF
	    %Beg
	    Ent_c_adr_set EQUATE: Relget_adr_set(NOMOD) ;
	    Csid_know_acc_id = NULL ;
	    Csid_acc_id_arg = NULL ;
	    %End

	    If (Cdt_idtype of Cdt_typ of Ent_credit_set = 
					"D" OR "V" OR "G" OR "F" ) %^ Or "P" 
	    THEN
		%Beg
		Csid_parse ^IN(Ent_credit_set.Cdt_typ.Cdt_id )
				^SPACE, Csid_acc_id_arg, ^SPACE, / ;
		Csid_know_acc_id.Idtype = Ent_credit_set.cdt_typ.cdt_idtype ;
	    	%End
		If (SUCCESS_IS in Csid_parse_status )
		  AND (Csid_acc_id_arg_length NOT = 0 )
		  AND (Csid_acc_id_arg NOT = SPACES )
		THEN
		    Move 3 to Csid_account_mode
		ELSE
		    Move 0 to Csid_account_mode
		    If (Cdt_acc_type_ls = SPACE)
			%Beg
			Csid_idtype_ws = Ent_credit_set.cdt_typ.Cdt_idtype; %End
		    ELSE
			Move Cdt_acc_type_ls to Csid_idtype_ws
		    END-IF
		END-IF
	    ELSE
	        If Cdt_acc_type_ls NOT = SPACE
	            Move 0 to Csid_account_mode
		    Move Cdt_acc_type_ls to Csid_idtype_ws
	        ELSE
	           If Success_is in Csid_itsa_clearhouse
	                Move 0 to Csid_account_mode
		        Move "P" to Csid_idtype_ws
		        Move Cdt_adv_typ of Ent_credit_set to Relget_adv_type
	  	   Else
		        Move 5 to Csid_account_mode
			Move SPACE to Csid_idtype_ws
		   END-IF
		END-IF
	    END-IF
	    If (Csid_acc_id_arg_length NOT = 0 )
	       AND (Csid_acc_id_arg(1:Csid_acc_id_arg_length) = SPACES )
	    THEN
%^ Compensate for compose peculiarity
		%Beg  Csid_acc_id_arg = NULL;  %End
	    END-IF
	END-IF.

	%Beg  Csid_ent_acc_conn = Ent_acc_set State.CONN ;  %End.
	If (Csid_ent_acc_conn NOT = 0 )
	    %Beg
	    BREAK: Csid_acc_set ;
	    Ent_acc_set EQUATE: Csid_acc_set(NOMOD) ;
	    BREAK: Ent_acc_set ;
	    %End
	END-IF.

	%^ Clear out the error message if we're about to try again
	%^ For the IF statement below, first get the .MSG field of ftrscr.credit.cdt_typ.cdt_idtype.
	%Beg
		Screen_field_ws = "credit.cdt_typ.cdt_idtype";
	%End.
	Call "FTRSCR_GET_FLDMSG" Using
          By Reference screen_field_ws    	%^ In
          By Reference csid_temp1_vstr 		%^ Out
          By Reference csid_temp1_vstr_length.	%^ Out

        If Csid_temp1_vstr not = SPACES
	Then
	     %Beg
		     screen_field_ws = "credit.cdt_typ.cdt_idtype";
		     error_mnemonic_ws = "";
	     %End
	     Call "FTRSCR_WRITE_ERROR" using
	       by reference screen_field_ws
	       by reference error_mnemonic_ws
	END-IF.
        Set Failure_is in Csid_ret_stat to true.

%^
%^ We already have an Accounting ID, go get it
%^
	If (Cdt_idtype of Cdt_typ of Ent_credit_set = "D" OR "V" OR "G") %^ OR "P")
	    Move SPACES to Csid_currency_ws
	    PERFORM B350_LOOKUP_ACCOUNT through B350_LOOKUP_ACCOUNT_END
	    GO TO B340_GET_ACCOUNT_SET_END
	END-IF.



	If (FX_ENA of Menu_cfg = LOW-VALUES )
	Then

		If (Credit_currency_ls NOT = SPACES )
		    Move Credit_currency_ls to Csid_currency_ws
		    PERFORM B350_LOOKUP_ACCOUNT through B350_LOOKUP_ACCOUNT_END
		    Go to B340_GET_ACCOUNT_SET_END
		END-IF

		If (Message_currency_ls = SPACES) 
			Move SPACES to Csid_currency_ws
			PERFORM B350_LOOKUP_ACCOUNT through B350_LOOKUP_ACCOUNT_END
		    	GO TO B340_GET_ACCOUNT_SET_END
		END-IF
		If (Dbt_idtype of Dbt_typ of Ent_debit_set = 
						      "D" OR "V" OR "G" OR "P")
			Move Message_currency_ls to Csid_currency_ws
			PERFORM B350_LOOKUP_ACCOUNT through B350_LOOKUP_ACCOUNT_END
	        	GO TO B340_GET_ACCOUNT_SET_END
	        END-IF

		If (Dbt_idtype of Dbt_typ of Ent_debit_set = "F" )
	    	Then
			If (Idbank of Rel_name_key of Csid_acctyp_seq = 
						    Bnk_id of Menu_bnk_union )
			    	Move Base_currency_id of Menu_bnk_union to Csid_currency_ws
			ELSE
		    		If (Idbank of Rel_name_key of Csid_acctyp_seq = 
							Csid_acc_bank_ws )
					%^ Note caching here to try to cut down on lookups.
       		 	        	Move Csid_bank_curr_ws to Csid_currency_ws
		 		ELSE
				%^  Rats.  We have to look up the bank.
					%Beg
						BREAK: Csid_bnk_union ;
							SEARCH: Bnk_index 
						    (Key = Csid_acctyp_seq.Rel_name_key.Idbank ) ;
					%End
					If Failure_is in Bnk_index_status  
                	    			Move SPACES to Csid_bank_curr_ws, Csid_currency_ws
					ELSE
			    			%Beg  Bnk_index CONN: Csid_bnk_union (NOMOD) ;  %End
			    			Move Bnk_Id of Csid_bnk_union to Csid_acc_bank_ws
			    			Move Base_currency_id of Csid_bnk_union to 
						     Csid_bank_curr_ws, Csid_currency_ws
					END-IF
		    		END-IF
			END-IF
	    	ELSE
			Move SPACES to Csid_currency_ws
	    	END-IF

		PERFORM B350_LOOKUP_ACCOUNT through B350_LOOKUP_ACCOUNT_END
	    	GO TO B340_GET_ACCOUNT_SET_END
	ELSE

%^ Cross_currency environment
%^ First try a search with the message currency and see if that works.
	    Move Relget_adv_type to Csid_save_adv_type
	    If Credit_currency_ls NOT = SPACES Then
		Move Credit_currency_ls to Csid_currency_arg
	    Else
		Move Message_currency_ls to Csid_currency_arg
	    End-if

	   If Csid_currency_arg NOT = Spaces
	   Then	%^ Is we have a currency, else skip right to  Mode 5
		    %^
		    %^ This branch for Non-Account Idtype. Try to force F first
		    %^ According to theory, we should try for an account in this
		    %^ Order -
		    %^		Mode 2  blank 	 Curr	Try for Default In curr
		    %^	        Mode 0	Idtype F Curr	Try for Nostro
		    %^		Mode 5  Get whatever
		    %^
		    %^ First Default in Currency
		    %^
		    Move Spaces to csid_idtype_ws
		    Move 2 to Csid_account_mode
		    Set CDT in Relget_title_flag to TRUE
		    Call "REL_ACC_FROM_ADR" USING
       	       		By reference Csid_account_mode
       	       		By reference Csid_idtype_ws
       	         	By reference Csid_currency_arg
       	         	By reference Idtype of Csid_know_acc_id
       	         	By reference Csid_acc_id_arg
       	         	By reference Csid_acc_id_arg_length
       	        		By reference Bnk_id of Ent_c_adr_set
       		     RETURNING Csid_ret_stat
		    %^
		    If ( Relget_reject_flag = "M") Or				%^
		       ( Csid_next_function not = Menu_next_function ) Or	%^ Three user initiated exits.
		       ( Relget_msgcode = "VMSG$_MISSINGDAT" )			%^
			       Or
			(Success_is in Csid_ret_stat)				%^ We found one
		       Or
			( Success_is in Relget_ambiguous_wf )			%^ We need a screen to disambiguate
		    Then
			%^ Exit, Caller will handle results. 
			Go to B340_GET_ACCOUNT_SET_END
		    End-if
		    %^
		    %^ Nostro match, In Currency
		    %^
		    %^   If csid_acc_id_arg = Spaces Then
		    Move  0  to csid_account_mode
		    If Csid_irr_acc_type_ws = Spaces
		    Then
			    Move "F" to csid_idtype_ws
		    Else
			    Move Csid_irr_acc_type_ws to csid_idtype_ws
		    End-if
		    %^
		    Set CDT in Relget_title_flag to TRUE
		    Call "REL_ACC_FROM_ADR" USING
       	    		By reference Csid_account_mode
       	      		By reference Csid_idtype_ws
       	         	By reference Csid_currency_arg
       	         	By reference Idtype of Csid_know_acc_id
       	         	By reference Csid_acc_id_arg
                	By reference Csid_acc_id_arg_length
               		By reference Bnk_id of Ent_c_adr_set
       		     RETURNING Csid_ret_stat

		    If ( Relget_reject_flag = "M") Or				%^
		       ( Csid_next_function not = Menu_next_function ) Or	%^ Three user initiated exits.
	      	       ( Relget_msgcode = "VMSG$_MISSINGDAT" )			%^
	       		or
			(Success_is in Csid_ret_stat)				%^ We found one
		       Or
			( Success_is in Relget_ambiguous_wf )			%^ We need a screen to disambiguate
		    Then
			%^ Exit, Caller will handle results. 
			Go to B340_GET_ACCOUNT_SET_END
		    End-if
		    %^
	    	    %^ Try for Anything in Currency
	    	    %^
	    	    Move 5  to csid_account_mode
		    Move Spaces to csid_idtype_ws
		    %^ 
		    %^
		    Set CDT in Relget_title_flag to TRUE
		    Call "REL_ACC_FROM_ADR" USING
       		    		By reference Csid_account_mode
       		      		By reference Csid_idtype_ws
       		         	By reference Csid_currency_arg
       		         	By reference Idtype of Csid_know_acc_id
       		         	By reference Csid_acc_id_arg
               		 	By reference Csid_acc_id_arg_length
               			By reference Bnk_id of Ent_c_adr_set
           	 	RETURNING Csid_ret_stat

		    If ( Relget_reject_flag = "M") Or				%^
		       ( Csid_next_function not = Menu_next_function ) Or	%^ Three user initiated exits.
		       ( Relget_msgcode = "VMSG$_MISSINGDAT" )			%^
		       Or
			(Success_is in Csid_ret_stat)				%^ We found one
		       Or
			( Success_is in Relget_ambiguous_wf )			%^ We need a screen to disambiguate
		    Then
			%^ Exit, Caller will handle results. 
			Go to B340_GET_ACCOUNT_SET_END
		    End-if

		    %^ No such account, so just try normal defaulting.
		    Move 5 to csid_account_mode
		    Move Csid_save_adv_type to Relget_adv_type
		    Move SPACES to Csid_currency_ws
	END-IF.	    

	Perform B350_LOOKUP_ACCOUNT through B350_LOOKUP_ACCOUNT_END.

B340_GET_ACCOUNT_SET_END.
   EXIT.


B340_GET_ACCT_SET_CLNUP.
	If (Success_is in Csid_ret_stat   )
	    If (Relget_return_bank NOT = SPACES )
		AND (Relget_return_bank NOT = 
					Cdt_adr_bnk_id of Ent_credit_set )
	        AND (Xbank_account_ok_ls = 0 )
	    THEN
%^ Credit party address and account cannot be in different banks.
		Add 1 to Csid_this_deletes
		If (Csid_this_deletes > Csid_loop_limit ) 
%^ Do nothing for now
		    Add 1 to Csid_this_more
		END-IF
		If (Cdt_account of Ent_credit_set NOT = SPACES )
	            %Beg
                    Ent_credit_set (
                        .cdt_account            = NULL,
                        .cdt_acc_prod_codes     = NULL,
                        .cdt_acc_class          = NULL ) ;
		    %End
		END-IF
		If (Cdt_hold_flg of Flgs of Ent_credit_set NOT = SPACE )
		    %Beg  Ent_credit_set.flgs.cdt_hold_flg = NULL ;  %End
		END-IF
 	    	%Beg
		    	screen_field_ws = "credit.cdt_typ.cdt_idtype";
       		     	error_mnemonic_ws = "VMSG$_NOSUCHACC";
			BREAK: Ent_c_acc_set;
			BREAK: Ent_c_acc_rel_reg;
	    	%End
	    	call "FTRSCR_WRITE_ERROR" using
	    	  by reference screen_field_ws
	    	  by reference error_mnemonic_ws
		Set Failure_is in Creditside_screen_ls to true
		Add 1 to Cdt_errmemo_count_ls
	        If (Csid_ent_acc_conn NOT = 0 )
		    %Beg
		    BREAK: Ent_acc_set ;
                    Csid_acc_set EQUATE: Ent_acc_set(NOMOD) ;
		    BREAK: Csid_acc_set ;
		    %End
		END-IF
                GO TO B340_GET_ACCT_SET_CLNUP_END
	    END-IF
	    %Beg
	    Ent_acc_set EQUATE: Ent_c_acc_set(NOMOD,
			REG: Ent_c_acc_rel_reg (NOMOD)); 
	    BREAK: Ent_acc_set ;
	    Csid_parse ^IN(Relget_return_key), ^SPACE,
			Ent_credit_set.Cdt_account.Idkey, ^SPACE, / ;
	    Ent_credit_set.Cdt_account (.Idbank = Relget_return_bank,
                                        .Idtype = Relget_return_idtype ) ;
	    %End
	    Move Currency_id of Ent_c_acc_set to Cdt_currency_found_ls
	    If (Cdt_currency_found_ls = SPACES )
	    THEN
	        %Beg
	        BREAK: Csid_bnk_union ;
	        SEARCH: Bnk_index (Key = Ent_credit_set.Cdt_adr_bnk_id ) ;
	        %End
	        If Success_is in Bnk_index_status  
		    %Beg  
		    Bnk_index CONN: Csid_bnk_union(NOMOD) ;
		    %End
		    Move Base_currency_id of Csid_bnk_union to
							Cdt_currency_found_ls
	        END-IF
	    END-IF
	ELSE
	    Add 1 to Csid_this_deletes
	    If (Csid_this_deletes > Csid_loop_limit ) 
%^ Do nothing for now
		Add 1 to Csid_this_more
	    END-IF
	    If (Cdt_account of Ent_credit_set NOT = SPACES )
                %Beg
                Ent_credit_set (
                        .cdt_account            = NULL,
                        .cdt_acc_prod_codes     = NULL,
                        .cdt_acc_class          = NULL ) ;
		%End
	    END-IF
	    If (Cdt_hold_flg of Flgs of Ent_credit_set NOT = SPACE )
		%Beg  Ent_credit_set.flgs.cdt_hold_flg = NULL ;  %End
	    END-IF
	    %Beg  BREAK: Ent_c_acc_set; 
		  BREAK: Ent_c_acc_rel_reg;
	    %End
	    If (Success_is in Csid_musthave_acct   )
		Move ZERO to Cdt_account_okay_ls
	    END-IF
	    If (Relget_msgcode NOT = SPACES )
	    Then
 	    	%Beg
		screen_field_ws = "credit.cdt_typ.cdt_idtype";
            	error_mnemonic_ws = Relget_msgcode ;
	    	%End
	    	call "FTRSCR_WRITE_ERROR" using
	    	  by reference screen_field_ws
	    	  by reference error_mnemonic_ws
	    END-IF
	END-IF.
	%Beg  BREAK: Relget_adr_set ;  %End.


B340_GET_ACCT_SET_CLNUP_END.
	EXIT.


B350_LOOKUP_ACCOUNT.	
	If (Csid_account_mode = 3 )
	    Move SPACES to Csid_currency_arg
	ELSE
	    Move Csid_currency_ws to Csid_currency_arg
	END-IF.
	Set CDT in Relget_title_flag to TRUE.
	Call "REL_ACC_FROM_ADR" USING
	    By reference Csid_account_mode
	    By reference Csid_idtype_ws
	    By reference Csid_currency_arg
	    By reference Idtype of Csid_know_acc_id
	    By reference Csid_acc_id_arg
	    By reference Csid_acc_id_arg_length
	    By reference Bnk_id of Ent_c_adr_set
        RETURNING Csid_ret_stat.



B350_LOOKUP_ACCOUNT_END.
    EXIT.

B360_SET_ACCOUNT.
%^ Credit account set has been found and connected to Ent_c_acc_set.
	Call "SET_CREDIT_ACCOUNT" USING
	    By reference Credit_account_ls
	    By reference Is_rptv_lookup_ls
	    By reference Special_fee_key_ls
          RETURNING Csid_ret_stat.

* Completed account setup.
	Set Success_is in Csid_set_account to TRUE.
	Move 1 to Cdt_account_okay_ls.
	Add 1 to Advice_parties_ls.
B360_SET_ACCOUNT_END.


   EXIT.
B400_SET_ADVICE.
* Sets up advice type for new credit party.

	If (Cdt_adv_flg of Ent_ftr_set = "Y" )
	   AND (Cdt_adv_typ of Ent_credit_set = SPACES )
	THEN
	    %Beg  Ent_ftr_set.flgs.Cdt_adv_flg = " " ;  %End
	END-IF.

	If (Csid_ain_advice NOT = SPACES )	
           AND (Csid_opr_advice = SPACES )
	THEN
* Set up AIN override to look to Cdt_adv_lookup routine like operator override.
	    Move Csid_ain_advice to Cdt_adv_typ of Ent_credit_set
	    Move "Y" to Cdt_adv_flg of Ent_ftr_set
	END-IF.

 	%^
 	%^ First time through, this may not be set yet. Tentatively set to allow
 	%^ SI's to be properly evaluated. #75468
 	%^
 	If (Bnp_bnk_flg of Ent_credit_set = SPACE OR "N" )
 	  AND (Bnp_idtype of bnp of ent_credit_set  = "B" OR "A" OR "S" )
 	THEN
             %Beg  Ent_credit_set.Bnp_bnk_flg = "Y";  %End
 	END-IF.

	If Not(Success_is in Csid_chdet_called) Then
		Set Success_is in csid_musthave_acct to True
		Set Failure_is in csid_chan_imposed_acct to True
		Set Success_is in Csid_Chdet_called to True
	        Perform X930_PRECALC_CVD thru X930_PRECALC_CVD_END
		Call "CHANNEL_DETERMINATION" Using By reference Csid_false_ws
						   By Reference Csid_true_ws
						   By Content "   "
						   By Reference csid_chan_acc_ws
						   By Reference csid_chan_acc_ws_lengths
						   By Reference Csid_disable_ain_ws
		returning  Csid_chdet_stat_ws
		If (Failure_is in Csid_chdet_stat_ws ) Then
	                %^ Leave alone, we still want to try
			%^ AIN PROCESSING unless AIN processing
			%^ is disabled - Set Failure_is in Creditside_screen_ls to true
			Set failure_is in Csid_ret_stat to True
			%beg 
			csid_compose ^out(csid_prm_name) "MTS$DISABLE_AIN",/;
		     	csid_prm_values_remain = <0>;
			csid_prm_value = NULL;
			%end
			Set Msg_ml in Csid_pr_level to true
			Call "PRULE_MSG_GET_PARAM_FROM" Using
				by Reference	csid_prm_name
				by Reference 	csid_prm_name_length
				by Reference	csid_pr_msg_side
				by Reference 	csid_pr_level
				by Reference	csid_prm_level
				by Reference 	csid_pr_source
				by reference 	csid_prm_edit_type
				by reference 	csid_prm_values_remain
				by reference 	csid_prm_value
				by reference 	csid_prm_value_length
				returning csid_pr_ret_stat
			If (Success_is in Csid_pr_ret_stat) and (csid_prm_value(1:1) = "Y")
			Then
				Set Failure_is in Creditside_screen_ls to true
			End-if
			Go to b400_set_advice_end
		Else
			If (Csid_know_acc_id = Spaces AND
			    Csid_chan_acc_ws NOT = Spaces) And
	   		NOT(tran_type of Ent_ftr_set = "DDR") Then
				%^ Insert the Account returned from Channel_Determination
				%^ We have been provided a clearing account, we don't need
				%^ anything else
		                Set Failure_is in Csid_musthave_acct to true
				Set Success_is in csid_chan_imposed_acct to True
				Move 1 to Cdt_account_okay_ls
			end-if
		end-if
	end-if

	%^ Call "CREDIT_ADVICE_LOOKUP" using by Value 1.
	%^ Call "SI_COPY_ADV".

	If (Csid_opr_advice = SPACES )
	   AND (Cdt_adv_flg of Ent_ftr_set = "Y" )
	THEN
* Put operator override flag back if we set up an AIN override.	
	    Move SPACE to Cdt_adv_flg of Ent_ftr_set
	END-IF.

* Force ABA if we are paying via FED *************************
%^
        If (Cdt_adv_typ of Ent_credit_set = "FED" )
           AND (Cdt_ovr of Cdt_typ of Ent_credit_set = SPACE )
        THEN
            If (Cdt_idtype of Cdt_typ of Ent_credit_set NOT = "A" )
                AND (Aba_id of Ent_c_adr_set NOT = SPACES )
            THEN
		%Beg
		Ent_credit_set.Cdt_typ.Cdt_idtype = "A";
		%End
		Set Success_is in Csid_changed_it to TRUE
		If (Bnk_id of Ent_c_adr_set not =
			Bank of Loc_info of Ent_ftr_set )
		THEN
		    %Beg
		    Csid_compose  ^OUT(Ent_credit_set.Cdt_typ.Cdt_id)
			Ent_c_adr_set.bnk_id, ":", Ent_c_adr_set.Aba_id, / ;
		    %End
		ELSE
		    %Beg
		    Ent_credit_set.cdt_typ.cdt_id = Ent_c_adr_set.Aba_id ;
                    %End
	        END-IF
            END-IF
        END-IF.
%^
%^ END ABA Force **************************

        %^ Check to see if this a "P" advice type
%^ REMOVED	Call "GET_PID_ADV_DATA" using
%^
%^	Connect to the Channel for Account and allowable 
%^	ID type information.
%^
	Set ID_IS in csid_prchan_mode to True.
	If Cdt_adr_bnk_id of Ent_credit_set not = spaces then
		%Beg
		csid_chan_ident_ws.Idbank = Ent_credit_set.Cdt_adr_bnk_id;
		%End
	Else
		%Beg
		csid_chan_ident_ws.Idbank = Ent_ftr_set.Loc_info.Bank;
		%End
	End-if.

	%Beg
		csid_chan_ident_ws.idkey = Ent_credit_set.Cdt_adv_typ;
	%End
		
	Call "GET_CHANNEL" using
			By Reference 	Csid_prchan_mode
			By Reference	Csid_chan_ident_ws
			By Reference 	Csid_chan_ident_ws_lengths
		returning Csid_got_channel_ws.

%^
%^ Channel contains all that we need from the
%^ PID table stuff.
%^
	If ((RTGS_IS in Endpoint_type of Rchan_channel_set) or
	    (clrhouse_is in Endpoint_type of Rchan_channel_set)) And
	    (csid_chan_acc_ws Not = Spaces) AND
	   NOT(Cdt_adv_typ of Ent_credit_set = "FED"  and Tran_type of Ent_ftr_set = "SEC") And
	   NOT(tran_type of Ent_ftr_set = "DDR")
	Then
		%^ Channel Determination provided an account number use, it
		%beg
		   Ent_Credit_set.cdt_adr_bnk_id = Csid_chan_acc_ws.idbank;
		   Ent_credit_set.cdt_account(.idbank = Csid_chan_acc_ws.idbank,
					      .idtype = Csid_chan_acc_ws.idtype,
					      .idkey  = Csid_chan_acc_ws.idkey ) ;
		   Break: Ent_c_acc_set; %^ clear leftover connections
		   Break: Ent_c_acc_rel_reg;
		%end
%^
%^ Get the proper channel info now 133476
%^
   	 	%ace_conn_root_q Rel_acc_index ;
    		%Beg
	    		BREAK: Ent_acc_set ;
	    		BREAK: Ent_acc_rel_reg ;
    			Rel_acc_index ^SEARCH (FORWARD, EQL,
			     .Rel_name_key(.Idbank = ent_credit_set.cdt_account.Idbank, 
			 	    .Idtype = ent_credit_set.cdt_account.Idtype,
			 	    .Idkey (.Idacc = ent_credit_set.cdt_account.Idkey,
				 	    .Idadr = NULL,
				 	    .Idpad = NULL ) ),
			 CONN: Ent_acc_set(NOMOD)) ;
		%end

		If (Success_is in Ent_acc_set_status) Then
		    Move Currency_id of Ent_acc_set to Cdt_currency_found_ls
		    %^ If blank, set to Base
   	            If (Cdt_currency_found_ls = SPACES ) Then
			    If Cdt_adr_bnk_id of Ent_credit_set =
						Bnk_id of Menu_bnk_union
			        Move Base_currency_id of Menu_bnk_union to 
						  Cdt_currency_found_ls
		            ELSE
	       			%Beg
	        		     BREAK: Csid_bnk_union ;
	   			     SEARCH: Bnk_index 
		 				(Key = Ent_credit_set.Cdt_adr_bnk_id ) ;
				%end
	        		    If Failure_is in Bnk_index_status  
	            			Move SPACES to Cdt_currency_found_ls
	        		    ELSE
	            			%Beg  Bnk_index CONN: Csid_bnk_union (NOMOD) ;
					%End
	            			Move Base_currency_id of Csid_bnk_union to 
						    Cdt_currency_found_ls
	        		    END-IF
            		     END-IF
        	    END-IF
		   %beg BREAK: Ent_acc_set; %end
		End-if
%^ End 133476
		Set Success_is in csid_chan_imposed_acct to True
		Move 1 to Cdt_account_okay_ls
		Set Failure_is in Csid_itsa_clearhouse to True
	end-if.
	%^ Want to see is this skips the account write over.
%^

	Call "GET_IDTYPE_FROM_CHAN" Using
		By Reference Csid_temp_idtype,
		By Reference csid_lookup_temp,
		By Reference Csid_lookup_temp_length
	Returning csid_ret_stat.

	If Success_is in csid_ret_stat Then
		%^ have have a good ID use it
		%beg ent_credit_set.cdt_typ.cdt_idtype = Csid_temp_idtype;
  		     Csid_compose ^OUT(Ent_credit_set.Cdt_typ.Cdt_id)
				    Csid_lookup_temp,/;
		%end
	end-if.

* Force P if we are paying via CHP or equivalent clearing house
%^
%^ This is either OBSELETE, or to be replaced by a check ID types allowed
%^ for channel and insert proper CDT_ID
%^
%^


	If (Success_is in Csid_itsa_clearhouse )
           AND (Cdt_ovr of Cdt_typ of Ent_credit_set = SPACE )
        THEN
	    Set Failure_is in Csid_found_it to TRUE
	    If (Cdt_idtype of Ent_credit_set = "E" )
	      AND (Cdt_id of Cdt_typ of Ent_credit_set(1:2) =
					Csid_clrhs_swf_acc )
	    THEN
* Look it up in the clearinghouse code table.
		%Beg
		Csid_union_key_ws(.Idname = "FIELD_EDIT_TABLES",
				  .Idprod = "MTS", 	   
		 		  .Idbank =  Menu_bnk_union.Bnk_id,    
		 		  .Idloc  = null,    	   
		 		  .Idcust = null);		  
   		Csid_compose ^OUT(Csid_item_key_ws),
						"EXTENDED_IDS:", /; 
		Csid_seq_ordinal_ws = <1>;
		Csid_compose ^OUT(Csid_match_key_ws), Csid_clrhs_swf_acc, / ;
		%End
		Call "CFG_MATCH_ITEM" USING
		    BY Reference Idname of Csid_union_key_ws
		    BY Reference Idprod of Csid_union_key_ws
		    BY Reference Idbank of Csid_union_key_ws
		    BY Reference Idloc of Csid_union_key_ws
		    BY Reference Idcust of Csid_union_key_ws
		    BY Reference Csid_item_key_ws
		    BY Reference Csid_match_key_ws
		    BY Reference Csid_match_key_ws_length
		    BY Reference Csid_seq_ordinal_ws
		    BY Reference Csid_error_msg_ws
		    BY Reference Csid_error_msg_ws_length
	          RETURNING Csid_ret_stat
		If (Success_is in Csid_ret_stat )
		    %Beg  Csid_item_type_ws = "VSTR(50)" ;  %End
		    Call "CFG_GET_ITEM" USING
			by Reference Idname of Csid_union_key_ws
			by Reference Idprod of Csid_union_key_ws
			by Reference Idbank of Csid_union_key_ws
			by Reference Idloc of Csid_union_key_ws
			by Reference Idcust of Csid_union_key_ws
			by Reference Csid_item_key_ws
			by Reference Csid_seq_ordinal_ws
        		by Reference Csid_item_type_ws
			by Reference Csid_item_data_ws
			by Reference Csid_item_data_ws_length
			by Reference Csid_error_msg_ws
			by Reference Csid_error_msg_ws_length
	              RETURNING Csid_ret_stat
		    If (Success_Is in Csid_ret_stat)
		        %Beg
		        Csid_ext_when = NULL ;
		        Csid_parse ^IN(Csid_item_data_ws)
				Csid_ext_got_id(^STRING<2>), "|",
				Csid_ext_min_length, "|",
				Csid_ext_max_length, "|", Csid_ext_dtype, "|",
				Csid_ext_mod, "|", Csid_ext_special, "|",
				Csid_ext_advice, "|", Csid_ext_when, "|",
				Csid_ext_errmsg, "|", / ;
		        %End
		        If (Success_is in Csid_parse_status )
		          AND (Csid_ext_when_length NOT = 0 )
		          AND (Csid_ext_when = "D" )
		        THEN
			    Set Success_is in Csid_found_it to TRUE
			END-IF
		    END-IF
		END-IF
	    END-IF

            %ACE_IS Relget_adr_set connected giving Csid_conn_stat;
            If (Success_is in Csid_conn_stat )
	      AND (Failure_is in Csid_found_it )
	    THEN
                %Beg
		BREAK: Csid_acc_seq;
                Relget_adr_set.account_seq CONN: Csid_acc_seq(NOMOD) ;
                FIRST: Csid_acc_seq ;
                %End
		Perform UNTIL (Success_is in Csid_found_it)
			      OR (Failure_is in Csid_acc_seq_status)
		    If (Idtype of Rel_name_key of Csid_acc_seq = "P" )
		       AND (Idbank of Rel_name_key of Csid_acc_seq =
					      Cdt_adr_bnk_id of Ent_credit_set)
		    THEN
		        If (Csid_clrhs_suffix_length NOT = 0 )
			    %Beg
			    Csid_clip_compose ^OUT(Csid_clrhs_pid_id)
				Csid_acc_seq.Rel_name_key.Idkey.Idacc, / ;
			    %End
			    Subtract Csid_clrhs_suffix_length from
				Csid_clrhs_pid_id_length giving
							   Csid_suffix_index
			    Add 1 to Csid_suffix_index
			    If
		  Csid_clrhs_pid_id(Csid_suffix_index:Csid_clrhs_suffix_length)
			        = Csid_clrhs_suffix(1:Csid_clrhs_suffix_length)
			    THEN
			        Set Success_is in Csid_found_it to TRUE
			    END-IF
			ELSE
			    Set Success_is in Csid_found_it to TRUE
			END-IF
		    END-IF
		    If (Failure_is in Csid_found_it )
		        %Beg  NEXT: Csid_acc_seq;  %End
		    END-IF
		END-PERFORM

                If (Success_is in Csid_found_it   )
                    If (Cdt_idtype of Cdt_typ of Ent_credit_set NOT = "P" )
			%Beg  Ent_credit_set.Cdt_typ.Cdt_idtype = "P";  %End
		    END-IF
		    If (Bank of Loc_info of Ent_ftr_set not =
				  Idbank of Rel_name_key of Csid_acc_seq )
		    THEN
			%Beg
			Csid_compose ^OUT(Ent_credit_set.Cdt_typ.Cdt_id)
				    Csid_acc_seq.Rel_name_key.Idbank, ":",
				    Csid_acc_seq.Rel_name_key.Idkey.idacc, / ;
			%End
		    ELSE
	                %Beg
		        Ent_credit_set.cdt_typ.cdt_id = 
				   Csid_acc_seq .Rel_name_key.Idkey.Idacc ;
			%End
                    END-IF
                END-IF
            END-IF
            %Beg  BREAK: Csid_acc_seq ;  %End
        END-IF.

%^
%^ If we don't have a Cdt_adr_bnk_id yet, we will be needing one to properly process
%^ the CDTAIN search to come.  Call the CUST_ADR_BNK_ID routine to load one, if needed
%^
b400_set_advice_cleanup.

	If (cdt_adr_bnk_id of Ent_credit_set = Spaces) Then
		Call "CUST_CDT_BNK_ID" using
			By Reference 	cdt_adr_bnk_id of ent_credit_set
		  Returning Csid_ret_stat
	end-if.

%^ Don;t do this here.
%^	Perform X930_CHANGE_CREDIT thru
%^		X930_CHANGE_CREDIT_END.

B400_SET_ADVICE_END.


   EXIT.
B420_GET_NEWPARTY.
* Checks preferred correspondent table and SI chain to see if we have a new
* credit party.

	Set Failure_is in Csid_iban_expanded to TRUE

	%Beg
	Csid_pref_corr_rec = NULL;
	Csid_pref_corr_2id_rec = NULL;
	Csid_pref_next_id_rec = NULL;
	%End.

 	If (Lock_cdt_party_ls NOT = 0) Or
	   (Success_is in Csid_disable_ain_ws)	%^ CHANNEL_DETERMINATION flagged no more AINS.
	Then
 		%^ Party Locked Nothing to Do 97335
	    Move 1 to Csid_onscreen
	    Call "CUST_PAYTO_NETWORK" using
	        by reference Cdt_adv_typ of Ent_credit_set
	        by reference Csid_onscreen
	        by reference Csid_pref_corr_rec
	        by reference Csid_pref_corr_rec_lengths
	        by reference Csid_do_pushdown
	        by reference Csid_corr_derivation
	        by reference Csid_ain_advice
	        by reference Csid_prm_secwir_ws
	        by reference Csid_net_memo
	        by reference Csid_net_memo_length
	        by reference Cdt_errmemo_count_ls
	        by reference Creditside_screen_ls
	      Returning Csid_net_stat

	    %Beg
	    Csid_pref_corr_rec( .Idtype change,
			        .Idkey change ) ;
	    %End
 	    Go to B420_GET_NEWPARTY_END
 	end-if.

 	Call "GLOBAL_PREF_CORR" USING
	    By reference Csid_pref_corr_rec
	    By reference Csid_pref_corr_rec_lengths
	  RETURNING Csid_ret_stat.

	%Beg
	Csid_pref_corr_rec( .Idtype change,
			    .Idkey change ) ;
	%End.

	If (Success_is in Csid_ret_stat )
            Set PUSHDOWN in Csid_do_pushdown to true
	    Move "GBL" to Csid_corr_derivation
	    %Beg
	    Csid_compose ^OUT(Csid_info_memo)
				"Credit party ",
				Ent_credit_set.cdt_typ,
				" had INTRTL global pref corr ",
				Csid_pref_corr_rec, / ;
	    %End
	    Perform X920_INFO_MEMO through X920_INFO_MEMO_END
            GO TO B420_GET_NEWPARTY_END
	end-if.


* No global preferred correspondent, so see if we have an AIN
	Set Failure_is in Csid_didansi_ws to TRUE
	MOVE Message_currency_ls to Csid_msg_curr_ws
	If  (Message_currency_ls = SPACES ) AND
	    (Cdt_idtype of Cdt_typ of Ent_credit_set NOT = "F" ) AND
	    (Dbt_idtype of Dbt_typ of Ent_debit_set NOT = "F" )
	THEN
		If (Cdt_adr_bnk_id of Ent_credit_set NOT = SPACES )
		    %Beg
		    Csid_id_bank_ws = Ent_credit_set.Cdt_adr_bnk_id ;
		    BREAK: Csid_bnk_union;
		    SEARCH: Bnk_index (Key = Csid_id_bank_ws ) ;
		    %End
		    If (Success_is in Bnk_index_status)
			%Beg
			Bnk_index CONN: Csid_bnk_union(NOMOD);
			Csid_msg_curr_ws = Csid_bnk_union.Base_currency_id;
			%End
		    END-IF
		END-IF
		If (Csid_msg_curr_ws = SPACES )
		    %Beg  
		    Csid_msg_curr_ws = Menu_bnk_union.Base_currency_id;  
                    %End
		END-IF
	END-IF

	%^
	%^ Set FTR.CURRENCY_CODE for the duration of the CDTAIN processing
	%^
	If Currency_code of Ent_ftr_set = Spaces and
	   Message_currency_ls NOT = Spaces
	Then
		Set Success_is in Moved_msg_cur_to_ftr to True
		Move Message_currency_ls to tmp_msg_cur_ws
		%beg ent_ftr_set.currency_code= tmp_msg_cur_ws; %end 
	End-if.
	%^
	%^
	%^ WAS SI_FIRST_CREDIT, must fill proper fields from retreived AIN.COR
	%^ execution parameter list
	
	CALL "CUST_SETUP_CREDIT_AINS"
	  Returning Csid_dummy_status.
	Set Success_is in Csid_retry_cdtain to TRUE.
	If Csid_num_AINSIs Not = 1 Then
		%^ Must be 2, we need to look for COR and AINS
		%^ COR first
		%beg 
		Csid_pr_type_ws = NULL;
		csid_compose ^out(csid_pr_type_ws) 
			"COR",/;
		csid_pr_ordinal_ws = <0>;
		%end

		Set Bad_ml in Csid_pr_search_level to true
		Set Bad_is in Csid_pr_search_source to true
		Call "PRULE_MSG_RULE_MATCH_FROM" using
				By Reference csid_pr_type_ws
				By Reference csid_pr_type_ws_length
				By Reference Csid_pr_credit_side
				By Reference Csid_pr_search_level
				By Reference Csid_pr_search_source
				by Reference csid_pr_ordinal_ws
				by Reference csid_pr_level
				By Reference csid_pr_source
				by reference csid_pr_subtype_ws
				by reference csid_pr_subtype_ws_length
				By Reference Csid_pr_memo
				by reference csid_pr_memo_length
			returning csid_pr_stat_ws
		If Not(Success_is in Csid_pr_stat_ws) Then
			%^ No Cor present, Look for an AIN
			%beg csid_compose ^out(csid_pr_type_ws) "CDTAIN",/;
			     csid_pr_ordinal_ws = <0>;
			%end
		    Perform UNTIL (Failure_is in Csid_retry_cdtain)
		        Set Bad_ml in Csid_pr_search_level to true
		        Set Bad_is in Csid_pr_search_source to true
			Set Failure_is in Csid_retry_cdtain to TRUE
			Call "PRULE_MSG_RULE_MATCH_FROM" using
					By Reference csid_pr_type_ws
					By Reference csid_pr_type_ws_length
					By Reference Csid_pr_credit_side
					By Reference Csid_pr_search_level
					By Reference Csid_pr_search_source
					by Reference csid_pr_ordinal_ws
					by Reference csid_pr_level
					By Reference csid_pr_source
					by reference csid_pr_subtype_ws
					by reference csid_pr_subtype_ws_length
					By Reference Csid_pr_memo
					by reference csid_pr_memo_length
				returning csid_pr_stat_ws
			If (Success_is in Csid_pr_stat_ws)
			    Call "CUST_FILTER_CREDIT_AINS" using
				by Reference csid_pr_level
				By Reference csid_pr_source
				by Reference csid_pr_subtype_ws
				by Reference csid_pr_subtype_ws_length
			      Returning Csid_pr_stat_ws
			    If (Failure_is in Csid_pr_stat_ws)
				Set Success_is in Csid_retry_cdtain to TRUE
			    END-IF
			END-IF
		    END-PERFORM
		End-if
			
	else
		%^ Only scanning for AIN's
		%beg 
		Csid_pr_type_ws = NULL;
		csid_compose ^out(csid_pr_type_ws) 
			"CDTAIN",/;
		csid_pr_ordinal_ws = <0>;
		%end
		Perform UNTIL (Failure_is in Csid_retry_cdtain)
		    Set Bad_ml in Csid_pr_search_level to true
		    Set Bad_is in Csid_pr_search_source to true
		    Set Failure_is in Csid_retry_cdtain to TRUE
		    Call "PRULE_MSG_RULE_MATCH_FROM" using
				By Reference csid_pr_type_ws
				By Reference csid_pr_type_ws_length
				By Reference Csid_pr_credit_side
				By Reference Csid_pr_search_level
				By Reference Csid_pr_search_source
				by Reference csid_pr_ordinal_ws
				by Reference csid_pr_level
				By Reference csid_pr_source
				by reference csid_pr_subtype_ws
				by reference csid_pr_subtype_ws_length
				By Reference Csid_pr_memo
				by reference csid_pr_memo_length
			returning csid_pr_stat_ws
		    If (Success_is in Csid_pr_stat_ws)
		        Call "CUST_FILTER_CREDIT_AINS" using
			    by Reference csid_pr_level
			    By Reference csid_pr_source
			    by Reference csid_pr_subtype_ws
			    by Reference csid_pr_subtype_ws_length
		          Returning Csid_pr_stat_ws
		        If (Failure_is in Csid_pr_stat_ws)
			    Set Success_is in Csid_retry_cdtain to TRUE
		        END-IF
		    END-IF
		END-PERFORM
	end-if.
	%^
	%^ Re-Set FTR.CURRENCY_CODE 
	%^
	If	Success_is in Moved_msg_cur_to_ftr
	Then
		Set Failure_is in Moved_msg_cur_to_ftr to True
		Move Spaces to tmp_msg_cur_ws
		%beg ent_ftr_set.currency_code = NULL; %end 
	End-if.

	If (Success_is in Csid_pr_stat_ws) Then
		%^
		Perform GET_EXEC_PARAMS Thru
			GET_EXEC_PARAMS_END

	        If (csid_pr_type_ws = "COR" )
		    Set Success_is in Csid_cor_found to true		
		    If (Cor_done of Si_flgs of Ent_ftr_set = SPACE )
			%Beg  Ent_ftr_set.Si_flgs.Cor_done = "P" ;  %End
		    END-IF
		    GO TO B420_GET_NEWPARTY_END
		END-IF
%^ Found a matching AIN SI.
	    	If (csid_pr_type_ws = "CDTAIN" )
		    If (csid_pr_subtype_ws = "BKT" )
%^	    	        %Beg Ftrscr.Credit.cdt_typ.cdt_id.Msg = "FTRSCR$_INV_AIN_SI";
		    	%Beg
		    	screen_field_ws = "credit.cdt_typ.cdt_id";
		    	error_mnemonic_ws = "FTRSCR$_INV_AIN_SI";
		    	%End
	            	call "FTRSCR_WRITE_ERROR" using
	              	  by reference screen_field_ws
		      	  by reference error_mnemonic_ws
		        %Beg
		        Csid_compose ^OUT(Csid_info_memo)
			     "Found credit AIN SI with RRT-only BKT method", / ;
	 	        %End
		        Perform X920_INFO_MEMO through X920_INFO_MEMO_END
		        Add 1 to Cdt_errmemo_count_ls
		        Set Failure_is in Creditside_screen_ls to true
		        Set Success_is in Csid_push_error to TRUE
		        GO TO B420_GET_NEWPARTY_END
                    END-IF
		    %^ 83550 - Already have done the substitution
	            If (idtype of csid_pref_corr_rec =
			cdt_idtype of cdt_typ of ent_credit_set) Then
			    If idtype of csid_pref_corr_rec = "D" or "F" or "V" or "G"  Then
				Move Cdt_id_length of Ent_credit_set_lengths to csid_tmp_fin_pos_ws
				If cdt_id of cdt_typ of ent_credit_set(csid_tmp_fin_pos_ws:1) = "/"
				Then	%^ Discount the trailing / if present
					Subtract 1 from cdt_id_length of Ent_credit_set_lengths giving
						csid_tmp_fin_pos_ws
				End-if 
				%^ First, if replacing with a larger key, don't bother checking
				%^ for dup
				%^ If our bank, strip for the comparision
				If idkey of csid_pref_corr_rec(4:1) = ":" and
				   (idkey of csid_pref_corr_rec(1:3) =  bnk_id of menu_bnk_union Or
				    idkey of csid_pref_corr_rec(1:3) = cdt_adr_bnk_id of ent_credit_set)
				Then
					Move 5 to Csid_tmp_start_pos_ws
				Else
					Move 1 to Csid_tmp_start_pos_ws
				end-if
				Move idkey_length of csid_pref_corr_rec_lengths to csid_tmp_corr_len_ws
			        If (idkey of csid_pref_corr_rec(csid_tmp_start_pos_ws:csid_tmp_corr_len_ws) =
				     cdt_id of cdt_typ of ent_credit_set(1:Csid_tmp_fin_pos_ws))
				Then
				    %^Check in length -1 due to addition of / at end of account number
				    %^ Bypass, we have a circular reference, replacing
				    %^ same with same.
				    %^ All done, clear the corr rec
				    %beg csid_pref_corr_rec = NULL; %end
				    Go to B420_GET_NEWPARTY_END
				end-if
			    Else
				If (idkey of csid_pref_corr_rec  =
				    cdt_id of cdt_typ of ent_credit_set) Then
				    %^ Bypass, we have a circular reference, replacing
				    %^ same with same.
				    %beg csid_pref_corr_rec = NULL; %end
				    Go to B420_GET_NEWPARTY_END
				end-if
			    end-if
		    end-if


		    Set Success_is in Csid_didansi_ws to TRUE

		    If (csid_prm_method_ws  NOT = SPACES )
		        %Beg
		        Ent_credit_set.cdt_adv_typ = csid_prm_method_ws ;
                        Ent_ftr_set.flgs.cdt_adv_flg = "Y";
		        Csid_ain_advice = csid_prm_method_ws;
		       %End
		    END-IF

		    Move "REL" to Csid_corr_derivation

                    Evaluate TRUE
		        When Csid_pr_subtype_ws = "SUB"
	                    Set SUBSTITUTE in Csid_do_pushdown to true

		        When Csid_pr_subtype_ws = "INS"
	                When Csid_pr_subtype_ws = SPACES
			    Set PUSHDOWN in Csid_do_pushdown to true

		        When Other
%^	    		    %Beg Ftrscr.Credit.cdt_typ.cdt_id.Msg =
%^							  "FTRSCR$_INV_AIN_SI";
		    	    %Beg
		   	    screen_field_ws = "credit.cdt_typ.cdt_id";
		    	    error_mnemonic_ws = "FTRSCR$_INV_AIN_SI";
		    	    %End
	             	    call "FTRSCR_WRITE_ERROR" using
	              	      by reference screen_field_ws
		              by reference error_mnemonic_ws
	        	    %Beg
		            Csid_compose ^OUT(Csid_info_memo)
			           "Illegal submethod ",
				   Csid_pr_subtype_ws, " in SI ",
				   Csid_pr_ordinal_ws, " for ", 
				   Ent_credit_set.Cdt_typ, /;
	    		    %End
			    Perform X920_INFO_MEMO through X920_INFO_MEMO_END
			    Add 1 to Cdt_errmemo_count_ls
		 	    Set Failure_is in Creditside_screen_ls to true
			    Set Success_is in Csid_push_error to TRUE
			    GO TO B420_GET_NEWPARTY_END
		    END-EVALUATE
                    GO TO B420_GET_NEWPARTY_END
	        ELSE
		    %Beg  Csid_pref_corr_rec = NULL ;  %End
	        END-IF
            ELSE
                %Beg  Csid_pref_corr_rec = NULL ;  %End
	End-If.

        If Idtype of Csid_pref_corr_rec not = spaces
          then  GO TO B420_GET_NEWPARTY_END
        end-if.

%^ Get account suffixes to pass to the special preferred correspondent routine
        Perform C730_GET_PID_SUFFIXES thru C730_GET_PID_SUFFIXES_end.

%^ See if there's a site specific preferred correspondent
	If (Credit_currency_ls = SPACES OR Message_currency_ls )
	    Move Message_currency_ls to Csid_pref_curr
	    Move Message_amount_ls to Csid_pref_amount
	ELSE
	    Move Credit_currency_ls to Csid_pref_curr
	    If (Message_amount_ls = 0 )
		Move ZERO to Csid_pref_amount
	    ELSE
	        Call "CONVERT_SI_AMOUNT" using
	            by reference Message_currency_ls
	            by reference Message_amount_ls
		    by reference Base_currency_ID of Menu_bnk_union
	            by reference Csid_pref_curr
                    by reference Csid_pref_amount
		    by reference Base_cur_precision of Menu_bnk_union
	          returning Csid_ret2_stat
%^ If the amount couldn't be calculated pass a zero.
        	If Failure_is in Csid_ret2_stat then
		    Move ZERO to Csid_pref_amount
		END-IF
	    END-IF
	END-IF.
        CALL "CUST_SPEC_PREF_CORR" USING
           BY REFERENCE Csid_pref_corr_rec
           BY REFERENCE Csid_pref_corr_rec_lengths
           BY REFERENCE Csid_preferred_advice
           BY REFERENCE Csid_pref_submethod
	   BY REFERENCE Csid_pref_next_id_rec
	   BY REFERENCE Csid_pref_next_id_rec_lengths
           BY REFERENCE Csid_pref_corr_2id_rec
           BY REFERENCE Csid_pref_corr_2id_rec_lengths
           BY REFERENCE Csid_suffixes
           BY REFERENCE Csid_suffixes_length
	   BY REFERENCE Csid_wire_svc_bits
	   BY REFERENCE Csid_pref_curr
	   BY REFERENCE Csid_pref_amount
	   BY REFERENCE Credit_currency_ls
	   BY REFERENCE Csid_second_id
	   BY REFERENCE Csid_second_id_length
         RETURNING Csid_Spec_Stat.

	%Beg
	Csid_pref_corr_rec( .Idtype change,
			    .Idkey change ) ;
	Csid_pref_next_id_rec( .Idtype change,
			    .Idkey change ) ;
	Csid_pref_corr_2id_rec( .Idtype change,
			    .Idkey change ) ;
	%End.

        If Success_is in Csid_Spec_Stat  
          then
            If (Csid_preferred_advice NOT = SPACES )
                %Beg
                Ent_credit_set.cdt_adv_typ = Csid_preferred_advice ;
                Ent_ftr_set.flgs.cdt_adv_flg = "Y";
                Csid_ain_advice = Csid_preferred_advice ;
                Csid_opr_advice = Csid_preferred_advice ;
                %End
            END-IF

	    Move "SPC" to Csid_corr_derivation

            Evaluate Csid_pref_submethod

                When "SUB"
                    Set SUBSTITUTE in Csid_do_pushdown to true

                When "INS"
                When SPACES
                    Set PUSHDOWN in Csid_do_pushdown to true

                When Other
                    Set PUSHDOWN in Csid_do_pushdown to true
                    %Beg
                    Csid_compose ^OUT(Csid_info_memo),
                           "Illegal submethod ", Csid_pref_submethod,
                   " returned from Intrtl_spec_pref_corr routine, INS assumed",
			/;
                    %End
                    Perform X920_INFO_MEMO through X920_INFO_MEMO_END

            END-EVALUATE
        END-IF.

        If Idtype of Csid_pref_corr_rec not = spaces
          then  GO TO B420_GET_NEWPARTY_END
        end-if.

%^ See if there's an Intrtl NIA Preferred Correspondent
        CALL "CUST_NIA_PREF_CORR" USING
           BY REFERENCE Csid_New_Idtype_Ws
           BY REFERENCE Csid_New_Id_Ws_Length
           BY REFERENCE Csid_New_Id_Ws
         RETURNING Csid_Nia_Stat.

        IF (Success_is in Csid_Nia_Stat  )
        THEN
           SET PUSHDOWN in Csid_do_Pushdown to true
	   Move "NIA" to Csid_corr_derivation
           %BEG
               Csid_Pref_Corr_Rec.Idtype = Csid_New_Idtype_Ws;
               Csid_Pref_Corr_Rec.Idkey  = Csid_New_Id_Ws;

%^   And now lets add an info memo saying what happened
               Csid_Compose ^OUT (Csid_Info_Memo)
                   "Pref correspondent ",Csid_Pref_Corr_Rec.Idtype,
                   "/",Csid_Pref_Corr_Rec.Idkey,
                   " inserted -> ", Ent_Credit_Set.Cdt_Typ.Cdt_Idtype,"/",
                   Ent_Credit_Set.Cdt_Typ.Cdt_Id," pushed down. " , / ;
               BREAK: Csid_acctyp_seq;
           %End
           Perform X920_INFO_MEMO through X920_INFO_MEMO_END
      	END-IF.

        If Idtype of Csid_pref_corr_rec not = spaces
          then  GO TO B420_GET_NEWPARTY_END
       	end-if.
	
	Move 1 to Csid_onscreen.
	Call "CUST_PAYTO_NETWORK" using
	    by reference Cdt_adv_typ of Ent_credit_set
	    by reference Csid_onscreen
	    by reference Csid_pref_corr_rec
	    by reference Csid_pref_corr_rec_lengths
	    by reference Csid_do_pushdown
	    by reference Csid_corr_derivation
	    by reference Csid_ain_advice
	    by reference Csid_prm_secwir_ws
	    by reference Csid_net_memo
	    by reference Csid_net_memo_length
	    by reference Cdt_errmemo_count_ls
	    by reference Creditside_screen_ls
	  Returning Csid_net_stat.

	%Beg
	Csid_pref_corr_rec( .Idtype change,
			    .Idkey change ) ;
	%End.

        If Idtype of Csid_pref_corr_rec not = spaces
          then  GO TO B420_GET_NEWPARTY_END
       	end-if.
	
%^
%^
%^	The below should be obselete, AUX addresses should be returned
%^	from RELGET connected, and searched by the Prule_search logic
%^

%^ Check to see if there was an AIN instruction attached to an AUX address.
%^ This code was put in for German Amex Clearing, Hotrep 35648
	Set Failure_is in Csid_didansi_ws to TRUE.
	Move spaces to Csid_pref_corr_rec.
	%Beg Csid_pref_corr_rec = NULL; %End.
	If (Relget_aux_ain = "CDTAIN" )
	   AND (Cdt_ovr of Cdt_typ of Ent_credit_set = "*" )
	   AND (Relget_msgcode = Vmsg_dat_notonfile_wc )
	THEN
	    Set Success_is in Csid_ret_stat to true
	    Set Success_is in Csid_didansi_ws to TRUE
	    %Beg  Csid_pref_corr_rec = Relget_ain_party;  %End
	    If (Relget_adv_type not = spaces )
		%Beg
		Ent_credit_set.cdt_adv_typ = Relget_adv_type ;
		Ent_ftr_set.flgs.cdt_adv_flg = "Y";
		Csid_ain_advice = Relget_adv_type ;
		%End
	    end-if
 
	    Move "AUX" to Csid_corr_derivation
 
	    Evaluate Relget_ain_submethod
		when "SUB"
		    Set SUBSTITUTE in Csid_do_pushdown to true
 
		when "INS"
		when spaces
		    Set PUSHDOWN in Csid_do_pushdown to true
 
		when other
		    %Beg
			    screen_field_ws = "credit.cdt_typ.cdt_id";
			    error_mnemonic_ws = "FTRSCR$_INV_AIN_SI";
		    %End
	            call "FTRSCR_WRITE_ERROR" using
	              by reference screen_field_ws
		      by reference error_mnemonic_ws
		    %Beg
		    Csid_compose ^OUT(Csid_info_memo)
		       "Illegal submethod ",
		       Relget_ain_submethod, " in AUX Rule ",
		       Relget_ain_ordinal, " for ",
		       Ent_credit_set.cdt_typ, /;
		    %End
		    Perform X920_INFO_MEMO through X920_INFO_MEMO_END
		    Add 1 to Cdt_errmemo_count_ls
		    Set Failure_is in Creditside_screen_ls to true
		    Set Success_is in Csid_push_error to TRUE
		    Go to B420_GET_NEWPARTY_END
	    end-evaluate
	end-if.

B420_GET_NEWPARTY_END.
   EXIT.


GET_EXEC_PARAMS.
%^
%^ Retrieve the Execution Parameters required
%^ This paragraph includes all params required for any rule
%^ checked by this program
%^
%^
	Move Spaces to csid_prm_method_ws, csid_prm_secwir_ws, csid_acctg_method_ws.
	Move 0 to Lcl_prms_remaining_ws.
	Move spaces to Lcl_Param_name_ws.
	Perform with test after until Failure_is in Lcl_scan_Stat_ws
		Call "PRULE_MSG_READEX_PARM" using
			by reference Lcl_Param_name_ws
			by reference Lcl_Param_name_ws_length
			by reference Lcl_Param_type_ws
			by reference Lcl_prms_remaining_ws
			by reference Lcl_Param_value_ws
			by reference Lcl_Param_value_ws_length
			returning Lcl_scan_stat_ws
		If Success_is in Lcl_scan_stat_ws then
			%^ All are alpha, copy use full fields
			Evaluate Lcl_Param_name_ws
			    when "MTS$PARTY"
				%^ Parse the party ID/ should be Idtype/Id
				%beg Csid_parse ^in(Lcl_param_value_ws)
					Csid_pref_corr_rec.Idtype , "/" ,
					Csid_pref_corr_rec.Idkey,/;
				%end
				%^ Parse should be enough but...
				If Not (Success_is in csid_parse_status) Then
					%^ lets jut move it in, maybe the / is missing
					Move Lcl_param_value_ws(1:Lcl_param_value_ws_length) to
					     csid_pref_corr_rec	%^ should be format
					%Beg	Csid_pref_corr_rec( .Idtype change,
				    				    .Idkey change ) ;
					%End
				end-if
			    when "MTS$METHOD"
			    when "MTS$PAYMENT_CHANNEL"
				Move Lcl_param_value_ws(1:Lcl_param_value_ws_length) to
				     csid_prm_method_ws
			    when "MTS$SEND_SECWIR"
				Move Lcl_param_value_ws(1:Lcl_param_value_ws_length) to
				     csid_prm_secwir_ws
			    When "MTS$ACCTG_METHOD"
				Move Lcl_param_value_ws to csid_acctg_method_ws
			    When "MTS$DISABLE_AIN"
				Set Success_is in Csid_disable_ain_ws to True	%^ TGT2

			    When "MTS$TARGET_SUBPARTICIPANT"
				%^ Store the value, write it when we complete the AIN
				Set Success_is in TGT2_subpartic to True


			    When "MTS$TARGET_ACCOUNT_BIC"
				Move Lcl_param_value_ws_length
				     		  to Csid_tgt_account_bic_length
	
				Move Lcl_param_value_ws(1:Lcl_param_value_ws_length) to
				     Csid_tgt_account_bic

			End-evaluate
		End-if
	End-perform.
GET_EXEC_PARAMS_END.

   EXIT.

B440_SCAN_DEBIT_SIS.
* First see if we have a CHK 
	If (Check_found of Si_flgs of Ent_ftr_set = "Y" )
	    Move 1 to  CHK_SI_relevant_ls
	     PERFORM B445_SCAN_PREVICE through B445_SCAN_PREVICE_END
	    GO TO B440_SCAN_DEBIT_SIS_END
	END-IF.
	Move 1 to Csid_number_SIs.
	Move SPACES to Csid_previce_vstr

	%beg csid_compose ^out(csid_pr_type_ws) "CHK",/;
	     csid_pr_ordinal_ws = <0>;
	%end

	Call "PRULE_MSG_RULE_MATCH" Using
			By Reference csid_pr_type_ws
			By Reference csid_pr_type_ws_length
			by Reference csid_pr_ordinal_ws
			by Reference csid_pr_level
			By Reference csid_pr_source
			by reference csid_pr_subtype_ws
			by reference csid_pr_subtype_ws_length
			By Reference Csid_pr_memo
			by reference csid_pr_memo_length
		returning csid_ret_stat.

%^ Support international version where advice type may be CHQ.
	If ((Intnatl_ena of Menu_cfg is NOT = low-values)
	   AND (Failure_is in Csid_ret_stat ))
	then
		%beg csid_compose ^out(csid_pr_type_ws) "CHQ",/;
		     csid_pr_ordinal_ws = <0>;
		%end
		Call "PRULE_MSG_RULE_MATCH" Using
			By Reference csid_pr_type_ws
			By Reference csid_pr_type_ws_length
			by Reference csid_pr_ordinal_ws
			by Reference csid_pr_level
			By Reference csid_pr_source
			by reference csid_pr_subtype_ws
			by reference csid_pr_subtype_ws_length
			By Reference Csid_pr_memo
			by reference csid_pr_memo_length
		returning csid_ret_stat

	END-IF.
	If Failure_is in Csid_ret_stat
	    Move ZERO to CHK_SI_relevant_ls
	ELSE
	    Move 1 to CHK_SI_relevant_ls
	END-IF.

	IF (CHK_SI_relevant_ls = 0 )
	     PERFORM B445_SCAN_PREVICE through B445_SCAN_PREVICE_END
	    GO TO B440_SCAN_DEBIT_SIS_END
	END-IF.

	%beg csid_pref_corr_rec = NULL; %end
	Perform GET_EXEC_PARAMS Thru
		GET_EXEC_PARAMS_END.
	If csid_pref_corr_rec = spaces Then
		%beg
		        Csid_compose ^OUT(Csid_err_memo)
				       "Missing Party for CHK,CHQ RULE "
					csid_pr_ordinal_ws,/ ;
 	        %End
	        Perform X920_INFO_MEMO through X920_INFO_MEMO_END
		Set Failure_is in Creditside_screen_ls to true
	    	GO TO B440_SCAN_DEBIT_SIS_END
	end-if.

	%Beg  Ent_ftr_set.Si_flgs.Check_found = "Y" ;  %End.
	If (Cdt_adv_typ of Ent_credit_set = "SCK" )
	   OR (Success_is in Csid_chk_codeword   ) 
	THEN
* Let's see if we can hook it up.
	    If (Bbk_id of Bbk of Ent_credit_set NOT = SPACES )
	       OR ( (Bbk_name1_length of Ent_credit_set_lengths NOT = 0 ) 
	            AND (Bbk_name1 of Ent_credit_set NOT = SPACES ) )
	    THEN
* Too many parties -- cannot do SWIFTCHECK.
		PERFORM B445_SCAN_PREVICE through B445_SCAN_PREVICE_END
	   	GO TO B440_SCAN_DEBIT_SIS_END
	    END-IF	
		%^ Alreadyl oaded    %Beg  Csid_pref_corr_rec = Ent_cnf_set.Si_party;  %End
	    Set CDT in Relget_title_flag to TRUE
	    %Beg
	    Csid_lookup_temp = Csid_pref_corr_rec.idkey ;
	    %End
	    %ACE_IS Ent_c_adr_set connected giving Csid_conn_stat;
	    Move "F" to Csid_lkup_pend_del
	    Call "ACCT_LOOKUP" using
	        by reference Idtype of Csid_pref_corr_rec
	        by reference Csid_lookup_temp
    	        by reference Csid_ovr
    	        by content "F"
    	        by reference Csid_multibank_ws
    	        by reference Credit_currency_ls
		by reference Csid_lkup_pend_del
 	      RETURNING Csid_ret_stat

     	    If (Csid_ovr NOT = SPACE )
%^ Lookup failed
		PERFORM B445_SCAN_PREVICE through B445_SCAN_PREVICE_END
	    	GO TO B440_SCAN_DEBIT_SIS_END
	    END-IF	
	    If Rel_id of Relget_adr_set = Cdt_rel_id of Ent_credit_set
* Been here, done that.
		PERFORM B445_SCAN_PREVICE through B445_SCAN_PREVICE_END
	    	GO TO B440_SCAN_DEBIT_SIS_END
	    END-IF
	ELSE
	    PERFORM B445_SCAN_PREVICE through B445_SCAN_PREVICE_END
	    GO TO B440_SCAN_DEBIT_SIS_END
	END-IF.
* CHK account is not already the credit party.  Insert it.
	Set Failure_is in Csid_push_error to TRUE
	%ACE_IS Relget_adr_set connected giving Csid_conn2_stat;
	If (Success_is in Csid_conn2_stat)
	    %Beg
	    BREAK: Csid_adr_set ;
            Relget_adr_set EQUATE: Csid_adr_set(NOMOD) ;
	    BREAK: Relget_adr_set ;
	    %End
	    %ACE_IS Ent_c_adr_set connected giving Csid_conn_stat;
	    If (Success_is in Csid_conn_stat)
		%Beg
	        Ent_c_adr_set EQUATE: Relget_adr_set(NOMOD) ;
	        BREAK: Ent_c_adr_set;
                %End
	    ELSE
		Move 0 to Rel_id of Relget_adr_set
	    END-IF
	END-IF
	PERFORM C640_PUSH_CREDIT through C640_PUSH_CREDIT_END.
	%Beg  BREAK: Relget_adr_set ;  %End
        If (Success_is in Csid_conn2_stat)
	    %Beg
	    Csid_adr_set EQUATE: Relget_adr_set(NOMOD) ;
	    BREAK: Csid_adr_set ;
	    %End
	END-IF.
	If Success_is in Csid_push_error
* OOPSIEs.  No room to push
	    PERFORM B445_SCAN_PREVICE through B445_SCAN_PREVICE_END
	    GO TO B440_SCAN_DEBIT_SIS_END
        END-IF.
	Move 1 to Csid_credit_changed
	PERFORM C620_COPY_ADDRESS through C620_COPY_ADDRESS_END.

	If (Relget_return_key NOT = SPACES )
	    %Beg
	    Csid_parse ^IN(Relget_return_key)
				 Csid_pref_corr_rec.idkey, ^SPACE, / ;
	    %End
	END-IF.
%^ And now lets add an info memo saying what happened
	%Beg
	Ent_credit_set.Cdt_adv_typ = "SCK";
	Ent_ftr_set.Flgs.Cdt_adv_flg = "Y" ;
	Ent_ftr_set.si_flgs.check_found = "Y";
	Csid_compose ^OUT(Csid_info_memo)
	    	"CHK SI inserted ", Csid_pref_corr_rec.idtype, "/",
		Csid_pref_corr_rec.idkey, " -> ", 
		Ent_credit_set.Cdt_typ.Cdt_idtype,"/", 
		Ent_credit_set.Cdt_typ.Cdt_id, / ;
	%End
	Perform X920_INFO_MEMO through X920_INFO_MEMO_END
 	%Beg
	Ent_credit_set.Cdt_adr_bnk_id = Relget_adr_set.bnk_id ;
	Csid_id_ws = Csid_pref_corr_rec.idkey ;
	%End
	If (Cdt_adr_bnk_id of Ent_credit_set NOT = SPACES )
	    AND (Cdt_adr_bnk_id of Ent_credit_set NOT =
				Bank of Loc_info of Ent_ftr_set )
	THEN
	    %Beg
	    Csid_parse ^IN(Csid_pref_corr_rec.Idkey), 
				^STRING<3>, ":", ^STRING, / ;
	    %End
	    If (Failure_is in Csid_parse_status   )
		%Beg
		Csid_compose ^OUT(Csid_id_ws)
				Ent_credit_set.cdt_adr_bnk_id, ":",
				Csid_pref_corr_rec.Idkey, / ;
		%End
	    END-IF
	END-IF.
	%Beg
	 	Ent_credit_set.Cdt_typ (.Cdt_ovr    = Csid_ovr,
 					.Cdt_idtype = Csid_pref_corr_rec.Idtype,
					.Cdt_id     = Csid_id_ws ) ;
		BREAK: Ent_c_adr_set ;
		csid_know_acc_id = NULL;	%^ clear out left over dat
		Ent_credit_set.flgs3.cdt_adr_ptr_ok = "T";
		Ent_credit_set.cdt_adr_set_ptr POINT: Relget_adr_set;
		BREAK: Ent_c_adr_set ;
		Relget_adr_set EQUATE: Ent_c_adr_set(NOMOD) ;
		Relget_adr_set EQUATE: Csid_adr_set(NOMOD);
	%End.

	PERFORM X930_CHANGE_CREDIT thru
		X930_CHANGE_CREDIT_END.

	Perform B400_SET_ADVICE through B400_SET_ADVICE_END.

B440_SCAN_DEBIT_SIS_END.

   EXIT.

B445_SCAN_PREVICE.
* Next we look for a PRE
	If (Pre_found of Si_flgs of Ent_ftr_set = "Y" )
	    GO TO B445_SCAN_PREVICE_END
	END-IF.
	Set Failure_is in csid_ret_stat to True.
%^ Need to check for rule
%^	If Success_is in Csid_pre_codeword
        %Beg  Csid_previce_vstr = "PREVICE" ;  %End
	Set Failure_is in csid_ret_stat to True
	%beg csid_compose ^out(csid_pr_type_ws) "PRE",/;
			     csid_pr_ordinal_ws = <0>;
	%end

	Call "PRULE_MSG_RULE_MATCH_FROM" using
			by reference Csid_pr_type_ws
			by reference Csid_pr_type_ws_length
			by reference dbt_search_side_wc
			by reference Csid_pr_search_level
			by reference Csid_pr_search_source
			by reference Csid_pr_ordinal_ws
			by reference csid_pr_level
			by reference csid_pr_source
			by reference csid_pr_subtype_ws
			by reference csid_pr_subtype_ws_length
			by reference csid_pr_memo
			by reference csid_pr_memo_length
	returning csid_ret_stat

	If (Success_is in csid_ret_stat)
	Then
%^ Found a matching PRE SI.
	   move spaces to csid_acctg_method_ws
	   Perform GET_EXEC_PARAMS Thru
		   GET_EXEC_PARAMS_END
	   %Beg  Ent_ftr_set.Si_flgs.Pre_found = "Y" ;  %End
           If csid_acctg_method_ws = " " then
                move "P" to csid_acctg_method_ws
           end-if
	   %Beg  
	   BREAK: Csid_tmp_acc_set(NOMOD);
	   BREAK: Csid_tmp_grp_set;
	   BREAK: Csid_tmp_rel_reg;
	   Csid_temp_conn = Ent_d_acc_set state.conn;
	   %End
	   Set Failure_is in Csid_got_group to TRUE
	   If Csid_temp_conn = 0
	      %Beg 
	      ALLOC_TEMP: Csid_tmp_acc_set(MOD);
	      Csid_tmp_acc_set.Preadv_limit = <0>;
	      %End
	   ELSE
	      %Beg
	      Ent_d_acc_set EQUATE: Csid_tmp_acc_set(NOMOD,
			REG: Csid_tmp_rel_reg(NOMOD)) ;
	      %End
	      If (Dbt_concen_acc of Ent_debit_set NOT = SPACES )
		 %ace_conn_root_q Rel_acc_index ;
		 %Beg
		 SEARCH: Rel_acc_index (FORWARD, GEQ, .Rel_name_key 
			(.Idbank        = Ent_debit_set.Dbt_concen_acc.Idbank,
			 .Idtype        = Ent_debit_set.Dbt_concen_acc.Idtype,
			 .Idkey (.Idacc = Ent_debit_set.Dbt_concen_acc.Idkey,
				 .Idadr = NULL,
			         .Idpad = NULL ) ) ) ;
		 %End
	         If (Success_is of Rel_acc_index_status )
	            AND (Idbank of Rel_name_key of Rel_acc_index =
				   Idbank of Dbt_concen_acc of Ent_debit_set )
	            AND (Idtype of Rel_name_key of Rel_acc_index =
				Idtype of Dbt_concen_acc of Ent_debit_set )
	            AND (Idacc of Idkey of Rel_name_key of Rel_acc_index =
				  Idkey of Dbt_concen_acc of Ent_debit_set )
		 THEN
		    %Beg  
		    BREAK: Csid_tmp_acc_set;
		    Rel_acc_index CONN: Csid_tmp_acc_set;
		    %End
		 END-IF
	      ELSE
		 If (Group_preadvise of Menu_cfg = "T" ) Then
%^ Connect debit party on file group subjects if necessary.
		     If Grp_id of Csid_tmp_rel_reg is not = spaces
	  		%beg
			Csid_tmp_rel_reg(
		 	    .Grp_join CONN: Csid_grp_acc_seq(NOMOD));
			%End
			%ACE_IS Csid_grp_acc_seq connected giving
								Csid_got_group;
			If (Success_is in Csid_got_group)
			    %Beg
		  	    Csid_grp_acc_seq TOP: Csid_tmp_rel_union(
		   			NOMOD,
		   			.Grp_set CONN: Csid_tmp_grp_set(NOMOD));
			    BREAK: Csid_tmp_rel_union;
			    BREAK: Csid_grp_acc_seq;
			    %End
			END-IF
			%Beg  BREAK: Csid_tmp_rel_reg;  %End
		     END-IF
		END-IF
	   If (Check_preadv_limit of Menu_cfg = "T" )
                     and (csid_acctg_method_ws = "P")
	   THEN
	      If (Success_is in Csid_got_group )
	         If (Preadv_limit of Csid_tmp_grp_set = 0) then
	            %Beg
	            Ent_debit_set.Flgs.Dbt_ps_elig_flg = "L" ;
		    BREAK: Csid_tmp_acc_set;
	            BREAK: Csid_tmp_grp_set;
	            Csid_compose ^OUT(Csid_info_memo)
	    	      	"Found PRE SI with no preadvise limit",/;
	            %End
	            Perform X920_INFO_MEMO through X920_INFO_MEMO_END
                    GO TO B445_SCAN_PREVICE_END
	         END-IF

	         If (Preadv_limit_exp_date of Csid_tmp_grp_set 	not = 0
							    and < Menu_date_ws)
	            %Beg	      
	            BREAK: Csid_tmp_acc_set;
	            BREAK: Csid_tmp_grp_set;
	            Ent_debit_set.Flgs.Dbt_ps_elig_flg = "X" ;
	            Csid_compose ^OUT(Csid_info_memo)
	    	    	    "Found PRE SI but group ", Csid_tmp_grp_set.Grp_id,
		    	    " preadvise limit expired.",/; 
	            %End
	            Perform X920_INFO_MEMO through X920_INFO_MEMO_END
                    GO TO B445_SCAN_PREVICE_END
	         END-IF 
	      ELSE
	         If (Preadv_limit of Csid_tmp_acc_set = 0) then
	            %Beg
	            Ent_debit_set.Flgs.Dbt_ps_elig_flg = "L" ;
		    BREAK: Csid_tmp_acc_set;
	            BREAK: Csid_tmp_grp_set;
	            Csid_compose ^OUT(Csid_info_memo)
	    	      	"Found PRE SI with no preadvise limit",/;
	            %End
	            Perform X920_INFO_MEMO through X920_INFO_MEMO_END
                    GO TO B445_SCAN_PREVICE_END
	         END-IF

	         If (Preadv_limit_exp_date of Csid_tmp_acc_set 
						not = 0 and < Menu_date_ws)
	            %Beg	      
	            BREAK: Csid_tmp_acc_set;
	            BREAK: Csid_tmp_grp_set;
	            Ent_debit_set.Flgs.Dbt_ps_elig_flg = "X" ;
	            Csid_compose ^OUT(Csid_info_memo)
	    	    		"Found PRE SI but ", 
				Ent_debit_set.Dbt_typ.Dbt_idtype,"/",
	    	    		Ent_debit_set.Dbt_typ.Dbt_id, 
		    		" preadvise limit expired.",/; 
	            %End
	            Perform X920_INFO_MEMO through X920_INFO_MEMO_END
                    GO TO B445_SCAN_PREVICE_END
	         END-IF 
	      END-IF
	      %Beg  
	      BREAK: Csid_tmp_acc_set;
	      BREAK: Csid_tmp_grp_set;
               Ent_debit_set.Flgs.Dbt_ps_elig_flg = csid_acctg_method_ws;
	       Csid_compose ^OUT(Csid_info_memo)
	    	    "Found PRE SI and preadvise limit",/;
	       %End
	       Perform X920_INFO_MEMO through X920_INFO_MEMO_END
	   ELSE
	       %Beg  
               Ent_debit_set.Flgs.Dbt_ps_elig_flg = csid_acctg_method_ws;
	       Csid_compose ^OUT(Csid_info_memo)
	    	    "Found PRE SI",/;
	       %End
	       Perform X920_INFO_MEMO through X920_INFO_MEMO_END
	   END-IF
	ELSE
	    Add 1 to Csid_this_psflags
	    If (Csid_this_psflags > Csid_loop_limit ) 
%^ Do nothing for now
		Add 1 to Csid_this_more
	    END-IF
	    If (Dbt_ps_elig_flg of Flgs of Ent_debit_set NOT = "N" )
	        %Beg  Ent_debit_set.Flgs.Dbt_ps_elig_flg = "N" ;  %End
	    END-IF
	END-IF.

B445_SCAN_PREVICE_END.

   EXIT.
B450_SCAN_DEBIT_AINS.

%^ Check for the existence of a debit ain that should cause the
%^ debit party to be looked up again.
        Set Failure_is in Csid_debit_ain to TRUE.

%^ If the debit party has changed, the lookup will occur anyway.
%^   No need to set a special flag.
%^ If the debit party is locked, no need to check for AINs
%^ If nothing has changed on the creditside, no need to check for AINs
%^ No need to check AIN's  if it's a NOF party
        If (Debit_changed_ls NOT = 0) or
           (Lock_dbt_party_ls NOT = 0) or
           (Csid_change_debit = 0) or
           (Dbt_rel_id of Ent_debit_set = 0) then
            go to B450_SCAN_DEBIT_AINS_end
        end-if.

%^ Connect up the debit address
        %Beg
        BREAK: Relget_adr_set ;
        Ent_debit_set.dbt_adr_set_ptr CONN: Relget_adr_set(NOMOD) ;
%^        Csid_si_types = "AINDBT" ;
%^        Csid_number_sis = <1>;
%^        Csid_si_defer_ws = <0>;  %^ Don't interupt SI processing
        %End.
	%^ Do we need an UPDATE DEBIT party here?


	%beg csid_compose ^out(csid_pr_type_ws) "DBTAIN",/;
	     csid_pr_ordinal_ws = <0>;
	%end
	Set Bad_ml in Csid_pr_search_level to true.
	Set Bad_is in Csid_pr_search_source to true.
	Call "PRULE_MSG_RULE_MATCH_FROM" using
		By Reference csid_pr_type_ws
		By Reference csid_pr_type_ws_length
		By Reference Csid_pr_debit_side
		By Reference Csid_pr_search_level
		By Reference Csid_pr_search_source
		by Reference csid_pr_ordinal_ws
		by Reference csid_pr_level
		By Reference csid_pr_source
		by reference csid_pr_subtype_ws
		by reference csid_pr_subtype_ws_length
		By Reference Csid_pr_memo
		by reference csid_pr_memo_length
	returning Csid_debit_ain.


        %Beg BREAK: Relget_adr_set; %End.

B450_SCAN_DEBIT_AINS_end.

   EXIT.
C520_UPDATE_BNP.
* Paragraph to update BNP id from contents of Csid_party_id/idtype.
* Removed overflow logic - obsolete
	If (Bnp_id of Bnp of Ent_credit_set NOT = Csid_party_id )
		%Beg  Ent_credit_set.Bnp.Bnp_id = Csid_party_id ;  %End
	END-IF.
	If Bnp_idtype of Bnp of Ent_credit_set NOT = Csid_party_idtype 
	    %Beg  Ent_credit_set.bnp.bnp_idtype = Csid_party_idtype ;  %End
	END-IF.
	If (Bnp_bnk_flg of Ent_credit_set = SPACE OR "N" )
	  AND (Csid_party_idtype = "B" OR "A" OR "S" )
	THEN
            %Beg  Ent_credit_set.Bnp_bnk_flg = "Y";  %End
	END-IF.

	%^  Ensure that we fill in res_country if possible 

	If bnp_res_country of ent_credit_set = spaces
	    Initialize Csid_risk_country_ws, Csid_country_code_ws
	    If rel_id of relget_adr_set not = 0
		  %Ace_is relget_adr_set connected;
		  If success_is in ace_status_wf
	            Move risk_country of relget_adr_set to Csid_risk_country_ws
	            Move country_code of relget_adr_set to Csid_country_code_ws
		  end-if
	    end-if
	    Call "DETERM_RES_COUNTRY" using
	       by content "BNP"
	       by reference bnp_idtype of Ent_credit_set
	       by reference bnp_id of Ent_credit_set
	       by reference bnp_id_length of Ent_credit_set_lengths
	       by reference Csid_risk_country_ws
	       by reference Csid_country_code_ws
	       by reference bnp_res_country of Ent_credit_set
	       by reference Csid_res_country_ws
	    If Csid_res_country_ws not = spaces
	        %Beg Ent_credit_set.bnp_res_country = Csid_res_country_ws; %end
	    end-if
	end-if.

C520_UPDATE_BNP_END.
	EXIT.

C540_UPDATE_BBK.
* Paragraph to update BBK id from contents of Csid_party_id/idtype.
* Removed overflow logic - obsolete
	If (Bbk_id of Bbk of Ent_credit_set NOT = Csid_party_id )
		%Beg  Ent_credit_set.Bbk.Bbk_id = Csid_party_id ;  %End
	END-IF.
	If Bbk_idtype of Bbk of Ent_credit_set NOT = Csid_party_idtype 
	    %Beg  Ent_credit_set.bbk.bbk_idtype = Csid_party_idtype ;  %End
	END-IF.


	%^  Ensure that we fill in res_country if possible

	If bbk_res_country of ent_credit_set = spaces and 
	   Bbk_idtype of Bbk of Ent_credit_set NOT = Spaces and
	   Bbk_id of Bbk of Ent_credit_set NOT = Spaces
	Then
	    Initialize Csid_risk_country_ws, Csid_country_code_ws
	    If rel_id of relget_adr_set not = 0
	    Then
		  %Ace_is relget_adr_set connected;
		  If success_is in ace_status_wf
		  Then
	            Move risk_country of relget_adr_set to Csid_risk_country_ws
	            Move country_code of relget_adr_set to Csid_country_code_ws
		  end-if
	    end-if
	    Call "DETERM_RES_COUNTRY" using
	       by content "BBK"
	       by reference bbk_idtype of Ent_credit_set
	       by reference bbk_id of Ent_credit_set
	       by reference bbk_id_length of Ent_credit_set_lengths
	       by reference Csid_risk_country_ws
	       by reference Csid_country_code_ws
	       by reference bbk_res_country of Ent_credit_set
	       by reference Csid_res_country_ws
	    If Csid_res_country_ws not = spaces
	    Then
	        %Beg Ent_credit_set.bbk_res_country = Csid_res_country_ws; %end
	    end-if

	    %^ 115131 if BBK changed and they didn't enter BNP mailing country, set BNP Mailing country
	    %^ 116032 only if BBK has changed or the bnp_mailing_country is spaces
	    If (Bnp_mailing_country of Ent_credit_set = Bnp_mailing_country of Change_credit_set or
		Bnp_mailing_country of Ent_credit_set = SPACES) and
               (Bbk of Ent_credit_set not = Bbk of Change_credit_set or
                Bnp_mailing_country of Ent_credit_set = SPACES) and 
	       (Bnp_bnk_flg of Ent_credit_set not = "Y") then

		%beg ent_credit_set.bnp_mailing_country = ent_credit_set.Bbk_res_country; %end
	    End-if
	end-if.

C540_UPDATE_BBK_END.


   EXIT.
C560_UPDATE_IBK.
* Paragraph to update IBK id from contents of Csid_party_id/idtype.
* Removed overflow logic - obsolete
	If (Ibk_id of Ibk of Ent_credit_set NOT = Csid_party_id )
		%Beg  Ent_credit_set.Ibk.Ibk_id = Csid_party_id ;  %End
	END-IF.
	If Ibk_idtype of Ibk of Ent_credit_set NOT = Csid_party_idtype 
	    %Beg  Ent_credit_set.ibk.ibk_idtype = Csid_party_idtype ;  %End
	END-IF.

	%^	Ensure that we fill in res_country if possible

	If ibk_res_country of ent_credit_set = spaces
	    Initialize Csid_risk_country_ws, Csid_country_code_ws
	    If rel_id of relget_adr_set not = 0
		  %Ace_is relget_adr_set connected;
		  If success_is in ace_status_wf
	            Move risk_country of relget_adr_set to Csid_risk_country_ws
	            Move country_code of relget_adr_set to Csid_country_code_ws
		  end-if
	    end-if
	    Call "DETERM_RES_COUNTRY" using
	       by content "IBK"
	       by reference ibk_idtype of Ent_credit_set
	       by reference ibk_id of Ent_credit_set
	       by reference ibk_id_length of Ent_credit_set_lengths
	       by reference Csid_risk_country_ws
	       by reference Csid_country_code_ws
	       by reference ib1_res_country of Ent_credit_set
	       by reference Csid_res_country_ws
	    If Csid_res_country_ws not = spaces
	        %Beg Ent_credit_set.ibk_res_country = Csid_res_country_ws; %end
	    end-if
	end-if.
C560_UPDATE_IBK_END.


   EXIT.
C580_UPDATE_IB1.
* Paragraph to update IB1 id from contents of Csid_party_id/idtype.
* Removed overflow logic - obsolete
	If (Ib1_id of Ib1 of Ent_credit_set NOT = Csid_party_id )
		%Beg  Ent_credit_set.Ib1.Ib1_id = Csid_party_id ;  %End
	END-IF.
	If Ib1_idtype of Ib1 of Ent_credit_set NOT = Csid_party_idtype 
	    %Beg  Ent_credit_set.ib1.ib1_idtype = Csid_party_idtype ;  %End
	END-IF.

	%^	Ensure that we fill in res_country if possible

	If ib1_res_country of ent_credit_set = spaces
	    Initialize Csid_risk_country_ws, Csid_country_code_ws
	    If rel_id of relget_adr_set not = 0
		  %Ace_is relget_adr_set connected;
		  If success_is in ace_status_wf
	            Move risk_country of relget_adr_set to Csid_risk_country_ws
	            Move country_code of relget_adr_set to Csid_country_code_ws
		  end-if
	    end-if
	    Call "DETERM_RES_COUNTRY" using
	       by content "IB1"
	       by reference ib1_idtype of Ent_credit_set
	       by reference ib1_id of Ent_credit_set
	       by reference ib1_id_length of Ent_credit_set_lengths
	       by reference Csid_risk_country_ws
	       by reference Csid_country_code_ws
	       by reference ib1_res_country of Ent_credit_set
	       by reference Csid_res_country_ws
	    If Csid_res_country_ws not = spaces
	        %Beg Ent_credit_set.ib1_res_country = Csid_res_country_ws; %end
	    end-if
	end-if.

C580_UPDATE_IB1_END.


   EXIT.
C600_CREDIT_FAIL.
*
* RELGET could not find the credit party.
*
* If an ABA number was returned from the AUX database, the Fed preferred bank
* might not yet be in the credit Id and the Cdt_adr_bnk_id.
* Note that for FED payments, (that is, for Cdt_idtype = "A"),
* tran type "BPF" will bypass the preferred FED pay bank,
	If (Cdt_idtype of Ent_credit_set = "A")
	    AND (Tran_type of Typ of Ent_ftr_set NOT = "BPF")
	    AND (Preferred_fed_bnk_id of Menu_bnk_union NOT = SPACES)
	THEN
	    If (Cdt_id of Ent_credit_set(4:1) NOT = ":" )
		%Beg
		Csid_temp1_vstr = Ent_credit_set.cdt_typ.cdt_id;
		Csid_compose ^OUT(Ent_credit_set.cdt_typ.cdt_id),
			Menu_bnk_union.preferred_fed_bnk_id, ":",
			Csid_temp1_vstr, /;
		%End
	    END-IF
	    Move Preferred_fed_bnk_id of Menu_bnk_union to Relget_return_bank
            If (Cdt_adr_bnk_id of Ent_credit_set NOT =
					Preferred_fed_bnk_id of Menu_bnk_union )
                %Beg
		Ent_credit_set.Cdt_adr_bnk_id =
					   Menu_bnk_union.preferred_fed_bnk_id ;
		%End
            END-IF
	END-IF.

* If this is a not-on-file SWIFT Id, try converting it to an ABA by using
* the SWIFT-to-ABA cross-reference index in the AUX database.
* Except when the source is "FED".
	If (Cdt_idtype of Ent_credit_set = "S")
	   AND (Src_code of Ent_ftr_set not = "FED")
	THEN
	    Perform D720_CDT_SWF_TO_ABA thru D720_CDT_SWF_TO_ABA_END
	END-IF.

	Perform D700_NOF_CDT_BANK thru D700_NOF_CDT_BANK_END.

	Set Failure_is in Csid_found_it to TRUE.
	If (Cdt_rel_id of Ent_credit_set NOT = ZERO ) Or
	   (Cdt_adr_ptr_ok in Flgs3 of Ent_credit_set = "T")
	Then
* last lookup succeeded -- current lookup failed -- erase name/addr info
	    Set Success_is in Csid_found_it to TRUE
	    %Beg
            Ent_credit_set( .Cdt_name1  = NULL ,
                            .Cdt_name2  = NULL ,
                            .Cdt_name3  = NULL ,
                            .Cdt_name4  = NULL ,
			    .Cdt_shnam = NULL  ,
			    .flgs3.cdt_adr_ptr_ok = Null);
            %^ No longer always true, AUX needs to stay connected
	    %^ Correct connection status will be maintained by REL_GET BREAK: Relget_adr_set;
            BREAK: Ent_c_adr_set;
            %End
            %^ Clear all the other stuff left over from previous
            %^   on-file address
	    Add 1 to Csid_this_deletes
	    If (Csid_this_deletes > Csid_loop_limit ) 
%^ Do nothing for now
		Add 1 to Csid_this_more
	    END-IF
            Call "ACCTSUB_CDT_NOF"
            MOVE "N" to Cdt_comm_charge_ws
            MOVE "N" to Cdt_cbl_charge_ws
	END-IF.

	If (Relget_msgcode_length = 0)
	    If (Cdt_ovr of Cdt_typ of Ent_credit_set NOT = "?" )
		%Beg  Ent_credit_set.cdt_typ.Cdt_ovr = "?";  %End
	    END-IF
	ELSE
	    If (Cdt_ovr of Cdt_typ of Ent_credit_set NOT = "*")
	        %Beg  Ent_credit_set.cdt_typ.cdt_ovr = "*";  %End
	    END-IF
	END-IF.

* Nothing was found on our database, but RELGET might have found
* an Relget_adr_set on one of the auxiliary databases (FED, SWF, UID, or CIF).

	If (Relget_msgcode NOT = Vmsg_dat_notonfile_wc )
	    AND (Success_is in Csid_found_it )
	THEN
	    %Beg  Ent_credit_set.cdt_shnam = NULL ;  %End
	END-IF.

	If (Relget_msgcode NOT = Vmsg_dat_notonfile_wc ) And
	   (Csid_lkup_pend_del NOT = "T")
	Then
	    If (cdt_idtype of cdt_typ of Ent_credit_set = "S")
	      AND (Swift_adr_nof_warning of Menu_cfg = "T")
	    THEN
%^		%Beg  Ftrscr.Credit.cdt_typ.cdt_id.Msg =  "ftrscr$_inv_swf_id";  %End
 	    	%Beg
	    	screen_field_ws = "credit.cdt_typ.cdt_id";
            	error_mnemonic_ws = "FTRSCR$_INV_SWF_ID";
	    	%End
	    	call "FTRSCR_WRITE_ERROR" using
	    	  by reference screen_field_ws
	    	  by reference error_mnemonic_ws
		Add 1 to Csid_bogus_parties
		Add 1 to Cdt_errmemo_count_ls
		Set Failure_is in Creditside_screen_ls to TRUE
	    END-IF
	END-IF.

C600_CREDIT_FAIL_end.


   EXIT.
C620_COPY_ADDRESS.
%^ Copies address from Relget_adr_set to Credit party.  Also does zip code.
%^      Do not increment database to initialize fields
	If (Adr_name_length of Relget_adr_set_lengths = ZERO )
	   AND (Cdt_name1_length of Ent_credit_set_lengths NOT = ZERO )
	THEN
 	    %Beg  Ent_credit_set.Cdt_name1 = NULL;  %End
	END-IF.
	If (Adr1_length of Relget_adr_set_lengths = ZERO )
	    AND (Cdt_name2_length of Ent_credit_set_lengths NOT = ZERO )
	THEN
 	    %Beg  Ent_credit_set.Cdt_name2 = NULL;  %End
	END-IF.
	If (Adr2_length of Relget_adr_set_lengths = ZERO )
	    AND (Cdt_name3_length of Ent_credit_set_lengths NOT = ZERO )
	THEN
 	    %Beg  Ent_credit_set.Cdt_name3 = NULL;  %End
	END-IF.
	If (Adr3_length of Relget_adr_set_lengths = ZERO )
	    AND (Cdt_name4_length of Ent_credit_set_lengths NOT = ZERO )
	THEN
 	    %Beg  Ent_credit_set.Cdt_name4 = NULL;  %End
	END-IF.
	If (Fed_short_name_length of Relget_adr_set_lengths = ZERO )
	THEN
 	    %Beg  Ent_credit_set.Cdt_shnam = NULL;  %End
	END-IF.
	%Beg
	Csid_Compose Relget_adr_set (
	  .Adr_name (^IF_NOTNULL(^OUT(Ent_credit_set.Cdt_name1), ^_, /)),
	  .Adr1 (^IF_NOTNULL(^OUT(Ent_credit_set.Cdt_name2), ^_, /)),
	  .Adr2 (^IF_NOTNULL(^OUT(Ent_credit_set.Cdt_name3), ^_, /)),
	  .Adr3(^IF_NOTNULL(^OUT(Ent_credit_set.Cdt_name4), ^_, /)),
	  .Fed_short_name(^IF_NOTNULL(^OUT(Ent_credit_set.Cdt_shnam),^_, /))) ;
%^ Build a CDT_ADR_TYPE field from country code and 
%^   ADR_TYPE field of Relget_adr_set
	Csid_Compose ^OUT(Ent_credit_set.Cdt_adr_type),
		Relget_adr_set.Country_code(^STRING<2>),
		Relget_adr_set.Adr_type, /;
	%End.

%^ copy in the zip code too
	If (Zip of Relget_adr_set NOT = SPACES )
	    Call "ZIPSUB" Using
		by reference Cdt_name4 of Ent_credit_set
		by reference Cdt_name4_length of Ent_credit_set_lengths
		by reference Cdt_name3 of Ent_credit_set
		by reference Cdt_name3_length of Ent_credit_set_lengths
		by reference Zip of Relget_adr_set
		by reference Line_flg_ws

	    EVALUATE Line_flg_ws
		WHEN "4"
		    %Beg  Ent_credit_set.Cdt_name4 CHANGE;  %End

		WHEN "3"
		    %Beg  Ent_credit_set.Cdt_name3 CHANGE;  %End

	    END-EVALUATE
	END-IF.

%^
%^ May be required here
%^           Ent_credit_set(.Cdt_rel_id = Ent_c_adr_set.Rel_id,
%^                          .Cdt_adr_set_ptr POINT: Ent_c_adr_set,
%^			    .flgs3.cdt_adr_ptr_ok = "T");
%^
%^
%^	Also set this info up for the Prule matching 
%^

%^ moved from B280_CDT_PARTY - happening too soon for IBAN Pushdowns
%^ If Credit party changed, change the country too if not differently entered.

	If (cdt_res_country of Ent_credit_set = cdt_res_country of Change_credit_set)
	AND  ( cdt_typ of ent_credit_set NOT = cdt_typ of Change_credit_set) %^ 107747
	Then
		%beg Ent_credit_set.cdt_res_country = NULL; %end
	end-if.


	If cdt_res_country of ent_credit_set = spaces
	    Initialize Csid_risk_country_ws, Csid_country_code_ws
	    If rel_id of relget_adr_set not = 0
		  %Ace_is relget_adr_set connected;
		  If success_is in ace_status_wf
	            Move risk_country of relget_adr_set to Csid_risk_country_ws
	            Move country_code of relget_adr_set to Csid_country_code_ws
		  end-if
	    end-if
	    Call "DETERM_RES_COUNTRY" using
	       			by content "CDT"
				by reference cdt_idtype of Ent_credit_set
	       			by reference cdt_id of Ent_credit_set
	       			by reference cdt_id_length of Ent_credit_set_lengths
	       			by reference Csid_risk_country_ws
	       			by reference Csid_country_code_ws
	       			by reference cdt_res_country of Ent_credit_set
	       			by reference Csid_res_country_ws
   	     If Csid_res_country_ws not = spaces
	       		%Beg ent_credit_set.cdt_res_country = Csid_res_country_ws; %end
	      end-if
	end-if.

	Perform X930_CHANGE_CREDIT thru
		X930_CHANGE_CREDIT_END.

C620_COPY_ADDRESS_END.

   EXIT.
C640_PUSH_CREDIT.

* Checks to make sure that there's an available creditside slot.
* Then calls PUSH_CREDIT_PARTY to push credit party down.oundf

	If (Ib1_id of Ib1 of Ent_credit_set NOT = SPACES )
	    %^  No place to push into.
	    Set Failure_is in Csid_ret_stat to true
	ELSE
    	    If (Cdt_id     of Cdt_typ of Ent_credit_set = Spaces and
	        Cdt_idtype of Cdt_typ of Ent_credit_set = Spaces) And
		cdt_name1 of Ent_credit_set = Spaces
	    Then
		%^ Nothing to Push, CDT party was blank,
		%^ treat as a sub.
		Set Success_is in Csid_ret_stat to True
	    Else
	    	%^ UID handling for CR12949
    	    	%beg csid_tmp_bnk_ws = Ent_ftr_set.loc_info.bank; %end
	    	If cdt_idtype of cdt_typ of Ent_credit_set = "C" And
	       	    Cdt_id of cdt_typ of Ent_credit_set(4:1) = ":" Then
	            %^ Strip the bank off the Pushed ID to allow for  CHIPS qualification
	            %^ BUT send the bank of the ID in, not the bank of the Owner
		    %beg
                        Csid_parse ^IN(Ent_credit_set.cdt_typ.cdt_id),
                           	csid_tmp_bnk_ws,":", Csid_temp1_vstr,/;
		    %end
		    If Success_is in Csid_parse_status
		    Then
			%beg
				ent_credit_set.cdt_typ.cdt_id = Csid_temp1_vstr;
			%end
		    end-if
	        End-if
	        CALL "PUSH_CREDIT_PARTY" USING
		        By reference csid_tmp_bnk_ws		%^Bank of Loc_info of Ent_ftr_set
			By reference Csid_pref_next_id_rec
			By reference Csid_pref_next_id_rec_lengths
			By reference Csid_pushed_credit
		      RETURNING Csid_ret_stat
	    end-if
	END-IF.

	If (Success_is in Csid_ret_stat   )
	    AND (Credit_depth_ls = 0 )
	THEN
	    Move Csid_pushed_credit to Credit_depth_ls
	    %^ If we pushed a UID, we need to try to qualify it, setup for a lookup - CR12949
	    If cdt_idtype of cdt_typ of Ent_credit_set = "C" And
	       Idtype of csid_pref_corr_rec = "P"
	    Then %^	       Cdt_id of cdt_typ of Ent_credit_set(4:1) = ":" Then
		Evaluate Csid_pushed_credit
			When 1
				Move 1 to IB1_changed_ls
			When 2
				Move 1 to IBK_changed_ls
			When 3
				Move 1 to BBK_changed_ls
			When 4 
				Move 1 to BNP_changed_ls
		End-if
		Move 0 to Csid_pushed_credit
	END-IF.

	%^ create another Channel_determination call
	Set Failure_is in Csid_Chdet_called to True. 


	If (Failure_is in Csid_ret_stat   )
	    %^  No place to push into.
%^	    %Beg Ftrscr.Credit.cdt_typ.cdt_id.Msg = "VMSG$_NOMORE_PARTIES";
            %Beg
	    screen_field_ws = "credit.cdt_typ.cdt_id";
            error_mnemonic_ws = "VMSG$_NOMORE_PARTIES";
	    %End
	    call "FTRSCR_WRITE_ERROR" using
	      by reference screen_field_ws
	      by reference error_mnemonic_ws
	    %Beg
	    Csid_compose ^OUT(Csid_info_memo),
		"No creditside slots for preferred corr ",
		    Csid_pref_corr_rec, / ;
	    %End
	    Perform X920_INFO_MEMO through X920_INFO_MEMO_END
	    Set Failure_is in Creditside_screen_ls to true
	    Set Success_is in Csid_push_error to TRUE
	    Move ZERO to Cdt_not_suspect_ls
            %^ Reconnect the current Ent_c_adr_set if necessary
            If Cdt_rel_id of Ent_credit_set not = 0 Or
	       cdt_adr_ptr_ok of flgs3 of ent_credit_set = "T" Then
		%ACE_IS Ent_c_adr_set connected giving Csid_conn_stat;
                If (Failure_is in Csid_conn_stat )
                THEN
                    %Beg
		    Ent_c_adr_set(NOTRAP);
		    Ent_credit_set(NOTRAP);
                    Ent_credit_set.Cdt_adr_set_ptr CONN: Ent_c_adr_set(NOMOD) ;
		    Ent_c_adr_set(ETRAP);
		    Ent_credit_set(ETRAP);
                    %End
                END-IF
	        %ACE_IS Relget_adr_set connected giving Csid_conn2_stat;
                If (Csid_conn2_stat = 0 ) or
		   (Rel_id of Relget_adr_set not = Rel_id of Ent_c_adr_set)
                THEN
                    %Beg
        	    BREAK: Relget_adr_set;
        	    Ent_c_adr_set EQUATE: Relget_adr_set(NOMOD) ;
                    %End
                END-IF
	      ELSE
		%Beg
                    Ent_credit_set( .Cdt_rel_id        = <0> ,
                                    .Cdt_adr_set_ptr DELETE,
				    .flgs3.cdt_adr_ptr_ok = Null) ;
            
			BREAK: Ent_c_adr_set;
			BREAK: Relget_adr_set;
		%End
		Move zeroes to Rel_id of Relget_adr_set
	    END-IF
	Else
		%^ If a warning message was present in the credit party,
		%^ push that down too
 		%^ First get the .MSG field of ftrscr.credit.cdt_typ.cdt_id.
		%Beg
		Screen_field_ws = "credit.cdt_typ.cdt_id";
		%End
		Call "FTRSCR_GET_FLDMSG" Using
                  By Reference screen_field_ws    	%^ In
	          By Reference tmp_scr_stat_ws 		%^ Out
	          By Reference tmp_scr_stat_ws_length	%^ Out

 		%^ Next write it to the .MSG field of ftrscr.credit.bnp_id.
		%Beg
		screen_field_ws = "credit.bnp.bnp_id";
	        error_mnemonic_ws = tmp_scr_stat_ws;
	        %End
	        Call "FTRSCR_WRITE_ERROR" using
	          by reference screen_field_ws
	          by reference error_mnemonic_ws

 		%^ Then clear out the .MSG field of ftrscr.credit.cdt_typ.cdt_id.
		%Beg
		screen_field_ws = "credit.cdt_typ.cdt_id";
	        error_mnemonic_ws = "";
	        %End
	        Call "FTRSCR_WRITE_ERROR" using
	          by reference screen_field_ws
	          by reference error_mnemonic_ws

		%^ If Not Expanding an IBAN, need to push down change flags
		If Failure_is in Csid_iban_expanded and
		   Chg_cdt of Change_fields of Ent_ftr_set not = SPACES then

			Evaluate TRUE
			   When  (Ib1_id of Ib1 of Ent_credit_set NOT = SPACES or
		      		  Ib1_name1_length of Ent_credit_set_lengths NOT = ZERO)
					%Beg 
					Ent_ftr_set.Change_fields.Chg_ib1 = Ent_ftr_set.change_fields.Chg_cdt;
					Ent_ftr_set.change_fields.Chg_cdt = NULL; 
					%End

			   When  (Ibk_id of Ibk of Ent_credit_set NOT = SPACES or
		          	  Ibk_name1_length of Ent_credit_set_lengths NOT = ZERO)
					%Beg 
					Ent_ftr_set.Change_fields.Chg_ibk = Ent_ftr_set.change_fields.Chg_cdt;
					Ent_ftr_set.change_fields.Chg_cdt = NULL; 
					%End
			
			   When  (Bbk_id of Bbk of Ent_credit_set NOT = SPACES or
			          Bbk_name1_length of Ent_credit_set_lengths NOT = ZERO)
					%Beg 
					Ent_ftr_set.Change_fields.Chg_Bbk = Ent_ftr_set.change_fields.Chg_cdt;
					Ent_ftr_set.change_fields.Chg_cdt = NULL; 
					%End
			   When  (Bnp_id of Bnp of Ent_credit_set NOT = SPACES or
			      	  Bnp_name1_length of Ent_credit_set_lengths NOT = ZERO)
					%Beg 
					Ent_ftr_set.Change_fields.Chg_Bnp = Ent_ftr_set.change_fields.Chg_cdt;
					Ent_ftr_set.change_fields.Chg_cdt = NULL; 
					%End
			End-evaluate
		End-if
	END-IF.

	If Success_is in TGT2_subpartic
	Then
		Set Failure_is in TGT2_subpartic to True
		  %Beg 
	 	  Compose ^OUT(csid_prm_name_ws) "MTS$TARGET_SUBPARTICIPANT", /; 
		  Compose ^OUT(csid_prm_value_ws) "Y", /;
		  csid_Prm_level_wo msg_is;
		  csid_Prm_source_wo msg_is;
		  csid_Prm_edit_wo Text_is;
		  %End
		  Initialize csid_prm_time_on_ws, csid_prm_time_off_ws
		  Initialize csid_prm_remaining_ws
		  Set Success_is in csid_prm_mode_wf to True
		  Call "PRULE_MSG_UPDATE_PARAM" using
			   by reference csid_prm_name_ws,	  %^ vstr(40)
			   by reference csid_prm_name_ws_length,  %^ length
			   by reference csid_prm_level_wo, 	  %^ PRULE_LEVEL_ONEOF.DDF
			   by reference csid_prm_source_wo, 	  %^ PRULE_SOURCE_ONEOF.DDF
			   by reference csid_prm_time_on_ws,	  %^ time
			   by reference csid_prm_time_off_ws,	  %^ time
			   by reference csid_prm_edit_wo, 	  %^ PR_PARAM_EDIT_ONEOF.DDF
			   by reference csid_prm_mode_wf,	  %^ boolean
			   by reference csid_prm_remaining_ws	  %^ long
			   by reference csid_prm_value_ws,	  %^ vstr(80)
			   by reference csid_prm_value_ws_length, %^ length
			   by reference csid_prm_present_wf, 	  %^ boolean
			   by reference csid_prm_memo_ws,	  %^ vstr(ACE$_MSG_STR_SIZE)
			   by reference csid_prm_memo_ws_length	  %^ length
			   returning csid_prm_status_wf		  %^ boolean
	End-if.

	If (Csid_tgt_account_bic NOT = SPACES)
	Then
		  %Beg 
	 	  Compose ^OUT(csid_prm_name_ws) 
			"MTS$TARGET_ACCOUNT_BIC", / ;
		  csid_Prm_level_wo msg_is;
		  csid_Prm_source_wo msg_is;
		  csid_Prm_edit_wo Text_is;
		  %End
		  Initialize csid_prm_time_on_ws, csid_prm_time_off_ws
		  Initialize csid_prm_remaining_ws
		  Set Success_is in csid_prm_mode_wf to True
		  Call "PRULE_MSG_UPDATE_PARAM" using
			   by reference csid_prm_name_ws,	  %^ vstr(40)
			   by reference csid_prm_name_ws_length,  %^ length
			   by reference csid_prm_level_wo, 	  %^ PRULE_LEVEL_ONEOF.DDF
			   by reference csid_prm_source_wo, 	  %^ PRULE_SOURCE_ONEOF.DDF
			   by reference csid_prm_time_on_ws,	  %^ time
			   by reference csid_prm_time_off_ws,	  %^ time
			   by reference csid_prm_edit_wo, 	  %^ PR_PARAM_EDIT_ONEOF.DDF
			   by reference csid_prm_mode_wf,	  %^ boolean
			   by reference csid_prm_remaining_ws,	  %^ long
			   by reference Csid_tgt_account_bic,	  %^ value
			   by reference Csid_tgt_account_bic_length, %^ length
			   by reference csid_prm_present_wf, 	  %^ boolean
			   by reference csid_prm_memo_ws,	  %^ vstr(ACE$_MSG_STR_SIZE)
			   by reference csid_prm_memo_ws_length	  %^ length
			   returning csid_prm_status_wf		  %^ boolean
		%Beg  Csid_tgt_account_bic = NULL;  %End
	End-if.
C640_PUSH_CREDIT_END.

   EXIT.
C650_LOOKUP_BBK_ADDRESS.

%^ If the secondary wire flag has a chance of being defaulted to "Y",
%^ then do a REL lookup of the BBK address.  Valdate_edit will determine if
%^ preadvising needs to be done for the message, and if so, Ftrscr_edits will
%^ set the Bbk_secwir flag to "Y".  If the Bbk_secwir flag is set to "Y",
%^ the REL will then be needed for destination info.
%^ Look for a SWIFT ID with no parenthesis
* Removed overflow from compose - obsolete
        %Beg
        Csid_compose ^OUT(Csid_temp1_vstr)
                        Ent_credit_set.Bbk.Bbk_id, / ;
        Csid_parse ^IN(Csid_temp1_vstr)
                        ^STRING, "/BC", Csid_temp2_vstr,
                        ^ONEOF ( ("/", ^STRING, / ),
                                 (/) ) ;
        %End.

%^ If there's a SWIFT ID, we don't need to lookup the REL Address.
        If (Success_is in Csid_parse_status   )
            Go to C650_LOOKUP_BBK_ADDRESS_end
        END-IF.

%^ Look for a SWIFT ID with parentheses
        %Beg
        Csid_parse ^IN(Csid_temp1_vstr),
                        ^STRING, "/(BC", Csid_temp2_vstr,
                        ^ONEOF ( ("/", ^STRING, / ),
                                 (")", ^STRING, / ),
                                 (/) ) ;
        %End.

%^ If there's a SWIFT ID, we don't need to lookup the REL Address.
        If (Success_is in Csid_parse_status   )
            Go to C650_LOOKUP_BBK_ADDRESS_end
        END-IF.

%^ Set up the temporary Idtype and ID
        %Beg
        Csid_parse ^IN(Csid_temp1_vstr)
            Csid_lookup_temp, ^ONEOF ( ("/", ^STRING, / ),
                                       ("(", ^STRING, / ),
                                       (/) ) ;
        Csid_temp_idtype = Ent_credit_set.Bbk.Bbk_idtype ;
        %End.

%^ If there's no idtype, look for a CH, FW or CP second party
        If Csid_temp_idtype = " " then
            %Beg
            Csid_parse ^IN(Csid_temp1_vstr)
                ^STRING,
                Csid_oneof_bbk( ^ONEOF(
                          ("/CH",|Csid_temp2_vstr, ^SPACE, /),
                          ("/(CH",|Csid_temp2_vstr, ^SPACE, /),
                          ("/FW",|Csid_temp2_vstr, ^SPACE, /),
                          ("/(FW",|Csid_temp2_vstr, ^SPACE, /),
                          ("/CP",|Csid_temp2_vstr, ^SPACE, /)
                          ("/(CP",|Csid_temp2_vstr, ^SPACE, /) ));
            %End
            If Success_is in Csid_parse_status  
                %Beg
                Csid_parse ^IN(Csid_temp2_vstr)
                    Csid_lookup_temp, ^ONEOF ( ("/", ^STRING, / ),
                                               (")", ^STRING, / ),
                                               ("(", ^STRING, / ),
                                               (/) ) ;
                %End
                Evaluate TRUE
                    When Csid_oneof_bbk = 0 OR 1
                        Move "C" to Csid_temp_idtype
                    When Csid_oneof_bbk = 2 OR 3
                        Move "A" to Csid_temp_idtype
		    When (Csid_oneof_bbk = 4 OR 5)
			If (Cdt_adr_bnk_id of Ent_credit_set NOT = SPACES )
			    %Beg
			    Csid_acc_bank_ws = Ent_credit_set.Cdt_adr_bnk_id;
			    %End
			ELSE
			    %Beg
			    Csid_acc_bank_ws = Ent_ftr_set.Loc_info.Bank;
			    %End
			END-IF
			Call "IS_SWF_CLEARHOUSE" Using
			    By Reference Csid_acc_bank_ws
			    By content "CP"
			  Returning Csid_itsa_clearhouse
			If (Success_is in Csid_itsa_clearhouse)
			    Move "P" to Csid_temp_idtype
		 	ELSE
%^ Else set up "CP" as an extended ID
			    Move "E" to Csid_temp_idtype
			    %Beg
			    Csid_clip_compose ^OUT(Csid_temp1_vstr)
			        Csid_lookup_temp, / ;
			    %End
			    Move Csid_temp1_vstr to Csid_lookup_temp(3:)
			    Move "CP" To Csid_lookup_temp (1:2)
			    Add 2 To Csid_lookup_temp_length
			END-IF

                END-EVALUATE
              ELSE
                go to C650_LOOKUP_BBK_ADDRESS_end
            end-if
        end-if.

%^ If the idtype is E, look for a CH, FW or CP party
        If Csid_temp_idtype = "E" then
            %Beg
            Csid_parse ^IN(Csid_temp1_vstr)
                Csid_oneof_bbk( ^ONEOF(
                          ("CH",|Csid_temp2_vstr, ^SPACE, /),
                          ("FW",|Csid_temp2_vstr, ^SPACE, /),
                          ("CP",|Csid_temp2_vstr, ^SPACE, /) ));
            %End
            If Success_is in Csid_parse_status  
                %Beg
                Csid_parse ^IN(Csid_temp2_vstr)
                    Csid_lookup_temp, ^ONEOF ( ("/", ^STRING, / ),
                                               (")", ^STRING, / ),
                                               ("(", ^STRING, / ),
                                               (/) ) ;
                %End
                Evaluate TRUE

                    When Csid_oneof_bbk = 0
                        Move "C" to Csid_temp_idtype
                    When Csid_oneof_bbk = 1
                        Move "A" to Csid_temp_idtype

		    When Csid_oneof_bbk = 2
			If (Cdt_adr_bnk_id of Ent_credit_set NOT = SPACES )
			    %Beg
			    Csid_acc_bank_ws = Ent_credit_set.Cdt_adr_bnk_id;
			    %End
			ELSE
			    %Beg
			    Csid_acc_bank_ws = Ent_ftr_set.Loc_info.Bank;
			    %End
			END-IF
			Call "IS_SWF_CLEARHOUSE" Using
			    By Reference Csid_acc_bank_ws
			    By content "CP"
			  Returning Csid_itsa_clearhouse
			If (Success_is in Csid_itsa_clearhouse)
			    Move "P" to Csid_temp_idtype
		 	ELSE
%^ Else set up "CP" as an extended ID
			    Move "E" to Csid_temp_idtype
			    %Beg
			    Csid_clip_compose ^OUT(Csid_temp1_vstr)
			        Csid_lookup_temp, / ;
			    %End
			    Move Csid_temp1_vstr to Csid_lookup_temp(3:)
			    Move "CP" To Csid_lookup_temp (1:2)
			    Add 2 To Csid_lookup_temp_length
			END-IF
                END-EVALUATE
              ELSE
                go to C650_LOOKUP_BBK_ADDRESS_end
            end-if
        end-if.

        Set BBK in Relget_title_flag to TRUE
	Move Spaces to Csid_lkup_pend_del	
	%Beg  Csid_next_function = Menu_next_function;  %End.
        Call "REL_GET" USING
            By reference Csid_temp_idtype
            By reference Csid_lookup_temp
            By reference Csid_lookup_temp_length
	    by reference Csid_lkup_pend_del
          RETURNING Csid_ret_stat.

        If (Success_is in Csid_ret_stat   )
            %Beg
            Ent_credit_set(.Bbk_rel_id = Relget_adr_set.rel_id,
                           .Bbk_adr_set_ptr POINT: Relget_adr_set,
			   .flgs3.bbk_adr_ptr_ok = "T");
            %End
        END-IF.



C650_LOOKUP_BBK_ADDRESS_END.

   EXIT.

%^
%^	TO DO  - NEED to see how to use this with Ambiguos, possibly just
%^	change the REL_GET to ACCOUNT_LOOKUP, since this is a hit or miss 
%^	scenario
%^
%^C650_BBK_ADDRESS_CONN.
%^
%^	Caller controlled state.
%^	
%^	Call "RELGET_CONNECT" USING 
%^	    by reference Csid_lkup_pend_del
%^	  RETURNING Csid_ret_stat.
%^
%^C650_BBK_ADDRESS_CONN_END.
%^	EXIT.

C660_LOWER_CREDIT.

* Finds subsidiary creditside party which may be identified by multiple IDs. 
* Full ID is in Csid_party_idtype and Csid_party_id.  Status of lookup is 
* returned in Csid_ret_stat and Csid_ovr.  All IDs must agree for the lookup to
* succeed and have its address used (Csid_ovr = SPACE, Csid_ret_stat SUCCESS).
* If any ID cannot be done, name and address should not be used but lookup
* has not failed, either.  Csid_ret_stat is success, but Csid_ovr is *.
* If any two IDs conflict, Csid_ret_stat is FAILURE and Csid_ovr is ?.
*
%^ We still need to try the lookup

	Move "*" to Csid_ovr.
	Set Success_is in Csid_ret_stat to true.
	Move ZERO to Csid_lc_error.
	%Beg  
	Csid_lc_aba = NULL ;
	Csid_lc_account = NULL ;
	Csid_lc_partic = NULL ;
	Csid_lc_swift = NULL ;
	Csid_lc_uid = NULL ;
	Csid_lc_extid = NULL ;
        Csid_lc_ansbak = NULL ;
        Csid_lc_dialdig = NULL ;
        Csid_lc_onrel = NULL ;
	Csid_lc_bogus = NULL ;
	Csid_lc_flg_aba = " " ;
	Csid_lc_flg_account = " " ;
	Csid_lc_flg_partic = " " ;
	Csid_lc_flg_swift = " " ;
	Csid_lc_flg_uid = " " ;
	Csid_lc_flg_extid = " " ;
        Csid_lc_flg_ansbak = " " ;
        Csid_lc_flg_dialdig = " " ;
        Csid_lc_flg_onrel = " " ;
	Csid_lc_flg_bogus = " " ;
	Csid_lc_first_idt = Csid_party_idtype ;
	Csid_acchfwid = NULL ;
	Csid_id_ws = NULL ;
	Csid_temp1_vstr = NULL ;
	%end

%^ The first code could be an RT, strip it and allow for a lookup
	If Csid_party_id(1:2) = "RT/" Then
		%beg csid_parse ^in(csid_party_id) "RT/";		%^ 118843
		     csid_lc_first_idt = " "; %^ clear, ID is really the next
		%end
		
	else
		%beg csid_parse ^in(csid_party_id); %end
	end-if.

%^ Could be a compound id with an /AC, /BC, /CH, or /FW or other 2-character 
%^ clearing ID designator
%^	Csid_Parse ^In(Csid_party_id), Csid_id_ws,
	%beg 
	Csid_Parse  Csid_id_ws,
		    Csid_oneof_acchfw (^ONEOF (	
			("///",|Csid_acchfwid, ^SPACE, /),
			("/AC",|Csid_acchfwid, ^SPACE, /),
			("/", |Csid_party_extype (^STRING<2>(<CHAR$M_ALPHA>)),
						    |Csid_acchfwid, ^SPACE, /),
			("/(",|Csid_acchfwid, ^SPACE, /),
			(/) ));
	%end

	If Failure_is in Csid_parse_status  
	    %Beg  Csid_acchfwid = NULL ;  %End
	    Move 0 To Csid_oneof_acchfw
	END-IF.
%^ Default is 2-char subtype
	Move 2 to Csid_twoof_acchfw.
	Evaluate TRUE
	    When Csid_party_idtype = "D"
		Move 0 to Csid_twoof_acchfw
		Move "AC" To Csid_party_extype2

	    When Csid_party_idtype = SPACE
		Move 1 to Csid_twoof_acchfw
		Move "AC" To Csid_party_extype2

	    When Csid_party_idtype = "S"
		Move "BC" To Csid_party_extype2
		
	    When Csid_party_idtype = "C"
		Move "CH" To Csid_party_extype2
		
	    When Csid_party_idtype = "P" 
%^ NOTE: if the ID is in P-form, it must already have any necessary suffix.
%^ Since this is a lower creditside party, we're just trying to get its
%^ extended Id form
		If Cdt_adr_bnk_id of Ent_credit_set = SPACES
		    Move Bank of Loc_info of Ent_ftr_set to Csid_acc_bank_ws
		ELSE
		    Move Cdt_adr_bnk_id of Ent_credit_set to Csid_acc_bank_ws
		END-IF
		CALL "GET_XIDTYPE_FROM_SUFFIX" Using
		    By reference Csid_acc_bank_ws
		    By reference Csid_id_ws
		    By Reference Csid_id_ws_length
		    By Reference Csid_party_extype2
		  Returning Csid_itsa_clearhouse

	    When Csid_party_idtype = "A"
		Move "FW" To Csid_party_extype2

	    When Csid_party_idtype = "E"
%^ #45981 If the string following the code word of the extended ID sub-type of
%^        "ID" were alpha characters, an ambiguous error message was written for
%^        the beneficiary.  By moving a "3" to Csid_oneof_acchfw and 
%^        Csid_twoof_acchfw, the ambiguous conditions are not encountered
		
                If Csid_id_ws (1:2) = "ID" 
		Then
                    Move 3 to Csid_oneof_acchfw
                    Move 3 to Csid_twoof_acchfw
		End-if			
		Move Csid_id_ws(1:2) To Csid_party_extype2
		%Beg
		Csid_clip_compose ^OUT(Csid_temp1_vstr)
		    Csid_id_ws, / ;
		%End
		IF Csid_temp1_vstr_length > 2 THEN		%^ 118843
		    Subtract 2 from Csid_temp1_vstr_length
		    Move Csid_temp1_vstr(3:Csid_temp1_vstr_length) To Csid_id_ws
		Else
		    Initialize Csid_id_ws, Csid_id_ws_length
		End-if
		If Csid_id_ws_length > 1
		    Subtract 2 From Csid_id_ws_length
		End-if

            When (Csid_party_idtype = "X" )
                 AND (Failure_is in Csid_multi_party)
		Move 5 to Csid_twoof_acchfw

            When (Csid_party_idtype = "T" )
		AND (Failure_is in Csid_multi_party)
		Move 6 to Csid_twoof_acchfw
		
            When OTHER
                If ( (Csid_lc_secwir = "Y" )
                   AND (Failure_is in Csid_multi_party)
                   AND (ANYTYPE_LOWER_CREDIT of Menu_cfg = "T" ) )
                THEN
		    Move "F" to Csid_lc_flg_onrel
		    Move 7 to Csid_twoof_acchfw
                ELSE
		    Move 0 to Csid_twoof_acchfw
                    %Beg  Csid_lc_bogus = Csid_id_ws ;  %End
		    Move "F" to Csid_lc_flg_bogus
		    If (Csid_acchfwid_length NOT = 0 )
		        %Beg
		        Csid_compose ^OUT(Csid_temp1_vstr )
	    	      		Csid_oneof_acchfw (^ONEOF ( 
				    (""),
				    ("/AC"),
				    ("/", |Csid_party_extype),
				    ("/("),
				    ("") ) ), 
			        Csid_acchfwid, / ;
        	       %End
                    END-IF
		END-IF
	END-EVALUATE.

	Perform UNTIL ( Csid_id_ws_length = 0 )

	    Evaluate Csid_twoof_acchfw
		When 1
* It's a foreign account
		    If (Csid_lc_account_length NOT = 0 )
			Move "?" to Csid_ovr
			Set Failure_is in Csid_ret_stat to true
			GO TO C660_LOWER_CREDIT_END
		    END-IF
		    %Beg  
		    Csid_lc_account = Csid_id_ws ;
		    Csid_lc_flg_account = "F" ;
		    %End

		When 2
* It's a 2-character subtype id

		 Evaluate Csid_party_extype2
		  When "BC"
%^ Its a BIC
		    If (Csid_lc_swift_length NOT = 0 )
			Move "?" to Csid_ovr
			Set Failure_is in Csid_ret_stat to true
			%Beg  Csid_lc_error = "FTRSCR$_MULTI_DUPE_ID";  %End
			GO TO C660_LOWER_CREDIT_END
		    END-IF
		    Move SPACES to Csid_lc_swift
		    %Beg  
		    Csid_lc_swift = Csid_id_ws ;
		    Csid_lc_flg_swift = "F" ;
		    %End

		  When "CH"
%^ It's a CHIPS UID
		    If (Csid_lc_uid_length NOT = 0 )
			Move "?" to Csid_ovr
			Set Failure_is in Csid_ret_stat to true
			%Beg  Csid_lc_error = "FTRSCR$_MULTI_DUPE_ID" ;  %End
			GO TO C660_LOWER_CREDIT_END
		    END-IF
		    %Beg  
		    Csid_lc_uid = Csid_id_ws ;
		    Csid_lc_flg_uid = "F" ;
		    %End

		  When "FW"
%^ It's a FED ABA
		    If Aba_is in csid_fed_index_flg Then
			    If (Csid_lc_aba_length NOT = 0 )
				Move "?" to Csid_ovr
				Set Failure_is in Csid_ret_stat to true
				%Beg  Csid_lc_error = "FTRSCR$_MULTI_DUPE_ID" ;  %End
				GO TO C660_LOWER_CREDIT_END
			    END-IF
			    %Beg  
				Csid_lc_aba = Csid_id_ws ;
				Csid_lc_flg_aba = "F" ;
			    %End
		    Else %^ Treat it as an E id
			    If (Csid_lc_extid_length NOT = 0 )
				Move "?" to Csid_ovr
				Set Failure_is in Csid_ret_stat to true
				GO TO C660_LOWER_CREDIT_END
		    	    END-IF
		    	    %Beg  
		    		Csid_compose ^Out(Csid_lc_extid)
				Csid_party_extype2, Csid_id_ws, /;
		    		Csid_lc_flg_extid = "F" ;
		    	    %End
		    End-if

		  When Other
%^ Other 2-char external ID
		    If (Csid_lc_extid_length NOT = 0 )
			Move "?" to Csid_ovr
			Set Failure_is in Csid_ret_stat to true
			GO TO C660_LOWER_CREDIT_END
		    END-IF
		    %Beg  
		    Csid_compose ^Out(Csid_lc_extid)
			Csid_party_extype2, Csid_id_ws, /;
		    Csid_lc_flg_extid = "F" ;
		    %End

		 End-evaluate

                When 5
* It's an answerback.  Must be in first position.
                    %Beg
                    Csid_lc_ansbak = Csid_id_ws ;
                    Csid_lc_flg_ansbak = "F" ;
                    %End

                When 6
* It's telex dial digits.  Must be in first position.
                    %Beg
                    Csid_lc_dialdig = Csid_id_ws ;
                    Csid_lc_flg_dialdig = "F" ;
                    %End

                When 7
* It's an onrel id.  Must be in first position.
                    %Beg
                    Csid_lc_onrel = Csid_id_ws ;
                    Csid_lc_flg_onrel = "F" ;
                    %End

	    END-EVALUATE

	    %Beg
	    Csid_temp1_vstr = Csid_acchfwid ;
	    Csid_acchfwid = NULL ;
	    Csid_id_ws = NULL ;
	    Csid_twoof_acchfw = Csid_oneof_acchfw ;
	    Csid_party_extype2 = Csid_party_extype;
	    Csid_oneof_acchfw = <0> ;
	    %End
	    If (Csid_temp1_vstr_length NOT = 0 )
		AND (Csid_twoof_acchfw < 4 )
	    THEN
		%Beg
	        Csid_Parse ^In(Csid_temp1_vstr), Csid_id_ws,
	    	    Csid_oneof_acchfw (^ONEOF (	
			("///",|Csid_acchfwid, ^SPACE, /),
			("/AC",|Csid_acchfwid, ^SPACE, /),
			("/", 
			    |Csid_party_extype(^STRING<2>(<CHAR$M_ALPHA>)),
			    |Csid_acchfwid, ^SPACE, /),
			("/(",|Csid_acchfwid, ^SPACE, /),
			(/) ));
                %End
	    END-IF
	END-PERFORM.

* We now have parsed the entire lower creditside id set.  So now we want to
* look it up.  Since we are interactive, we let our first key determine
* everything, unless it's a foreign account, since we assume that the
* operator typed it that way.
	If (Csid_lc_first_idt = SPACE )
* OOPS.  Let's see if we have a second id.
	    If (Csid_lc_flg_swift = "F" )
		Move "S" to Csid_lc_first_idt
	    ELSE
	        If (Csid_lc_flg_aba = "F" )
		    Move "A" to Csid_lc_first_idt
                ELSE
	            If (Csid_lc_flg_uid = "F" )
		        Move "C" to Csid_lc_first_idt
                    ELSE
			If (Csid_lc_flg_partic = "F" )
			    Move "P" to Csid_lc_first_idt
                        END-IF
		    END-IF
		END-IF
	    END-IF
	END-IF.

	%Beg  
	Csid_id_ws = NULL ;
	Csid_temp_idtype = Csid_lc_first_idt ;
	%End.
	Evaluate TRUE
	    When Csid_lc_first_idt = "S"
		%Beg  
		Csid_id_ws = Csid_lc_swift ;
                Csid_parse ^IN(Csid_id_ws)
                        ^STRING<3>, ":", ^STRING, / ;
                %End
		%^ Need to use S when ID has been provided by Bank_code table
		%^ from an IBAN. 91254
		If (Failure_is in Csid_parse_status   )
                   AND (Csid_lc_secwir NOT = "Y" )
		   And NOT(BNP_IS in csid_iban_party_ws)
                    %Beg  Csid_temp_idtype = "$" ;  %End
                ELSE
                    %Beg  Csid_temp_idtype = "S" ;  %End
                END-IF
		%^ Check for RPT and inhibit the AUX ambiguous select screen 97564
		If Is_rptv_lookup_ls Not = 0 Then
	   		%beg Csid_compose ^out(Csid_temp1_vstr) csid_id_ws,"/",/;
			     csid_id_ws = csid_temp1_vstr;
	   		%end
		end-if
		
	    When Csid_lc_first_idt = "C"
		%Beg
		Csid_id_ws = Csid_lc_uid ;
                Csid_parse ^IN(Csid_id_ws)
                        ^STRING<3>, ":", ^STRING, / ;
                %End
                If (Failure_is in Csid_parse_status   )
                   AND (Csid_lc_secwir NOT = "Y" )
                THEN
                    %Beg  Csid_temp_idtype = "u" ;  %End
                END-IF
		
	    When Csid_lc_first_idt = "P"
		%Beg  Csid_id_ws = Csid_lc_partic ;  %End
		
	    When Csid_lc_first_idt = "A"
		%Beg  Csid_id_ws = Csid_lc_aba ;  %End

            When Csid_lc_first_idt = "X"
                %Beg  Csid_id_ws = Csid_lc_ansbak ;  %End

            When Csid_lc_first_idt = "T"
                %Beg  Csid_id_ws = Csid_lc_dialdig ;  %End

%^ spr 30746
            When Csid_lc_first_idt = "E"
                %Beg  Csid_id_ws = Csid_lc_extid ;  %End

            When Csid_lc_flg_onrel = "F"
                %Beg  Csid_id_ws = Csid_lc_onrel ;  %End
		
            When OTHER
		%Beg  Csid_id_ws = Csid_lc_bogus ;  %End
	END-EVALUATE.

	Move SPACES to Csid_lkup_pend_del	
	%Beg  Csid_next_function = Menu_next_function;  %End.
	Call "REL_GET" USING 
	    By reference Csid_temp_idtype
	    By reference Csid_id_ws
	    By reference Csid_id_ws_length
	    by reference Csid_lkup_pend_del
	  RETURNING Csid_ret2_stat.
%^
%^ Conditions will be checked in the caller to maintain the screen state values.
%^
%^
C660_LOWER_CREDIT_END.
	EXIT.


C660_LOWER_CREDIT_CONN.
%^
%^ No state setting, caller controlled
%^
	Call "RELGET_CONNECT" USING 
	    by reference csid_lkup_pend_del
	  RETURNING csid_ret2_stat.

C660_LOWER_CREDIT_CONN_END.
	EXIT.

C660_LOWER_CREDIT_MAP.

	If (Success_is in Csid_ret2_stat   )
	   OR (Relget_msgcode = Vmsg_dat_notonfile_wc )
	THEN
* Found it in REL or AUX database.
            If (Relget_return_key NOT = SPACES )
            and (Relget_return_idtype = Csid_lc_first_idt)
            and (Relget_return_key NOT = Csid_id_ws)
%^ If a different key of the same idtype was returned, then parse out
%^ the old key and replace it with the new key.
                %Beg
                Csid_parse ^IN(Relget_return_key),
                        Csid_id_ws, ^ONEOF("/",(^SPACE,/));
                %End
                Evaluate Relget_return_idtype
                  when "A"
                    %Beg
                    Csid_lc_aba = Csid_id_ws ;
                    Csid_parse ^IN(Csid_party_id)
                        Csid_temp2_vstr,
                        ^ONEOF("/FW","/(FW"),
                        ^OUT(Csid_temp3_vstr),
                        Csid_temp4_vstr, /;
                    %end
                  when "P"
                    %Beg
                    Csid_lc_partic = Csid_id_ws ;
                    Csid_parse ^IN(Csid_party_id)
                        Csid_temp2_vstr,
                        ^ONEOF("/CP","/(CP"),
                        ^OUT(Csid_temp3_vstr),
                        Csid_temp4_vstr, /;
                    %end
                  when "S"
                    %Beg
                    Csid_lc_swift = Csid_id_ws ;
                    Csid_parse ^IN(Csid_party_id)
                        Csid_temp2_vstr,
                        ^ONEOF("/BC","/(BC"),
                        ^OUT(Csid_temp3_vstr),
                        Csid_temp4_vstr, /;
                    %end
                  when "C"
                    %Beg
                    Csid_lc_uid = Csid_id_ws ;
                    Csid_parse ^IN(Csid_party_id)
                        Csid_temp2_vstr,
                        ^ONEOF("/CH","/(CH"),
                        ^OUT(Csid_temp3_vstr),
                        Csid_temp4_vstr, /;
                    %end
                  when "X"
                    %Beg Csid_lc_ansbak = Csid_id_ws ; %end
                    Set Failure_is in Csid_parse_status to true
                  when "T"
                    %Beg Csid_lc_dialdig = Csid_id_ws ; %end
                    Set Failure_is in Csid_parse_status to true
                  when other
                    Set Failure_is in Csid_parse_status to true
                end-evaluate
                If Failure_is in Csid_parse_status
                    %Beg
                    Csid_temp2_vstr = "";
                    Csid_temp3_vstr = "";
                    Csid_temp4_vstr = Csid_party_id;
                    %end
                end-if
                %Beg
                Csid_parse ^IN(Csid_temp4_vstr),
                    ^STRING,
                    ^ONEOF ( ("/"), (")") ),
                    ^OUT(Csid_temp5_vstr),
                    Csid_temp6_vstr, /;
                %end
                IF Failure_is in Csid_parse_status   then
                    %beg
                    Csid_temp5_vstr = "";
                    Csid_temp6_vstr = "";
                    %End
                end-if
                %Beg
                Csid_party_id = NULL;
                %^ Recreate the ID, replacing the old key with the new key.
                Csid_compose ^OUT(Csid_party_id),
                    Csid_temp2_vstr,
                    Csid_temp3_vstr,
                    Csid_id_ws,
                    Csid_temp5_vstr,
                    Csid_temp6_vstr,
                    /;
                %end
            END-IF
	    Evaluate TRUE 
	      When Csid_lc_first_idt = "S"
		Move "Y" to Csid_lc_flg_swift

	      When Csid_lc_first_idt = "C"
		Move "Y" to Csid_lc_flg_uid
		
	      When Csid_lc_first_idt = "P"
		Move "Y" to Csid_lc_flg_partic
		
	      When Csid_lc_first_idt = "A"
		Move "Y" to Csid_lc_flg_aba

              When Csid_lc_first_idt = "X"
                Move "Y" to Csid_lc_flg_ansbak

              When Csid_lc_first_idt = "T"
                Move "Y" to Csid_lc_flg_dialdig
		
              When Csid_lc_first_idt = "E"
                Move "Y" to Csid_lc_flg_extid
		
              When OTHER
                If (Csid_lc_flg_onrel = "F" )
                    Move "Y" to Csid_lc_flg_onrel
                ELSE
                    Move "Y" to Csid_lc_flg_bogus
                END-IF
* And now we must figure out what to change this ID to.
		If (Csid_lc_flg_swift = SPACE )
		   AND (Swift_id of Relget_adr_set NOT = SPACES )
		THEN
		    Move "Y" to Csid_lc_flg_swift
		    %Beg  
		    Csid_lc_swift = Relget_adr_set.swift_id ;  
		    Csid_party_idtype = "S" ;
		    Csid_party_id = NULL ;
		    Csid_compose ^OUT(Csid_party_id )
			Relget_adr_set.swift_id, Csid_temp1_vstr, / ;
		    %End
		ELSE
		    If (Csid_lc_flg_aba = SPACE )
		       AND (ABA_id of Relget_adr_set NOT = SPACES )
		    THEN
		        Move "Y" to Csid_lc_flg_aba
		        %Beg  
			Csid_party_idtype = "A" ;
		    	Csid_party_id = NULL ;
		    	Csid_compose ^OUT(Csid_party_id )
				Relget_adr_set.aba_id, Csid_temp1_vstr, / ;
			Csid_lc_aba = Relget_adr_set.aba_id ;  
			%End
		    ELSE
		        If (Csid_lc_flg_uid = SPACE )
		           AND (Chips_uid_id of Relget_adr_set NOT = SPACES )
		        THEN
		            Move "Y" to Csid_lc_flg_uid
		            %Beg
			    Csid_party_idtype = "C" ;
		    	    Csid_party_id = NULL ;
		    	    Csid_compose ^OUT(Csid_party_id )
				Relget_adr_set.Chips_uid_id,
				Csid_temp1_vstr, / ;
			    Csid_lc_uid = Relget_adr_set.Chips_uid_id ;
			    %End
		        ELSE
* Need to flag fact we could not change it.
                            If (Csid_lc_flg_onrel NOT = "Y" )
                                %Beg
				Csid_lc_error = "FTRSCR$_IDTYPE_HERE" ;  %End
                                Move "?" to Csid_ovr
                                Set Failure_is in Csid_ret_stat to true
                                If Csid_party_idtype = "U" then
				    %^ Exit immediately to flag the error
                                    GO TO C660_LOWER_CREDIT_MAP_END
                                END-IF
                            END-IF
			END-IF
		    END-IF
		END-IF
	    END-EVALUATE
	END-IF.

	If Success_is in Csid_ret2_stat  
* RELGET lookup found something in the REL
	    Perform D740_MATCH_IDS_TO_REL through D740_MATCH_IDS_TO_REL_END 
	    GO TO C660_LOWER_CREDIT_MAP_CLEANUP
	END-IF.

	IF (Relget_msgcode = Vmsg_dat_notonfile_wc )
* RELGET lookup found something in the AUX.
	    If (Csid_lc_flg_uid = "Y" )
		If (Csid_lc_flg_swift NOT = SPACE )
		    If (Csid_lc_swift(1:11) = 
			   Swift_id of Relget_adr_set(1:11) )
		    THEN
			Move "Y" to Csid_lc_flg_swift
	    	        If (Csid_lc_flg_aba NOT = SPACE )
			    Perform D760_LC_SWF_TO_ABA through
                                     D760_LC_SWF_TO_ABA_END
			    If (Success_is in Csid_ret2_stat   )
				If (Csid_lc_aba(1:9) = Idkey of Disp_id
					of Csid_aux_index(1:9))
				THEN
				    Move "Y" to Csid_lc_flg_aba
				ELSE
				    Move "N" to Csid_lc_flg_aba
				END-IF
			    END-IF   
			END-IF
		    END-IF
		END-IF
	    	GO TO C660_LOWER_CREDIT_MAP_CLEANUP
	    END-IF

	    If (Csid_lc_flg_ABA = "Y" )
		If (Csid_lc_flg_swift NOT = SPACE )
		    Perform D760_LC_SWF_TO_ABA through
				D760_LC_SWF_TO_ABA_END
		    If (Success_is in Csid_ret2_stat   )
			If (Csid_lc_aba(1:9) = Idkey of Disp_id
					of Csid_aux_index(1:9))
			THEN
			    Move "Y" to Csid_lc_flg_swift
			ELSE
			    Move "N" to Csid_lc_flg_swift
			END-IF
		    END-IF
		END-IF
	    	GO TO C660_LOWER_CREDIT_MAP_CLEANUP
	    END-IF

	    If (Csid_lc_flg_swift = "Y" )
		If (Csid_lc_flg_uid = "F" )
		    Move "s" to Csid_temp_idtype
		    Move Spaces to Csid_lkup_pend_del	
	    	    Call "ACCT_LOOKUP" USING
		    	by reference Csid_temp_idtype
			by reference Csid_lc_swift
			by reference Csid_ovr
			by content   "T" 
			by content SPACE
		      	by reference Credit_currency_ls
			by reference Csid_lkup_pend_del
		      RETURNING Csid_ret2_stat

		    If (Csid_ovr = "*" )
			AND (Relget_msgcode = Vmsg_dat_notonfile_wc )
			AND (Chips_uid_id of Relget_adr_set = Csid_lc_uid )
		    THEN
			Move "Y" to Csid_lc_flg_uid
		    END-IF

		END-IF
		If (Csid_lc_flg_aba = "F" )
		    Perform D760_LC_SWF_TO_ABA through
				D760_LC_SWF_TO_ABA_END
		    If (Success_is in Csid_ret2_stat   )
			If (Csid_lc_aba(1:9) = Idkey of Disp_id
					of Csid_aux_index(1:9))
			THEN
			    Move "Y" to Csid_lc_flg_aba
			ELSE
			    Move "N" to Csid_lc_flg_aba
			END-IF
		    END-IF
		END-IF
		If (Csid_lc_flg_extid = "F" )
		    Perform D750_MATCH_EXTENDED_IDS thru
			    D750_MATCH_EXTENDED_IDS_END
		END-IF
	    	GO TO C660_LOWER_CREDIT_MAP_CLEANUP
	    END-IF
	END-IF.

C660_LOWER_CREDIT_MAP_CLEANUP.
* See how we fared.
	Set Failure_is in Csid_ret_stat to true
	If (Csid_lc_flg_aba = "N" )
           OR (Csid_lc_flg_account = "N" )
           OR (Csid_lc_flg_partic = "N" )
           OR (Csid_lc_flg_swift = "N" )
	   OR (Csid_lc_flg_uid = "N" )                            
	THEN
* Hard failure -- we have a conflict.
            Move "?" to Csid_ovr
	    GO TO C660_LOWER_CREDIT_MAP_END
	END-IF.
	If (Csid_lc_flg_aba NOT = "Y" )
           AND (Csid_lc_flg_account NOT = "Y" )
           AND (Csid_lc_flg_partic NOT = "Y" )
           AND (Csid_lc_flg_swift NOT = "Y" )
	   AND (Csid_lc_flg_uid NOT = "Y" )
           AND (Csid_lc_flg_ansbak NOT = "Y" )
           AND (Csid_lc_flg_dialdig NOT = "Y" )
           AND (Csid_lc_flg_extid NOT = "Y" )
           AND (Csid_lc_flg_onrel NOT = "Y" )
	THEN
* Soft failure -- we have no hits.
	    Move "*" to Csid_ovr
	    GO TO C660_LOWER_CREDIT_MAP_END
	END-IF.

	Set Success_is in Csid_ret_stat to true
	If (Csid_lc_flg_aba NOT = "F" )
           AND (Csid_lc_flg_account NOT = "F" )
           AND (Csid_lc_flg_partic NOT = "F" )
           AND (Csid_lc_flg_swift NOT = "F" )
	   AND (Csid_lc_flg_uid NOT = "F" )
           AND (Csid_lc_flg_ansbak NOT = "F" )
           AND (Csid_lc_flg_dialdig NOT = "F" )
           AND (Csid_lc_flg_extid NOT = "F" )
           AND (Csid_lc_flg_onrel NOT = "F" )
	THEN
* Hard success -- We could look up everything we found
	    Move SPACE to Csid_ovr
	ELSE
* Soft success -- We have some leftovers.
	    Move "*" to Csid_ovr	%^ 136705 was set to "*"
	END-IF.

C660_LOWER_CREDIT_MAP_END.
   EXIT.



C670_CHECK_COMMON_UID.

* Check for the case of a COMMON UID and SWIFT TID.

	If (Csid_party_idtype = "C" OR "S" OR space)
	  AND (Success_is in Csid_multi_party   )
	  THEN
	        If (Csid_party_idtype = "S" )
		    %Beg
		    Csid_parse ^IN(Csid_party_id )
		    	    Csid_party_swfid, "/", Csid_temp1_vstr,
			    ^SPACE, / ;
        	    %End
	        ELSE
		    %Beg
		    Csid_parse ^IN(Csid_party_id )
	    		    Csid_temp1_vstr, "/(BC", Csid_party_swfid, 
			    ^SPACE, / ;
        	    %End
   	        END-IF
		%Beg Csid_party_uid = Relget_adr_set.Chips_uid_id; %End
	        If (Success_is in Csid_parse_status   ) 
		    AND (Csid_party_swfid_length = 8 OR 11 )
	        THEN 
		    If (Cdt_rel_id of Ent_credit_set NOT = 0 )
	               AND (Csid_party_swfid(1:8) = Swift_id of 
				Ent_c_adr_set(1:8) ) 
	            THEN
			%Beg
			Csid_union_key_ws(.Idname = "FED_CHIP_TABLES",
					  .Idprod = "MTS", 	   
			 		  .Idbank =  Menu_bnk_union.Bnk_id,    
			 		  .Idloc  = null,    	   
			 		  .Idcust = null);		  
   			Csid_compose ^OUT(Csid_item_key_ws),
						"CHP_COMMON_UIDS:", /; 
		 	Csid_seq_ordinal_ws = <1>;
			Csid_compose ^OUT(Csid_match_key_ws),
					 		    Csid_party_uid, /;
			%End
			Call "CFG_MATCH_ITEM" USING
			    BY Reference Idname of Csid_union_key_ws
			    BY Reference Idprod of Csid_union_key_ws
			    BY Reference Idbank of Csid_union_key_ws
			    BY Reference Idloc of Csid_union_key_ws
			    BY Reference Idcust of Csid_union_key_ws
			    BY Reference Csid_item_key_ws
			    BY Reference Csid_match_key_ws
			    BY Reference Csid_match_key_ws_length
			    BY Reference Csid_seq_ordinal_ws
			    BY Reference Csid_error_msg_ws
			    BY Reference Csid_error_msg_ws_length
            		  RETURNING Csid_chips_party
		        If (Success_is in Csid_chips_party  ) 
* Match is implied if the first part of SWIFT ID on the next party is the same
* as the credit party; i.e. the bank to which we are making the payment
* is repeated in the SWIFT ID of the next party
	    		    %Beg
 	   		    Csid_compose ^OUT(Csid_info_memo)
			      "Message had common CHIPS UID and SWF TID match", 
				/ ;
    			    %End
    			    Perform X920_INFO_MEMO through 
						X920_INFO_MEMO_END
			    If (Csid_party_idtype = "S" )
* Reverse the fields to put the common UID first.
			        %Beg
			        Csid_party_idtype = "C" ;
			        Csid_compose ^OUT(Csid_party_id )
				        Csid_party_uid, "/BC", 
				        Csid_party_swfid, / ;
			        %End
			    ELSE
				If Csid_party_idtype = spaces
				    %Beg
				    Csid_temp1_vstr = Csid_party_id;
				    Csid_compose ^OUT(Csid_party_id)
					Csid_temp1_vstr,
					"/(CH",Csid_party_uid,")",/;
				    %END
				END-IF
			    END-IF
		        END-IF			
		    END-IF
        	END-IF
	END-IF.

%^ If the common UID check was a failure, just exit
        If (Failure_is in Csid_chips_party  )
	  then
	    Go to C670_CHECK_COMMON_UID_end
	end-if.

%^ Otherwise, return Csid_party_id in Csid_id_ws and Csid_temp1_vstr
        If (Csid_party_id_length > 64 )
            Move Csid_party_id(1:64) to Csid_id_ws
            Move 64 to Csid_id_ws_length
            Subtract 64 from Csid_party_id_length giving Csid_length
            Move Csid_party_id(65:Csid_length) to Csid_temp1_vstr
            Move Csid_length to Csid_temp1_vstr_length
        ELSE
            %Beg
            Csid_id_ws = Csid_party_id;
            Csid_temp1_vstr = NULL;
	    %End
        END-IF.

C670_CHECK_COMMON_UID_end.

   EXIT.
%^C680_IBAN_DETECTED.
%^	We need to evaluate what was returned from Validate Iban. Several cases
%^ 	for what we need to to.
%^
%^ Full IBAN passes test:
%^	If we are here for Credit Party:
%^		Push BBAN section to BNF and insert derived bank as Credit Party
%^
%^	If we are here for BNP:
%^		format BNP as BBAN
%^		If BBK present:
%^			Overwrite BBK with derived bank	 ONLY IF NO BBK ID data is Present.
%^			Also parameter driven if D format BBK info is present
%^
%^		If no BBK:
%^			Insert Derived bank as BBK
%^
%^ Passes as BBAN:
%^	I believe that we are to ASSUME that this is for Our Country and
%^	attempt to lookup. 
%^

%^ If we are credit party, and this is a 2 party payment, PUSH
%^
%^ Lets see if we have been returned a Bank code to use for a
%^ lookup to the BANK_CODES_INDEX. We need to lookup based upon the returned
%^ Country and Bank code obtained from the IBAN. This will return us a BIC to
%^ use in the BBK
%^ 
%^ This check may be moved down, dependant upon PRM setting whether we need to
%^ clear and replace BBK or not.
%^	If (Csid_iban_cntry_ws not = Spaces) And
%^	   (Csid_iban_bnk_ws_length  NOT = 0) Then
%^		%^ We do have info for a bank table lookup, get the BIC
%^		%^ we need for insertion
%^		%^ Access the bank_codes_index, an retreive a BIC,
%^		%^ THen get the rest of the BIC info from AUX
%^	End-if.
%^
%^	Set Failure_is in csid_on_us_bnk_code to True.
%^
%^	Call "CUST_IS_ID_ON_US" using
%^		By Reference 	idacc of idkey of csid_bnk_code_rec_ws
%^		By Reference 	idacc_length of csid_bnk_code_rec_ws_lengths
%^		By Reference	csid_bnk_code_bnk_ws
%^	Returning  csid_on_us_bnk_code.
%^
%^	Set Failure_is in csid_iban_expanded to True.
%^
%^	Evaluate True
%^		When Bnp_is in Csid_iban_party_ws
%^			%^ Push into BBK if required
%^			Perform  D780_BNP_IBAN thru
%^				 D780_BNP_IBAN_END
%^		When Cdt_is in Csid_iban_party_ws
%^			%^ straight AIN style Insertion
%^			Perform D790_CDT_IBAN thru
%^				D790_CDT_IBAN_END
%^	end-evaluate
%^
%^	Move 0 to csid_ret_stat.
%^
%^	If (csid_valid_iban_flg_ws NOT = "N")
%^	Then 
%^		%^ Set flag, need to clear if changed..... But only if IBAN, leave blank for BBAN
%^		%beg
%^			ent_credit_set.flgs3.cdt_iban = "T";
%^		%end
%^	End-if.
%^
%^C680_IBAN_DETECTED_END.
%^    EXIT.

C730_GET_PID_SUFFIXES.

%^ This routine builds a list of all the 3 character suffixes of P
%^ accounts connected to the address.  The suffixes are delimited by commas.
	%Beg
	Csid_suffixes = NULL;
	BREAK: Csid_acc_seq;
	%End.
	%ACE_IS Csid_adr_set connected giving Csid_conn_stat;
	If (Failure_is in Csid_conn_stat)
	    GO TO C730_GET_PID_SUFFIXES_END
	END-IF.
	%Beg
	BREAK: Csid_acc_seq;
	Csid_adr_set.account_seq CONN: Csid_acc_seq(NOMOD) ;
	FIRST: Csid_acc_seq;
	Csid_compose ^OUT(Csid_suffixes);
	%End.
	Set Failure_is in Csid_found_it to TRUE.
	PERFORM UNTIL (Failure_is in Csid_acc_seq_status )
	    If (Idtype of Rel_name_key of Csid_acc_seq = "P")
		%Beg
		Csid_clip_compose ^OUT(Csid_temp1_vstr),
		    Csid_acc_seq.Rel_name_key.Idkey.Idacc, / ;
	  	%End
		CALL "GET_SUFFIX_FROM_PID" Using
		    By Reference Bnk_id of Csid_adr_set
		    By Reference Csid_temp1_vstr
		    By Reference Csid_temp1_vstr_length
		    By Reference Csid_temp2_vstr
		    By Reference Csid_temp2_vstr_length
		  Returning Csid_itsa_clearhouse
		If Success_is in Csid_itsa_clearhouse
		   AND Csid_temp1_vstr_length NOT = 0
		THEN
		    If (Failure_is in Csid_found_it )
			%Beg  Csid_compose Csid_temp2_vstr;  %End
			Set Success_is in Csid_found_it to TRUE
		    ELSE
			%Beg  Csid_compose ",", Csid_temp2_vstr;  %End
		    END-IF
		END-IF
	    END-IF
	    %Beg  NEXT: Csid_acc_seq;  %End
	END-PERFORM.
	%Beg  Csid_compose /;  %End.
			
C730_GET_PID_SUFFIXES_end.
	EXIT.

C750_BBK_TO_BNP.
%^
%^ For Collection processing, the BBK should be copied to the 
%^ BNP when not present.
%^ Question, since this is POST  bbk lookup, should all connection be
%^ Made" or just copy down the info and allow BNP processing to take care of it.
	%beg
		Ent_credit_set(
	       	     .Bnp(.Bnp_idtype = ent_credit_set.bbk.bbk_idtype,
		    .Bnp_id = ent_credit_set.bbk.bbk_id),
		       .Bnp_name1 = Ent_credit_set.bbk_name1,
		       .Bnp_name2 = Ent_credit_set.bbk_name2,
		       .Bnp_name3 = Ent_credit_set.bbk_name3,
		       .Bnp_name4 = Ent_credit_set.bbk_name4,
		       .Bnp_res_country = ent_credit_set.bbk_res_country) ;
	%End.
C750_BBK_TO_BNP_END.
	EXIT.

D100_BCC_LKUP_BIC.

%^ If configured, replace "E" BCC Code with the BIC

%^ Assume successful processing
	Set Success_is in Bcc_lkup_status to true.

%^ Exit if not valid for processing 
	IF (Lkup_bic_by_bcc_ws = "D" OR "B") AND
	   (Relget_return_idtype = "E")
	    Continue
	ELSE
	    Go to D100_BCC_LKUP_BIC_END
	END-IF.

%^ If SWIFT ID not available, set error;
%^ Otherwise, replace BCC with BIC
%^ FTRSCR_EDITS will perform final validation
	IF Swift_id of Relget_adr_set = spaces 
	    Set Failure_is in Csid_ret_stat to true
	    Add 1 to Csid_bogus_parties
	    Add 1 to Cdt_errmemo_count_ls
	    Set Failure_is in Creditside_screen_ls to true
	    Set Failure_is in Bcc_lkup_status to true
	    %beg Csid_return_key = NULL; %end
	    Evaluate Bcc_lkup_party
		When "BNP"
%^	    		%beg Ftrscr.credit.bnp.bnp_id.msg = "LKUP$_SWF_ID_REQ"; %end
 	    		%Beg
	    		screen_field_ws = "credit.bnp.bnp_id";
            		error_mnemonic_ws = "LKUP$_SWF_ID_REQ";
	    		%End
	    		call "FTRSCR_WRITE_ERROR" using
	    		  by reference screen_field_ws
	    		  by reference error_mnemonic_ws
		When "BBK"
%^	    		%beg Ftrscr.credit.bbk.bbk_id.msg = "LKUP$_SWF_ID_REQ"; %end
 	    		%Beg
	    		screen_field_ws = "credit.bbk.bbk_id";
            		error_mnemonic_ws = "LKUP$_SWF_ID_REQ";
	    		%End
	    		call "FTRSCR_WRITE_ERROR" using
	    		  by reference screen_field_ws
	    		  by reference error_mnemonic_ws
		When "IBK"
%^	    		%beg Ftrscr.credit.ibk.ibk_id.msg = "LKUP$_SWF_ID_REQ"; %end
 	    		%Beg
	    		screen_field_ws = "credit.ibk.ibk_id";
            		error_mnemonic_ws = "LKUP$_SWF_ID_REQ";
	    		%End
	    		call "FTRSCR_WRITE_ERROR" using
	    		  by reference screen_field_ws
	    		  by reference error_mnemonic_ws
		When "IB1"
%^	    		%beg Ftrscr.credit.ib1.ib1_id.msg = "LKUP$_SWF_ID_REQ"; %end
 	    		%Beg
	    		screen_field_ws = "credit.ib1.ib1_id";
            		error_mnemonic_ws = "LKUP$_SWF_ID_REQ";
	    		%End
	    		call "FTRSCR_WRITE_ERROR" using
	    		  by reference screen_field_ws
	    		  by reference error_mnemonic_ws
	    End-evaluate
	ELSE
	    %Beg
	    Relget_return_idtype = "S";
	    Csid_compose ^OUT(Relget_return_key),
			Relget_adr_set.Swift_id, /;
	    Csid_parse ^IN(Relget_return_key), Csid_return_key, ^SPACE, / ;
	    %End
	END-IF.

D100_BCC_LKUP_BIC_END.
   EXIT.


D700_NOF_CDT_BANK.
* 
* For not-on-file credit parties, this paragraph ensures that:
*	- if first 3 bytes of CDT_ID are a bank id, it shouldn't match 
*	  the default menu bank
*	- if first 3 bytes of CDT_ID are a bank id, it should be a valid
*	  bank id
*


	If Cdt_id of Ent_credit_set(4:1) NOT = ":"
	    %Beg  Csid_id_bank_ws = NULL;  %End
	    GO TO D700_NOF_CDT_BANK_END
	END-IF.

%^ If the bank in the credit id matches the message bank, strip it out.
	If Cdt_id of Ent_credit_set(1:3) = Bank of Loc_info of Ent_ftr_set
	    %Beg
	    Csid_parse ^IN(Ent_credit_set.cdt_typ.cdt_id),
		      ^STRING<3>, ":",
		      Ent_credit_set.cdt_typ.cdt_id, /;
	    %End
	    %Beg  Csid_id_bank_ws = NULL;  %End
	    GO TO D700_NOF_CDT_BANK_END
	END-IF.		

%^ Extract the bank ID. If it matches the MENU bank, strip it out.
%^ Try a search of the bank index.
	Move Cdt_id of Ent_credit_set(1:3) to Csid_id_bank_ws.
	Move 3 to Csid_id_bank_ws_length.
	%Beg
	Search:	Bnk_index (Key = Csid_id_bank_ws);
	%End.
	If Failure_is in Bnk_index_status
%^	    %Beg Ftrscr.Credit.cdt_typ.cdt_id.Msg = "VMSG$_DAT_NOBANKKEY"; %End
 	    %Beg
	    screen_field_ws = "credit.cdt_typ.cdt_id";
            error_mnemonic_ws = "VMSG$_DAT_NOBANKKEY";
	    %End
	    call "FTRSCR_WRITE_ERROR" using
	      by reference screen_field_ws
	      by reference error_mnemonic_ws
	    Add 1 to Cdt_errmemo_count_ls
	    Set Failure_is in Creditside_screen_ls to true
	END-IF.
D700_NOF_CDT_BANK_END.


   EXIT.
D720_CDT_SWF_TO_ABA.
*
* This paragraph is performed when the credit Id is a not-on-file SWIFT Id.
* It hopes to turn the SWIFT Id into an ABA number by using the SWIFT-to-ABA
* cross-reference index in the AUX database.
*
* Output: Relget_msgcode = Vmsg_dat_notonfile_wc if a cross-reference listing
*			   was found and an AUX address for the referenced ABA
*			   number existed.
*	  Relget_adr_set = the AUX/ABA address if found
*

%^	P. Labo		08-Nov-94  SPR#3433
	%Beg
	Csid_parse ^IN(Ent_credit_set.Cdt_typ.Cdt_id),
		Csid_20charid_ws,  ^SPACE, ^ONEOF( ("/", ^STRING, / ), (/) ) ;
	%End

	%ACE_IS Csid_aux_set connected returning Ace_status_wf ;.
	If Failure_is in Ace_status_wf
	    %Beg  dat_root_set.Aux_db_set CONN: Csid_aux_set(NOMOD);  %End
	END-IF.

%^ Connect to the cross-reference index and search by SWIFT Id.
	%Beg
	Csid_aux_index(notrap);
	Csid_20charid_ws Change;
	Csid_scr_adr_id(
	    .Idbank = "",
	    .Idtype = "S",
	    .Idkey(
		.Idacc = Csid_20charid_ws,
		.Idadr = "",
		.Idpad = ""));
	Csid_aux_set.Swf_to_aba_index CONN: Csid_aux_index;
	Csid_aux_index ^SEARCH (READ_ONLY, FORWARD, EQL, Key = Csid_scr_adr_id);
	Csid_ret_stat = Csid_aux_index Status;
	Csid_aux_index(etrap);
	BREAK: Csid_aux_index;
	%End.

%^ If successful, search for the cross-referenced ABA in the ABA index.
%^ If the ABA exists, connect RELGET_ADR_SET and change the credit Id.
%^ When changing CDT_ID, don't forget the preferred FED bank (if any)
%^ -- unless the tran type = BPF (Bypass Preferred Fed Pay Bank).
	If Success_is in Csid_ret_stat
	    %Beg
	    BREAK: Relget_adr_set;
	    Csid_aux_index(notrap);
	    Csid_scr_adr_id = Csid_aux_index.Disp_id;
	    Csid_aux_set.Fed_tape_aba_index CONN: Csid_aux_index;
	    Csid_aux_index ^SEARCH (READ_ONLY, FORWARD, EQL, Key = Csid_scr_adr_id);
	    Csid_aux_index CONN: Relget_adr_set(NOMOD);
	    Csid_ret2_stat = Csid_aux_index Status;
	    Csid_aux_index(etrap);
	    BREAK: Csid_aux_index;
	    %End

	    If Success_is in Csid_ret2_stat
		If Preferred_fed_bnk_id of Menu_bnk_union = SPACES  OR
		   Tran_type of Typ of Ent_ftr_set = "BPF"
		    %Beg
		    Ent_credit_set.Cdt_typ (.Cdt_idtype = "A",
					    .Cdt_id = Relget_adr_set.Aba_id);
		    %End
		ELSE
		    %Beg
		    Csid_compose ^OUT(Csid_id_ws),
				Menu_bnk_union.preferred_fed_bnk_id, ":",
				Relget_adr_set.Aba_id, /;
		    Ent_credit_set (
			.Cdt_typ (.Cdt_idtype = "A",
				  .Cdt_id = Csid_id_ws)
			.Cdt_adr_bnk_id = Menu_bnk_union.preferred_fed_bnk_id );
		    %End
		END-IF
		%Beg  Relget_msgcode = Vmsg_dat_notonfile_wc;  %End
	    END-IF
	END-IF.

D720_CDT_SWF_TO_ABA_END.


   EXIT.
D740_MATCH_IDS_TO_REL.
* Paragraph takes relget_adr_set and matches any "F"(ound) flagged IDs to
*  it if it can.
	If (Csid_lc_flg_aba = "F" )
	    If (Csid_lc_aba(1:Csid_lc_aba_length) = Aba_id of Relget_adr_set ) Or
	       (Aba_id of Relget_adr_set = Spaces)
	    Then
		Move "Y" to Csid_lc_flg_aba
	    ELSE
		Move "N" to Csid_lc_flg_aba
		%Beg Csid_lc_error = "FTRSCR$_MULTI_DISAGREE";  %End
	    END-IF
	END-IF.

	If (Csid_lc_flg_partic = "F" )
	    If (Csid_lc_flg_partic(1:Csid_lc_flg_partic_length) = 
					      Chips_id of Relget_adr_set ) Or
	       (Chips_id  of Relget_adr_set = Spaces)
	    Then
		Move "Y" to Csid_lc_flg_partic
	    ELSE	      
		Move "N" to Csid_lc_flg_partic
		%Beg Csid_lc_error = "FTRSCR$_MULTI_DISAGREE";  %End
	    END-IF
	END-IF.
			
	If (Csid_lc_flg_swift = "F" )
	    If (Csid_lc_swift(1:Csid_lc_swift_length) = 
				Swift_id of Relget_adr_set ) Or
		(Swift_id  of Relget_adr_set = Spaces) Or
	       ( Success_is in Csid_swf_dualid_match6 And %^ 132507
		 Csid_lc_swift(1:6) = Swift_id of Relget_adr_set(1:6)
	       )
	    Then
		Move "Y" to Csid_lc_flg_swift
	    ELSE
		Move "N" to Csid_lc_flg_swift
		%Beg Csid_lc_error = "FTRSCR$_MULTI_DISAGREE";  %End
	    END-IF
	END-IF.

	If (Csid_lc_flg_uid = "F" )
	    If (Csid_lc_uid(1:Csid_lc_uid_length) = 
					      Chips_uid_id of Relget_adr_set )  Or
		(Chips_uid_id  of Relget_adr_set = Spaces)
	    Then
		Move "Y" to Csid_lc_flg_uid
	    ELSE
		Move "N" to Csid_lc_flg_uid
		%Beg Csid_lc_error = "FTRSCR$_MULTI_DISAGREE";  %End
	    END-IF
	END-IF.


	PERFORM D750_MATCH_EXTENDED_IDS thru
		D750_MATCH_EXTENDED_IDS_END.

D740_MATCH_IDS_TO_REL_END.
   EXIT.

D750_MATCH_EXTENDED_IDS.
*  This paragraphs ensures that the extended id found in the id is one of
*  the Extended IDs or Supplement IDs in REL or AUX record in relget_adr_set. 
%^ Removed Extended_id1 -> id4 check, fields obselete

	If (Csid_lc_flg_extid = "F" )
		%beg
		BREAK: Relget_supp_id_seq;
		Relget_adr_set.Supplement_id_seq CONN: Relget_supp_id_seq ^FIRST (nomod);
		%end
		Move "N" to Csid_lc_flg_extid
		%Beg Csid_lc_error = "FTRSCR$_MULTI_DISAGREE";  %End
		Perform until seq_end_is in Relget_supp_id_seq_cursor
			If Csid_lc_extid(1:Csid_lc_extid_length) =
				Idacc of Idkey of Rel_name_key of Relget_supp_id_seq
			  then	Move "Y" to Csid_lc_flg_extid
				%Beg Csid_lc_error = Null;  
				     END: Relget_supp_id_seq;
				%end
			  else	%beg
				NEXT: Relget_supp_id_seq;
				%end
			End-if
		End-perform
	END-IF.

D750_MATCH_EXTENDED_IDS_END.
   EXIT.

D760_LC_SWF_TO_ABA.
* Paragraph to look up SWIFT ID in the SWIFT to ABA INDEX.
* If we got a hit, Csid_ret2_stat is SUCCESS and the ABA is in Disp_id of
*    Csid_aux_index.
	%ACE_IS Csid_aux_set connected returning Ace_status_wf ;.
	If Failure_is in Ace_status_wf
	    %Beg  dat_root_set.Aux_db_set CONN: Csid_aux_set(NOMOD);  %End
	END-IF.
	Move SPACES to Csid_scr_adr_id.
	%Beg
	BREAK: Csid_aux_index ;
	Csid_scr_adr_id.Idtype = "S" ;
	Csid_compose ^OUT(Csid_scr_adr_id.idkey.idacc), 
				    Csid_lc_swift, / ;
	Csid_aux_set(.Swf_to_aba_index CONN: Csid_aux_index ^SEARCH
			(READ_ONLY, 
			 EQL,
			 .Rel_name_key = Csid_scr_adr_id ) );
	Csid_ret2_stat = Csid_aux_index Status;
	BREAK: Csid_aux_index ;
	%End.

D760_LC_SWF_TO_ABA_END.
	EXIT.

D780_BNP_IBAN.
%^
%^	Perform the check for insert/overwrite the
%^	BBK party when an IBAN is processed
%^

	Set Failure_is in  Csid_iban_bbk_proc To True.

	Set Failure_is in csid_on_us_bnk_code to True.

	Call "CUST_IS_ID_ON_US" using
		By Reference 	idacc of idkey of csid_bnk_code_rec_ws
		By Reference 	idacc_length of csid_bnk_code_rec_ws_lengths
		By Reference	csid_bnk_code_bnk_ws
	Returning  csid_on_us_bnk_code.

	Set Failure_is in csid_iban_expanded to True.
	
	Move 0 to csid_ret_stat.

	If (Csid_iban_cntry_ws not = Spaces) 	Then 
		If bnp_mailing_country of ent_credit_set = Spaces Then
		   %beg ent_credit_set.bnp_mailing_country = csid_iban_cntry_ws; %end
		end-if
	end-if.

	If  (Cdt_iban of flgs3 of Ent_credit_set = "T") OR	%^ already expanded
	    (Cdt_idtype of cdt_typ of Ent_credit_set = "S" And
	     bbk_id of Ent_credit_set = Spaces and	%^ already have a BIC and
	     bbk_name1 of Ent_credit_set = spaces And
	     (idkey of csid_bnk_code_rec_ws  =
	      cdt_id of cdt_typ of Ent_credit_set)) %^ already replaced
	OR
	    (Cdt_idtype of cdt_typ of Ent_credit_set = "S" And     %^ 119839
	     cdt_adr_ptr_ok of flgs3 of Ent_credit_set NOT = "T")  %^ Error on credit party, skip insertion
  	Then 
		%^ OK we have BBK ID data already  Do NOT replace.
		%^ Also if was are sending to a BIC. spr 100258
		%^ Send along the FULL IBAN to the next party and let them
		%^ expand upon it.
		Go to D780_BNP_IBAN_END
	End-if
%^
%^ If the Credit Party has a BIC, either in it's address or in it's ID, dont 
%^ push the IBAN
%^
	%^ Check if the credit is On-rel, and if so, do we have the adr_set.
	%^ If we have the adr_set, check for a BIC, if match the bank code, skip the insert.
	%^ also set the cdt_iban flag to inhibit further activity.
	%^ If we don;t have the adr_set get it foor the check.
	%^
	If cdt_adr_ptr_ok Of flgs3 of ent_credit_set = "T" Then
		%beg break: csid_tmp_adr_set;
		     Ent_credit_set.cdt_adr_set_ptr CONN: csid_tmp_adr_set;
		     break: csid_tmp_adr_set;	%^ have the data, discard the connection
		%end
	    	If (Idtype of csid_bnk_code_rec_ws = "S" and   %^ If we would insert a BIC future
							       %^ id types considered
		    Swift_id of csid_tmp_adr_set = Idkey of csid_bnk_code_rec_ws)
		OR
		   (Idtype of csid_bnk_code_rec_ws = "S" and   %^ If we would insert a BIC future
							       %^ id types considered
		    Swift_id of csid_tmp_adr_set Not = Spaces And
		    bbk_id of Ent_credit_set = Spaces and	%^ already have a BIC and
		    bbk_name1 of Ent_credit_set = spaces)	%^ and no BBK, do not insert.	    
		Then
			%^
			%^
			%^ IBAN OK, BUT bank_code not found, leave as is
			%^
			Set Failure_is in csid_lookup_bban to True
			Go to D780_BNP_IBAN_END
		end-if
	end-if.
	%^
	%^	
	If Bbk_idtype of Ent_credit_set = "S"	%^ BIC in BBK A format
	Then
		%^ Parse the id to see if it contains more than a BIC.
	    	%^ If it does, do not perform replacement logic.

	    	%beg 
	    	Csid_Parse ^IN(Ent_credit_set.bbk.bbk_id)
			Csid_tmp_id_ws, "/", Csid_tmp_id2_ws, /;
		%end
	    	If Success_is in Csid_parse_status
	    	Then
		    %^ Exit without replacing
		    Go to D780_BNP_IBAN_END
	    	end_if
		If ( Success_is in Csid_swf_dualid_match6) And
		   ( idkey of csid_bnk_code_rec_ws(1:6)  =
		     bbk_id of bbk of Ent_credit_set(1:6)
		   )
		Then
			%^ first 6 match, leave id alone.
			Go to D780_BNP_IBAN_END
		End-if
		%^ perform replacement logic

		%beg csid_compose ^out(csid_prm_name) "MTS$REP_BBK_AFORMAT",/;
		     csid_prm_values_remain = <0>;
		%end
		Call "PRULE_MSG_GET_PARAM" Using
			by Reference	csid_prm_name
			by Reference 	csid_prm_name_length
			by Reference 	csid_prm_level
			by Reference 	csid_pr_source
			by reference 	csid_prm_edit_type
			by reference 	csid_prm_values_remain
			by reference 	csid_prm_value
			by reference 	csid_prm_value_length
		returning csid_pr_ret_stat
		If Not(Success_is in Csid_pr_ret_stat) or
	 	      (csid_prm_value NOT = "Y")
		Then
			%^ If not present, Exit without replacing
			Set Failure_is in csid_lookup_bban to True
			Go to D780_BNP_IBAN_END
		end-if
	Else
		If Not(Bbk_id of Ent_credit_set = Spaces)
			%^ OK we have BBK ID data already  Do NOT replace.
			%^ Send along the FULL IBAN to the next party and let them
			%^ expand upon it.
			Go to D780_BNP_IBAN_END
		End-if
		If Bbk_name1 of Ent_credit_set NOT = SPACES Then
			%^ BBK  D format check Flag and Override or Ignore
			%^ Call get_param for REP_BBK_DFORMAT
			%beg csid_compose ^out(csid_prm_name) "MTS$REP_BBK_DFORMAT",/;
			     csid_prm_values_remain = <0>;
			%end
			Call "PRULE_MSG_GET_PARAM" Using
				by Reference	csid_prm_name
				by Reference 	csid_prm_name_length
				by Reference 	csid_prm_level
				by Reference 	csid_pr_source
				by reference 	csid_prm_edit_type
				by reference 	csid_prm_values_remain
				by reference 	csid_prm_value
				by reference 	csid_prm_value_length
			returning csid_pr_ret_stat
			If Not(Success_is in Csid_pr_ret_stat) Or
			   (csid_prm_value NOT = "Y")
			Then
				%^ If not present, Exit without replacing
				Set Failure_is in csid_lookup_bban to True
				Go to D780_BNP_IBAN_END				
			end-if
		end-if
	End-if.
	%^
	%^ populate the BBK field with the returned BIC and
	%^ set up for the update
	%^

	%^
	%^ We need to be sure that the BIC returned is NOT the
	%^ same as the Current CDT party. We may be here after a push
	%^ from CDT to BNP
	%^
	If (Idkey of csid_bnk_code_rec_ws = Spaces)  Or
	   ((Idkey of csid_bnk_code_rec_ws Not = Spaces) AND	    %^ avoid multiple replacements
	    (Cdt_idtype of Cdt_typ of Ent_credit_set
				= Idtype of csid_bnk_code_rec_ws) And
	    (Cdt_id of Cdt_typ of Ent_credit_set
				= Idkey of csid_bnk_code_rec_ws))
	%^Or
	%^ (Idtype of csid_bnk_code_rec_ws = "S" and	%^ relget_adr_set should contain CDT party
	%^     Swift_id of Relget_adr_set = Idkey of csid_bnk_code_rec_ws)
	Then
		%^
		%^ IBAN OK, BUT bank_code not found, leave as is
		%^
		Set Failure_is in csid_lookup_bban to True
	Else
		%^
		%^ Validate IBAN has returned us a bank code
		%^
		%beg
			Ent_credit_set(.bbk
					 (.bbk_id     = csid_bnk_code_rec_ws.idkey,
				 	  .bbk_idtype = csid_bnk_code_rec_ws.idtype),
				       .bbk_res_country = csid_iban_cntry_ws);
			%^ Clear the name/address for re-lookup
			Ent_credit_set( .bbk_name1 = Null,
				        .bbk_name2 = Null,
					.bbk_name3 = Null,
					.bbk_name4 = Null,
					.bbk_res_country = NULL);
			Ent_ftr_set.change_fields(.CHG_BIC = "R",
						  .CHG_BBK = "R");	%^ 107268
			%^ We are leaving the BNP ID INTACT, Reset it	
			Csid_party_id = Ent_credit_set.bnp.bnp_id ; 
			Csid_party_idtype = Ent_credit_set.Bnp.Bnp_idtype ;
		%end
		If  csid_iban_curr_ws not = Spaces Then
			%beg Ent_credit_set.cdt_currency = csid_iban_curr_ws; %end
		end-if
		%^ not sure this is even required
		Perform C520_UPDATE_BNP thru
			C520_UPDATE_BNP_END
		%^	Set Success_is in csid_lookup_bban to True
		%^
		%^ Add the BBK with the returned info
		%^ And set it changed, it will simlute an entry above
		Move 1 to bbk_changed_ls	%^ force a discard
		%^
%^
%^ Need to manually perform the BBK processing, - the RELGET?
%^
		Set Bbk_init_lkup in Cdt_screen_state to True

		Set Success_is in  Csid_iban_bbk_proc To True  %^ Control reentry at end of bnp_lookups
	
%^		PERFORM B220_BBK THRU B220_BBK_END
%^		%^ Secondary wire code to inserted party Copied from inline post-b220_bbk code
%^	    	If Relget_reject_flag = "M"
%^		    Go to D780_BNP_IBAN_END
%^	    	End-if
%^   	        If Csid_next_function not = Menu_next_function
%^			%^ Blast out of here, 
%^	        	Go to D780_BNP_IBAN_END
%^		end-if
%^		%^ If the secondary wire flag has a chance of being defaulted
%^		%^   to "Y", then look up the BBK address.
%^		If date_time of Cdt_value_date of Ent_credit_set NOT = 0 Then
%^			%beg tmp_value_date_ws =
%^			   	Ent_credit_set.cdt_value_date.date_time;
%^			%end
%^		else
%^			%beg tmp_value_date_ws = Null; %end
%^		end-if
%^               If (Def_secwir_if_pre_spl of Menu_cfg = "Y")
%^		    and (Bbk_rel_id of Ent_credit_set = 0)
%^       	            and (Dbt_ps_elig_flg of Ent_debit_set = "P" or "S")
%^      	            and (tmp_value_date_ws > Menu_date_ws)
%^       	            and (Bbk_idtype of Ent_credit_set not = "S")
%^       	            and ((Bbk_id of ent_credit_set not = spaces) or
%^                         (Bbk_name1 of ent_credit_set not = spaces))
%^                    and (Bbk_secwir of ent_credit_set = SPACE)
%^                    and (Ib1_secwir of ent_credit_set not = "Y")
%^                    and (Ibk_secwir of ent_credit_set not = "Y")
%^                    	Perform C650_LOOKUP_BBK_ADDRESS thru
%^                      	        C650_LOOKUP_BBK_ADDRESS_end
%^                end-if
	end-if.

D780_BNP_IBAN_CLEANUP.

	If (csid_valid_iban_flg_ws NOT = "N")
	Then 
		%^ Set flag, need to clear if changed..... But only if IBAN, leave blank for BBAN
		%beg
			ent_credit_set.flgs3.cdt_iban = "T";
		%end
	End-if.


	Move 0 to csid_ret_stat.

D780_BNP_IBAN_END.
    EXIT.

D790_CDT_IBAN.
	Set Failure_is in csid_on_us_bnk_code to True.

	Call "CUST_IS_ID_ON_US" using
		By Reference 	idacc of idkey of csid_bnk_code_rec_ws
		By Reference 	idacc_length of csid_bnk_code_rec_ws_lengths
		By Reference	csid_bnk_code_bnk_ws
	Returning  csid_on_us_bnk_code.

	Set Failure_is in csid_iban_expanded to True.
	%^
	Move 0 to csid_ret_stat.
	%^
	%^
	If (idkey of csid_bnk_code_rec_ws Not = Spaces) Then
		%^
		%^ We have a BIC to insert, setup and perform Cdt Party Insertion
		%^
		%^ But First, check if the code is on us, If so, perform a SUB
		%^ with the BBAN instead
		If Success_is in csid_on_us_bnk_code Then
		    If (Csid_bnk_code_bnk_ws NOT =  Bank of Loc_info of Ent_ftr_set)
 			%Beg    
	    			Csid_compose ^OUT(csid_pref_corr_rec.idkey)
					Csid_bnk_code_bnk_ws, ":", Csid_party_id, / ;
		    	%End
		    Else
			%beg   csid_pref_corr_rec.idkey  = csid_party_id;  %end
		    end-if
		    %^
		    %beg csid_pref_corr_rec.idtype = "D"; %end
	            Set SUBSTITUTE in Csid_do_pushdown to true
		    %^
		Else
			%beg
				csid_pref_corr_rec
					( .idkey  = csid_bnk_code_rec_ws.idkey,
					  .idtype = csid_bnk_code_rec_ws.idtype);
				Ent_ftr_set.Change_fields(.CHG_CDT = "R",
							  .CHG_BIC = "R"); %^ 107268
			%end
		        Set PUSHDOWN in Csid_do_pushdown to true
			%Beg
			    Csid_compose ^OUT(Csid_info_memo)
					"IBAN/BBAN Detected",
					Ent_credit_set.cdt_typ,
					" inserted  ",
					Csid_pref_corr_rec ,/ ;
			%End
			Perform X920_INFO_MEMO through X920_INFO_MEMO_END
		end-if
		Set Success_is in csid_iban_expanded to True
	end-if.

	If (csid_valid_iban_flg_ws NOT = "N")
	Then 
		%^ Set flag, need to clear if changed..... But only if IBAN, leave blank for BBAN
		%beg
			ent_credit_set.flgs3.cdt_iban = "T";
		%end
	End-if.


	Move 0 to csid_ret_stat.

D790_CDT_IBAN_END.
    EXIT.

* Utility paragraphs.

X920_INFO_MEMO.
*  This paragraph writes an informational trace memo using the text string
*      in Csid_info_memo.
	If Csid_info_memo_length = 0 
	    GO TO X920_INFO_MEMO_END
	END-IF.
	Move SPACES to Csid_temp_memo
	If Csid_info_memo_length > 80
	    Move 80 to Csid_temp_memo_length
	ELSE
	    Move Csid_info_memo_length to Csid_temp_memo_length
	END-IF
	Move Csid_info_memo(1:Csid_temp_memo_length) to 
		Csid_temp_memo(1:Csid_temp_memo_length)
	%Beg
	ALLOC_END: Ent_msg_history (mod,
			.qname (
				.Idbank = Ent_ftr_set.loc_info.bank,
				.Idloc = NULL,
				.Idname = "*SYS_MEMO"),
			.memo   = Csid_temp_memo,
			.qtype	= "OBJTYP$_NULL");
	%End.

X920_INFO_MEMO_END.
	EXIT.

X930_CHANGE_CREDIT.
	%^
	%ACE_IS Relget_adr_set connected giving Csid_conn_stat;
	%^
	%^	%ACE_IS Ent_c_adr_set connected giving Csid_conn_stat
	%^
	%Beg
	BREAK: Prulepty_rule_seq(NOMOD);
	BREAK: Prulepty_party_adr_set(NOMOD);
	%End
	If Success_is in Csid_conn_stat Then
		%beg Prulepty_source rel_is;
		     Prulepty_party_adr_ok Success_is;
	     	     Relget_adr_set.adr_proc_rule CONN:
						      Prulepty_rule_seq(NOMOD);
		     Relget_adr_set EQUATE: Prulepty_party_adr_set(NOMOD);
		%end
		If (Rel_id of Relget_adr_set = 0 )
		    %Beg  Prulepty_source aux_is;  %End
		end-if
	Else
		%beg Prulepty_source host_is;
		     Ent_credit_set.Cdt_proc_rule CONN:
						      Prulepty_rule_seq(NOMOD);
		     Prulepty_party_adr_ok Failure_is;
		%end
		Initialize Prulepty_party_adr_set
	end-if.

	%beg
	    Csid_id_bank_ws = Ent_credit_set.Cdt_adr_bnk_id;
	    Prulepty_bank_prof_rec = NULL;
	%end
	If (Csid_id_bank_ws = SPACES)
	    %Beg  Csid_id_bank_ws = Ent_ftr_set.Loc_info.Bank;  %End
	end-if

	If (Csid_id_bank_ws = Bnk_id of Menu_bnk_union)
		%beg
		     Prulepty_bank_prof_rec =
					     Menu_bnk_union.Bnk_profile_id_rec;
		%end
	else
		%Beg
		   BREAK: Csid_bnk_union ;
		   SEARCH: Bnk_index 
			   (Key = Csid_id_bank_ws );
		%end
 		If (Success_is in Bnk_index_status)
			%Beg Bnk_index CONN: Csid_bnk_union(NOMOD); %end
		end-if
		%beg
  		   Prulepty_bank_prof_rec = Csid_bnk_union.Bnk_profile_id_rec;
		%End
	end-if.

	Call "PRULE_CHANGE_CREDIT" returning Csid_ret_stat.
	%^If Failure_is in Csid_ret_stat Then
	%^	Display "CHANGE Credit_failed"
	%^End-if.

X930_CHANGE_CREDIT_END.
	EXIT.

X930_PRECALC_CVD.

	Call "GCV_PRECALC_CVD" using
		by reference csid_precalc_cvd_ws.

	If csid_precalc_cvd_ws = "T" and Date_Time of Cdt_value_date of Ent_credit_set = ZERO Then
	   Call "PRECALC_CDT_VALUE_DATE" Using By reference  Csid_error_msg_ws
					       By reference  Csid_error_msg_ws_length
					       Returning  Csid_ret_stat
	End-if.	

X930_PRECALC_CVD_END.
	EXIT.

X1000_CHECK_FOR_FED.
%^
%^ If FED is available as an Advice type, look  E/FW id's on the ABA index 
%^ If FED is NOT available, treat FW as an Extended_id type
%^
%^ Now see if FED is a valid advice type.
	%Beg
	    Csid_union_key_ws(.Idname = "FIELD_EDIT_TABLES",
		  	      .Idprod = "MTS", 	   
		   	      .Idbank =  Menu_bnk_union.Bnk_id,    
		  	      .Idloc  = null,    	   
		  	      .Idcust = null);
	    Csid_item_key_ws = "CREDIT_ADV_TYPES:";
	    Csid_match_key_ws = "FED" ;
	%End       
	Call "CFG_MATCH_ITEM" USING
	    	By Reference Idname of Csid_union_key_ws
            	By Reference Idprod of Csid_union_key_ws
            	By Reference Idbank of Csid_union_key_ws
            	By Reference Idloc  of Csid_union_key_ws
            	By Reference Idcust of Csid_union_key_ws
		BY Reference Csid_item_key_ws
		BY Reference Csid_match_key_ws
		BY Reference Csid_match_key_ws_length
		BY Reference Csid_seq_ordinal_ws
		BY Reference Csid_error_msg_ws
		BY Reference Csid_error_msg_ws_length
          Returning Csid_ret_stat.

	If (Success_is in Csid_ret_stat)
	Then
		Set Aba_is in Csid_fed_index_flg to True
	Else
		Set Extended_is in Csid_fed_index_flg to True
	end-if.

X1000_CHECK_FOR_FED_END.
	EXIT.

X1100_CHECK_IBAN_BNP.
%^
%^ See if the BNP is a valid iban. If so, we should replace the Credit party
%^ if the proper Prule flags are set.
%^
%^
%^
%^ I think we may need to do a lookahead to see if we could be replacing
%^ the CDT party, if no BBK is present Let's check and see ONLY when 
%^ structured accounts are being enforced
	If Not((BBK_id of Ent_credit_set = Spaces) and
	       (BBK_name1 of Ent_credit_set = Spaces) ) OR
           Not ( Lock_cdt_party_ls = 0 )  			%^ Don't mess with locked party
	OR	Cdt_iban of flgs3 of Ent_credit_set = "T"	%^ been here before, skip replacement
	Then
		%^ No check required.
		Go to X1100_CHECK_IBAN_BNP_END
	End-if
	%^
	%beg csid_temp_party_id = Ent_credit_set.bnp.bnp_id;	%end


	Initialize Csid_iban_cntry_ws
	%^ Check the Credit Party
	If Cdt_idtype of Cdt_typ of Ent_credit_set = "S" Then
	    If  Cdt_id of Cdt_typ of Ent_credit_set(4:1) = ":"
	    Then    %^ Skip over the bank
		Move Cdt_id of Cdt_typ of Ent_credit_set(9:2) to Csid_iban_cntry_ws 
	    Else
	    	Move Cdt_id of Cdt_typ of Ent_credit_set(5:2) to Csid_iban_cntry_ws 
	    End-if 
	Else
	    If (Cdt_adr_ptr_ok of flgs3 of ent_credit_set = "T")
	    Then
		%beg break: csid_tmp_adr_set;
   			     Ent_credit_set.Cdt_adr_set_ptr CONN: csid_tmp_adr_set;
     			     break: csid_tmp_adr_set;
		%end
		If (Swift_id of csid_tmp_adr_set Not = Spaces)
		Then
		    Move Swift_id of  csid_tmp_adr_set(5:2) to Csid_iban_cntry_ws
		end-if
	    Else
		If Cdt_idtype of cdt_typ of Ent_credit_set = "E"
		Then
			%beg
				Csid_parse ^in(ent_credit_set.cdt_typ.cdt_id)
					Csid_party_extype (^STRING<2>),
					csid_gcheck_id,/;
			%end
			CALL "CUST_XTEND_ID_EDIT" using
				BY REFERENCE Csid_party_extype
   				BY REFERENCE Csid_gcheck_id
   	     			BY REFERENCE Csid_gcheck_id_length
    				BY REFERENCE Csid_temp1_vstr
    				By REFERENCE Csid_temp1_vstr_length
    				By REFERENCE Csid_delay_change
    				BY REFERENCE Csid_got_advice
    				By Reference Csid_extnd_country
    				BY REFERENCE Csid_error_memo
    				BY REFERENCE Csid_error_memo_length
    				By REFERENCE Csid_error_code
    				By REFERENCE Csid_error_code_length
    				BY REFERENCE Csid_check_stat
    				BY REFERENCE Csid_not_garbage
  			RETURNING Csid_ret2_stat
			If Success_is in Csid_ret2_stat And
			   Csid_extnd_country NOT = Spaces
			Then
				%beg csid_iban_cntry_ws = csid_extnd_country; %end
			end-if
			%^ get country for Extended IDs table
		end-if
	    end-if
	end-if

	If Csid_iban_cntry_ws = Spaces AND
	   Bnp_mailing_country of ent_credit_set Not = SPACES then
	        %beg csid_iban_cntry_ws = ent_credit_set.bnp_mailing_country; %end
	Else
		%beg csid_iban_cntry_ws = ent_credit_set.cdt_res_country; %end
	End-if.
	%^
	Set Success_is in csid_set_chg_flg_ws to True.
	Set Failure_is in Csid_iban_found to True.
	%^
	Call "VALIDATE_IBAN" Using
		by Reference csid_temp_party_id
		by Reference csid_temp_party_id_length
		by Reference csid_iban_cntry_ws
		by Reference csid_iban_bnk_ws
		by Reference csid_iban_bnk_ws_length
		by Reference csid_iban_brnch_ws
		by Reference csid_iban_brnch_ws_length
		by Reference csid_iban_curr_ws
		By Reference csid_bnk_code_rec_ws
		By Reference csid_bnk_code_rec_ws_lengths
		By Reference csid_valid_iban_flg_ws
	returning Csid_val_iban_ret
	%^
	%^
	If Success_is in Csid_val_iban_ret AND
	   Csid_bnk_code_rec_ws NOT = SPACES
	Then
		%^ 1 represents a completly valid IBAN/BBAN, withbank codes
		%^ If rules are set, replace the CDT party with it.
		If Cdt_idtype of Ent_credit_set = "S"
		Then
			%^ Parse the id to see if it contains more than a BIC.
		    	%^ If it does, do not perform replacement logic.

		    	%beg 
		    	Csid_Parse ^IN(Ent_credit_set.cdt_typ.cdt_id)
			Csid_tmp_id_ws, "/", Csid_tmp_id2_ws, /;		
	 	    	%end
		    	If Success_is in Csid_parse_status OR
		      	   (Idkey of csid_bnk_code_rec_ws  =
		  	    cdt_id of cdt_typ of Ent_credit_set)
			Then 
			    %^ Exit without replacing
			    Go to X1100_CHECK_IBAN_BNP_END
		    	end-if
			If ( Success_is in Csid_swf_dualid_match6) And
			   ( idkey of csid_bnk_code_rec_ws(1:6)  =
		  	     cdt_id of cdt_typ of Ent_credit_set(1:6)
			   )
			Then
			    %^ first 6 match, leave id alone.
			    Go to X1100_CHECK_IBAN_BNP_END
			End-if
		    	%^ perform replacement logic

			%beg csid_compose ^out(csid_prm_name) "MTS$REP_BBK_AFORMAT",/;
			     csid_prm_values_remain = <0>;
			%end
			Call "PRULE_MSG_GET_PARAM" Using
				by Reference	csid_prm_name
				by Reference 	csid_prm_name_length
				by Reference 	csid_prm_level
				by Reference 	csid_pr_source
				by reference 	csid_prm_edit_type
				by reference 	csid_prm_values_remain
				by reference 	csid_prm_value
				by reference 	csid_prm_value_length
			returning csid_pr_ret_stat
			If Not(Success_is in Csid_pr_ret_stat) Or
			      (csid_prm_value NOT = "Y")
			Then
				Go to X1100_CHECK_IBAN_BNP_END
			Else
				%beg csid_compose ^out(csid_info_memo)
				"Rule MTS$REP_BBK_AFORMAT -	",
				ent_credit_set.cdt_typ," Replaced.",/;
				%end
				%^ Need to see if BIC is on REL/AUX 
				%^
				%beg
					Csid_temp_idtype = "S" ;
			    		Csid_id_ws = Ent_credit_set.cdt_typ.cdt_id ;
			    	%End
				%beg break: relget_adr_set; %end
				Move Spaces to Csid_lkup_pend_del
		            	Call "ACCT_LOOKUP" USING
		    	       	 	by reference Csid_temp_idtype
			       		by reference Csid_id_ws
			        	by reference Csid_ovr
			        	by reference Csid_ambig_ws 
			        	by reference Csid_multibank_ws
		      	        	by reference Credit_currency_ls
					by reference Csid_lkup_pend_del
		              	RETURNING Csid_ret2_stat
				If Success_is in csid_ret2_stat
			 	   OR (Relget_msgcode = Vmsg_dat_notonfile_wc)
				Then
					%beg break: relget_adr_set; %end
					%^ Do not set if on REL/AUX
					Set Failure_is in csid_set_chg_flg_ws to True
				end-if
			end-if
		Else
			If Not(CDT_id of Ent_credit_set = Spaces)
				%^ OK we have BBK ID data already  Do NOT replace.
				%^ Send along the FULL IBAN to the next party and let them
				%^ expand upon it.
				Go to X1100_CHECK_IBAN_BNP_END
			End-if
			If Cdt_name1 of Ent_credit_set NOT = SPACES Then
				%^ BBK  D format check Flag and Override or Ignore
				%^ Call get_param for REP_BBK_DFORMAT
				%beg csid_compose ^out(csid_prm_name) "MTS$REP_BBK_DFORMAT",/;
	     			     csid_prm_values_remain = <0>;
				%end
				Call "PRULE_MSG_GET_PARAM" Using
					by Reference	csid_prm_name
					by Reference 	csid_prm_name_length
					by Reference 	csid_prm_level
					by Reference 	csid_pr_source
					by reference 	csid_prm_edit_type
					by reference 	csid_prm_values_remain
					by reference 	csid_prm_value
					by reference 	csid_prm_value_length
				returning csid_pr_ret_stat
				If Not(Success_is in Csid_pr_ret_stat) Or
	  			      (csid_prm_value NOT = "Y")
				Then
					%^ No flag, no action
					Go to X1100_CHECK_IBAN_BNP_END
				Else
				%beg csid_compose ^out(csid_info_memo)
					"Rule MTS$REP_BBK_DFORMAT - ",
					" Replaced CDT party - see original message",/;
				%end
				end-if
			End-if
		end-if
		%^ If we get here, we need to replace the credit party with the BBAN/IBAN
		%^
		Perform X920_INFO_MEMO Thru X920_INFO_MEMO_END
		%^ this should allow the info to flow through
		%beg Ent_credit_set.cdt_typ.cdt_idtype  = ent_credit_set.bnp.bnp_idtype;
		     Ent_credit_set.cdt_typ.cdt_id	= ent_credit_set.bnp.bnp_id;
		     Ent_credit_set( .Cdt_shnam  = NULL ,
				    .Cdt_name1  = Ent_credit_set.Bnp_name1 ,
                                    .Cdt_name2  = Ent_credit_set.Bnp_name2 ,
                                    .Cdt_name3  = Ent_credit_set.Bnp_name3 ,
                                    .Cdt_name4  = Ent_credit_set.Bnp_name4,
				    .cdt_res_country = Ent_credit_set.bnp_res_country,
				    .cdt_rel_id = <0>,
				    .flgs3.cdt_adr_ptr_ok = Null);
		     Ent_credit_set(.bnp.bnp_id	= NULL,
				    .bnp.bnp_idtype = Null,
				    .bnp_name1  = NULL ,
                                    .bnp_name2  = NULL ,
                                    .bnp_name3  = NULL ,
                                    .bnp_name4  = NULL ,
				    .bnp_res_country = NULL) ;

		%end
		If Success_is in  csid_set_chg_flg_ws
		Then		%^ 116909
		    %beg
			Ent_ftr_set.change_fields(.CHG_CDT = "R",
						  .CHG_BIC = "R");	%^ 107268
		    %end
		End-if
		%^
		If Csid_valid_iban_flg_ws NOT = "I" %^ 117314
		Then
			%beg ent_credit_set.bnp_mailing_country = csid_iban_cntry_ws; %end
		end-if
		%^
		If Credit_changed_ls = 0
		Then
			%^ we are here from a BNP change, force a Credit change
			Move 1 to Credit_changed_ls
		End-if
	end-if.

X1100_CHECK_IBAN_BNP_END.
	EXIT.


X1150_CHECK_IBAN_CNTRY.
%^
%^ Country of party above IBAN does not match IBAN country.
%^ Check table to see if this is allowable.
%^
	Set Failure_is in Csid_Bic_cc_exc_wf to True.
	
	%Beg
		Csid_union_key_ws(.idname	= "FIELD_EDIT_TABLES",
			       .idprod	= "MTS",
			       .idbank	= "",
			       .idloc	= "",
			       .idcust	= "");
		Csid_item_key_ws = "IBAN_BIC_CC_EXC:";
		Csid_item_type_ws = "VSTR(5)";
		Csid_seq_ordinal_ws = <1>;
		Cfg_status_wf Success_is;
	%End

	Perform until Failure_is in Cfg_status_wf
	    Call "CFG_GET_ITEM"
	       using
		by reference Idname of Csid_union_key_ws
		by reference Idprod of csid_union_key_ws
		by reference Idbank of Csid_union_key_ws
		by reference Idloc of  Csid_union_key_ws
		by reference Idcust of Csid_union_key_ws
		by Reference Csid_item_key_ws
		by Reference Csid_seq_ordinal_ws
       		by Reference Csid_item_type_ws
		by Reference Csid_item_data_ws
		by Reference Csid_item_data_ws_length
		by Reference Csid_error_msg_ws
		by Reference Csid_error_msg_ws_length
            RETURNING Cfg_status_wf

	    If Success_is in cfg_status_wf
		%Beg 
			Csid_parse ^IN(Csid_item_data_ws) 
				csid_Cfg_bic_ctry_ws, "|" csid_Cfg_iban_ctry_ws, /;
		%End
		If Success_is in Csid_Parse_status and
		       csid_Cfg_bic_ctry_ws = csid_save_cntry_ws and
		       csid_Cfg_iban_ctry_ws = csid_iban_cntry_ws
		    Set Success_is in Csid_Bic_cc_exc_wf to True
		    Set Failure_is in Cfg_status_wf to True
		End-if
	    End-if
	    Add 1 to Csid_seq_ordinal_ws
	End-perform.

X1150_CHECK_IBAN_CNTRY_END.
	EXIT.

X1300_CHK_UCC_SRC.
%^
%^ See if we should replace the Name/Address with our REL/AUX
%^
	Set Failure_is in csid_non_ucc_src to True
	If Src_code of Ent_ftr_set = Spaces
	Then	%^ Must be here from RPT, consider a NON_UCC source
		Set Success_is in csid_non_ucc_src to True
		Go to X1300_CHK_UCC_SRC_END
	End-if.


	Move Src_code of Ent_ftr_set to Csid_ucc_save_src
	%Beg
	    Csid_union_key_ws(.Idname = "SOURCE_CODE_TABLES",
		  	      .Idprod = "MTS", 	   
		   	      .Idbank =  Menu_bnk_union.Bnk_id,    
		  	      .Idloc  = null,    	   
		  	      .Idcust = null);
	    Csid_item_key_ws = "NON_UCC_SOURCES:";
	    Csid_match_key_ws = Ent_ftr_set.src_code ;
	%End       
	Call "CFG_MATCH_ITEM" USING
	    	By Reference Idname of Csid_union_key_ws
            	By Reference Idprod of Csid_union_key_ws
            	By Reference Idbank of Csid_union_key_ws
            	By Reference Idloc  of Csid_union_key_ws
            	By Reference Idcust of Csid_union_key_ws
		BY Reference Csid_item_key_ws
		BY Reference Csid_match_key_ws
		BY Reference Csid_match_key_ws_length
		BY Reference Csid_seq_ordinal_ws
		BY Reference Csid_error_msg_ws
		BY Reference Csid_error_msg_ws_length
          Returning Csid_non_ucc_src.

X1300_CHK_UCC_SRC_END.
	EXIT.

X1400_CHK_DUAL_MATCH6.
%^
%^ Check the SWF_DUALID_MATCH6 Table for a  value in the owning bank
%^
	Move "N" to csid_tmp_flg_ws.

	%Beg
	    Csid_union_key_ws(.Idname = "FIELD_EDIT_TABLES",
		  	      .Idprod = "MTS", 	   
		   	      .Idbank =  Menu_bnk_union.Bnk_id,    
		  	      .Idloc  = null,    	   
		  	      .Idcust = null);
	    Csid_item_key_ws = "SWF_DUALID_MATCH6:";
	    Csid_match_key_ws = Ent_ftr_set.loc_info.bank ;
	%End       
	Call "CFG_MATCH_ITEM" USING
	    	By Reference Idname of Csid_union_key_ws
            	By Reference Idprod of Csid_union_key_ws
            	By Reference Idbank of Csid_union_key_ws
            	By Reference Idloc  of Csid_union_key_ws
            	By Reference Idcust of Csid_union_key_ws
		BY Reference Csid_item_key_ws
		BY Reference Csid_match_key_ws
		BY Reference Csid_match_key_ws_length
		BY Reference Csid_seq_ordinal_ws
		BY Reference Csid_error_msg_ws
		BY Reference Csid_error_msg_ws_length
          Returning Csid_ret_stat.

	If Success_is in csid_ret_stat
	Then
		If (Success_is in Csid_ret_stat )
		    %Beg  Csid_item_type_ws = "STR(5)" ;  %End
		    Call "CFG_GET_ITEM" USING
			by Reference Idname of Csid_union_key_ws
			by Reference Idprod of Csid_union_key_ws
			by Reference Idbank of Csid_union_key_ws
			by Reference Idloc of Csid_union_key_ws
			by Reference Idcust of Csid_union_key_ws
			by Reference Csid_item_key_ws
			by Reference Csid_seq_ordinal_ws
        		by Reference Csid_item_type_ws
			by Reference Csid_item_data_ws
			by Reference Csid_item_data_ws_length
			by Reference Csid_error_msg_ws
			by Reference Csid_error_msg_ws_length
	              RETURNING Csid_ret_stat
		    If (Success_Is in Csid_ret_stat)
			%beg
				Csid_Parse ^in(csid_item_data_ws) ^str<4>,csid_tmp_flg_ws,/;
			%end
		    end-if
	End-if.

X1400_CHK_DUAL_MATCH6_END.
	EXIT.


%module CREDITSIDE_SCREEN_RESET;

%^*****************************************************************************
%^                                                                            *
%^ This entry point resets the Cdt_screen_state value to Init_is.             *
%^ This comes into play only in java mode and is therefore not an exported    *
%^ cobol entry point.                                                         *
%^                                                                            *
%^ Paragraphs in this procedure are labeled as follows:                       *
%^                                                                            *
%^	A100_MAIN	     Subroutine entry point, dispatch, and return
%^                                                                            *
%^*****************************************************************************


%Procedure.
%^*****************************************************************************

%^*****************************************************************************
A100_MAIN.

	Set Init_is in Cdt_screen_state to True.

A100_MAIN_END.

	%EXIT PROGRAM.


%module CREDITSIDE_SCREEN_EQUATE;

%^*****************************************************************************
%^                                                                            *
%^ For an external (java) caller to use when it wants to save a Relget_index  *
%^ selection that might get clobbered by a debitside call that occurs before  *
%^ coming back into creditside.                                               *
%^                                                                            *
%^ This comes into play only in java mode and is therefore not an exported    *
%^ cobol entry point.                                                         *
%^                                                                            *
%^ Paragraphs in this procedure are labeled as follows:                       *
%^                                                                            *
%^	A100_MAIN	     Subroutine entry point, dispatch, and return
%^                                                                            *
%^*****************************************************************************


%Procedure.
%^*****************************************************************************

%^*****************************************************************************
A100_MAIN.

	%Beg
	Break: Csid_relget_index;
	%End.

%^ Saving the current Relget_index connection is pointless if
%^ Cdt_screen_state is Init_is or Relget_title_flag is not a creditside party.

	If ( (Init_is in Cdt_screen_state) or
	     ( (not Cdt in Relget_title_flag) and
	       (not Ib1 in Relget_title_flag) and
	       (not Ibk in Relget_title_flag) and
	       (not Bbk in Relget_title_flag) and
	       (not Bnp in Relget_title_flag) ) ) then
		Go to A100_MAIN_END
	End-if.

%^ Ensure Relget_index is connected before trying to save the connection.

	%Beg
	Csid_relget_index_conn = Relget_index state.conn;
	%End.
	If Failure_is in Csid_relget_index_conn then
		Go to A100_MAIN_END
	End-if.

	%Beg
	Relget_index equate: Csid_relget_index;
	%End.
	Move Relget_return_idtype to Csid_relget_return_idt.
	Move Relget_return_bank to Csid_relget_return_bank.
	
A100_MAIN_END.

	%EXIT PROGRAM.



%module CREDITSIDE_SCREEN_RESTORE;

%^*****************************************************************************
%^                                                                            *
%^ At the start of CREDITSIDE_SCREEN, this routine is called to restore       *
%^ a Relget_index connection that might have been saved by an external (java) *
%^ call to CREDITSIDE_SCREEN_EQUATE.                                          *
%^                                                                            *
%^ This is only called internally and is therefore not an exported cobol      *
%^ entry point. Also, it ends up being a NOP in cobol mode because cobol      *
%^ never calls CREDITSIDE_SCREEN_EQUATE.                                      *
%^                                                                            *
%^ Paragraphs in this procedure are labeled as follows:                       *
%^                                                                            *
%^	A100_MAIN	     Subroutine entry point, dispatch, and return
%^                                                                            *
%^*****************************************************************************


%Procedure.
%^*****************************************************************************

%^*****************************************************************************
A100_MAIN.


%^ Restoring the current Relget_index connection is pointless if
%^ Cdt_screen_state is Init_is.

	If Init_is in Cdt_screen_state then
		Go to A100_MAIN_END
	End-if.

%^ Ensure Csid_relget_index is connected before trying to restore the connection.

	%Beg
	Csid_relget_index_conn = Csid_relget_index state.conn;
	%End.
	If Failure_is in Csid_relget_index_conn then
		Go to A100_MAIN_END
	End-if.

	%Beg
	Break: Relget_index;
	Csid_relget_index equate: Relget_index;
	Break: Csid_relget_index;
	%End.
	Move Csid_relget_return_idt to Relget_return_idtype.
	Move Csid_relget_return_bank to Relget_return_bank.

A100_MAIN_END.

	%EXIT PROGRAM.


%^
%^ This routine initiates all the processing related to the rerouting
%^ of a message via calls to CHANNEL_DETERMINATION" and 
%^ "CREDITSIDE_NEW_CHANNEL". It accepts a target channel 
%^ passed from the calling module, uses it to make the appropriate calls 
%^ to "CHANNEL_DETERMINATION" and "CREDITSIDE_NEW_CHANNEL" and returns
%^ success or fail to the calling module.  
%^
%^ INPUT ARGUMENTS:
%^ explicit:
%^  Target_Channel           STR(3)    Contains advice method which we are
%^	rerouting away from and implies target advice method.  This would be
%^	"FED" for a fed message (implying a CHP target) or "CHP" for a
%^	CHP message (implying a FED target).
%^ implicit:
%^   Credit party:
%^	Ent_credit_set.Cdt_typ
%^
%^ OUTPUT ARGUMENTS:
%^explicit:
%^  Return_status_ws is SUCCESS if a reroute routing was successfully set up,
%^	otherwise FAILURE.
%^Implicit:
%^   Message history
%^   Credit party:
%^	Ent_credit_set.Cdt_adr_set_ptr
%^	Ent_credit_set.Cdt_rel_id
%^	Ent_credit_set.Cdt_adr_bnk_id
%^	Ent_credit_set.Cdt_typ
%^	Ent_credit_set.Cdt_name1		
%^	Ent_credit_set.Cdt_name2		
%^	Ent_credit_set.Cdt_name3		
%^	Ent_credit_set.Cdt_name4		
%^	Ent_credit_set.Cdt_account
%^	Ent_credit_set.Cdt_acc_class         
%^	Ent_credit_set.Cdt_acc_parent_code
%^	Ent_credit_set.Cdt_acc_prod_codes         
%^	Ent_credit_set.Cdt_adr_class         
%^	Ent_credit_set.Cdt_adv_typ         
%^	Ent_credit_set.Cdt_concen_acc
%^	Ent_credit_set.Cdt_currency         
%^	Ent_credit_set.Cdt_department         
%^	Ent_credit_set.Cdt_recon_ref        
%^	Ent_credit_set.Cdt_shnam         
%^	Ent_credit_set.Cdt_spc_inst1         
%^	Ent_credit_set.Cdt_spc_inst2         
%^	Ent_credit_set.Cdt_spc_inst3
%^	Ent_credit_set.Cdt_sys_of_rec         
%^	Ent_credit_set.Cdt_wir_key         
%^	Ent_credit_set.Flgs.Cdt_hold_flg         
%^	Ent_credit_set.Pymnt.Adv_type         
%^	Ent_credit_set.Pymnt.Location
%^	Ent_credit_set.Pymnt.Phn_time         
%^	Ent_credit_set.Pymnt.Que 
%^   IB1:
%^	Ent_credit_set.Ib1_adr_set_ptr
%^	Ent_credit_set.Ib1_adr_bnk_id
%^	Ent_credit_set.Ib1_rel_id
%^	Ent_credit_set.Ib1
%^	Ent_credit_set.Ib1_id_overflow
%^	Ent_credit_set.Ib1_name1
%^	Ent_credit_set.Ib1_name2
%^	Ent_credit_set.Ib1_name3
%^	Ent_credit_set.Ib1_name4
%^   IBK:
%^	Ent_credit_set.Ibk_adr_set_ptr
%^	Ent_credit_set.Ibk_adr_bnk_id
%^	Ent_credit_set.Ibk_rel_id
%^	Ent_credit_set.Ibk
%^	Ent_credit_set.Ibk_id_overflow
%^	Ent_credit_set.Ibk_name1
%^	Ent_credit_set.Ibk_name2
%^	Ent_credit_set.Ibk_name3
%^	Ent_credit_set.Ibk_name4
%^   BBK:
%^	Ent_credit_set.Bbk_adr_set_ptr
%^	Ent_credit_set.Bbk_adr_bnk_id
%^	Ent_credit_set.Bbk_rel_id
%^	Ent_credit_set.Bbk
%^	Ent_credit_set.Bbk_id_overflow
%^	Ent_credit_set.Bbk_name1
%^	Ent_credit_set.Bbk_name2
%^	Ent_credit_set.Bbk_name3
%^	Ent_credit_set.Bbk_name4
%^   BNP:
%^	Ent_credit_set.Bnp
%^	Ent_credit_set.Bnp_id_overflow
%^	Ent_credit_set.Bnp_name1
%^	Ent_credit_set.Bnp_name2
%^	Ent_credit_set.Bnp_name3
%^	Ent_credit_set.Bnp_name4
%^   FTR:
%^	Ent_ftr_set.cdt_adv_flg
%^      Ent_ftr_set.chrg.cdt_chrg 
%^	Ent_ftr_set.chrg.dbt_chrg 
%^	Ent_ftr_set.currency_code 
%^	Ent_ftr_set.flgs.adv_ovr_flg 
%^	Ent_ftr_set.flgs.cdt_adv_flg 
%^	Ent_ftr_set.instr_adv_type 
%^	Ent_ftr_set.loc_info.bank 
%^	Ent_ftr_set.si_flgs.check_found 
%^	Ent_ftr_set.si_flgs.cor_done 
%^	Ent_ftr_set.si_flgs.fx_found 
%^	Ent_ftr_set.si_flgs.pre_found 
%^	Ent_ftr_set.si_flgs.rte_done 
%^	Ent_ftr_set.type_code
%^
%^ Modification history:
%^
%^ Fred P. Isaacs  12-SEP-1995
%^    Initial implementation.
%^ Fred P. Isaacs  21-SEP-1995
%^    Eliminated overwrite argument and switched to using SI_submethod instead.
%^ Fred P. Isaacs  22-SEP-1995
%^    Fixed bug setting up new credit party from preferred corr during AIN.
%^ Fred P. Isaacs  25-SEP-1995
%^    Fixed bug setting new credit set on pushdown
%^    Fixed bug in handling "BKT" advice method.
%^ Fred P. Isaacs  19-OCT-1995
%^    Fixed loop problem in B600_GET_ACCOUNT
%^ Fred P. Isaacs  20-OCT-1995
%^    Fixed SI memo text.
%^ Fred P. Isaacs  12-JAN-1996
%^    Now clears fed short name if there isn't one; also sets non-repetitive
%^	mode for setting address, account, and advice.
%^ Fred P. Isaacs  15-MAR-1996
%^    Limit depth for AIN execution of eql RRT match parameter AINs to 1.
%^    Remember change to BKT advice when executing AIN.  Map BKT to a real
%^    advice type when done.
%^ Fred P. Isaacs   19-APR-1996
%^	Insulate id in calls to ACCT_LOOKUP and make sure any changes
%^	made to fill out the id are kept.
%^ Fred P. Isaacs  9-MAY-1996
%^      Removed code to reset Cdt_wir_key since this is now done in
%^	the CREDIT_ADVICE_LOOKUP routine.
%^ Fred P. Isaacs  17-MAY-1996
%^      Shortened error memos; made error /info memo write more robust.
%^ John R. Phelan  02-SEP-1996
%^      Set the NOF Cdt_account correctly.  #19175, #19199, #19313.
%^ John R. Phelan  26-SEP-1996
%^      Break Ent_c_acc_set and clear out other account level fields
%^      when Cdt_account is cleared.  #20393
%^ John R. Phelan  27-SEP-1996
%^      Add call to Intrtl_spec_pref_corr to determine
%^      site specific preferred correspondents.  #19967
%^ John R. Phelan  16-OCT-1996
%^      Break Relget_adr_set and Ent_c_adr_set for NOF parties.  #21072
%^ John R. Phelan   24-OCT-1996
%^      Make sure Set_nof_cdt_account is called prior to calling
%^      Set_credit_unit_cnf to make sure that the Cdt_account field is
%^      set correctly.  Set_credit_unit_cnf passes Cdt_account to the
%^      Nof_domicil_unit Intrtl routine.  #21591
%^ John R. Phelan    24-OCT-1996
%^      Check for a valid AIN Alt/Acct before pushing down the credit party.
%^      If the AIN Alt/Acct is not-on-file or ambiguous, write an error memo,
%^      and send the item to exception, without changing the existing credit
%^      party.  Also, fix a bug that caused the credit name and address to
%^      be blanked out if the address didn't have a zip code.  #21006
%^ John R. Phelan    28-OCT-1996
%^      Added Preferred advice and preferred submethod return arguments
%^      from Intrtl_spec_pref_corr routine.  #20726
%^ John R. Phelan    21-NOV-1996
%^      Strip possible "/" off the preferred account before using it to do
%^      a search on the Rel_acc_index.  #22371
%^ John R. Phelan    23-JAN-1997
%^	Make sure address sets are always connected NOMOD.  #22302
%^ John R. Phelan    13-MAR-1997
%^      Cross currency changes.  #23745
%^ John R. Phelan    13-MAR-1997
%^      Connect up the Relget_adr_set before calling Push_credit_party.  #24256
%^ John R. Phelan    13-MAR-1997
%^      Clear out the Cdt_hold flag from the previous account whenever
%^      the Cdt_account field is cleared.  #24455
%^
%^	Fred P. Isaacs	23-JUL-1997.  Check that account etc. are not spaces
%^		before clearing them.
%^
%^      John R. Phelan  03-FEB-1998
%^      35648   Added three new parameters to the Intrtl_spec_pref_corr
%^              routine to pass the 3 characters suffixes of P/ accounts,
%^              and the bank wire service register.  Changed to call the new
%^              Validate_pid_adv_type subroutine to determine the valid "P"
%^              advice type, since this can now vary depending on bank.
%^		These changes are necessary for the Amex German Clearing 
%^		Interface.
%^
%^      John R. Phelan  10-FEB-1998
%^      39285   Implement Aux AIN Standing Instructions for the Amex German
%^              clearing interface.  They need to be able to add a single
%^              AIN to Aux records.  Acct_lookup will return the AIN in
%^              Relget si set.  
%^
%^ 	Fred P. Isaacs	8-APR-1998
%^	41596.  Now forces in bank id before lookup on AIN and also in 
%^		credit party when credit party bank is not the same as the
%^		owning bank for the message.
%^
%^ 	Fred P. Isaacs	27-APR-1998
%^	42122.  Now allows AIN to cite ABA from AUX but not NOF ABA.
%^
%^	Fred Isaacs	10-SEP-1998	#45875
%^ 	Now changes ID in message to match credit account.
%^
%^ 	Fred P. Isaacs	5-MAY-1999	54146(PORT)
%^	Corrected call to GET_SUFFIX_FROM_PID
%^
%^	K. Hanlon	14-Jun-1999	PER 50434
%^	Call SI_COPY_ADV to copy the advice set into the message (adv_Seq)
%^	(MT103 processing needs this information)
%^
%^	Fred Isaacs	26-OCT-2000	68396
%^	Add currency and amount arguments to call to CUST_SPEC_PREF_CORR routine
%^	so that those passed as arguments to CREDITSIDE routines can be passed
%^	through to CUST routines.  They are not set in the message yet.
%^
%^	Fred Isaacs	1-NOV-2000	67416, 67675
%^	Make sure that record structure of preferred correspondent ids is
%^	reflected in code and that record lengths are passed as an argument when
%^	records are passed.
%^
%^	Fred P. Isaacs	7-FEB-2001	70982
%^	Move SET_NOF_CDT_ACCOUNT calls to right place.
%^	Make clearing recon field explicit.
%^
%^ 	Fred P. Isaacs	10-APR-2001	71839
%^	Cleaned up logic to force preferred bank into AIN ABA.
%^
%^	S. Smith	25-Feb-2002	81673, 81772
%^	Do not null out the cdt_recon_ref field if this message is
%^	a repetitive. 
%^
%^	H. Zindell	31-Aug-2004	99599 (roll forward from 1.2)                
%^	The CREDITSIDE_REROUTE module is no longer the primary area of        
%^	processing for  rerouting a message to a new channel and adjusting
%^	the credit record. That processing is now concentrated in
%^	CHANNEL_DETERMINATION" and "CREDITSIDE_NEW_CHANNEL". So, 
%^	CREDITSIDE_REROUTE's current role is to accept a target channel 
%^	passed from the calling module (primarily PRR), make the necessary calls to
%^	"CHANNEL_DETERMINATION" and "CREDITSIDE_NEW_CHANNEL" and return
%^	success or fail to the calling module. All other processing 
%^	has been removed.
%^
%^ D. Beer	31-Aug-2004	113640
%^	Change CREDITSIDE_REROUTE to call CREDITSIDE_NEW_CHANNEL even if
%^	CHANNEL_DETERMINATION fails. CREDITSIDE_NEW_CHANNEL might find an RRT AIN
%^	which makes the reroute succeeds.
%^
%^ H.Zindell	09-Sep-2004	99599 (roll forward from 1.2)                
%^	The newer Csid_disable_AIN param in CREDITSIDE_REROUTE's call to 
%^	CHANNEL_DETERMINATION got dropped/overwritten during the 
%^	roll forward of CREDITSIDE_REROUTE from 8/31/04. Restoring it here.
%^
%^  Fred P. Isaacs	13-SEP-2004  116939
%^	Add missing argument to CREDITSIDE_NEW_CHANNEL() call.
%^

%^
%^ Ken Bjelke 	21-Aug-2006	132692
%^	If cdt_acc_2.sec_flg is Information, leave all cdt_acc_2 field intact.
%^
%^ End Revision History
%^******************************************************************************

%^******************************************************************************
%module CREDITSIDE_REROUTE;

%^*****************************************************************************
%^                                                                            *
%^ Paragraphs in this procedure are labeled as follows:                       *
%^                                                                            *
%^	A100_MAIN	     Subroutine entry point, dispatch, and return
%^                                                                            *
%^*****************************************************************************
%linkage
01  Targ_chnl_ls    	%Str(3);
01  Return_val_ls      %Boolean;

%Procedure using Targ_chnl_ls
 	RETURNING  Return_val_ls.

%^*****************************************************************************
A100_MAIN.

	Set Success_is in return_val_ls to true.

%^^^^^^Okay.  Let's see if we have an on_file credit party.
       If (Cdt_rel_id of Ent_credit_set = 0 )
%^^^^^^    NOF, so give up now.
	    Set Failure_is in return_val_ls to true
	    %EXIT PROGRAM;
	End-if.

      
       %Beg                                     
	 Previous_chnl_ws = Ent_credit_set.Cdt_adv_typ; 
	 Csid_err_memo = null;
	%End.
	
	If targ_chnl_ls = spaces or     
          targ_chnl_ls	= "ANY"
	Then
%^^^^^^^^^^^we pass the previous channel to determine a new channel       
	     %Beg
	      Chnl_to_skip_ws = Previous_chnl_ws ;  
  	      Ent_ftr_set.Flgs.Cdt_adv_flg = "N";
	     %End
       Else
%^^^^^^^^^^^we pass a blank channel to verify whether requested
%^^^^^^^^^^^target channel is ok.
	     Move targ_chnl_ls to Targ_chnl_ws
	     %Beg
	      Chnl_to_skip_ws = null; 
  	      Ent_ftr_set.Flgs.Cdt_adv_flg = "Y";
  	      Ent_credit_set.Cdt_adv_typ = Targ_chnl_ws;
	     %End
	End-if.

	%^ Find/validate new channel. Hold any error messages in
	%^ Ent_errors_seq until after CREDITSIDE_NEW_CHANNEL in case
	%^ an AIN makes the error obsolete.

	%Beg
	Alloc_temp: Ent_errors_seq(mod);
	%End.
	Call "CHANNEL_DETERMINATION" Using By Reference Csid_true_ws
					   By Reference Csid_false_ws
					   By Reference Chnl_to_skip_ws
					   By Reference csid_chan_acc_ws
					   By Reference csid_chan_acc_ws_lengths
					   By Reference Csid_disable_AIN_ws
		                     returning Csid_chdet_stat_ws.
	%Beg
	Break: Ent_errors_seq;
	%End.

	%^ If CHANNEL_DETERMINATION fails, we might still be OK if
	%^ CREDITSIDE_NEW_CHANNEL finds an AIN. Pass a special "Ain"
	%^ value to CREDITSIDE_NEW_CHANNEL signifying that it should only
	%^ succeed if an AIN can be found.

	If Failure_is in Csid_chdet_stat_ws
	Then
	    Move "Ain" to Previous_chnl_ws
	End-if.

	Call "CREDITSIDE_NEW_CHANNEL" using
		by reference Previous_chnl_ws
		by reference csid_chan_acc_ws
		by reference csid_chan_acc_ws_lengths
		By Reference Csid_disable_AIN_ws
		returning Sts_ws.

	If Failure_is in Sts_ws

		%^ If the CHANNEL_DETERMINATION call above failed, report its error now.

		If Failure_is in Csid_chdet_stat_ws
		Then
		    Set Failure_is in return_val_ls to true
		    If Txt_length of Ent_errors_seq_lengths > 0 then
			%Beg
			Csid_err_memo = Ent_errors_seq.Txt;
			%End
			Perform X900_error_memo THRU 
				X900_error_memo_end
		    End-if
		    %Beg
		     Csid_err_memo = 
		       "Problem finding alternate channel or verifying target channel.";
		    %End
		    Perform X900_error_memo THRU 
			    X900_error_memo_end
		    %EXIT PROGRAM;
		End-if

	        Set Failure_is in return_val_ls to true
		%Beg
		 Csid_err_memo = "Failure in CREDITSIDE_NEW_CHANNEL.";
		%End
                Perform X900_error_memo THRU 
		         X900_error_memo_end
               %EXIT PROGRAM;
	End-if.

A100_MAIN_END.
	%EXIT PROGRAM.


X900_ERROR_MEMO.
*  This paragraph writes an error memo using the text string in Csid_err_memo.
	If Csid_err_memo_length = 0 
	    GO TO X900_ERROR_MEMO_END
	END-IF.
	Move SPACES to Csid_temp_memo
	If Csid_err_memo_length > 80
	    Move 80 to Csid_temp_memo_length
	ELSE
	    Move Csid_err_memo_length to Csid_temp_memo_length
	END-IF
	Move Csid_err_memo(1:Csid_temp_memo_length) to 
		Csid_temp_memo(1:Csid_temp_memo_length)
	%Beg
	ALLOC_END: Ent_msg_history (mod,
			.qname (
				.Idbank = Ent_ftr_set.loc_info.bank,
				.Idloc = NULL,
				.Idname = "*SYS_MEMO"),
			.memo   = Csid_temp_memo,
			.qtype	= "OBJTYP$_NULL");
	%End.
X900_ERROR_MEMO_END.
   EXIT.


%^
%^ CREDITSIDE_PUSHSCR routine.
%^
%^   Calling format:
%^	Call "Creditside_pushdown" Using
%^		By Reference New_adr_idtype_ls
%^		By Reference New_adr_id_ls
%^		By Reference New_acc_req_ls
%^		By Reference New_acc_name_ls
%^		By Reference Do_pushdown_ls
%^		By Reference Error_memo_ls
%^		By Reference Error_memo_length_ls
%^	    Giving Return_status_ws.
%^	Possible return status values are:
%^		SUCCESS
%^		FAILURE
%^
%^    This routine is used to change the credit party when a new credit party
%^ needs to be inserted or overwritten.  It assumes that the funds transfer
%^ screen is in use.
%^    The new address identifier is passed in as two arguments -- an idtype and
%^ an ID.  This address MUST be on file and must not have any AIN SI's or 
%^ global preferred correspondents.
%^    The new account name argument must be set if an account is to be used 
%^ which is not on the new address's account sequence.
%^    If the new account argument name is not set, the account request argument
%^ determines how the account will be selected from the address's account
%^ sequence.  If an account type is requested, an account of that type will
%^ be selected if there is one.  If type "*" is requested, then any account
%^ type will be selected.  (If there is a default account, this will select
%^ it, regardless of type.)  If the account request argument is blank (SPACE)
%^ NO account will be selected.
%^    The pushdown argument determines whether the new credit party is inserted
%^ or whether it overwrites the current credit party.
%^    If the credit party insertion or substitution was accomplished correctly,
%^ including locating and connecting the account if one was desired, the 
%^ status will be returned SUCCESS and a memo will be posted to the message
%^ history.  If any part failed, the status will be returned FAILURE with an 
%^ FTRSCR message set.  Error_memo_ls will contain a descriptive memo but no 
%^ error memo will be written to the message history.
%^
%^ INPUT ARGUMENTS:
%^ explicit:
%^  New_adr_idtype_ls	STR(1) 		Id type for new credit party address.
%^  New_adr_id_ls	STR(25) 	Id for new credit party address.
%^  New_acc_req_ls	STR(1) 		Selector for new credit party account.
%^  New_acc_name_ls	ACC_ID_REC.DDF  Predetermined account id or SPACES.
%^  Do_overwrite_ls	LONG		Overwrite if non-0; else push down.
%^ implicit:
%^   Credit party:
%^	Ent_credit_set.Cdt_typ   
%^
%^ OUTPUT ARGUMENTS:
%^ explicit:
%^  Error_memo_ls	STR(80)		Text of error memo, if any.
%^  Error_memo_length_ls WORD		Length of error memo.
%^  Return_status_ws is SUCCESS if new credit party was set up, otherwise 
%^     FAILURE.
%^Implicit:
%^   Message history
%^   Credit party:
%^	Ent_credit_set.Cdt_adr_set_ptr
%^	Ent_credit_set.Cdt_rel_id
%^	Ent_credit_set.Cdt_adr_bnk_id
%^	Ent_credit_set.Cdt_typ
%^	Ent_credit_set.Cdt_name1		
%^	Ent_credit_set.Cdt_name2		
%^	Ent_credit_set.Cdt_name3		
%^	Ent_credit_set.Cdt_name4		
%^	Ent_credit_set.Cdt_account
%^	Ent_credit_set.Cdt_acc_class         
%^	Ent_credit_set.Cdt_acc_parent_code
%^	Ent_credit_set.Cdt_acc_prod_codes         
%^	Ent_credit_set.Cdt_adr_class         
%^	Ent_credit_set.Cdt_adv_typ         
%^	Ent_credit_set.Cdt_concen_acc
%^	Ent_credit_set.Cdt_currency         
%^	Ent_credit_set.Cdt_department         
%^	Ent_credit_set.Cdt_recon_ref        
%^	Ent_credit_set.Cdt_shnam         
%^	Ent_credit_set.Cdt_spc_inst1         
%^	Ent_credit_set.Cdt_spc_inst2         
%^	Ent_credit_set.Cdt_spc_inst3
%^	Ent_credit_set.Cdt_sys_of_rec         
%^	Ent_credit_set.Cdt_wir_key         
%^	Ent_credit_set.Flgs.Cdt_hold_flg         
%^	Ent_credit_set.Pymnt.Adv_type         
%^	Ent_credit_set.Pymnt.Location
%^	Ent_credit_set.Pymnt.Phn_time         
%^	Ent_credit_set.Pymnt.Que 
%^   IB1:
%^	Ent_credit_set.Ib1_adr_set_ptr
%^	Ent_credit_set.Ib1_adr_bnk_id
%^	Ent_credit_set.Ib1_rel_id
%^	Ent_credit_set.Ib1
%^	Ent_credit_set.Ib1_id_overflow
%^	Ent_credit_set.Ib1_name1
%^	Ent_credit_set.Ib1_name2
%^	Ent_credit_set.Ib1_name3
%^	Ent_credit_set.Ib1_name4
%^   IBK:
%^	Ent_credit_set.Ibk_adr_set_ptr
%^	Ent_credit_set.Ibk_adr_bnk_id
%^	Ent_credit_set.Ibk_rel_id
%^	Ent_credit_set.Ibk
%^	Ent_credit_set.Ibk_id_overflow
%^	Ent_credit_set.Ibk_name1
%^	Ent_credit_set.Ibk_name2
%^	Ent_credit_set.Ibk_name3
%^	Ent_credit_set.Ibk_name4
%^   BBK:
%^	Ent_credit_set.Bbk_adr_set_ptr
%^	Ent_credit_set.Bbk_adr_bnk_id
%^	Ent_credit_set.Bbk_rel_id
%^	Ent_credit_set.Bbk
%^	Ent_credit_set.Bbk_id_overflow
%^	Ent_credit_set.Bbk_name1
%^	Ent_credit_set.Bbk_name2
%^	Ent_credit_set.Bbk_name3
%^	Ent_credit_set.Bbk_name4
%^   BNP:
%^	Ent_credit_set.Bnp
%^	Ent_credit_set.Bnp_id_overflow
%^	Ent_credit_set.Bnp_name1
%^	Ent_credit_set.Bnp_name2
%^	Ent_credit_set.Bnp_name3
%^	Ent_credit_set.Bnp_name4
%^   FTR:
%^	Ent_ftr_set.cdt_adv_flg
%^      Ent_ftr_set.chrg.cdt_chrg 
%^	Ent_ftr_set.chrg.dbt_chrg 
%^	Ent_ftr_set.currency_code 
%^	Ent_ftr_set.flgs.adv_ovr_flg 
%^	Ent_ftr_set.flgs.cdt_adv_flg 
%^	Ent_ftr_set.instr_adv_type 
%^	Ent_ftr_set.loc_info.bank 
%^	Ent_ftr_set.si_flgs.check_found 
%^	Ent_ftr_set.si_flgs.cor_done 
%^	Ent_ftr_set.si_flgs.fx_found 
%^	Ent_ftr_set.si_flgs.pre_found 
%^	Ent_ftr_set.si_flgs.rte_done 
%^	Ent_ftr_set.type_code
%^
%^ Modification history:
%^
%^ Fred P. Isaacs  8-JAN-1996
%^    Initial implementation.
%^ Fred P. Isaacs  12-JAN-1996
%^    Now clears fed short name if there isn't one; also sets non-repetitive
%^	mode for setting address, account, and advice.
%^ Fred P. Isaacs  9-MAY-1996
%^    Removed code to reset Cdt_wir_key since this is now done in
%^	the CREDIT_ADVICE_LOOKUP routine.
%^ Fred P. Isaacs  19-JUN-1996
%^	Fixed defaults for LTR advice.
%^ John R. Phelan  02-SEP-1996
%^      Set the NOF Cdt_account correctly.  #19175, #19199, #19313.
%^ John R. Phelan  26-SEP-1996
%^      Break Ent_c_acc_set and clear out other account level fields
%^      when Cdt_account is cleared.  #20393
%^ John R. Phelan  16-OCT-1996
%^      Break Relget_adr_set and Ent_c_adr_set for NOF parties.  #21072
%^ John R. Phelan   24-OCT-1996
%^      Make sure Set_nof_cdt_account is called prior to calling
%^      Set_credit_unit_cnf to make sure that the Cdt_account field is
%^      set correctly.  Set_credit_unit_cnf passes Cdt_account to the
%^      Nof_domicil_unit Intrtl routine.  #21591
%^ John R. Phelan    30-DEC-1996
%^      Clear out credit party name and address when the address
%^      changes from on-file to not-on-file.  #21817
%^ John R. Phelan    16-JAN-1997
%^      Connect up the Relget_adr_set before calling Push_credit_party.  #24256
%^ John R. Phelan    23-JAN-1997
%^	Make sure address sets are always connected NOMOD.  #22302
%^ John R. Phelan    13-MAR-1997
%^      Cross currency changes.  #23745
%^
%^	Fred P. Isaacs	23-JUL-1997.  Check that account etc. are not spaces
%^		before clearing them.
%^
%^      John R. Phelan  03-FEB-1998
%^      35648   Changed to call the new Validate_pid_adv_type subroutine to 
%^		determine the valid "P" advice type, since this can now vary 
%^		depending on bank.  This change is necessary for the Amex 
%^		German Clearing Interface.
%^
%^	Fred Isaacs	10-SEP-1998	#45875
%^ 	Now changes ID in message to match credit account.
%^
%^	Fred Isaacs	18-May-1999	#54525
%^	Make sure we preserve current form of credit party if we do 
%^	a pushdown.
%^
%^	K. Hanlon	14-Jun-1999	PER 50434
%^	Call SI_COPY_ADV to copy the advice set into the message (adv_Seq)
%^	(MT103 processing needs this information)
%^
%^	Fred Isaacs	18-May-1999	#57677 migrate lost fix for 36764
%^	Make sure we force base currency of bank for inserted siezure account.
%^
%^	Fred Isaacs	20-JAN-2000	60544
%^	Clean up base id argument to have a zero length when its blank.
%^	COMPOSE will turn a null string into a single trailing space even if
%^	you turn off trailing spaces.
%^
%^ 	Ken Bjelke	14-Mar-2003	93662
%^	add calls to PRULE_CHANGE_CREDIT and PRULE_UPDATE_PARTY.
%^
%^ 	Melynda Harris	6-APR-2005	121781
%^	Check Relget_reject_flag (from REL_GET call) for "C", to see if user
%^	chose shift/cancel while in REL_GET.
%^
%^	K. Morrow	17-Oct-2005
%^	Replace old error messaging logic with new logic for 3.0 UI
%^	(ie. calls to "ftrscr_write_error"). Remove FTRSCR fsect.
%^
%^
%^ Ken Bjelke 	21-Aug-2006	132692
%^	If cdt_acc_2.sec_flg is Information, leave all cdt_acc_2 field intact.
%^ 
%^ Ken Bjelke 	31-Aug-2006	132097
%^	Clear cdt_recon_ref  prior to re-lookup, account is changing. 
%^
%^ End revision history
%^******************************************************************************

%^******************************************************************************
%module CREDITSIDE_PUSHSCR;

%^*****************************************************************************
%^                                                                            *
%^ Paragraphs in this procedure are labeled as follows:                       *
%^                                                                            *
%^	A100_MAIN	     Subroutine entry point, dispatch, and return
%^                                                                            *
%^*****************************************************************************
%^ Macro definitions.
%^ %MAR
%^ .default	displacement,long
%^ %end
%^*****************************************************************************

%linkage
01  New_adr_idtype_ls	  	%Str(1);
01  New_adr_id_ls	  	%Str(25);
01  New_acc_req_ls	  	%Str(1);
01  New_acc_name_ls	  	%Str(34);
01  Do_overwrite_ls	  	%Long;
01  Error_memo_ls	  	%Str(80);
01  Error_memo_length_ls  	%Length;
01  Creditside_pushscr_ls	%Boolean;


%Procedure using New_adr_idtype_ls, New_adr_id_ls, New_acc_req_ls, 
		New_acc_name_ls, Do_overwrite_ls, Error_memo_ls,
		Error_memo_length_ls
 	RETURNING  Creditside_pushscr_ls.

%^*****************************************************************************

%^*****************************************************************************
A100_MAIN.
* Make sure that we have room to DO a pushdown.
	Set Success_is in Creditside_pushscr_ls to true.
	Move ZERO to Error_memo_length_ls
	%Beg
	Csid_pref_corr_rec = NULL ;
	Csid_pref_next_id_rec = NULL ;
	%End.
	If (Do_overwrite_ls = 0 )
	   AND ( (Ib1_idtype of Ib1 of Ent_credit_set NOT = SPACE)
	       OR ( (Ib1_length of Ent_credit_set_lengths > 2 )
	            AND (Ib1_id of Ib1 of Ent_credit_set NOT = SPACES ) )
	       OR ( (Ib1_name1_length of Ent_credit_set_lengths NOT = 0 )
                    AND (Ib1_name1 of Ent_credit_set NOT = SPACES ) ) )
	THEN
%^	    %Beg Ftrscr.credit.cdt_typ.cdt_id.msg = "VMSG$_NOMORE_PARTIES";
	    %Beg
	    screen_field_ws = "credit.cdt_typ.cdt_id";
            error_mnemonic_ws = "VMSG$_NOMORE_PARTIES";
	    %End
	    call "FTRSCR_WRITE_ERROR" using
	      by reference screen_field_ws
	      by reference error_mnemonic_ws
	    %Beg
	    Csid_compose ^OUT(Csid_err_memo)
	    "No empty creditside parties -- no place to put credit party.", / ;
	    %End
 	    Set Failure_is in Creditside_pushscr_ls to true
	    GO TO A100_MAIN_CLEANUP
	END-IF.
* Initialize returned variables.
 	Move SPACES to Csid_id_ws. 
	Move New_adr_idtype_ls to Idtype of Csid_pref_corr_rec
	Move New_adr_id_ls to Csid_id_ws.
	Move %SIZ(Csid_id_ws) to Csid_id_ws_length.
	%Beg
        Csid_parse ^IN(Csid_id_ws)
		Csid_pref_corr_rec.Idkey, ^SPACE, / ;
	%End.
	Move SPACES to Csid_know_acc_id
	Move New_acc_name_ls to Csid_know_acc_id
	Move SPACES to Csid_acc_id_ws
	%Beg  Csid_acc_id_ws = Csid_pref_corr_rec.idkey ;  %End

* Now have new preferred correspondent in Csid_pref_corr_rec.  
* See if we need to push down the credit party.
	Set Failure_is in Csid_push_error to TRUE.
	If (Do_overwrite_ls = 0 )
* Push it down.
	    %ACE_IS Relget_adr_set connected giving Csid_conn_stat;
            %^ If Relget_adr_set is connected to the wrong address, break it
            If (Success_is in Csid_conn_stat)   and
                Rel_id of Relget_adr_set not = Cdt_rel_id of Ent_credit_set
                %Beg BREAK: Relget_adr_set; %End
                Move ZERO to Csid_conn_stat
            end-if
            %^ If Relget_adr_set isn't connected, zero out the Rel_id
            If (Failure_is in Csid_conn_stat)   then
                Move 0 to Rel_id of Relget_adr_set
            end-if
            %^ If we have an on-file address, and it's not connected yet,
            %^   connect Relget_adr_set to it
            If (Cdt_rel_id of Ent_credit_set > 0)
		AND (Failure_is in Csid_conn_stat)
	    THEN
                %Beg 
		Ent_credit_set.cdt_adr_set_ptr CONN: Relget_adr_set(NOMOD) ; 
		%End
            end-if
%^ Preserve the old ID
	    %Beg
	    Csid_pref_next_id_rec.Idtype = Ent_credit_set.cdt_typ.cdt_idtype;
	    Csid_clip_compose ^OUT(Csid_pref_next_id_rec.idkey)
		Ent_credit_set.cdt_typ.cdt_id, / ;
	    %End
	    If (Failure_is in Csid_clip_compose_status )
		%Beg  Csid_pref_next_id_rec = NULL;  %End
	    END-IF

	    CALL "PUSH_CREDIT_PARTY" USING
		By reference Bank of Loc_info of Ent_ftr_set
		By reference Csid_pref_next_id_rec
		By reference Csid_pref_next_id_rec_lengths
		By reference Csid_pushed_credit
	      RETURNING Csid_ret_stat
	    If (Failure_is in Csid_ret_stat   )
%^	        %Beg Ftrscr.credit.cdt_typ.cdt_id.msg = "VMSG$_NOMORE_PARTIES";
	        %Beg
	        screen_field_ws = "credit.cdt_typ.cdt_id";
		error_mnemonic_ws = "VMSG$_NOMORE_PARTIES";
		%End
	        call "FTRSCR_WRITE_ERROR" using
	          by reference screen_field_ws
		  by reference error_mnemonic_ws
		%Beg
	    	Csid_compose ^OUT(Csid_err_memo)
	        "No empty creditside parties -- error moving credit party.", / ;
	        %End
 	        Set Failure_is in Creditside_pushscr_ls to true
		Set Success_is in Csid_push_error to TRUE
	    END-IF
	END-IF.	
	If Success_is in Csid_push_error
	   GO TO A100_MAIN_CLEANUP
	END-IF.	 	

* I'm ready for my lookup, Mr. DeMille.
	%Beg  
	BREAK: Ent_c_adr_set ;  
	BREAK: Ent_c_acc_set ;     	
	BREAK: Ent_c_acc_rel_reg;
	%End.
	Set CDT in Relget_title_flag to TRUE
	Move Spaces to Csid_lkup_pend_del
	%Beg  Csid_next_function = Menu_next_function;  %End
	Call "REL_GET" USING 
	    By reference Idtype of Csid_pref_corr_rec
	    By reference Csid_acc_id_ws
	    By reference Csid_acc_id_ws_length
	    by reference Csid_lkup_pend_del
	  RETURNING Csid_ret_stat

* User selected MENU or SHIFT/CANCEL while in RELGET.
	If Relget_reject_flag = "M"
	OR Relget_reject_flag = "C"
	    Go to A100_MAIN_END
	End-if.

	If Csid_next_function not = Menu_next_function
	    Go to A100_MAIN_END
	End-if.

	If (Success_is in Csid_ret_stat   )
	   OR (Relget_msgcode = Vmsg_dat_notonfile_wc )
	THEN
* We actually did get a REL or AUX db hit, so let's copy the address.
	     Perform B200_COPY_ADDRESS through B200_COPY_ADDRESS_END
	END-IF.

	If (Relget_return_key NOT = SPACES )
	    %Beg
	    Csid_parse ^IN(Relget_return_key), Csid_return_key, 
			^SPACE, / ;
	    %End
	ELSE
	    %Beg  Csid_return_key = Csid_acc_id_ws ;  %End
	END-IF.	

%^ Obselete	%Beg  BREAK: Ent_adv_seq ;  %End

	If (Failure_is in Csid_ret_stat   )
	    If (Csid_lkup_pend_del = "T" )
%^		%Beg Ftrscr.credit.cdt_typ.cdt_id.msg = "VMSG$_ADR_PEND_DEL";  %End
 	    	%Beg
	    	screen_field_ws = "credit.cdt_typ.cdt_id";
            	error_mnemonic_ws = "VMSG$_ADR_PEND_DEL";
	    	%End
	    	call "FTRSCR_WRITE_ERROR" using
	   	  by reference screen_field_ws
	    	  by reference error_mnemonic_ws
	    ELSE
%^		%Beg Ftrscr.credit.cdt_typ.cdt_id.msg = "VMSG$_MR_CORRNOTONFILE"; %End
 	    	%Beg
	    	screen_field_ws = "credit.cdt_typ.cdt_id";
            	error_mnemonic_ws = "VMSG$_MR_CORRNOTONFILE";
	    	%End
	    	call "FTRSCR_WRITE_ERROR" using
	   	  by reference screen_field_ws
	    	  by reference error_mnemonic_ws
	    END-IF

            If (Cdt_rel_id of Ent_credit_set NOT = 0 )
                %Beg
                Ent_credit_set( .Cdt_name1  = NULL ,
                                .Cdt_name2  = NULL ,
                                .Cdt_name3  = NULL ,
                                .Cdt_name4  = NULL ,
				.Cdt_shnam = NULL,
				.cdt_recon_ref 	= NULL ) ;
                %End
                %^ Clear all the other stuff left over from previous
                %^   on-file address
                Call "ACCTSUB_CDT_NOF"
                MOVE "N" to Cdt_comm_charge_ws
                MOVE "N" to Cdt_cbl_charge_ws
            END-IF
	    %Beg
	    Ent_credit_set (.cdt_rel_id         =  <0>,
			    .cdt_adr_set_ptr    DELETE,
			    .cdt_typ (.cdt_idtype = Relget_return_idtype,
				      .cdt_id     = Csid_return_key,
	    			      .cdt_ovr    = "*" ) ) ;
            BREAK: Relget_adr_set ;
            BREAK: Ent_c_adr_set ;
	    %End
	    Set Failure_is in Creditside_pushscr_ls to true
 	ELSE
	    If (Do_overwrite_ls = 0 )
 	        %Beg
	        Csid_compose ^OUT(Csid_info_memo)
			"Inserted new credit party ", Csid_pref_corr_rec,
			 " pushing down ", Ent_credit_set.cdt_typ, / ;  
		%End
	    ELSE
 	        %Beg
	        Csid_compose ^OUT(Csid_info_memo)
			"New credit party ", Csid_pref_corr_rec,
			 " overwrote ", Ent_credit_set.cdt_typ, / ;  
		%End
	    END-IF
	    %Beg
	    ALLOC_END: Ent_msg_history (mod,
			.qname (
				.Idbank = Ent_ftr_set.loc_info.bank,
				.Idloc = NULL,
				.Idname = "*SYS_MEMO"),
			.qtype	= "OBJTYP$_NULL",
			.memo   = Csid_info_memo );
	    %End
 	    If (Cdt_ovr of Cdt_typ of Ent_credit_set NOT = SPACE )
	        %Beg  Ent_credit_set.Cdt_typ.Cdt_ovr = " " ;  %End
	    END-IF
	    %Beg
	    Relget_adr_set EQUATE: Ent_c_adr_set(NOMOD) ;
	    Ent_credit_set.Cdt_typ (.Cdt_idtype = Relget_return_idtype,
				    .Cdt_id = Csid_return_key ) ;
	    Ent_credit_set.Cdt_adr_bnk_id = Relget_return_bank ;
%^ OBSELETE	    Relget_adr_set.adv_seq CONN: Ent_adv_seq(NOMOD) ;
	    %End


	    Perform X930_CHANGE_CREDIT thru
		    X930_CHANGE_CREDIT_END

	    Perform B300_SET_ADVICE through B300_SET_ADVICE_END

* The address info and the credit adr set are already set up.
	    Move ZERO to Csid_temp_long
            Move Priority_flg of Ent_ftr_set to Csid_hold_priority_ws
	    Call "SET_CREDIT_ADDRESS" USING
	        By reference Csid_temp_long	%^ Act like a non-repetitive
	      RETURNING Csid_ret_stat

            If Priority_flg of Ent_ftr_set not = Csid_hold_priority_ws
                %Beg
                Csid_compose ^OUT(Csid_info_memo),
                    "Priority set to ", Ent_ftr_set.flgs.priority_flg,
                    " by credit party ", Ent_credit_set.cdt_typ(.cdt_idtype,
		    "/", .cdt_id) , / ;
		ALLOC_END: Ent_msg_history (mod,
			.qname (.Idbank = Ent_ftr_set.loc_info.bank,
				.Idloc = NULL,
				.Idname = "*SYS_MEMO"),
			.qtype  = "OBJTYP$_NULL",
                        .memo   = Csid_info_memo );
                %End
            End-if

	    %Beg
	    BREAK: Csid_acc_seq ;
	    Ent_c_adr_set.account_seq CONN: Csid_acc_seq(NOMOD) ;
	    %End
	END-IF.

	If (Failure_is in Creditside_pushscr_ls  )
%^	    GO TO A100_MAIN_NOF
	    %^ If this is a not on file account, check to see if any unit
            %^ confirmations need to be generated.
            If Cdt_rel_id of Ent_credit_set = 0 then
                Call "SET_CREDIT_UNIT_CNF"
            end-if
	    GO TO A100_MAIN_CLEANUP
	END-IF.
	If (New_acc_req_ls NOT = SPACE )
	    Perform B400_GET_ACCOUNT through B400_GET_ACCOUNT_END
            If (Success_is in Creditside_pushscr_ls   )
* Have credit account.  Set it into message.
	        Move ZERO to Csid_temp_long
	        Call "SET_CREDIT_ACCOUNT" USING
	            By reference New_acc_name_ls
	            By reference Csid_temp_long
		    By reference Csid_spec_key_dummy
                  RETURNING Csid_ret_stat
	        Move Csid_ret_stat to Creditside_pushscr_ls
	    END-IF
            If (Success_is in Creditside_pushscr_ls   )
* Now juggle things if the credit advice type requires it.
	        Move ZERO to Csid_temp_long
	        Call "SET_CREDIT_ADVICE" USING
	            By reference New_acc_name_ls
	            By reference Csid_temp_long
                  RETURNING Csid_ret_stat
	        Move Csid_ret_stat to Creditside_pushscr_ls
	    END-IF
	END-IF.
	%beg csid_upd_level cdt_party_is; %end
	Call "PRULE_UPDATE_PARTY" Using
		By Reference csid_upd_level
		By Reference csid_pr_memo
		by reference csid_pr_memo_length
	returning csid_ret_stat.
%^A100_MAIN_NOF.

        %^ If this is a not on file account, check to see if any unit
    %^ confirmations need to be generated.
    %^    If Cdt_rel_id of Ent_credit_set = 0 then
    %^            Call "SET_CREDIT_UNIT_CNF"
    %^    end-if.

A100_MAIN_CLEANUP.
	If (Csid_err_memo_length NOT = 0 )
	    Move Csid_err_memo(1:Csid_err_memo_length) to Error_memo_ls
	    Move Csid_err_memo_length to Error_memo_length_ls
	END-IF.

A100_MAIN_END.
	%EXIT PROGRAM.


B200_COPY_ADDRESS.
%^ Copies address from Relget_adr_set to Credit party.  Also does zip code.
%^      Do not increment database to initialize fields
	If (Adr_name_length of Relget_adr_set_lengths = ZERO )
	   AND (Cdt_name1_length of Ent_credit_set_lengths NOT = ZERO )
	THEN
 	    %Beg  Ent_credit_set.Cdt_name1 = NULL;  %End
	END-IF.
	If (Adr1_length of Relget_adr_set_lengths = ZERO )
	    AND (Cdt_name2_length of Ent_credit_set_lengths NOT = ZERO )
	THEN
 	    %Beg  Ent_credit_set.Cdt_name2 = NULL;  %End
	END-IF.
	If (Adr2_length of Relget_adr_set_lengths = ZERO )
	    AND (Cdt_name3_length of Ent_credit_set_lengths NOT = ZERO )
	THEN
 	    %Beg  Ent_credit_set.Cdt_name3 = NULL;  %End
	END-IF.
	If (Adr3_length of Relget_adr_set_lengths = ZERO )
	    AND (Cdt_name4_length of Ent_credit_set_lengths NOT = ZERO )
	THEN
 	    %Beg  Ent_credit_set.Cdt_name4 = NULL;  %End
	END-IF.
	If (Fed_short_name_length of Relget_adr_set_lengths = ZERO )
	THEN
 	    %Beg  Ent_credit_set.Cdt_shnam = NULL;  %End
	END-IF.
	%Beg
	Csid_Compose Relget_adr_set (
	  .Adr_name (^IF_NOTNULL(^OUT(Ent_credit_set.Cdt_name1), ^_, /)),
	  .Adr1 (^IF_NOTNULL(^OUT(Ent_credit_set.Cdt_name2), ^_, /)),
	  .Adr2 (^IF_NOTNULL(^OUT(Ent_credit_set.Cdt_name3), ^_, /)),
	  .Adr3(^IF_NOTNULL(^OUT(Ent_credit_set.Cdt_name4), ^_, /)),
	  .Fed_short_name(^IF_NOTNULL(^OUT(Ent_credit_set.Cdt_shnam),^_, /))) ;
%^ Build a CDT_ADRT_YPE field from country code and 
%^   ADR_TYPE field of Relget_adr_set
	Csid_Compose ^OUT(Ent_credit_set.Cdt_adr_type),
		Relget_adr_set.Country_code(^STRING<2>),
		Relget_adr_set.Adr_type, /;
	%End.

%^ copy in the zip code too
	If (Zip of Relget_adr_set NOT = SPACES )
	    Call "ZIPSUB" Using
		by reference Cdt_name4 of Ent_credit_set
		by reference Cdt_name4_length of Ent_credit_set_lengths
		by reference Cdt_name3 of Ent_credit_set
		by reference Cdt_name3_length of Ent_credit_set_lengths
		by reference Zip of Relget_adr_set
		by reference Line_flg_ws

	    EVALUATE Line_flg_ws
		WHEN "4"
		    %Beg  Ent_credit_set.Cdt_name4 CHANGE;  %End

		WHEN "3"
		    %Beg  Ent_credit_set.Cdt_name3 CHANGE;  %End

	    END-EVALUATE
	END-IF.
B200_COPY_ADDRESS_END.

   EXIT.
B300_SET_ADVICE.
* Sets up advice type for new credit party.
	Move SPACES to Cdt_adv_typ of Ent_credit_set
	%Beg  
	Ent_ftr_set.flgs.Adv_ovr_flg = " " ;  
	Ent_ftr_set.flgs.Cdt_adv_flg = " " ;
	%End.
%^ REMOVED ADV_SEQ REFERENCES
	%^
	Call "CHANNEL_DETERMINATION" Using By reference Csid_false_ws
					   By Reference Csid_true_ws
					   By Content "   "
					   By Reference csid_chan_acc_ws
					   By Reference csid_chan_acc_ws_lengths
					   By Reference Csid_disable_ain_ws
		RETURNING csid_ret_stat.

B300_SET_ADVICE_END.

   EXIT.
B400_GET_ACCOUNT.
%^  Calls REL_ACCOUNT_FROM_ADR to get an account from the current address.
%^  Ent_c_adr_set must be connected.
	%^ Make local copy of argument
	Move New_acc_req_ls to Csid_party_idtype
        %^ Check to see if this a "P" advice type
	Call "GET_PID_ADV_SUFFIX" Using
	   by reference Cdt_adr_bnk_id of Ent_credit_set
           by reference Cdt_adv_typ of Ent_credit_set
	   by reference Csid_clrhs_suffix
	   by reference Csid_clrhs_suffix_length
         Returning Csid_itsa_clearhouse.

	IF (Csid_know_acc_id NOT = SPACES )
	    If (Idbank of Csid_know_acc_id NOT = SPACES )
		AND (Idbank of Csid_know_acc_id NOT = 
					Cdt_adr_bnk_id of Ent_credit_set )
	    THEN
%^ Credit party address and account cannot be in different banks.
		If (Cdt_account of Ent_credit_set NOT = SPACES )
		        %Beg
       		             Ent_credit_set (
       		                 .cdt_account            = NULL,
       		                 .cdt_acc_prod_codes     = NULL,
       		                 .cdt_acc_class          = NULL,
				 .cdt_recon_ref 	 = NULL);
			%end
			If NOT(Informational in Sec_flg of Cdt_acc_2 of Ent_credit_set)
			Then   %^ Not account related, pass along the fee info 132692
			    %Beg
               			Ent_credit_set.cdt_acc_2
			  		(.Sec_amt = <0>,
			   		 .Sec_cur = NULL,
			   		 .Sec_acc = Null);
			    %End
			    Set Null_flg in Sec_flg of Cdt_acc_2 of Ent_credit_set to true
			End-if
			If Not(MT103_Charges in ter_flg of cdt_acc_3 of Ent_credit_set)
			Then
				Set Null_flg in Ter_flg of Cdt_acc_3 of Ent_credit_set to true
				%beg
					ent_credit_set.cdt_acc_3
						    	(.Ter_amt = <0>,
							 .Ter_cur= NULL,
							 .Ter_acc = Null);
				%end
			End-if
		END-IF
		If (Cdt_hold_flg of Flgs of Ent_credit_set NOT = SPACE )
		    %Beg  Ent_credit_set.flgs.cdt_hold_flg = NULL ;  %End
		END-IF
%^	        %Beg Ftrscr.credit.cdt_typ.cdt_idtype.Msg = "VMSG$_NOSUCHACC" ;
		%Beg
		screen_field_ws = "credit.cdt_typ.cdt_idtype";
		error_mnemonic_ws = "VMSG$_NOSUCHACC";
		%End
	        call "FTRSCR_WRITE_ERROR" using
	          by reference screen_field_ws
		  by reference error_mnemonic_ws
		%Beg
 		BREAK: Ent_c_acc_set;   	
		BREAK: Ent_c_acc_rel_reg;
	    	Csid_compose ^OUT(Csid_err_memo)
	        	"New credit party account not in address bank ",
			Ent_credit_set.Cdt_adr_bnk_id, / ;
		%End				
		Set Failure_is in Creditside_pushscr_ls to true
                GO TO B400_GET_ACCOUNT_END
	    END-IF
	    Move 4 to Csid_account_mode
            %Beg
	    Csid_parse ^IN(Csid_know_acc_id.idkey)
		^SPACE, Csid_acc_id_arg, ^SPACE, / ;
	    %End				    
	ELSE
	    %Beg  BREAK: Relget_adr_set; %End
	    %ACE_IS Ent_c_adr_set connected giving Csid_conn_stat;
	    If (Failure_is in Csid_conn_stat)
	       OR (Rel_id of Ent_c_adr_set = 0 )
	    THEN
%^ We have a NOF credit party.
 		If (Cdt_account of Ent_credit_set NOT = SPACES )
		        %Beg
       		             Ent_credit_set (
       		                 .cdt_account            = NULL,
       		                 .cdt_acc_prod_codes     = NULL,
       		                 .cdt_acc_class          = NULL,
	 			 .cdt_recon_ref   	 = NULL);
			%end
			If NOT(Informational in Sec_flg of Cdt_acc_2 of Ent_credit_set)
			Then   %^ Not account related, pass along the fee info 132692
			    %Beg
               			Ent_credit_set.cdt_acc_2
			  		(.Sec_amt = <0>,
			   		 .Sec_cur = NULL,
			   		 .Sec_acc = Null);
			    %End
			    Set Null_flg in Sec_flg of Cdt_acc_2 of Ent_credit_set to true
			End-if
			If Not(MT103_Charges in ter_flg of cdt_acc_3 of Ent_credit_set)
			Then
				Set Null_flg in Ter_flg of Cdt_acc_3 of Ent_credit_set to true
				%beg
					ent_credit_set.cdt_acc_3
						    	(.Ter_amt = <0>,
							 .Ter_cur= NULL,
							 .Ter_acc = Null);
				%end
			End-if
		END-IF
		If (Cdt_hold_flg of Flgs of Ent_credit_set NOT = SPACE )
		    %Beg  Ent_credit_set.flgs.cdt_hold_flg = NULL ;  %End
		END-IF
 		%Beg
			BREAK: Ent_c_acc_set;   	
			BREAK: Ent_c_acc_rel_reg;
		%End
                GO TO B400_GET_ACCOUNT_END
	    END-IF
	    %Beg
	    Ent_c_adr_set EQUATE: Relget_adr_set(NOMOD);
	    Csid_know_acc_id = NULL;
	    Csid_acc_id_arg = NULL;
	    %End
	    If (Success_is in Csid_itsa_clearhouse )
		%^ Force a clearinghouse account
		Move "P" to Csid_party_idtype
	        Move 0 to Csid_account_mode
		Move Cdt_adv_typ of Ent_credit_set to Relget_adv_type
		If (Cdt_idtype of Cdt_typ of Ent_credit_set = "P" )
		    %Beg
		    Csid_clip_compose ^OUT(Csid_acc_id_arg )
			 Ent_credit_set.Cdt_typ.Cdt_id, / ;
	    	    %End
	        END-IF
	    ELSE
	        If (Csid_party_idtype NOT = "*" AND SPACE )
	            Move 0 to Csid_account_mode
	        ELSE
	            Move 5 to Csid_account_mode
	        END-IF
	        If (Cdt_idtype of Cdt_typ of Ent_credit_set = 
					"D" OR "V" OR "G" OR "F" )
		THEN
		    %Beg
		    Csid_parse ^IN(Ent_credit_set.Cdt_typ.Cdt_id )
			^SPACE, Csid_acc_id_arg, ^SPACE, / ;
		    Csid_know_acc_id.Idtype = 
					Ent_credit_set.cdt_typ.cdt_idtype ;
	    	    %End
	        END-IF
	    END-IF
	    If (Csid_acc_id_arg_length NOT = 0 )
	       AND (Csid_acc_id_arg(1:Csid_acc_id_arg_length) = SPACES )
	    THEN
%^ Compensate for compose peculiarity
		%Beg  Csid_acc_id_arg = NULL;  %End
	    END-IF
	END-IF.

	%Beg  Csid_ent_acc_conn = Ent_acc_set State.CONN ;  %End.
	If (Csid_ent_acc_conn NOT = 0 )
	    %Beg
	    BREAK: Csid_acc_set ;
	    Ent_acc_set EQUATE: Csid_acc_set(NOMOD) ;
	    BREAK: Ent_acc_set ;
	    %End
	END-IF.

	If (Fx_ena of Menu_cfg = LOW-VALUES )
	    Move SPACES to Csid_acc_curr_ws
	ELSE
	    Move Base_currency_id of Menu_bnk_union to Csid_acc_curr_ws
	END-IF.
	Call "REL_ACC_FROM_ADR" USING
	    By reference Csid_account_mode
	    By reference Csid_party_idtype
	    By reference Csid_acc_curr_ws
            By reference Idtype of Csid_know_acc_id
	    By reference Csid_acc_id_arg
 	    By reference Csid_acc_id_arg_length
	    By reference Bnk_id of Ent_c_adr_set
	  RETURNING Csid_ret_stat.

	If (Success_is in Csid_ret_stat   )
	    If (Relget_return_bank NOT = SPACES )
		AND (Relget_return_bank NOT = 
					Cdt_adr_bnk_id of Ent_credit_set )
	    THEN
%^ Credit party address and account cannot be in different banks.
 		If (Cdt_account of Ent_credit_set NOT = SPACES )
		        %Beg
       		             Ent_credit_set (
       		                 .cdt_account            = NULL,
       		                 .cdt_acc_prod_codes     = NULL,
       		                 .cdt_acc_class          = NULL,
			         .cdt_recon_ref 	 = NULL);
			%end
			If NOT(Informational in Sec_flg of Cdt_acc_2 of Ent_credit_set)
			Then   %^ Not account related, pass along the fee info 132692
			    %Beg
               			Ent_credit_set.cdt_acc_2
			  		(.Sec_amt = <0>,
			   		 .Sec_cur = NULL,
			   		 .Sec_acc = Null);
			    %End
			    Set Null_flg in Sec_flg of Cdt_acc_2 of Ent_credit_set to true
			End-if
			If Not(MT103_Charges in ter_flg of cdt_acc_3 of Ent_credit_set)
			Then
				Set Null_flg in Ter_flg of Cdt_acc_3 of Ent_credit_set to true
				%beg
					ent_credit_set.cdt_acc_3
						    	(.Ter_amt = <0>,
							 .Ter_cur= NULL,
							 .Ter_acc = Null);
				%end
			End-if
		END-IF
		If (Cdt_hold_flg of Flgs of Ent_credit_set NOT = SPACE )
		    %Beg  Ent_credit_set.flgs.cdt_hold_flg = NULL ;  %End
		END-IF
%^		%Beg Ftrscr.credit.cdt_typ.cdt_idtype.Msg = "VMSG$_NOSUCHACC" ;
		%Beg
		screen_field_ws = "credit.cdt_typ.cdt_idtype";
		error_mnemonic_ws = "VMSG$_NOSUCHACC";
		%End
	        call "FTRSCR_WRITE_ERROR" using
	          by reference screen_field_ws
		  by reference error_mnemonic_ws
		%Beg
			BREAK: Ent_c_acc_set;
			BREAK: Ent_c_acc_rel_reg;
		    	Csid_compose ^OUT(Csid_err_memo)
		        	"New credit party account not in address bank ",
				Ent_credit_set.Cdt_adr_bnk_id, / ;
		%End				
		Set Failure_is in Creditside_pushscr_ls to true
	        If (Csid_ent_acc_conn NOT = 0 )
		    %Beg
		    BREAK: Ent_acc_set ;
                    Csid_acc_set EQUATE: Ent_acc_set(NOMOD) ;
		    BREAK: Csid_acc_set ;
		    %End
		END-IF
                GO TO B400_GET_ACCOUNT_END
	    END-IF
	    %Beg
		    Ent_acc_set EQUATE: Ent_c_acc_set(NOMOD,
				REG: Ent_c_acc_rel_reg (NOMOD)); 
		    BREAK: Ent_acc_set ;
		    Csid_clip_compose ^OUT(Ent_credit_set.Cdt_account.Idkey)
			Relget_return_key, / ;
		    Ent_credit_set.Cdt_account (.Idbank = Relget_return_bank,
       		                                .Idtype = Relget_return_idtype ) ;
	    %End
	    If (Csid_ent_acc_conn NOT = 0 )
		%Beg
                Csid_acc_set EQUATE: Ent_acc_set(NOMOD) ;
		BREAK: Csid_acc_set ;
		%End
	    END-IF
	ELSE
 	    If (Cdt_account of Ent_credit_set NOT = SPACES )
		 %Beg
       		            Ent_credit_set (
       		                .cdt_account            = NULL,
       		                .cdt_acc_prod_codes     = NULL,
       		                .cdt_acc_class          = NULL,
				.cdt_recon_ref 		= NULL);
		%end
		If NOT(Informational in Sec_flg of Cdt_acc_2 of Ent_credit_set)
		Then   %^ Not account related, pass along the fee info 132692
		    %Beg
               		Ent_credit_set.cdt_acc_2
		  		(.Sec_amt = <0>,
		   		 .Sec_cur = NULL,
		   		 .Sec_acc = Null);
		    %End
		    Set Null_flg in Sec_flg of Cdt_acc_2 of Ent_credit_set to true
		End-if
		If Not(MT103_Charges in ter_flg of cdt_acc_3 of Ent_credit_set)
		Then
			Set Null_flg in Ter_flg of Cdt_acc_3 of Ent_credit_set to true
			%beg
				ent_credit_set.cdt_acc_3
					    	(.Ter_amt = <0>,
						 .Ter_cur= NULL,
						 .Ter_acc = Null);
			%end
		End-if
	    END-IF
	    If (Cdt_hold_flg of Flgs of Ent_credit_set NOT = SPACE )
		%Beg  Ent_credit_set.flgs.cdt_hold_flg = NULL ;  %End
	    END-IF
 	    %Beg  BREAK: Ent_c_acc_set;
		  BREAK: Ent_c_acc_rel_reg;
	   %End
	    If (Relget_msgcode NOT = SPACES)
	    Then
 	    	%Beg
		    	screen_field_ws = "credit.cdt_typ.cdt_idtype";
       		     	error_mnemonic_ws = Relget_msgcode ;
	    	%End
	    	call "FTRSCR_WRITE_ERROR" using
	   	  by reference screen_field_ws
	    	  by reference error_mnemonic_ws
	    END-IF
	END-IF.
	%Beg  BREAK: Relget_adr_set ;  %End.
B400_GET_ACCOUNT_END.
	Exit.

X930_CHANGE_CREDIT.
	%^
	%ACE_IS Relget_adr_set connected giving Csid_conn_stat;
	%^
	%^	%ACE_IS Ent_c_adr_set connected giving Csid_conn_stat
	%^
	%Beg
	BREAK: Prulepty_rule_seq(NOMOD);
	BREAK: Prulepty_party_adr_set(NOMOD);
	%End
	If Success_is in Csid_conn_stat Then
		%beg Prulepty_source rel_is;
		     Prulepty_party_adr_ok Success_is;
	     	     Relget_adr_set.adr_proc_rule CONN:
						      Prulepty_rule_seq(NOMOD);
		     Relget_adr_set EQUATE: Prulepty_party_adr_set(NOMOD);
		%end
		If (Rel_id of Relget_adr_set = 0 )
		    %Beg  Prulepty_source aux_is;  %End
		end-if
	Else
		%beg Prulepty_source host_is;
		     Ent_credit_set.Cdt_proc_rule CONN:
						      Prulepty_rule_seq(NOMOD);
		     Prulepty_party_adr_ok Failure_is;
		%end
		Initialize Prulepty_party_adr_set
	end-if.

	%beg
	    Csid_id_bank_ws = Ent_credit_set.Cdt_adr_bnk_id;
	    Prulepty_bank_prof_rec = NULL;
	%end
	If (Csid_id_bank_ws = SPACES)
	    %Beg  Csid_id_bank_ws = Ent_ftr_set.Loc_info.Bank;  %End
	end-if

	If (Csid_id_bank_ws = Bnk_id of Menu_bnk_union)
		%beg
		     Prulepty_bank_prof_rec =
					     Menu_bnk_union.Bnk_profile_id_rec;
		%end
	else
		%Beg
		   BREAK: Csid_bnk_union ;
		   SEARCH: Bnk_index 
			   (Key = Csid_id_bank_ws );
		%end
 		If (Success_is in Bnk_index_status)
			%Beg Bnk_index CONN: Csid_bnk_union(NOMOD); %end
		end-if
		%beg
  		   Prulepty_bank_prof_rec = Csid_bnk_union.Bnk_profile_id_rec;
		%End
	end-if.

	Call "PRULE_CHANGE_CREDIT" returning Csid_ret_stat.
	%^If Failure_is in Csid_ret_stat Then
	%^	Display "CHANGE Credit_failed"
	%^End-if.

X930_CHANGE_CREDIT_END.
	EXIT.


