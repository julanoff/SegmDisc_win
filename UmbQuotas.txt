
%MODULE ISI2CBT_XMTEDT;

**********************************************************
*							 *
* Copyright (c) 1995-2004				 *
* by IntraNet, Inc., 1 Gateway Center, Newton MA 02458	 *
*							 *
**********************************************************

* ISI2 link
* API component.
* XMTEDT routine.
*
* Modification history:
*
* D. Alquist	16-OCT-1995 11:41:28.85		PER #10977
*	Add optional sender's reference output arguments.
* A. Smith	22-MAR-2001
*	Derive ISI2CBT_XMTEDT from ISI2XXX_XMTEDT. Only difference
*	is that the memo field is set to indicate the type of message
*	dequeued (data message, reply, dlvack or dlvrej)
*
* A. Smith	19-Oct-2001
*	Port to AIX V1.1
*
* A. Smith	15-JUL-2002			#86879
*	Pass entire ENQ-memo back through interface for *DLV_REJ. There may be
*	additional data following "*DLV_REJ:(<NAK reason>)" that is needed by XMTMAP.
*
* A. Smith	15-JUL-2002			#87022
*	Don't ENQ to pending queue unconditionally if it is configured - make sure
*	a COA or COD will actually be requested for this message case before doing so -
*	these are not requested even if COA or COD is enabled for delivery ack/nak messages
*	nor for messages with type "*REPLY"
*
* A. Smith	11-SEP-2002
*	Edit for message size by counting characters. If the message exceeds the SWIFT
*	limit, return failure so the message will busted to an exception queue.
*
* A. Smith	18-Oct-2002
*	The TRN followed by "-"<dest-ordinal> is now the key used when the message is
*	queued to the pending ack queue or pending dlvack queue. Previously the contents
*	of field 108 was used as the key.
*
* A. Smith	27-Nov-2002
*	Don't do length validation if we are sending an ACK vs. the entire message text.
*
* A. Smith	9-Dec-2002	#93803
*	Set key delivery-pending queue entry according to config option.
*
* A. Smith	14-Jan-2003	#94648, 94769
*	Initialization problem in text size count was causing erroneous "text too large"
*	error. Search for data within message was too conservative, and did not work
*	unless there was a full SWIFT header. Now field 20 is found even if there is no
*	header.
*
* A. Smith	3-Mar-2003	#96642
*	The reference returned from this routine was not appropriate as the linelog reference,
*	which is associated with the ISI2 header reference field, except in implied-header mode
*	where the ISI2 header is not transmitted. Change to not return a
*	reference and allow the caller to default it. The reference used internally in this
*	routine is  relevant only to the delivery ack field.
*
* E. Dulog	16-Mar-2003	#93644
*	Check history memo if the message is a resend and set flag
*	if it is. Note that the *RESEND in the memo is an indication that the
*	message was re-queued to the the output queue for retransmission.
*	Don't confuse it with the RESEND command where messages are re-entered
*	into the fmtlog to be retransmitted using the same sequence number
*	assigned previously (original).
*
* A. Smith	1-May-2003	#99475
*	Temporary string to pull out 1st 5 lines of message was not being constructed
*	correctly, so that parse of fields 108 and 20 was not working.
*
* A. Smith	24-Sep-2003
*	Expand REF fields in headers from 16 to 24 characters to be
*	compatible with MQ MsgId fields.
*	Optimize logic for parsing field 20 or header field 108 when the
*	pending-delivery-ack key is needed to find the original message.
*
* A. Smith	22-Jan-2004	#108966
*	TRN+ORD ack key was being truncated after string was constructed.
*
* E. Dulog  26-Oct-2004 #117738
*   Fix typo error, should be prm_pend_dlvack_qname_length instead of
*   prm_pend_ack_qname_length when checking dlvack type.
*
* E. Dulog  10-Mar-2005 #119492
*   Use the compressed version of the TRN (excluded the century of the trn_date
*   and the 1st digit of the trn_num) to make room for the "-" plus the 2 digits
*   dst ordinal. This will ensure that every message that is sent out to SWF
*   will have a unique pending dlv queue key only if DLV ACK KEY is set to 108.
*
* A. Sowers 15-May-2007 #132163
*   Suppress the allocation of messages to the xxxx_PNDACKQ and the xxxx_PNDDLVQ
*   when in contingency mode.
*
* A. Sowers 22-Feb-2008 #454779 - CR1396
*   Added a call to ISI2_GET_LT_ADR to determine the message direction and the 
*   lt_address. If no sending lt_address can be determined misroute the message
*   to a repair queue with a sys_memo stating the sending lt_address could not 
*   be determined.
*
* D. Alquist 25-Feb-2008	#454788
*   Store destination BIC in dst.dst_outgoing_ref.
*   If the msg receives a positive logical ack, then this value will be used to
*   index the msg on the SWF_DST_NDX.  This functionality is present in Swflink
*   but missing from isi2/cbt.  In Swflink, the destination address is stashed in
*   the pnding logical ack queue, and recovered from there upon logical ack,
*   but isi2 doesn't use a pending logical ack queue so this is the next best
*   solution.  The dst_outgoing_ref field is overwritten with logical ack info
*   after the dst bic is retrieved from it (see isi2cbt_rcvbuf).
*
* End Modification History
********************************************************************************

* This routine is presented with a an outgoing message just dequeued by 
* the ISI2 link from its pending-transmission logical queue.
* The message is a candidate for transmission over the link.
* This routine edits the message for a valid destination address, and
* for whatever else is required to deliver the message, and returns
* a status code indicating whether ISI2 should proceed with transmission,
* route to outgoing repair, etc.

* If the outgoing text should be preserved for this message, it should be
* done here, and later recovered in the API's XMTMAP routine.
* Text preservation is done by allocating a text sequence object out of the
* ENT_DST_SET.DST_TEMPLATE_SEQ object, and copying the text to be preserved
* into it.

* INPUT:
*   ENT_* subjects connected; MOD access.
*   XMTEDT_DEST_LS = T if ENT_DST_SET connected; else F.
* OUTPUT:
*   XMTEDT_STS_LS: A return status to indicate message disposition.
*	Currently supported values (defined in APL$DDL:ISI2API_FSECT):
*	  APIEDTSTS_DROP = Drop message (do not deliver).
*	  APIEDTSTS_MISR = Misroute message.  Queue to outgoing repair.
*	    The MEMO output parameters should contain a memo for the
*	    repair operator describing why the message went to repair.
*	  APIEDTSTS_SEND = Send message.  Message will be scheduled for
*	    transmission.
*   XMTEDT_REF_LEN_LS: Return length of following argument.
*   XMTEDT_REF_LS: Return sender's reference number to use for current msg.
*	If not supplied, ISI2 will generate one upon return.
*   XMTEDT_TXT_LS: Return "T" if we preserve outgoing text in
*	DST_SET.DST_TEMPLATE_SEQ.
*   XMTEDT_MEMO_LEN_LS:
*	Length of the memo returned in XMTEDT_LEN_LS.
*   XMTEDT_MEMO_LS:
*	Memo field.
*
* IMPLICIT INPUT:
* NEXT_TO_XMT = Sequence number that will be associated with this message,
*   if our return status indicates to send message.

* If a delivery or acceptance response is expected, then put the message on
* the corresponding acknowledgement queue

%DEF <ACE>		%`SBJ_DD_PATH:ACE_FSECT.DDL` %END
%DEF <ISI2>		%`SBJ_DD_PATH:ISI2_FSECT.DDL` %END
%DEF <ISI2API>		%`SBJ_DD_PATH:ISI2API_FSECT.DDL` %END
%DEF <ENTFTR>		%`SBJ_DD_PATH:ENTFTR_FSECT.DDL` %END
%DEF <SWF2FMT>		%`SBJ_DD_PATH:SWF2FMT_FSECT.DDL` %END

%DEF
char_count_ws:	Long;
Crlf_flag_ws: Vstr(2);
swf_msg_type:	str(3);
Swf_app_is:		ONEOF (Gpa, Fin);	%^ For SWF_HEADER call
pnd_dlv_key:	VSTR(32);
pnd_ack_key:	VSTR(32);
hist_memo:	Vstr(80);
comp_trn_ref:   STR(16);            %^ compressed trn_ref for field 108
dest_ordinal:   STR(6);             %^ dst set ordinal
lt_address_ws:  Str(12);
hdr_direction_ws: Str(1);
%END

%LINKAGE
01 xmtedt_dest_ls	%Str(1);
01 xmtedt_sts_ls	%Str(1);
01 xmtedt_ref_len_ls	%Length;
01 xmtedt_ref_ls	%Vstr(24);
01 xmtedt_txt_ls	%Str(1);
01 xmtedt_memo_len_ls	%Length;
01 xmtedt_memo_ls	%Vstr(80);

%PROCEDURE USING
  xmtedt_dest_ls,
  xmtedt_sts_ls,
  xmtedt_ref_len_ls,
  xmtedt_ref_ls,
  xmtedt_txt_ls,
  xmtedt_memo_len_ls,
  xmtedt_memo_ls.

* Implied output: VSTR80 contains the memo for the send log join

a100_main.

* Send message.  No text preservation.
	MOVE apiedtsts_send TO xmtedt_sts_ls.
	MOVE 0 TO Char_count_ws, xmtedt_memo_len_ls, pnd_ack_key_length.

* Pare message history memo to see if the message is a resend and if it is,
* needs to preserve the memo so it will be indicated that it is so in the
* log message to be created later. Also parse for the original sequence
* number.
	%BEG
	tmp_prs ^IN(Ent_msg_history.memo), ^STRING, "*RESEND of ",
		resend_seq_num, /;
	%END.
	IF (Success_is IN tmp_prs_status)
	THEN
		%BEG hist_memo = Ent_msg_history.memo; %END
		MOVE hist_memo(1:hist_memo_length) TO xmtedt_memo_ls
		MOVE hist_memo_length To xmtedt_memo_len_ls
		MOVE "T" TO requed_msg_flag
	END-IF.

* Set the message history memo for the send log join to indicate the type of message
	EVALUATE TRUE

	  WHEN memo OF ent_msg_history (1:8) = "*DLV_CNF"
	    IF (Failure_is IN tmp_prs_status)
	    THEN
	       MOVE memo OF ent_msg_history (1:8) TO xmtedt_memo_ls (1:8)
	       MOVE 8 TO xmtedt_memo_len_ls
	    END-IF
	    GO TO a100_main_end

	  WHEN memo OF ent_msg_history (1:8) = "*DLV_REJ"
	    IF (Failure_is IN tmp_prs_status)
	    THEN
	       %BEG tmp_vstr = Ent_msg_history.memo; %END
	       MOVE tmp_vstr (1:tmp_vstr_length) TO 
					xmtedt_memo_ls (1:tmp_vstr_length)
	       MOVE tmp_vstr_length TO xmtedt_memo_len_ls
	    END-IF
	    GO TO a100_main_end

	  WHEN memo OF ent_msg_history (1:6) = "*REPLY"
	    IF (Failure_is IN tmp_prs_status)
	    THEN
	       MOVE memo OF ent_msg_history (1:6) TO xmtedt_memo_ls (1:6)
	       MOVE 6 TO xmtedt_memo_len_ls
	    END-IF
	    GO TO a100_main_end

	  WHEN memo OF ent_msg_history (1:8) = "*REQUEST"
	    IF (Failure_is IN tmp_prs_status)
	    THEN
	       MOVE memo OF ent_msg_history (1:8) TO xmtedt_memo_ls (1:8)
	       MOVE 8 TO xmtedt_memo_len_ls
	    END-IF
	    GO TO a100_main_end

	  WHEN other
	    IF (NOT(memo OF ent_msg_history(1:7) = "*RESEND"))
	    THEN
	       IF (Failure_is IN tmp_prs_status)
	       THEN
	          MOVE 0 TO xmtedt_memo_len_ls
	          MOVE SPACES TO xmtedt_memo_ls (1:4)
	       END-IF
	    END-IF
	END-EVALUATE.

* Here if this is an outgoing message. Put it on up to two pending queues if defined.
	%BEG FIRST: ent_text_seq; %END.					%^ Position for ref parse, and character count

* Requesting COA or COD: confirmation of acceptance or delivery (returned when the remote application has
* read the message, or message has reached node):
* Join message to ACK pending queue
	IF (prm_pend_ack_qname_length > 0)				%^ If queue exists
	   AND (prm_mq_ack_type (1:2) = "CO")				%^	and  COA or COD ack type configured
	   AND (xmtedt_memo_ls (1:5) NOT = "*DLV_" and "*REPL")		%^	and not a response message type
	   AND (NOT net_rms IN net_type)				%^ 	and NOT contingency mode
	    PERFORM b100_get_hdr_ref THRU b100_get_hdr_ref_end
	    %ace_conn_q /<Link_bnk_id>///<prm_pend_ack_qname> to saf_pndq with optimization;
	    IF Failure_is in Que_root_index_status
		DISPLAY "?SE ISI2CBT_XMTEDT\main PEND ACKQ not found: ", prm_pend_ack_qname
	        %LIBSTOP "ISI2$SE_ISI2API_XMTEDT_BADPARAM";		%^ SE - event out of range
	    END-IF
	    %BEG
	    ALLOC_END: ent_msg_history (
		    .qname (	.Idbank = Link_bnk_id,
				.idloc = null,
				.idname = prm_pend_ack_qname),
		    .qtype = "QTYP$_SAF_PND_QUE",
		    .memo = null,
			ALLOC_JOIN: 
			     saf_pndq (	.systime NOW,
					.seq1 = next_to_log,
					.ref_num = pnd_ack_key));
	  %END
	END-IF.

* Requesting or expecting PAN/NAN: positive or negative application acknowledgement - equates to
* the MTS "delivery acknowledgement", which generally means the message has been completely
* processed by the remote application.
* The message goes on the delivery acknowledgement queue if there is an explicitly requested PAN/NAN, or if there
* is an explicitly requested NAN plus an implied PAN, or if there is an implied PAN/NAN. If there is only an
* explicitly requested NAN, then the message does not go on the delivery ACK queue because a report (PAN or NAN or
* other report type) will only be received in an exception situation.

* If there is a delivery acknowledgement queue configured, and a response is expected for this message, queue it

	EVALUATE True

	  WHEN prm_mq_dlvack_type = "NAN"
      WHEN prm_pend_dlvack_qname_length = 0                         %^ #117738
	    CONTINUE

	  WHEN prm_mq_dlvack_type = "NAN+IMP"
	  WHEN prm_mq_dlvack_type = "IMP"
	  WHEN prm_mq_dlvack_type = "PAN"
	    IF pnd_ack_key_length = 0				%^ Parse the header ref only if not already done
		PERFORM b100_get_hdr_ref THRU b100_get_hdr_ref_end
	    END-IF
	    %ace_conn_q /<Link_bnk_id>///<prm_pend_dlvack_qname> to saf_pndq with optimization;
	    IF Failure_is in Que_root_index_status
		DISPLAY "?SE ISI2CBT_XMTEDT\main PEND DLVACKQ not found: ", prm_pend_dlvack_qname
	        %LIBSTOP "ISI2$SE_ISI2API_XMTEDT_BADPARAM";		%^ SE - event out of range
	    END-IF
	    If NOT net_rms IN net_type					%^ NOT contingency mode
	       %BEG
%^ Join    message to PAN pending queue
	       ALLOC_END: ent_msg_history (
		       .qname (	.Idbank = Link_bnk_id,
		   		.idloc = null,
		   		.idname = prm_pend_dlvack_qname),
		       .qtype = "QTYP$_SAF_PND_QUE",
		       .memo = null,
		   	ALLOC_JOIN: 
		   	     saf_pndq (	.systime NOW,
		   			.seq1 = next_to_log,
		   			.ref_num = pnd_dlv_key));
	       %END
	    End-if
	END-EVALUATE.

* If we created the senders ref key, return it to caller, but only if implied_header mode
	IF Implied_header in prm_header_format
	  MOVE pnd_dlv_key_length TO xmtedt_ref_len_ls
	  MOVE pnd_dlv_key (1:pnd_dlv_key_length) TO xmtedt_ref_ls
	ELSE
	  MOVE 0 TO xmtedt_ref_len_ls
	END-IF.

* Starting from the currently-positioned text record, count the
* characters in the text sequence. Assume that any records that have already
* been passed, excluding the current record, are already in the count

	PERFORM UNTIL Seq_end_is in Ent_text_seq_cursor
	  Add 2, txt_length of Ent_text_seq_lengths to Char_count_ws	%^ Allow for CRLF line separators
	  %BEG NEXT: ent_text_seq; %END
	END-PERFORM.

* Determine message direction & sending LT; check for configuration error.
* Direction & sending LT are input arguments to SWF_HEADER_SUB, below.
	Move Spaces to hdr_direction_ws.
	Move Spaces to lt_address_ws.
	Call "ISI2_GET_LT_ADR" Using
          By Reference hdr_direction_ws
          By Reference lt_address_ws.
*   hdr_direction_ws = "I" implies Inbound to Swift or output from ISI2-CBT
*   hdr_direction_ws = "O" implies Outbound from Swift or input to ISI2-CBT
	If hdr_direction_ws = "I" AND lt_address_ws = Spaces
	  Move apiedtsts_misr TO xmtedt_sts_ls
	  Move "Sending LT address could not be determined from current configuration." to xmtedt_memo_ls
	  Move 70 TO xmtedt_memo_len_ls
	  go to a100_main_end
	End-if.

* If not a *DLV, call SWF_HEADER_SUB to insure:
* (1) that we can actually send this msg in isi2cbt_xmtmap, and
* (2) to determine the destination address, so we can update SWF_DST_NDX upon +ve logical ack.
	If (xmtedt_memo_ls(1:4) NOT = "*DLV")
	  Set Fin in Swf_app_is to TRUE
	  CALL "SWF_HEADER_SUB" USING BY REFERENCE
			Swf_app_is,				%^ Forced to FIN
		BY CONTENT "0000"				%^ Session 0000
			"0000",
			"000000",				%^ Sequence number is 0
		BY REFERENCE
			memo OF ent_msg_subhist,		%^ DEQ memo
			memo_length of ent_msg_subhist_lengths,	%^ length of memo
			hdr_direction_ws,			%^ Message direction
			idname of qname OF ent_msg_subhist,	%^ Not the right hist entry, but no impact on size
			Bank of Loc_info of Ent_ftr_set,
			Loc of Loc_info of Ent_ftr_set
			lt_address_ws,				%^ LT
			swift_bic_ws,
			tmp_xmt_msg,
			tmp_xmt_msg_length,
			swf_msg_type,
			tmp_vstr,				%^ Memo showing error if failure return
			tmp_vstr_length
		RETURNING ReturnStatus
	  Evaluate True
	    WHEN Failure_is in ReturnStatus			%^ If header formatting failed
	      MOVE apiedtsts_misr TO xmtedt_sts_ls
	      MOVE tmp_vstr to xmtedt_memo_ls
	      MOVE tmp_vstr_length TO xmtedt_memo_len_ls
	      Go to a100_main_end

	    WHEN Char_count_ws > Vstr_free_byte_count		%^ If length overflow
	      MOVE apiedtsts_misr TO xmtedt_sts_ls
	      MOVE "Message text too large" to xmtedt_memo_ls
	      MOVE 22 TO xmtedt_memo_len_ls
	      Go to a100_main_end

	  End-evaluate

* Destination address should have been returned in swift_bic_ws.
* Store it in dst.dst_outgoing_ref
* (in swflink, the dst address is stored in/recovered from the pending logical ack queue join,
* but ISI2 does not use a pending logical ack queue).
* If we get a +ve logical ack, this value will be used to index the msg in SWF_DST_NDX.
* In either case (+ve or -ve logical ack), dst.dst_outgoing_ref will be overwritten with ack info.
	  %beg ent_dst_set(mod, .dst_outgoing_ref = swift_bic_ws); %end

	End-if.

a100_main_end.

	EXIT PROGRAM.

b100_get_hdr_ref.

* If this is an admin message, then we look in the outgoing text to see if there
* is a reference in field 108. If not, then the message TRN will be in field 108.
* Output:

*	PND_ACK_KEY contains the TRN with DST_SET.ORDINAL suffix (if any)
*	PND_DLV_KEY contains either a copy of PND_ACK_KEY, or ref from field 20, or field 108
*		contents, depending on config option
*	CHAR_COUNT_WS has accumulated the size of any text that was stepped through, to avoid
*	the need to re-scan the same lines later.

	IF Xmtedt_dest_ls = "F"
	  THEN MOVE 0 TO vstr80_length		%^ Flag for compose: no dst-ordinal suffix if not subhist
	  ELSE MOVE 1 TO vstr80_length
	END-IF.
	%BEG
	tmp_cmp ^OUT(Pnd_ack_key), Ent_ftr_set.Trn_ref,
			Vstr80 (^IF_NOTNULL("-", |Ent_dst_set.Dst_ordinal)), /;
	tmp_cmp ^OUT(tmp_big_vstr);
	%END.

	Move 0 to Pnd_dlv_key_length, Crlf_flag_ws_length.

* Pull out field 108 from block 3, if present, or field :20: if
* called for by the configuration setting.
* Compose first 5 text lines into a string buffer for easy parsing. Keep count of
* characters as we go

	IF (fld108 in prm_dlvack_key) OR (fld20 in prm_dlvack_key)
	  PERFORM VARYING tmp_long FROM 1 BY 1 UNTIL tmp_long > 5
	    IF Txt of Ent_text_seq (1:1) = ":" THEN MOVE 2 TO Crlf_flag_ws_length END-IF
	    Add txt_length of Ent_text_seq_lengths, Crlf_flag_ws_length to Char_count_ws
	    %BEG
	    tmp_cmp ent_text_seq.txt, Crlf_flag_ws (^IF_NOTNULL(<13>, <10>));
	    NEXT: ent_text_seq;
	    %END
	  END-PERFORM
	  %BEG tmp_cmp /; %END				%^ Close out string containing 1st 5 lines
	END-IF.

	EVALUATE TRUE

	  WHEN fld108 in prm_dlvack_key

*  Return actual field 108, or MTS TRN if no 108
	    %BEG tmp_prs ^IN(tmp_big_vstr) ^STRING, "{108:", pnd_dlv_key, "}"; %END
        IF (Failure_is in tmp_prs_status)
        THEN

* Exclude the century in the date and 1st digit of the trn_num to make
* room for "-" followed by 2 digits dst ordinal number to ensure every
* message will have a unique field 108.

            MOVE trn_date Of trn_ref Of ent_ftr_set(3:6) To comp_trn_ref(1:6)
            MOVE trn_num Of trn_ref Of ent_ftr_set(2:7) To comp_trn_ref(7:7)
            %BEG
            Tmp_cmp ^OUT(dest_ordinal) ent_dst_set.dst_ordinal(^NUMBER<6>(^LEADING_ZEROS));
            %END
            MOVE "-" To comp_trn_ref(14:1)
            MOVE dest_ordinal(5:2) To comp_trn_ref(15:2)
            MOVE comp_trn_ref To pnd_dlv_key(1:16)
            MOVE 16 To pnd_dlv_key_length
        END-IF
        GO TO b100_get_hdr_ref_end

	  WHEN fld20 in prm_dlvack_key
	    %BEG tmp_prs ^IN(tmp_big_vstr) ^STRING, ":20:", pnd_dlv_key, <13>; %END
	    IF (Success_is in tmp_prs_status) THEN GO TO b100_get_hdr_ref_end END-IF

	END-EVALUATE.

* IF TRN_MSGID, or configured key not found, default to TRN || dst-ordinal
	MOVE pnd_ack_key (1:pnd_ack_key_length) to pnd_dlv_key.
	MOVE pnd_ack_key_length to pnd_dlv_key_length.

b100_get_hdr_ref_end.
	EXIT.
  
  
  
  
  
%module ISI2CBT_XMTMAP;

**********************************************************
*							 *
* Copyright (c) 1995-2007				 *
* by IntraNet, Inc., 1 Gateway Center, Newton MA 02458	 *
*							 *
**********************************************************

* ISI2 link.
* API component.
* XMTMAP routine.

* Given a connection to a text sequence in ENT_TEXT_SEQ, we make any
* additional pre-transmit modifications.  The resulting text sequence is
* returned to ISI2 for transmission to the remote system.

* The string {SOH}, if appearing alone
* in text sequence, is compressed back to a binary character.
* This reverses the expansion done in our DELIMIT routine.
* {STX} and {ETX} are dropped.

* INPUT:
*   dest_conn_ls = T if ENT_DST_SET connected; else F.
*   txt_ind_ls = Connected text indicator; indicates which text sequence
*	from the message union is being transmitted.
*	See values in ISI2_FSECT.DDL (field TXT_IND).
*   preserved_txt_ls = T if connected text is actually the copy of the
*	text sequence previously preserved in the dest set by the call to
*	XMTEDT.
* OUTPUT:
*   crlf_option_ls = T if ISI2 should append <CR><LF> to each line of text.
*   ENT_TEXT_SEQ_CURSOR positioned at beginning of text to transmit.
*
* IMPLICIT INPUT:
* FMTLOG.LAST_SEQ = Sequence number associated with this message.
*
* Modification history:
* D. Alquist	12-MAR-1996 15:24:48.60
*	Fix a couple of primordial bugs in intersequence text copy logic.
*	Bugs resulted in ENT_TEXT_SEQ_LENGTH > 80, eventually clobbering
*	unrelated field data in ISI2 fsect!
* A. Smith	22-MAR-2001
*	Derive ISI2CBT_XMT_MAP from ISI2XXX_XMT_MAP
* A. Smith	17-Dec-2001	80194
*	Search top-level history for the LNK_INF memo.
* D. Alquist	24-Dec-2001	80709
*	No elements were being output to ent_text_seq; add ALLOC_ELEM: calls.
*	Debugging trace.
*	Blank out extra part of residual line.
* A. Smith	2-Jan-2002	80194
*	2 errors were found in formatting of SWIFT ACK/NAK reply messages.
*	The status code in field-tag 451 was backwards - 0 means ACK and
*	1 means NAK, but it was returning the opposite.
*	There was also a logic problem in picking up the NAK reason code from the message
*	history.
* A. Smith	30-Jan-2002	#81264, 81265, 81288
*	{STX}, {ETX} on its own line should not be transmitted, since it is a marker
*	for internal use within MTS and not part of the incoming message. {SOH} is
*	still converted to a binary character.
*	Send the "S" block as appended as the trailer on an inbound telex message being
*	forwarded via ISI2:
*		"{S:"
*		"{MID:" <3-character MTS source code > "}"
*		"{MRN:" <12- or 16- digit MTS transaction reference number" (note: this was formerly "TRN:")
*		"{TRN:  0-16 character reference from field 20: of message being acknowledged (new as of 10/5/02)
*		"{ANS:" <Telex answerback of sender, if identified> "}"
*		"{ID:" <idtype> "-" <id> "}"
*		"{SAC}"		authenticated with current key
*		"{SAF}"		authenticated with future key
*		"{SAO}"		authenticated with old key
*		"{SAB}"		authentication bypassed
*		"{SAI}"		authentication failed
*		"{SAN}"		authentication status unknown
*		 "}" - End of "S" block
*
*		Notes:
*		1.	Common identifier types are:
*		a.	N - MTS name key for sending entity
*		b.	U - MTS site-specific name key
*		c.	I - MTS site-specific multi-bank name key
*		d.	C - CHIPS UID
*	See release note for complete details of trailer usage.
*
* A. Smith	10-Jul-2002
*	Index by the BIC of the destination of a message inbound to SWIFT.
*
* A. Smith	15-JUL-2002
*	New field in "S" block "{DET:" contains the "details" of the CNF or REJ (ack or nak)
*	message. The details are derived from a suffix on the "*DLV_REJ" memo,
*	of the form "*DLV_REJ:(OPERCANCEL)". Max of 40 characters of details are allowed.
* D. Ryan	21-aug-2002	#85303
*	Update for the fin copy service of "RPT" and its associated values.
*	In paragraph C500_build_fin_header (note: paragraph removed in transition to calling*
*	common header subroutines)
*
* A. Smith	8-Oct-2002
*	For both inbound and outbound messages, as well as acknowledgements, the S: block contents
*	has changed. The "TRN:" sub-block, containing the MTS transaction reference number, is
*	now the "MRN:" sub-block. See the original change note above, from 20-Jan-2002.
*	A new sub-block now appears within the S: block of acknowledgement messages only.
*	This is the "TRN:" sub-block, and contains the contents of field 20 of the message
*	being acknowledged.
*
* A. Smith	16-Oct-2002
*	Authentication result was being formatted in S: block of acknowledgement messages, which
*	is incorrect. It is now formatted in the S: block of inbound messages.
*	Add support for client-mode telex. The telex, fax or email routing details are
*	copied to sub-blocks of the S: block from the dest set.
*
* A. Smith	4-Nov-2002
*	Adapt to ISI2_MSG_HDR change.
*
* D. Alquist	18-Nov-2002
*	lcl_msg_history set nomod.
*
* A. Smith	27-Nov-2002
*	Use current time, not evt_systime.
*	Use correct syntax to output ENT_TEXT_SEQ using the current COBOL-set length. This
*	requires not using the CHANGE factor on the ALLOC_ELEM.
*
* E. Dulog	03-Mar-2003		#93644
*	Call routine that builds the implied header if implied header is set 
*	and the api that builds the implies header is present.
*
* A. Smith	31-Mar-2003	#98367
*	Add new formatting options for delivery ACK and NAK messages. Based on new RMT
*	options "ACK FORMAT" and "NAK FORMAT", the NAK and/or ACK may now be returned
*	as a copy of the original message, a copy of the original header (or the 1st 100
*	bytes if the original does not have a SWIFT-2 header), or a SWIFT-format ACK message.
*	Also add support for S-block records containing information about operator actions
*	taken on messages within MTS, and ACK details within the S-block if not "SWIFT"
*	ACK format.
*
* A. Smith	17-Apr-2003	#98367
*	Changes to S-block formatting.
*	In the ORIGINAL HEADER and ORIGINAL MESSAGE acknowledgement message formats,
*	the MTSOPR (MTS operator action log) and MTSACK (SWIFT ACK/NAK message logs) now
*	appear in the S-block in the order of occurrence within the message history.
*
*	For example, if a message is sent to SWIFT, NAK'ed, sent to the ADX or WRP
*	function, repaired by an operator, resent to SWIFT AND ACK'ED, then the S-block
*	will contain a copy of the original S-block from the originator, followed by
*	"{MID:<source>}", "{MRN:<MTS trn>}", "{TRN:<message field 20>}", ["{SES:}","{SEQ:}"],
*	{MTSACK:{1:F21...{451:1}}}{MTSOPR:030418092311 WRP      SIMPSON}{MTSACK:{1:F21...
*	...{451:0}}}}
*	Notes:	1. {SES:, {SEQ: are conditioned on "SENDER REF FORMAT"="1"
*		2. MTSOPR entries appear only if "ACK AUDIT LOG"="T"
*		3. MTSOPR entries are truncated to the maximum text length specified by parameter
*		   "MTSOPR MAX LENGTH". This limits the length of the entire string between
*		   "{MTSOPR:" and the closing "}".
*
*	The above example shows the order of fields in the delivery ACK or NAK. The S-block
*	for an inbound message is as follows:
*	"{MID:<source>}","{MRN:<MTS trn>}","{<auth result>}",["{MTSOPR:}",...]"}"
*	Any MTS operator logs are included in the order they appeared in the history only
*	if "ACK AUDIT LOG" is set to "T" on the send instance RMT record.
*
* A. Smith	30-Apr-2003	#98367
*	Remove extraneous call to get SWF2 logs in inbound messages; fix typo.
*
* A. Smith	15-Jun-2003	#101347
*	Fix problems formatting SWIFT ACK caused by COMPOSE state error.
*	Fix formatting of simulated SWIFT ACK/NAK.
*
* E. Dulog	02-Jul-2003	#101397
*	Add protection against traps when connecting to a linelog with date
*	that has been erased in the system. The error code gets is
*	SBJ$_INVOBJTYPE.
*
* A. Smith	27-Jul-2003	#102871, 103019
*	Changes in called SWF_SUBS routines to prevent ENT_MSG_SUBHIST trap in this one.
*	In server mode, append block 5 on return from SWF_BUILD_TEXT.
*
* A. Smith	27-Jul-2003	#103908
*	S-block was being garbled for an inbound message where there are operator memos
*	to format. This was because of an improper setting of the compose subject prior
*	to the call to the routine that emits memos to the S-block.
*	Also avoid searching for the receiving LT when this is an inbound message and
*	the link is in CBT mode - assume it will be in the received header
*
* A. Smith	10-Sep-2003
*	Change scheme for avoiding duplicate ACK and NAK entries in audit trail. Previously
*	entries were ignored unless they were on a linelog. Now the most recently seen entry
*	is remembered, and if it occurs as the next entry (scanning in reverse order), it is
*	ignored. This addresses scenarios in which the "Ack MIR:" and "Nak MIR:" are not
*	made on linelogs.
*
* A. Smith	24-Sep-2003
*	Expand REF fields in headers from 16 to 24 characters to be
*	compatible with MQ MsgId fields.
*
* A. Smith	12-Nov-2003
*	S-block routing information for "FAX" and "MAI" did not match functional spec.
*	Fix problem in which trailing "XXX" was not being stripped from BIC.
*
* A. Smith	20-Jan-2004	#108966
*	Default MIR formatting (when no MIR is found in the message history) was not working\
*	due to typo. Fix a few comments.
*
* D. Alquist	13-Feb-2004
*	99704: STEP2 changes.
*	Check for prule channel parameter MTS$CHANNEL_BIC.
*	If found, use it as sending LT.
*	Also, prevent obj lock wait at x50_sys_memo.
*	Also, append an "A" (fake LT) to an 8-char MTS$CHANNEL_BIC for use in the header.
*
* C. McKenzie	03-Jan-2005	SPR#119114
*	Added code to set the .txt field to the transaction reference number.  Logs
*	and queues that can be scanned by by_logs_dump need to have this field set.
*
* E. Dulog      8-Aug-2005  #124769
*   If server mode and inbound msg direction, make sure that the terminal ID of
*   the LT address which is copied from the swift id of the of the menu bank
*   union is not a space. If it is, derive the LT address from the queue name.
*
* D. Alquist		12-Oct-2006	#133508 & #133115
*	This function returns isi2_rcv_log_memo as an implicit output parameter.
*	Formerly this was parsed from the *LNK_INF: value of the rcv linelog.memo field.
*	Now however this string is composed from the variable portions of two new *sys_memo
*	history elements immediately following the rcv linelog:
*		*LNK_INF_REPLYQ:<reply-to-q>
*		*LNK_INF_MSGID:<msgid-hex>
*	This is because these values would overflow the .memo field when combined in a single entry.
*	The format of the data returned in isi2_rcv_log_memo is:
*	<reply-to-q>||<msgid-hex>
*
* A. Sowers		22-Feb-2007	#135539
*	Fixed trap condition when looking for the incoming reference in the rcv linelog when
*	the message has been erased from the linelog. The incoming reference can be found in
*	the incoming_ref of the ent_ftr_set.
*
* D. Alquist		23-May-2007	138232
*	Fix x40 logic to derive transmit LT from output queue name.
*
* A. Sowers		22-Feb-2008	454779 - CR1396
*	Removed the logic to determine the message direction and the LT address and 
*	replaced it with a call ISI2_GET_LT_ADR. This logic was moved to ISI2_GET_LT_ADR
*	in ISI2_APPL_SUBS so it can be accessed by isi2cbt_xmtedt and isi2cbt_xmtmap.
*
* D. Alquist		24-Mar-2008	454788
*	Remove SWF_DST_NDX update from this module.  It should only be done upon receipt
*	of +ve logical ack, so the logic has been relocated to the CBT_RCVBUF module.
*
* G. Johnston		13-Nov-2009	CR12116
*	Migrate up 1.2 Fix to set correct MIR if we take in a header without a branch or terminal
*	id in the {1: ... } record , and this API is formatting an ACK.. See 
*	C300_Format_F21. Researched by D. Alquist, R. Gadzinski.
*
* J. Pfaff		15-Dec-2009	CR14785
*	Migrate CR14715 from v2.0.
*     	Change orig_srf_ws to vstr(28) to accomodate ent_ftr_set.incoming_ref value.
*     	Adjust formatting of SES and SEQ from orig_srf_ws.
*
* End Revision History
*

%DEF <ACE>		%`SBJ_DD_PATH:ACE_FSECT.DDL` %END
%DEF <ISI2>		%`SBJ_DD_PATH:ISI2_FSECT.DDL` %END
%DEF <ISI2API>		%`SBJ_DD_PATH:ISI2API_FSECT.DDL` %END
%DEF <ENTFTR>		%`SBJ_DD_PATH:ENTFTR_FSECT.DDL` %END
%DEF <SWF2FMT>		%`SBJ_DD_PATH:SWF2FMT_FSECT.DDL` %END
%DEF <RMT>		%`SBJ_DD_PATH:RMT_FSECT.DDL` %END

%DEF
Lcl_swf2_log:		Que(%`SBJ_DD_PATH:SWF2_LOG.DDF`);
Lcl_msg_history:	Seq(%`SBJ_DD_PATH:MSG_HISTORY_SEQ.DDF`);
Lcl_linelog:		Que(%`SBJ_DD_PATH:LINE_LOG.DDF`);
Lcl_opr_action:		Que(%`SBJ_DD_PATH:OPR_ACTION_LOG.DDF`);
Out_text_seq:		Seq(%`SBJ_DD_PATH:DAT_TEXT_SEQ.DDF`);
S_blk_seq:		Seq(%`SBJ_DD_PATH:DAT_WIDE_TEXT_SEQ.DDF`);
orig_srf_ws:		vstr(28);
hdr1:			vstr(120);
hdr2:			vstr(120);
Swf_App_Is:		ONEOF (Gpa, Fin);	%^ For SWF_HEADER call
msg_direction_wf:	ONEOF(Outbound,Inbound);
hdr_direction_ws:	str(1);
tmp_func:		str(8);
tmp_mir: Record (		
  Mir_date:		str(6);
  Mir_lt:		str(9);
  Mir_branch:		str(3);
  Mir_in_ses_no:	str(4);
  Mir_in_seq_no:	str(6); );
Last_MIR:		vstr(28);
Last_SWF2LOG_MIR:	vstr(28);
prev_MIR:		str(28);
prev_ack_oneof:		word;
SWF2LOG_time:		time;		%^ Timestamp on most recently found SWF2LOG
Linelog_time:		time;		%^ Timestamp on most recently found linelog
last_reason_code:	VSTR(6);
tmp_reason_code_ws:	VSTR(6);	%^ NAK reason code
Lt_Address_ws: 		REC (		%^ LT argument in header call: TID sub-field="A"
  Lt_Id:		REC (
    Fin_Code:		REC (
      Part_A:		STR(3);
      Part_B:		STR(1));
    Country_Code:	STR(2);
    Location_Code:	STR(2);
    Address_Extension:	STR(1) = "A");
  Branch_Code:		STR(3));
ack_submemo_ws:		VSTR(40);	%^ Additional details in DLV_CNF or DLV_REJ enq memo
orig_f20_ws:		VSTR(16);
swf_msg_type:		str(3);
found_lnk_inf_wf:	Boolean;
now_hhmm_ws:		STR(4);
hhmm_ws:		STR(4);
yyyymmdd_ws:		STR(8);
time_param_ws:		time;		%^ Date-time variable
vReplyToQueue:		vstr(48);
vMsgidHex:		vstr(48);

Xmtmap_rmt_init:	Boolean;
Opr_log_max_len:	Long;
MQSA_emulation_wf: ONEOF(MQSA_disabled, MQSA_enabled);
MQSA_UMID_field_len: LONG = <45>;
Ack_audit_log_wf:	Boolean;
Crlf_str_wf:		Vstr(2);
Found_s_block_wf:	Boolean;
Lcl_linelog_status_wf:	Boolean;								%^ #101397

%^ #85303 String to hold RTP codeword's data
Rtp_str_ws:		Str(4);
Tmp_parse:		parse(^notrap);

%END

%WORK
COPY "isi2_global_fdf.cob".

%LINKAGE
01 dest_conn_ls		%str(1);
01 txt_ind_ls		%str(2);
01 preserved_txt_ls	%str(1);
01 crlf_option_ls	%str(1);

%PROCEDURE USING
  dest_conn_ls,
  txt_ind_ls,
  preserved_txt_ls,
  crlf_option_ls.

a1_main.

	%BEG
	FIRST: Ent_text_seq;
	ALLOC_TEMP: S_blk_seq(MOD);			%^ Alloc temporaries
	ALLOC_TEMP: out_text_seq(MOD);
	%END.
	MOVE 0 TO txt_length of out_text_seq_lengths.
	MOVE "F" TO crlf_option_ls.			%^ No implied CR-LF - they are inserted explicitly
	MOVE -1 TO Prev_ack_oneof.

	IF (implied_header in prm_header_format)	%^ #93644
	  CALL api-bldhdr-rtn-ptr USING		%^ build implied header
			BY REFERENCE txt of out_text_seq
			BY REFERENCE txt_length of out_text_seq_lengths
	  IF txt_length of out_text_seq_lengths > 0
	    %BEG alloc_elem: out_text_seq; %END
	    MOVE 0 TO txt_length of out_text_seq_lengths
	  END-IF
	END-IF.

* One-time search for RMT parameters local to this module
	IF Failure_is in Xmtmap_rmt_init
	  Set Success_is in Xmtmap_rmt_init TO TRUE
	  %BEG SEARCH: rmt_parameter_seq(Key = "MQSA EMULATION"); %END
	  IF Parameter_value of Rmt_parameter_seq = "T"
	    THEN SET MQSA_enabled IN MQSA_emulation_wf to TRUE
	    ELSE SET MQSA_disabled IN MQSA_emulation_wf to TRUE
	  END-IF
	  %BEG SEARCH: rmt_parameter_seq(Key = "ACK AUDIT LOG"); %END
	  IF Parameter_value of Rmt_parameter_seq = "T"
	    THEN SET Success_is IN Ack_audit_log_wf TO TRUE
	    ELSE SET Failure_is IN Ack_audit_log_wf TO TRUE
	  END-IF
	  %BEG
	  SEARCH: rmt_parameter_seq(Key = "MTSOPR MAX LENGTH");		%^ Maximum text size in MTSOPR entries
	  tmp_prs ^IN(Rmt_parameter_seq.Parameter_value), Opr_log_max_len, /;
	  %END
	  IF (Failure_is in Tmp_prs_status) or (Opr_log_max_len > 120) or (Opr_log_max_len < 32)
	    IF Parameter_value of Rmt_parameter_seq NOT = SPACES
	      DISPLAY "ISI2-CBT-XMTMAP MTSOPR MAX LENGTH is not a valid number or not between 32 and 120"
	      %LIBSTOP "ISI2$SE_ISI2LNK Configuration Error!";
	    END-IF
	    ADD 7 TO %SIZ(S_blk_seq.Txt) GIVING Opr_log_max_len		%^ Leave room for "MTSOPR:" in size
	  ELSE
	    ADD 7 TO Opr_log_max_len
	  END-IF
	END-IF.

* Determine the type of message we are sending
* Assume: ENT_MSG_HISTORY is still positioned to the SNDLOG element, containing a copy of the DEQ memo
	EVALUATE True

	  WHEN Memo of Ent_msg_history (1:8) = "*DLV_CNF"
	    SET dlvack in isi2_msg_type TO TRUE
	    PERFORM b100_format_ack thru b100_format_ack_end

	  WHEN Memo of Ent_msg_history (1:8) = "*DLV_REJ"
	    SET dlvrej in isi2_msg_type TO TRUE
	    PERFORM b100_format_ack thru b100_format_ack_end

	  WHEN OTHER
* If not a delivery ACK or REJ, then insert the message text
* A SWIFT-like header will be constructed if not already present in the message text
	    EVALUATE TRUE
	      WHEN Memo of Ent_msg_history (1:8) = "*REQUEST"
		SET request_msg in isi2_msg_type TO TRUE
	      WHEN Memo of Ent_msg_history (1:6) = "*REPLY"
		SET reply_msg in isi2_msg_type TO TRUE
	      WHEN OTHER
		SET data_msg in isi2_msg_type TO TRUE
	    END-EVALUATE

	    PERFORM b200_format_msg thru b200_format_msg_end

	END-EVALUATE.

* Return on first line, and discard temporary connections and objects
	%BEG
	BREAK: ent_text_seq;
	out_text_seq EQUATE: ent_text_seq ^FIRST;
	BREAK: out_text_seq;
	BREAK: S_blk_seq;
	%END.

* Done, exit
	EXIT PROGRAM.

b100_format_ack.

* This is a response message (delivery ACK or delivery REJ): format the response in one of
* the three ack/nak formats
* Input:
*	ISI2_MSG_TYPE contains the type of msg to format
*	ENT_MSG_SUBHIST is within DEQ history
* Output:
*	OUT_TEXT_SEQ contains the ACK or NAK message in SWIFT-2 format
*	There are three basic formats:
*		If RMT parameter "ACK FORMAT" is "SWIFT" (this the default), then the SWIFT
*		ACK message (FIN service id 21) is returned.
*		If the value is "ORIGINAL MESSAGE", then the a copy of the original message being
*		positively or negatively acknowledged is returned.
*		If the value is "ORIGINAL HEADER", then blocks 1-3 of the original message are
*		returned, or if there is not a SWIFT header on the original, the first 100 bytes
*		of the original are returned.
*
*		In all three cases, the last block ("{2:" or "{3:" or "{4:" or "{5:" or the
*		first 100 bytes) is followed by an "{S:" block.
*		This is either newly generated, or is a copy of the "{S:" block that was
*		already present on the outgoing message, with additional sub-blocks inserted
*		following the last already-existing sub-block
*
*		If the RMT paramter "NAK FORMAT" is defined as "SWIFT" or "ORIGINAL HEADER" or
*		"ORIGINAL MESSAGE", then this governs the format for negative acknowledgements
*		(SWIFT NAK or MTS REJECT). If "NAK FORMAT" is not defined, then NAK and REJECT
*		messages default to the same format as ACK messages.
*
*		If the RMT parameter "ACK AUDIT LOG" is set to "T", then selected entries from
*		the message history are formatted into the "{S:" block as "{MTSLOG:" sub-blocks.
*
* Retrieve the ACK or NAK data as stored in the message history and MIR log by the SWFAPC link
* Assume anything following a ":" in a delivery ack/nak is a memo to be returned in the S-block

	EVALUATE TRUE

	  WHEN dlvrej in isi2_msg_type
	    %BEG
	    vstr80 = Ent_msg_history.memo;
	    tmp_prs ^IN(vstr80), "*DLV_REJ:", ^ONEOF (
			("(", ack_submemo_ws, ")"),
			( ack_submemo_ws, /));
	    %END
	    IF Failure_is in tmp_prs_status MOVE 0 TO ack_submemo_ws_length END-IF

	  WHEN dlvack in isi2_msg_type
	    %BEG
	    vstr80 = Ent_msg_history.memo;
	    tmp_prs ^IN(vstr80), "*DLV_CNF:", ^ONEOF (
			("(", ack_submemo_ws, ")"),
			( ack_submemo_ws, /));
	    %END
	    IF Failure_is in tmp_prs_status MOVE 0 TO ack_submemo_ws_length END-IF

	  WHEN OTHER
	    MOVE 0 TO ack_submemo_ws_length

	END-EVALUATE.

	%BEG
	LAST: ent_msg_subhist;
	Ent_msg_union.Msg_history CONN: Lcl_msg_history ^FIRST(nomod);	%^ Top-level history
	%END.
	MOVE 0 TO Last_MIR_length, Last_SWF2LOG_MIR_length, Last_reason_code_length,
		SWF2LOG_time, Linelog_time.

* Scan back through sub-history looking for the ACK/NAK memo(s), and the (most recent) join to the SWF2 log
* If gathering operator memo's, pick these up along the way; if not gathering operator memos, stop when logs found
	PERFORM UNTIL Seq_beg_is IN ent_msg_subhist_cursor
		OR ((Last_SWF2LOG_MIR_length > 0) AND (Last_MIR_length > 0) AND Failure_is in Ack_audit_log_wf)
	  IF qtype of ent_msg_subhist = "QTYP$_SWF2_LOG"
	    IF ((Last_SWF2LOG_MIR_length = 0) OR NOT (swift_ack in prm_ack_format))
	      PERFORM C320_PARSE_SWF2LOG THRU C320_PARSE_SWF2LOG_END
	    END-IF
	  END-IF

* Parse the SWIFT MIR from the Ack/Nak memo string. Avoid consecutive duplicates
	  IF ((Last_MIR_length = 0) OR NOT (swift_ack in prm_ack_format))	%^ If SWIFT format, stop after finding newest
	    IF (memo of ent_msg_subhist (1:8) = "Nak MIR:")			%^ For ORIG MSG or ORIG HDR, gather them all
		OR (memo of ent_msg_subhist (1:8) = "Ack MIR:")
	      PERFORM C280_PARSE_MIR_MEMO THRU C280_PARSE_MIR_MEMO_END
	    END-IF
	  END-IF

* Get latest timestamp from linelog
	  IF Linelog_time = 0							%^ Pick up time from linelog
	    IF qtype of ent_msg_subhist = "QTYP$_LINE_LOG"
* Capture the latest linelog during the backward scan
		  IF ( Object_is In Ent_msg_subhist_cursor )			%^ #101397
	         %BEG
	         BREAK: Lcl_linelog( NOTRAP );
	         Ent_msg_subhist CONN: Lcl_linelog (READ_ONLY);
			 Lcl_linelog_status_wf = Lcl_linelog Status;
	         BREAK: Lcl_linelog( ETRAP );
	         %END
			 IF ( Success_is In Lcl_linelog_status_wf )
	      		MOVE Systime Of Lcl_linelog TO Linelog_time
			 END-IF
		  END-IF
	    END-IF
	  END-IF
	  IF Success_is in Ack_audit_log_wf
	    IF qtype of ent_msg_subhist = "QTYP$_OPR_ACTION_LOG"
	      %BEG
	      Ent_msg_subhist CONN: Lcl_opr_action (READ_ONLY);
	      Tmp_vstr = Ent_msg_subhist.Memo;
	      Vstr80 = Ent_msg_subhist.Qname.Idname;
	      %END
	      PERFORM C100_accum_opr_action THRU C100_accum_opr_action_end
	    END-IF
	  END-IF
	  %BEG PREV: ent_msg_subhist; %END
	END-PERFORM.

* Now search top-level history for the LNK_INF memo, and accumulate audit entries if needed
* Search is in a forward direction, so any entries found are inserted at the beg to reflect
* the order in which they were added to the message given the assumption that S_BLK_SEQ is
* in newest to oldest order
	SET Failure_is in found_lnk_inf_wf TO TRUE.
	PERFORM UNTIL (Seq_end_is IN Lcl_msg_history_cursor)
			OR (Success_is in found_lnk_inf_wf AND Failure_is in Ack_audit_log_wf)
	  IF (Failure_is in found_lnk_inf_wf) AND (memo of Lcl_msg_history (1:8) = "*LNK_INF")
	    PERFORM C700_rcvlog_memo THRU C700_rcvlog_memo_end
	    SET Success_is in found_lnk_inf_wf TO TRUE
	    IF orig_srf_ws_length = 0 THEN %BEG orig_srf_ws = isi2_msg_hdr.sender_ref; %END END-IF
	  END-IF
	  IF Success_is in Ack_audit_log_wf
	    IF qtype of Lcl_msg_history = "QTYP$_OPR_ACTION_LOG"
	      %BEG
	      Lcl_msg_history CONN: Lcl_opr_action (READ_ONLY);
	      Tmp_vstr = Lcl_msg_history.Memo;
	      Vstr80 = Lcl_msg_history.Qname.Idname;
	      BEG: S_blk_seq;					%^ Insert oldest at front of sequence
	      %END
	      PERFORM C100_accum_opr_action THRU C100_accum_opr_action_end
	    END-IF
	  END-IF
	  %BEG NEXT: Lcl_msg_history; %END
	END-PERFORM.
	%BEG BREAK: Lcl_msg_history; %END.

	EVALUATE TRUE

	  WHEN Last_MIR_length > 0

* Found everything we need
	    CONTINUE

	  WHEN Last_SWF2LOG_MIR_length > 0

* Did not find memo, or could not parse it, but did find SWF2 LOG
	    MOVE Last_SWF2LOG_MIR TO Last_mir
	    MOVE Last_SWF2LOG_MIR_length TO Last_mir_length

	  WHEN OTHER

* We did not find the SWIFT log nor the memo, possibly because the message was cancelled before being sent
* Manufacture the fields we need instead
	    MOVE dst_route_id of ent_dst_set to mir_lt of Tmp_mir
	    IF dst_route_id of ent_dst_set = SPACES MOVE "XXXXXXXX" to mir_lt of Tmp_mir END-IF
	    MOVE "X" to mir_lt of Tmp_mir (9:1)
	    MOVE dst_route_id OF ent_dst_set(9:3) TO mir_branch of Tmp_mir
	    IF mir_branch of Tmp_mir = SPACES MOVE "XXX" TO mir_branch of Tmp_mir END-IF
	    MOVE "0000" TO mir_in_ses_no of Tmp_mir
	    MOVE "000000" TO mir_in_seq_no of Tmp_mir
	    IF Linelog_time NOT = 0
	      MOVE Linelog_time TO Time_param_ws
	    ELSE
	      %BEG Time_param_ws NOW; %END
	    END-IF
	    PERFORM X20_FORMAT_TIME THRU X20_FORMAT_TIME_END		%^ Create YYYYMMDD string for current date
	    MOVE yyyymmdd_ws (3:6) to mir_date of Tmp_mir
	    MOVE Tmp_mir to Last_mir
	    MOVE %SIZ(Tmp_mir) TO Last_mir_length
	    MOVE 0 TO Last_reason_code_length


	END-EVALUATE.

	IF MQSA_enabled IN MQSA_emulation_wf
* Insert the UMID prefix before the message
	  MOVE Trn_ref of Ent_ftr_set TO tmp_xmt_msg (1:MQSA_UMID_field_len)
	  MOVE MQSA_UMID_field_len TO tmp_xmt_msg_length
	ELSE
	  MOVE 0 TO tmp_xmt_msg_length
	END-IF.

* Search for field 20 in original message text, then leave text at 1st line
	%BEG
	Tmp_prs ^LINE_SKIP, ^IN(Ent_text_seq.Txt), ^STRING, ":20:", orig_f20_ws, /;
	FIRST: Ent_text_seq;
	%END.
	IF Failure_is in Tmp_prs_status
	  MOVE 0 to orig_f20_ws_length
	END-IF.

* Format the appropriate type of ACK OR NAK response message
	EVALUATE TRUE
	  WHEN swift_ack in prm_ack_format
	    PERFORM C200_swift_ack THRU C200_swift_ack_end
	  WHEN orig_hdr in prm_ack_format
	    PERFORM C220_orig_hdr THRU C220_orig_hdr_end
	  WHEN orig_msg in prm_ack_format
	    PERFORM C240_orig_msg THRU C240_orig_msg_end
	END-EVALUATE.

* Finish off the "{S:" block with fields common in all 3 format types
* Pseudo-trailer block "S""
	%BEG
	Tmp_prs ^NOLINE_SKIP;
	isi2_compose ^OUT(tmp_xmt_msg), ^APPEND, "{MID:", ent_ftr_set.src_code, "}{MRN:", ent_ftr_set.trn_ref, "}",

%^ Optionally add more sub-blocks to the "S:" block

%^ 1. Reference from original field 20

		orig_f20_ws (^IF_NOTNULL("{TRN:", ^_, "}")), /;
	%END.

	IF lnk_sender_ref_format = "1"
* 2. The session and sequence numbers from the original message are returned here, in separate blocks
	  MOVE orig_srf_ws (19:4) to tmp_vstr (1:4)
	  MOVE 4 TO tmp_vstr_length
	  MOVE orig_srf_ws (23:) TO orig_srf_ws (1:6)
	  MOVE 6 TO orig_srf_ws_length
	  %BEG isi2_compose ^OUT(tmp_xmt_msg), ^APPEND, "{SES:", tmp_vstr, "}{SEQ:", orig_srf_ws, "}", /; %END
	END-IF.

* 3. Optionally output the "{MTSOPR:" operator memos and "{MTSACK:" blocks to the limit of
*    the message buffer, newest to oldest.
	PERFORM C400_EMIT_SUB_BLOCKS THRU C400_EMIT_SUB_BLOCKS_end.

* 4. Additional status information derived from *DLV_(REJ/CNF) memo:
	IF ack_submemo_ws_length > 0
	  EVALUATE TRUE
	    WHEN dlvack IN isi2_msg_type
	      %BEG isi2_compose "{ACK:", ack_submemo_ws, "}"; %END
	    WHEN dlvrej IN isi2_msg_type
	      %BEG isi2_compose "{NAK:", ack_submemo_ws, "}"; %END
	  END-EVALUATE
	END-IF.

* Finish off block S, and set the total length
	%BEG isi2_compose "}", /; %END.

* Output the text to the temporary sequence for transmission
	PERFORM d100_copy_line THRU d100_copy_line_end.

* Flush any pending output in output sequence.
	IF (txt_length of out_text_seq_lengths > 0)
	  %BEG alloc_elem: out_text_seq; %END
	END-IF.

* Leave the msg history positioned at end since we scanned backwards
* Delete the temporary audit sequence if it was allocated
	%BEG
	END: ent_msg_subhist;
	%END.

b100_format_ack_end.
	EXIT.

b200_format_msg.

*   ISI2_GET_LT_ADR will determine the message direction and the sending LT address.

    Move Spaces to hdr_direction_ws.
    Move Spaces to lt_address_ws.
    Call "ISI2_GET_LT_ADR" Using
         By Reference hdr_direction_ws
         By Reference lt_address_ws.

    If hdr_direction_ws = "I"
       Set Outbound in Msg_direction_wf to true
    Else
       Set Inbound in Msg_direction_wf to true
    End-if.


    Move SPACES TO Swift_bic_ws.
    Move "*" TO Dest_ovr_ws.	  %^ Flag that no address lookup was done (yet)

*   Inbound (from SWIFT or carrier): if no SWIFT header, get sender address in 
*   SWIFT_BIC_WS. The receiving LT address should not be needed since it will be 
*   derived from the header, but default it to bank BIC.
    If Inbound in Msg_direction_wf
       If Ent_text_seq (1:3) NOT = "{1:"
          Perform C800_get_sender_bic thru C800_get_sender_bic_end
       End-if

       %BEG END: Ent_msg_subhist; %END
    End-if.


* Insert the UMID prefix before the message if MQSA EMULATION RMT param is set
	IF MQSA_enabled IN MQSA_emulation_wf
	  MOVE Trn_ref of Ent_ftr_set TO tmp_xmt_msg (1:MQSA_UMID_field_len)
	  MOVE MQSA_UMID_field_len TO tmp_xmt_msg_length
	ELSE
	  MOVE 0 TO tmp_xmt_msg_length
	END-IF.

* With correct text subject selected, format the header into the beginning of the message text
	Set Fin in Swf_app_is to TRUE.
	CALL "SWF_HEADER_SUB" USING BY REFERENCE
			Swf_app_is,				%^ Forced to FIN
		BY CONTENT "0000"				%^ FIN Session 0000
			"0000",					%^ GPA session (no-op in ISI2)
		BY REFERENCE
			seq_num OF isi2_msg_hdr (3:),		%^ Last 6 digits of seq # is current linelog value
			memo OF ent_msg_subhist,		%^ DEQ memo
			memo_length of ent_msg_subhist_lengths,	%^ length of memo
			hdr_direction_ws,			%^ "I" input or "O" output header format
			idname of qname OF ent_msg_subhist,	%^ DEQ hist entry containing queue name
			Bank of Loc_info of Ent_ftr_set,
			Loc of Loc_info of Ent_ftr_set,
			lt_address_ws,				%^ Input: Our own LT
			swift_bic_ws,				%^ Output: sender or dest BIC determined in subr
			tmp_xmt_msg (tmp_xmt_msg_length + 1:),
			tmp_long,
			swf_msg_type,
			tmp_vstr,				%^ Memo showing error if failure return
			tmp_vstr_length
		RETURNING ReturnStatus.

* Update length of buffer contents with returned header length
	ADD tmp_long to tmp_xmt_msg_length.

	If Failure_is in ReturnStatus				%^ If error in header building, make memo but ignore
								%^   (only error currently returned is bad Y/T-copy service)
	  PERFORM X50_sys_memo THRU X50_sys_memo_end
	END-IF.

* Don't bother with Ent_text_seq if block 4 is not needed.
	If Success_is in Block_4
	then
* If inbound (CBT side), SWF_BUILD_TEXT copies all of the text through block 5
* If outbound, it stops at the end of block 4 before emitting the "-}".

	     CALL "SWF_BUILD_TEXT" USING BY REFERENCE
		swf_msg_type,
		msg_direction_wf,
		tmp_vstr,
		tmp_vstr_length,
		RETURNING ReturnStatus
	     If Failure_is in ReturnStatus	%^ Message too long
* Error means text buffer overflow. This should be caught in _XMTEDT. It is ignored here, except for making the memo
		PERFORM X50_sys_memo THRU X50_sys_memo_end
	     End-if
	End-if.

	IF Outbound in Msg_direction_wf 

	  %BEG isi2_compose ^OUT(tmp_xmt_msg) ^APPEND; %END

* The pending queue argument to SWF_PDE_TRAILER is passed as blank, which prevents finding an
* MIR to include in the PDE. Finding the MIR of the previous attempt is possible in the CBT, not in the
* client system which is our role in this case.

	  IF (dst_pdm_flag OF ent_dst_set = "T" OR "Y") OR (pdm_flg OF ent_ftr_set = "T" OR "Y")
	    MOVE SPACES TO vstr80 (1:20)
	    CALL "SWF_PDE_TRAILER" USING BY REFERENCE
		vstr80,							%^ Pending queue - none
		tmp_big_vstr,
		tmp_big_vstr_length,
		tmp_vstr,
		tmp_vstr_length
		RETURNING ReturnStatus
	    If Failure_is in ReturnStatus					%^ Ignore errors except for making memo
	      PERFORM X50_sys_memo THRU X50_sys_memo_end
	    End-if
	  ELSE
	    MOVE 0 TO tmp_big_vstr_length
	  END-IF


	  IF Vstr_free_byte_count < (tmp_big_vstr_length + 6)
	    %BEG tmp_vstr = "PDE trailer would exceed max msg size"; %END
	    PERFORM X50_sys_memo THRU X50_sys_memo_end
	  ELSE
	    %BEG isi2_compose EOL_STR, "-}", tmp_big_vstr (^IF_NOTNULL("{5:", ^_, "}")), /; %END
	  END-IF

* Emit what we have so far
	  PERFORM d100_copy_line THRU d100_copy_line_end

* Outbound message: create "S:" block if non-SWF destination with telex, fax, etc. dest sub-blocks

	  EVALUATE TRUE
	    WHEN Dst_type of Ent_dst_set is = "TLX"
	    WHEN Dst_type of Ent_dst_set is = "FAX"
		%BEG
		isi2_compose ^OUT(Tmp_xmt_msg),
			"{S:{", Ent_dst_set.Dst_type, ":", Ent_dst_set.Dst_area_code, Ent_dst_set.Dst_dial, "}";
		%END
		IF Dst_type of Ent_dst_set is = "TLX"
		  %BEG
		  isi2_compose
			"{ANS:", Ent_dst_set.Dst_ans;
		  %END
		END-IF

	    WHEN Dst_type of Ent_dst_set is = "MAC"
		%BEG
		isi2_compose ^OUT(Tmp_xmt_msg),
			"{S:{MAC:", Ent_dst_set.Dst_mac;
		%END

	    WHEN Dst_type of Ent_dst_set is = "MAI"
		%BEG
		isi2_compose ^OUT(Tmp_xmt_msg),
			"{S:{MAI:", Ent_dst_set.Dst_name1, Ent_dst_set.Dst_cab2,
			Ent_dst_set.Dst_cab3, Ent_dst_set.Dst_cab4;
		%END

	    WHEN OTHER
		GO TO b200_format_msg_cleanup

	  END-EVALUATE

* Fall through if non-SWF: finish and emit  the S-block
	  %BEG isi2_compose "}}", /; %END
	  PERFORM d100_copy_line THRU d100_copy_line_end
	  GO TO b200_format_msg_cleanup
	END-IF.

* INBOUND (CBT side):
* Copy end of block 4, and block 5, to temporary string

	IF txt OF ent_text_seq(1:2) = "-}"
	  %BEG
	  NEXT: Ent_text_seq;
	  isi2_compose ^OUT(Tmp_xmt_msg), ^APPEND, EOL_STR, "-}";
	  %END
	ELSE
	  %BEG isi2_compose ^OUT(Tmp_xmt_msg), ^APPEND; %END
	END-IF.

	PERFORM UNTIL (seq_end_is IN ent_text_seq_cursor) OR
		      (txt OF ent_text_seq(1:3) = "{S:")
	  %BEG
	  isi2_compose Ent_text_seq.Txt;
	  NEXT: Ent_text_seq;
	  %END
	END-PERFORM.

* Create "S" pseudo-block for inbound message with sender information
	%Beg
	isi2_compose "{S:{MID:", Ent_ftr_set.Src_code,
			"}{MRN:", Ent_ftr_set.Trn_ref, "}";
	%END.

* Authentication status
	Evaluate Test_state_flg OF Flgs2 OF Ent_ftr_set
	  WHEN "P" %BEG isi2_compose "{SAC}"; %END		%^ Authenticated with current key
	  WHEN "N" %BEG isi2_compose "{SAF}"; %END		%^ Authenticated with future key
	  WHEN "O" %BEG isi2_compose "{SAO}"; %END		%^ Authenticated with old key
	  WHEN "B" %BEG isi2_compose "{SAB}"; %END		%^ Authentication bypassed
	  WHEN "F" %BEG isi2_compose "{SAI}"; %END		%^ Authentication failed
	  WHEN "U" %BEG isi2_compose "{SAN}"; %END		%^ Authentication status unknown
	End-evaluate.

* Additional sub-blocks showing sender keys
	Perform C900_sender_keys THRU C900_sender_keys_end.

* Gather optional audit trail entries
	IF Success_is in Ack_audit_log_wf
	  %BEG FIRST: Ent_msg_subhist; %END
	  PERFORM UNTIL (Seq_end_is IN Ent_msg_subhist_cursor)
	    IF qtype of Ent_msg_subhist = "QTYP$_OPR_ACTION_LOG"
	      %BEG
	      Ent_msg_subhist CONN: Lcl_opr_action (READ_ONLY);
	      Tmp_vstr = Ent_msg_subhist.Memo;
	      Vstr80 = Ent_msg_subhist.Qname.Idname;
	      BEG: S_blk_seq;					%^ Insert oldest at front of sequence
	      %END
	      PERFORM C100_accum_opr_action THRU C100_accum_opr_action_end
	    END-IF
	    %BEG NEXT: Ent_msg_subhist; %END
	  END-PERFORM
	END-IF.

* Emit any memos accumulated
	%BEG isi2_compose /; %END.				%^ Set length in preparation for ^APPEND
	PERFORM C400_EMIT_SUB_BLOCKS THRU C400_EMIT_SUB_BLOCKS_end.

* Close block and set string length, then emit the S block
	%Beg isi2_compose  "}", /; %END.
	PERFORM d100_copy_line THRU d100_copy_line_end.

b200_format_msg_cleanup.
* Flush any pending output again to account for S-block data
	IF (txt_length of out_text_seq_lengths > 0)
	  if (txt_length of out_text_seq_lengths < %siz(out_text_seq.txt))
	    move spaces to txt of out_text_seq(1 + txt_length of out_text_seq_lengths:)
	  end-if
	  %BEG alloc_elem: out_text_seq; %END
	END-IF.

b200_format_msg_end.
	EXIT.

C100_accum_opr_action.

* Input:
*	LCL_OPR_ACTION is connected to an OPR_ACTION log
*	TMP_VSTR contains the message history memo from the log
*	VSTR80 contains the QNAME field, which is the name of the log
*	S_BLK_SEQ is allocated in scratch, correctly positioned for memo in newest-to-oldest order
* Output:
*	LCL_OPR_ACTION disconnected
*	Add the memo information to the temporary memo sequence

*	"MTSOPR:yymmddhhmmss <func> <operator> "  (_ = space)
* Fixed record format is: "MTSOPR:", 12 byte date-time, space, 8 character function, space,
*			  10 character operator, space, variable length memo

* Translate the log name to the function name for recognized log names; else take the 1st 8 chars of the log name
	EVALUATE Vstr80(1:Vstr80_length)

	  WHEN "WIRERPR_LOG"
	    MOVE "WRP" TO Tmp_func

	  WHEN "WRP_EXC_LOG"
	    MOVE "WRPEXC" TO Tmp_func

	  WHEN "WRP_HOLD_LOG"
	    MOVE "WRPHOLD" TO Tmp_func

	  WHEN "WRP_WAIT_LOG"
	    MOVE "WRPWAIT" TO Tmp_func

	  WHEN "WRP_SRVC_LOG"
	    MOVE "WRPSRVC" TO Tmp_func

	  WHEN "WRV_CHG_LOG"
	    MOVE "WRPCHG" TO Tmp_func

	  WHEN "PARENT_LOG"
	    MOVE "PARENT" TO Tmp_func

	  WHEN "WIREVFY_LOG"
	    MOVE "WRV" TO Tmp_func

	  WHEN "WRV_CHG_LOG"
	    MOVE "WRVCHG" TO Tmp_func

	  WHEN "RPRTST_LOG"
	    MOVE "RPRTST" TO Tmp_func

	  WHEN "SPLIT_LOG"
	    MOVE "SPLIT" TO Tmp_func

	  WHEN "FORCETST_LOG"
	    MOVE "FORCETST" TO Tmp_func

	  WHEN "FAI_AUX_LOG"
	    MOVE "FAIAUX" TO Tmp_func

	  WHEN "TEST_LOG"
	    MOVE "TEST" TO Tmp_func

	  WHEN "ADMENT_LOG"
	    MOVE "ADE" TO Tmp_func

	  WHEN "CANCEL_LOG"
	    MOVE "CANCEL" TO Tmp_func

	  WHEN "SWFOPRLOG"
	    EVALUATE TRUE
		WHEN Tmp_vstr(1:23) = "AUTHENTICATION bypassed"
		   MOVE "AUTHBYP" to Tmp_func
		WHEN Tmp_vstr(1:23) = "Message Reauthenticated"
		   MOVE "REAUTHEN" to tmp_func
		WHEN Tmp_vstr(1:13) = "PDM Cancelled"
		   MOVE "PDMCAN" to Tmp_func
		WHEN Tmp_vstr(1:12) = "PDM Released"
		   MOVE "PDMREL" to Tmp_func
		WHEN Tmp_vstr(1:31) = "TRN WITH PAC BYPASSED CANCELLED"
		   MOVE "PACCAN" to Tmp_func
		WHEN Tmp_vstr(1:30) = "TRN WITH PAC BYPASSED RELEASED"
		   MOVE "PACREL" to Tmp_func
		WHEN OTHER
		   MOVE "AUTHBYP" to Tmp_func
		END-EVALUATE

	  WHEN OTHER
	    MOVE Vstr80 (1:Vstr80_length) TO Tmp_func

	END-EVALUATE.

	%BEG
	BREAK: Lcl_opr_action;
	isi2_compose ^OUT(S_blk_seq.Txt), "MTSOPR:",
		Lcl_opr_action.Systime (.ye, .mo, .da, .ho, .mi, .se),	%^ yymmddhhmmss
		" ", Tmp_func, ^COLUMN<30>, Lcl_opr_action.Person, ^COLUMN<41>, Tmp_Vstr, /;
	%END.

* Limit the length to the configured maximum
	IF Txt_length of S_blk_seq_lengths > Opr_log_max_len
	  MOVE Opr_log_max_len TO Txt_length of S_blk_seq_lengths
	END-IF.
	%BEG ALLOC_ELEM: S_blk_seq; %END.

C100_accum_opr_action_end.
	EXIT.

C200_SWIFT_ACK.

* Format the response as a traditional SWIFT ACK. The string has already been constructed
* in TMP_BIG_VSTR. ALso begin the "{S:" block, to be completed by caller, or append the S-block
* from the original message, if present

	%Beg
	isi2_compose ^OUT(tmp_xmt_msg) ^APPEND;			%^ Append to optional Alliance header
	tmp_reason_code_ws = Last_reason_code;
	%END.

* Set up C300 arguments for type of ACK block
	EVALUATE TRUE
	  WHEN dlvack IN isi2_msg_type
	    MOVE 0 TO tmp_reason_code_ws_length
	  WHEN last_reason_code_length = 0
	    %BEG tmp_reason_code_ws = "HXX"; %END			%^ Default if not found in history
	  WHEN OTHER
	    MOVE last_reason_code TO tmp_reason_code_ws
	    MOVE last_reason_code_length TO tmp_reason_code_ws_length
	END-EVALUATE.

	MOVE Last_MIR (1:Last_MIR_length) to Tmp_mir.		%^ Most recent MIR is used to format blocks 1 and 4
	PERFORM C300_FORMAT_F21 THRU C300_FORMAT_F21_END.	%^ Format the SWIFT ACK through block 4
	%Beg isi2_compose ^OUT(tmp_xmt_msg) ^APPEND; %END.	%^ Set up to append S-block
	PERFORM C260_ORIG_S_BLOCK THRU C260_ORIG_S_BLOCK_END.	%^ Copy in original S-block, if any, or start a new one

C200_SWIFT_ACK_END.
	EXIT.

C220_ORIG_HDR.

* Input:
*	ENT_TEXT_SEQ is on the 1st line of the message
*
* Emit the text from the original text sequence, stopping at block 4.
* Then begin the "{S:" block with the "{MSGACK:" sub-block containing the SWIFT-ACK or NAK
* Return for the caller to append additional "{S:" block sub-blocks
*
	%BEG isi2_compose ^OUT(tmp_xmt_msg) ^APPEND; %END.	%^ Set up to append text to Alliance hdr if present

* If no SWIFT header is found at the start of the text, output the 1st 100 bytes
* of the original message.
* Return with the text sequence restored to the first line of the message.

	If Txt of Ent_text_seq (1:1) NOT = "{"
* No SWIFT header - output the 1st 100 bytes of the original message, followed by CR-LF before
* beginning the S-block with the SWIFT-ACK
	  MOVE 0 TO Tmp_long
	  PERFORM UNTIL (Tmp_long > 99) or (Seq_end_is in Ent_text_seq_cursor)
	    %BEG Vstr80 = Ent_text_seq.Txt; %END
	    IF Vstr80_length > (100 - Tmp_long)
	      SUBTRACT Tmp_long FROM 100 GIVING Vstr80_length		%^ Truncate to limit count to 100 characters
	    END-IF
	    %BEG
	    isi2_compose Vstr80, <13>, <10>;
	    NEXT: Ent_text_seq;
	    %END
	    ADD Vstr80_length TO Tmp_long
	    ADD 2 TO Tmp_long						%^ Count CR-LF
	  END-PERFORM
	  GO TO C220_orig_hdr_cleanup
	END-IF.

* There is a real SWIFT header. Output blocks, stopping at the "{4:" block if found
* Arbitrarily stop if the accumulated text passes <buffer-size> - 100 characters, which should not happen for any normal
* SWIFT-sized message, and should certainly not happen if only header blocks are being output

	MOVE 0 TO Tmp_long.
	PERFORM UNTIL (tmp_long > (Net_buffer_size - 100))
		OR (Seq_end_is in Ent_text_seq_cursor)
		OR (Txt of Ent_text_seq (1:3) = "{4:")
	    ADD Txt_length of Ent_text_seq_lengths TO Tmp_long
	    %BEG
	    isi2_compose Ent_text_seq.Txt;
	    NEXT: Ent_text_seq;
	    %END
	END-PERFORM.

C220_ORIG_HDR_CLEANUP.

	PERFORM C260_ORIG_S_BLOCK THRU C260_ORIG_S_BLOCK_END.

C220_ORIG_HDR_END.
	EXIT.

C240_ORIG_MSG.

* Input:
*	ENT_TEXT_SEQ is on the 1st line of the message
*	TMP_BIG_VSTR contains the constructed SWIFT ACK message
*
* Emit the entire text from the original text sequence.
* Then begin the "{S:" block with the "{MSGACK:" sub-block containing the SWIFT-ACK or NAK
* Return for the caller to append additional "{S:" block sub-blocks
* Truncate the text at <buffer-size - 200> characters

	MOVE 0 TO Tmp_long.
	SET Failure_is in Found_s_block_wf TO TRUE.

	If Txt of Ent_text_seq (1:1) = "{"
	  MOVE 0 TO Crlf_str_wf_length				%^ If SWIFT format, no CRLF until past header
	ELSE
	  MOVE 2 TO Crlf_str_wf_length				%^ Else append CRLF from the get-go
	END-IF.

	%BEG isi2_compose ^OUT(tmp_xmt_msg) ^APPEND; %END.	%^ Set up to append text to Alliance hdr if present

	PERFORM UNTIL (tmp_long > (net_buffer_size - 200))
		OR (Seq_end_is in Ent_text_seq_cursor)
	    ADD Txt_length of Ent_text_seq_lengths TO Tmp_long
	    IF Txt of Ent_text_seq (1:3) = "{4:"
	      MOVE 2 TO Crlf_str_wf_length
	    END-IF
	    IF Txt of Ent_text_seq (1:1) = "-"
	      MOVE 0 TO Crlf_str_wf_length			%^ Stop emitting CRLF at end of block 4 text part
	    END-IF
	    IF Txt of Ent_text_seq (1:3) = "{5:"
	      MOVE 0 TO Crlf_str_wf_length			%^ If in 5 block, stop emitting CRLF
	    END-IF
	    IF Txt of Ent_text_seq (1:3) = "{S:"
	      MOVE 0 TO Crlf_str_wf_length			%^ If in 5 or S block, stop emitting CRLF
	      SET Success_is in Found_s_block_wf TO TRUE
	    END-IF
	    %BEG
	    isi2_compose Ent_text_seq.Txt, Crlf_str_wf (^IF_NOTNULL(<13>,<10>));
	    NEXT: Ent_text_seq;
	    %END
* Skip past "{STX}" marker-line if present
	    IF txt of ent_text_seq (1: txt_length of ent_text_seq_lengths) = "{STX}"
	      %BEG NEXT: ent_text_seq; %END
	    END-IF

	END-PERFORM.

* Now append the SWIFT ACK message as the first sub-block of the "{S:" block
	IF Failure_is in Found_s_block_wf
	  %BEG isi2_compose "{S:", /; %END
	ELSE
	  %BEG isi2_compose /; %END
	  SUBTRACT 1 FROM tmp_xmt_msg_length			%^ Strip closing "}" from original S-block to
	END-IF.							%^ prepare to insert more S-block sub-blocks

C240_ORIG_MSG_END.
	EXIT.

C260_ORIG_S_BLOCK.

* Step back to beginning of original S-block, if any.
* If found, append it to the buffer excluding the closing "}".
* If the original S-block was not found, start a new one
* Input:
*	ISI2_COMPOSE is set up to append to the message buffer
* Output:
*	ISI2_COMPOSE has been terminated, setting length of underlying field

	%BEG LAST: Ent_text_seq; %END.
	PERFORM UNTIL (Txt of Ent_text_seq (1:3) = "{S:")
			or (Txt of Ent_text_seq (1:3) = "{5:")
			or (Txt of Ent_text_seq (1:1) = "-")
			or (Seq_beg_is in Ent_text_seq_cursor)
	  %BEG PREV: Ent_text_seq; %END
	END-PERFORM.

* If an existing S-block was present, emit it excluding the closing "}".
	IF Txt of Ent_text_seq (1:3) = "{S:"
	  PERFORM UNTIL Seq_end_is in Ent_text_seq_cursor
	    %BEG
	    isi2_compose Ent_text_seq.Txt;
	    NEXT: Ent_text_seq;
	    %END
	  END-PERFORM
* Strip the closing "}" from the end of the buffer
	  %BEG isi2_compose /; %END
	  SUBTRACT 1 FROM tmp_xmt_msg_length
	ELSE
	  %BEG isi2_compose "{S:", /; %END
	END-IF.

C260_ORIG_S_BLOCK_END.
	EXIT.

C280_PARSE_MIR_MEMO.

* Input:
*	ENT_MSG_SUBHIST is positioned on a SWIFT MIR ACK/NAK string
*	Parse out the MIR and NAK reason code
* Output:
*	TMP_REASON_CODE_WS contains the SWIFT reason code if this is the last MIR of the message
*	If LAST_MIR was not already occupied, TMP_MIR is copied there as well and tmp_reason_code_ws is
*		copied to LAST_REASON_CODE
* Side effects:
*	If ORIGINAL HEADER/MESSAGE, then an S-block element is allocated containing an F21 SWIFT-ACK (blocks 1, 4)
*	for the SWIFT ACK or NAK instance represented by the current MIR memo

	%BEG vstr80 = ent_msg_subhist.memo; %END.

* Extract MIR and possibly reason codes from message history memo
	%BEG
	tmp_prs ^IN(vstr80), tmp_oneof (^ONEOF (
				("Ack MIR:", |tmp_mir, /),
				("Nak MIR:", |tmp_mir, ";", ^Space, "Reason=", |tmp_reason_code_ws, /) ) );
	%END.

	EVALUATE TRUE
	  WHEN Failure_is in tmp_prs_status
	    MOVE -1 TO tmp_oneof
	    MOVE SPACES TO tmp_mir
	    GO TO C280_PARSE_MIR_MEMO_END

	  WHEN tmp_oneof = 0
	    MOVE 0 TO Tmp_reason_code_ws_length

	END-EVALUATE.

* Remember this as the newest MIR if it is the first found
	IF Last_mir_length = 0
	  %BEG
	  Last_mir = Tmp_mir;
	  Last_reason_code = Tmp_reason_code_ws;
	  %END
	END-IF.

* If this MIR is identical to the most recently seen ACK or NAK mir, ignore it as it has already been processed
	IF (tmp_MIR = prev_MIR) and (tmp_oneof = prev_ack_oneof)
	  GO TO C280_PARSE_MIR_MEMO_END
	END-IF.
	MOVE tmp_MIR (1:tmp_MIR_length) TO prev_MIR.
	MOVE tmp_oneof TO prev_ack_oneof.

* If SWIFT ACK message format is being used, don't build this memo in the ACK memo sequence
	IF swift_ack in prm_ack_format
	  GO TO C280_PARSE_MIR_MEMO_END
	END-IF.

	%BEG isi2_compose ^OUT(S_blk_seq.Txt), "MSGACK:"; %END.		%^ Begin an S-block memo string sub-block
	PERFORM C300_FORMAT_F21 THRU C300_FORMAT_F21_END.		%^ Format the SWIFT ACK through block 4 as a memo-line
	%BEG ALLOC_ELEM: S_blk_seq; %END.

C280_PARSE_MIR_MEMO_END.
	EXIT.

C300_FORMAT_F21.

* Construct the SWIFT-format ACK or NAK, with block 1 containing the MIR and block 4 the ACK details.
* Input:
*	Timestamp is in SWF2LOG_time or Linelog_time.
*	ISI2_COMPOSE has been set up to point to the target string
*	TMP_MIR contains the MIR with ACK/NAK data
*	TMP_REASON_CODE_WS contains the SWIFT NAK reason code if this is a NAK
*	If not a NAK, TMP_REASON_CODE_WS is null
* Output:
*	ISI2_COMPOSE has been terminated, setting the length

* Get the timestamp for the SWIFT ACK event
	EVALUATE TRUE
	  WHEN SWF2LOG_TIME NOT = 0
	    MOVE SWF2LOG_TIME TO Time_param_ws
	  WHEN Linelog_time NOT = 0
	    MOVE Linelog_time TO Time_param_ws
	  WHEN OTHER
	    %BEG Time_param_ws NOW; %END
	END-EVALUATE.
	PERFORM X20_FORMAT_TIME THRU X20_FORMAT_TIME_END.		%^ Create HHMM, YYMMDD strings for current time

%^ CR12116
%^
%^	Check for spaces in the 9th position of the mir_lt and in the mir_branch. Replace with X's as needed	

	If mir_lt of tmp_mir(9:1) = " "
	   move "A" to mir_lt of tmp_mir(9:1) 
	end-if.

	if mir_branch of tmp_mir = "   " 
	   move "XXX" to mir_branch of tmp_mir
	end-if.
%^
%^ CR12116 end

	%Beg
	isi2_compose "{1:F21",
	  tmp_mir (.mir_lt, .mir_branch, .mir_in_ses_no, .mir_in_seq_no), "}";
	%END.

* Hdr block 4:
	%BEG
	isi2_compose
	  "{4:{177:", tmp_mir.mir_date, hhmm_ws,
	  "}{451:";
	%END.

%^ +ve vs. -ve ACK is implied by the reason-code string being null or not
	%BEG
	isi2_compose tmp_reason_code_ws (
				^IF_NULL ("0}}"),
				^IF_NOTNULL ("1}{405:", ^_, "}}")
				), /;
	%END.

	MOVE 0 TO Linelog_time, SWF2LOG_time.		%^ Reset to find time for another SWIFT ACK/NAK log group

C300_FORMAT_F21_END.
	EXIT.

C320_PARSE_SWF2LOG.

* Extract useful data from the SWF2LOG on which ENT_MSG_SUBHIST is positioned

	%BEG
	ent_msg_subhist CONN: lcl_swf2_log (READ_ONLY);
	BREAK: lcl_swf2_log;
	Last_SWF2LOG_MIR = lcl_swf2_log.MIR;
	%END.
	MOVE systime of lcl_swf2_log TO SWF2LOG_time.

C320_PARSE_SWF2LOG_END.
	EXIT.

C400_EMIT_SUB_BLOCKS.

* Memos have been accumulated in the temporary sequence in newest to oldest order.
* Make a 1st pass from the beginning forwards, stopping on the oldest that will fit, then output to text buffer.
* Leave room to close out the S-block (1 character), and calculate a reserve for the formatting around the memo
* Output:
*	ISI2_COMPOSE is positioned to output at the end of the S-block in the buffer

	%BEG
	FIRST: S_blk_seq;
	isi2_compose ^OUT(Tmp_xmt_msg) ^APPEND;		%^ Set compose pointer to append at end of buffer
	%END.
	SUBTRACT Tmp_xmt_msg_length FROM %SIZ(Tmp_xmt_msg) GIVING Tmp_long.
	SUBTRACT 3 FROM Tmp_long.		%^ Room for S-block terminator + "{}" of each entry

	PERFORM UNTIL ((Txt_length of S_blk_seq_lengths) > Tmp_long)
			OR (Seq_end_is in S_blk_seq_cursor)
	  SUBTRACT Txt_length of S_blk_seq_lengths FROM Tmp_long
	  SUBTRACT 2 FROM Tmp_long
	  %BEG NEXT: S_blk_seq; %END
	END-PERFORM.

* Here when we went one record past the first to output, or to the end of the memo sequence
* Loop to output all from next forward
	%BEG PREV: S_blk_seq; %END.
	PERFORM UNTIL Seq_beg_is in S_blk_seq_cursor
	  %BEG
	  isi2_compose "{", S_blk_seq.Txt, "}";
	  PREV: S_blk_seq;
	  %END
	END-PERFORM.

C400_EMIT_SUB_BLOCKS_end.
	EXIT.

C700_rcvlog_memo.

* LCL_MSG_HISTORY is positioned on a "*LNK_INF" entry.
* This should be the first of two sys_memo entries (reply-to-q and msgid) immediately following the rcv log.
* Step forward thru the two *LNK_INF entries to concatenate the reply_to queue and msgid values.
* Output:
*	ISI2_RCV_LOG_MEMO contains string following "*LNK_INF:" from original receive log
*	ORIG_SRF_WS contains the sender's reference logged on message receipt

	MOVE 0 TO orig_srf_ws_length, isi2_rcv_log_memo_length.


* Fetch sender ref, from ent_ftr_set.incoming_ref
    %Beg
     orig_srf_ws = ent_ftr_set.incoming_ref;
    %End


* Collect the reply-to-q and msgid-hex values from adjacent sys_memos following rcv linelog.
* These are returned in the isi2_rcv_log_memo.
	%beg
	vReplyToQueue = null;
	vMsgidHex = null;
	tmp_prs ^in(lcl_msg_history.memo),
	  "*LNK_INF_REPLYQ:", vReplyToQueue, /,
	  "*LNK_INF_MSGID:", vMsgidHex, /;
	tmp_cmp ^out(isi2_rcv_log_memo), vReplyToQueue, "||", vMsgidHex, /;
	%end.

	call "NEX_LNK_TRACE_DATA" using
	  by value trace_ctx_blk of trace_ctx_rec,
	  by content z"xmtmap c700 - rcv log",
	  by value isi2_rcv_log_memo_length,
	  by reference isi2_rcv_log_memo,
	  by value trace_asc.

C700_rcvlog_memo_end.
	EXIT.

C800_get_sender_bic.

* If there is not a FIN header on the message, try to derive a sender BIC based on the
* sender address
* Output:
*	SWIFT_BIC_WS contains string to insert in pseudo output header. If not needed because there
*	is a valid SWIFT BIC already present in a header, then it is returned as blanks
*	Address set for sender is connected if there is not an alphabetic SWIFT BIC in the sender header-2 record

* Look up sender address record if inbound, and non-SWIFT
	If Sbk_idtype of Sbk of Ent_debit_set NOT = SPACE
	  MOVE Sbk_idtype of Sbk of Ent_debit_set TO Dest_idtype_ws
	  %BEG Dest_id_ws = Ent_debit_set.Sbk.Sbk_id; %END
	  IF Sbk_rel_id of Ent_debit_set NOT = 0
	    %BEG
	    Ent_debit_set.Sbk_adr_set_ptr CONN: Ent_d_adr_set (NOMOD);
	    BREAK: Ent_d_adr_set;
	    %END
	  ELSE
	    MOVE "*" TO Dest_ovr_ws
	  END-IF
	ELSE
	  MOVE Dbt_idtype of Dbt_typ of Ent_debit_set TO Dest_idtype_ws
	  %BEG Dest_id_ws = Ent_debit_set.Dbt_typ.Dbt_id; %END
	  IF Dbt_rel_id of Ent_debit_set NOT = 0
	    %BEG
	    Ent_debit_set.Dbt_adr_set_ptr CONN: Ent_d_adr_set (NOMOD);
	    BREAK: Ent_d_adr_set;
	    %END
	  ELSE
	    MOVE "*" TO Dest_ovr_ws
	  END-IF
	END-IF.

* Choose a suitable ID for the pseudo-header
	Evaluate True
	  WHEN Swift_id of Ent_d_adr_set NOT = SPACES
	    MOVE Swift_id of Ent_d_adr_set (1:11) to Swift_bic_ws (1:11)
	    IF swift_bic_ws (9:3) = SPACES
	      THEN MOVE "XXX" to swift_bic_ws (9:3)
	    END-IF
	  WHEN Dest_ovr_ws  = "*"
* If no address available, return the SBK_ID or DBT_ID to go in the pseudo-header
	    MOVE Dest_id_ws TO swift_bic_ws
	  WHEN OTHER
* Use the REL-ID of the sender if on-file
	    %BEG isi2_compose ^OUT(swift_bic_ws), Ent_d_adr_set.Rel_id, /; %END

	END-EVALUATE.

C800_get_sender_bic_end.
	EXIT.

C900_sender_keys.

* Optionally format additional sub-blocks into the S-block
* Input:
*	DEST_OVR_WS contains blank if REL address was looked up, contents in ENT_D_ADR_SET

* If address was not found, or if we already have the sender's BIC, don't append trailer ID
	If (Dest_ovr_ws = "*")
	  OR (Sbk_idtype of Sbk of Ent_debit_set = "S")
	  GO TO C900_sender_keys_end
	End-if.

* See if there is a telex destination to derive the answerback from
	%BEG
	Ent_d_adr_set.Dst_seq CONN: Ent_dst_seq ^FIRST (NOMOD, CONN: Ent_dst_set (NOMOD));
	%END.

	PERFORM UNTIL Seq_end_is in Ent_dst_seq_cursor
		OR Dst_type of Ent_dst_set = "TLX"
	  %BEG
	  BREAK: Ent_dst_set;
	  NEXT: Ent_dst_seq (CONN: Ent_dst_set);
	  %END
	END-PERFORM.

	IF NOT Seq_end_is in Ent_dst_seq_cursor
* Found a telex destination. Copy the answerback to the S block
	  %BEG isi2_compose "{ANS:", Ent_dst_set.Dst_ans, "}"; %END
	END-IF.

	%BEG
	BREAK: Ent_dst_seq;
	BREAK: Ent_dst_set;
	%END.

* Choose an additional identifier, in order of precedence
* CHIPS UID, User-name, or short-name
	Evaluate TRUE
	  WHEN Chips_Uid_id of Ent_d_adr_set NOT = SPACES
	    %BEG isi2_compose "{ID:C-", Ent_d_adr_set.Chips_uid_id, "}"; %END
	  WHEN User_id of Ent_d_adr_set NOT = SPACES
	    %BEG isi2_compose "{ID:U-", Ent_d_adr_set.User_id, "}"; %END
	  WHEN Sname_id of Ent_d_adr_set NOT = SPACES
	    %BEG isi2_compose "{ID:N-", Ent_d_adr_set.Sname_id, "}"; %END
	End-Evaluate.

C900_sender_keys_end.
	EXIT.

d100_copy_line.
* Transfer text line from tmp_xmt_msg to output sequence.  Append <CR><LF> unless flag says not to.
* Input:
*	tmp_xmt_msg = text to move
*	Output sequence connected to Out_text_seq.

* Trace proposed data
	call "NEX_LNK_TRACE_DATA" using
	  by value trace_ctx_blk of trace_ctx_rec,
	  by content z"cbt xmtmap d100",
	  by value tmp_xmt_msg_length,
	  by reference tmp_xmt_msg,
	  by value trace_asc.

* Initialize input pointer/len.
	MOVE 1 TO api_tmp_idx.
	MOVE tmp_xmt_msg_length TO api_tmp_len.

* Compute free space remaining in output sequence line.
	SUBTRACT txt_length of out_text_seq_lengths FROM %SIZ(out_text_seq.txt) GIVING tmp_long.

* If input line won't fit, insert as much as we can, and flush lines, until remainder will fit within txt line
	PERFORM UNTIL NOT (tmp_xmt_msg_length > tmp_long)
	  ADD 1 TO txt_length of out_text_seq_lengths GIVING api_tmp_idx2
	  MOVE tmp_xmt_msg(api_tmp_idx:tmp_long) TO txt of out_text_seq(api_tmp_idx2:tmp_long)
	  MOVE %SIZ(out_text_seq.txt) TO txt_length of out_text_seq_lengths
	  %BEG alloc_elem: out_text_seq; %END
	  MOVE 0 TO txt_length of out_text_seq_lengths
	  ADD tmp_long TO api_tmp_idx
	  SUBTRACT tmp_long FROM tmp_xmt_msg_length
	  MOVE 80 TO tmp_long
	END-PERFORM.

* Should be enough room now.  Insert whatever was not moved above.
	ADD 1 TO txt_length of out_text_seq_lengths GIVING api_tmp_idx2.
	MOVE tmp_xmt_msg (api_tmp_idx:tmp_xmt_msg_length) TO txt of out_text_seq(api_tmp_idx2:tmp_xmt_msg_length).
	ADD tmp_xmt_msg_length TO txt_length of out_text_seq_lengths.

* Append <CR><LF> unless suppressed: flush line first if not enough room.
* Compute TMP_LONG = OUT_TEXT_SEQ free space.
	SUBTRACT txt_length of out_text_seq_lengths FROM %SIZ(out_text_seq.txt) GIVING tmp_long.
	IF (%SIZ(cr_lf_rec) > tmp_long)
	  %BEG alloc_elem: out_text_seq; %END
	  MOVE 0 TO txt_length of out_text_seq_lengths
	END-IF.

* Compute API_TMP_IDX = index to first free byte in OUT_TEXT_SEQ
	ADD 1 TO txt_length of out_text_seq_lengths GIVING api_tmp_idx.

d100_copy_line_end.
	EXIT.

x10_tst1.
* Test for 1 byte free space in output sequence.
* On failure (len = output sequence size), output line and reset length.
* OUTPUT:
*   API_TMP_IDX = Offset to free byte.
	IF (txt_length of out_text_seq_lengths = %SIZ(out_text_seq.txt))
	  %BEG alloc_elem: out_text_seq; %END
	  MOVE 0 TO txt_length of out_text_seq_lengths
	END-IF.
	ADD 1 TO txt_length of out_text_seq_lengths GIVING api_tmp_idx.
x10_tst1_end.
	EXIT.

X20_FORMAT_TIME.

* Input:
*	TIME_PARAM_WS contains a timestamp, or 0 for current time
* Output:
*	HHMM contains the hours, minutes derived from the calling argument
*	YYYYMMDD_WS contains the date derived from the calling argument

	%Beg
	Tmp_Cmp ^Out(hhmm_ws),
		time_param_ws.Ho(^number<2> (^leading_zeros)), 
		time_param_ws.Mi(^number<2>(^leading_zeros)), / ;
	Tmp_Cmp ^Out(yyyymmdd_ws),
		time_param_ws.Yyyy(^number<4>(^leading_zeros)), 
		time_param_ws.Mo(^number<2>(^leading_zeros)),
		time_param_ws.Da(^number<2>(^leading_zeros)), /;
	%End.

X20_FORMAT_TIME_END.
	EXIT.

X50_sys_memo.
* Insert a memo into subhistory.
* Input:
*	ent_msg_history MOD on subhistory.
*	TMP_VSTR contains the memo text

* We must nomod the main history sbj to prevent a deadlock.
* However we make memo via ent_msg_subhist so as not to lose our position.
	%BEG
	ent_msg_history(nomod);
	ALLOC_END: ent_msg_subhist (mod,
				 .qname(
					.idbank  = Link_bnk_id,
					.idloc   = NULL,
					.idname  = "*SYS_MEMO"),
				 .qtype = "OBJTYP$_NULL",
				 .memo  = tmp_vstr);
	ent_msg_subhist(nomod);
	ent_msg_history(mod);
	%END.

X50_sys_memo_end.
	exit.

